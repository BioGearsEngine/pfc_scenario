// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef PFC_SCENARIO_COMPLEX_TYPES_0_1_HXX
#define PFC_SCENARIO_COMPLEX_TYPES_0_1_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace pfc
{
  namespace schema
  {
    class equipment_definition_list;
    class equipment;
    class trauma_definition_list;
    class trauma;
    class trauma_severity_range;
    class numeric_range;
    class token_range;
    class citation_ref_list;
    class treatment_plan_definition_list;
    class treatment_plan;
    class equipment_ref_list;
    class medical_reference_list;
    class cpg_ref_list;
    class cpg_list;
    class cpg;
    class learning_objective_reference_list;
    class treatment_plan_ref_list;
    class trauma_profile_list;
    class trauma_profile;
    class trauma_profile_ref_list;
    class trauma_occurence_list;
    class trauma_occurence;
    class medical_scenario_syllabus;
    class learning_objective_list;
    class learning_objective;
    class assessment_list;
    class assessment;
    class medical_scenario;
    class role_list;
    class role;
    class role_ref_list;
    class item_list;
    class item;
    class scene_list;
    class scene;
    class event_list;
    class event;
    class event_category_enum;
    class event_fidelity_enum;
    class citation_list;
    class citation;
    class properties_list;
    class property;
    class property_value_list;
    class property_value;
    class relates_to;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "militaryscenario_1.0.0.hxx"

namespace pfc
{
  namespace schema
  {
    class equipment_definition_list: public ::xml_schema::type
    {
      public:
      // equipment
      //
      typedef ::pfc::schema::equipment equipment_type;
      typedef ::xsd::cxx::tree::sequence< equipment_type > equipment_sequence;
      typedef equipment_sequence::iterator equipment_iterator;
      typedef equipment_sequence::const_iterator equipment_const_iterator;
      typedef ::xsd::cxx::tree::traits< equipment_type, char > equipment_traits;

      const equipment_sequence&
      equipment () const;

      equipment_sequence&
      equipment ();

      void
      equipment (const equipment_sequence& s);

      // Constructors.
      //
      equipment_definition_list ();

      equipment_definition_list (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      equipment_definition_list (const equipment_definition_list& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual equipment_definition_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      equipment_definition_list&
      operator= (const equipment_definition_list& x);

      virtual 
      ~equipment_definition_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      equipment_sequence equipment_;
    };

    class equipment: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::string id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // type
      //
      typedef ::xml_schema::integer type_type;
      typedef ::xsd::cxx::tree::optional< type_type > type_optional;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_optional&
      type () const;

      type_optional&
      type ();

      void
      type (const type_type& x);

      void
      type (const type_optional& x);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // citations
      //
      typedef ::pfc::schema::citation_ref_list citations_type;
      typedef ::xsd::cxx::tree::traits< citations_type, char > citations_traits;

      const citations_type&
      citations () const;

      citations_type&
      citations ();

      void
      citations (const citations_type& x);

      void
      citations (::std::unique_ptr< citations_type > p);

      // image
      //
      typedef ::xml_schema::string image_type;
      typedef ::xsd::cxx::tree::optional< image_type > image_optional;
      typedef ::xsd::cxx::tree::traits< image_type, char > image_traits;

      const image_optional&
      image () const;

      image_optional&
      image ();

      void
      image (const image_type& x);

      void
      image (const image_optional& x);

      void
      image (::std::unique_ptr< image_type > p);

      // properties
      //
      typedef ::pfc::schema::properties_list properties_type;
      typedef ::xsd::cxx::tree::traits< properties_type, char > properties_traits;

      const properties_type&
      properties () const;

      properties_type&
      properties ();

      void
      properties (const properties_type& x);

      void
      properties (::std::unique_ptr< properties_type > p);

      // Constructors.
      //
      equipment (const id_type&,
                 const name_type&,
                 const description_type&,
                 const citations_type&,
                 const properties_type&);

      equipment (const id_type&,
                 const name_type&,
                 const description_type&,
                 ::std::unique_ptr< citations_type >,
                 ::std::unique_ptr< properties_type >);

      equipment (::std::unique_ptr< id_type >,
                 ::std::unique_ptr< name_type >,
                 ::std::unique_ptr< description_type >,
                 ::std::unique_ptr< citations_type >,
                 ::std::unique_ptr< properties_type >);

      equipment (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      equipment (const equipment& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual equipment*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      equipment&
      operator= (const equipment& x);

      virtual 
      ~equipment ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< name_type > name_;
      type_optional type_;
      ::xsd::cxx::tree::one< description_type > description_;
      ::xsd::cxx::tree::one< citations_type > citations_;
      image_optional image_;
      ::xsd::cxx::tree::one< properties_type > properties_;
    };

    class trauma_definition_list: public ::xml_schema::type
    {
      public:
      // trauma
      //
      typedef ::pfc::schema::trauma trauma_type;
      typedef ::xsd::cxx::tree::sequence< trauma_type > trauma_sequence;
      typedef trauma_sequence::iterator trauma_iterator;
      typedef trauma_sequence::const_iterator trauma_const_iterator;
      typedef ::xsd::cxx::tree::traits< trauma_type, char > trauma_traits;

      const trauma_sequence&
      trauma () const;

      trauma_sequence&
      trauma ();

      void
      trauma (const trauma_sequence& s);

      // Constructors.
      //
      trauma_definition_list ();

      trauma_definition_list (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      trauma_definition_list (const trauma_definition_list& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual trauma_definition_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      trauma_definition_list&
      operator= (const trauma_definition_list& x);

      virtual 
      ~trauma_definition_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      trauma_sequence trauma_;
    };

    class trauma: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::string id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // common-name
      //
      typedef ::xml_schema::string common_name_type;
      typedef ::xsd::cxx::tree::optional< common_name_type > common_name_optional;
      typedef ::xsd::cxx::tree::traits< common_name_type, char > common_name_traits;

      const common_name_optional&
      common_name () const;

      common_name_optional&
      common_name ();

      void
      common_name (const common_name_type& x);

      void
      common_name (const common_name_optional& x);

      void
      common_name (::std::unique_ptr< common_name_type > p);

      // medical-name
      //
      typedef ::xml_schema::string medical_name_type;
      typedef ::xsd::cxx::tree::traits< medical_name_type, char > medical_name_traits;

      const medical_name_type&
      medical_name () const;

      medical_name_type&
      medical_name ();

      void
      medical_name (const medical_name_type& x);

      void
      medical_name (::std::unique_ptr< medical_name_type > p);

      // citations
      //
      typedef ::pfc::schema::citation_ref_list citations_type;
      typedef ::xsd::cxx::tree::traits< citations_type, char > citations_traits;

      const citations_type&
      citations () const;

      citations_type&
      citations ();

      void
      citations (const citations_type& x);

      void
      citations (::std::unique_ptr< citations_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // severity-range
      //
      typedef ::pfc::schema::trauma_severity_range severity_range_type;
      typedef ::xsd::cxx::tree::traits< severity_range_type, char > severity_range_traits;

      const severity_range_type&
      severity_range () const;

      severity_range_type&
      severity_range ();

      void
      severity_range (const severity_range_type& x);

      void
      severity_range (::std::unique_ptr< severity_range_type > p);

      // Constructors.
      //
      trauma (const id_type&,
              const medical_name_type&,
              const citations_type&,
              const description_type&,
              const severity_range_type&);

      trauma (const id_type&,
              const medical_name_type&,
              ::std::unique_ptr< citations_type >,
              const description_type&,
              ::std::unique_ptr< severity_range_type >);

      trauma (::std::unique_ptr< id_type >,
              ::std::unique_ptr< medical_name_type >,
              ::std::unique_ptr< citations_type >,
              ::std::unique_ptr< description_type >,
              ::std::unique_ptr< severity_range_type >);

      trauma (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      trauma (const trauma& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual trauma*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      trauma&
      operator= (const trauma& x);

      virtual 
      ~trauma ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      common_name_optional common_name_;
      ::xsd::cxx::tree::one< medical_name_type > medical_name_;
      ::xsd::cxx::tree::one< citations_type > citations_;
      ::xsd::cxx::tree::one< description_type > description_;
      ::xsd::cxx::tree::one< severity_range_type > severity_range_;
    };

    class trauma_severity_range: public ::xml_schema::type
    {
      public:
      // numeric-range
      //
      typedef ::pfc::schema::numeric_range numeric_range_type;
      typedef ::xsd::cxx::tree::optional< numeric_range_type > numeric_range_optional;
      typedef ::xsd::cxx::tree::traits< numeric_range_type, char > numeric_range_traits;

      const numeric_range_optional&
      numeric_range () const;

      numeric_range_optional&
      numeric_range ();

      void
      numeric_range (const numeric_range_type& x);

      void
      numeric_range (const numeric_range_optional& x);

      void
      numeric_range (::std::unique_ptr< numeric_range_type > p);

      // token-range
      //
      typedef ::pfc::schema::token_range token_range_type;
      typedef ::xsd::cxx::tree::optional< token_range_type > token_range_optional;
      typedef ::xsd::cxx::tree::traits< token_range_type, char > token_range_traits;

      const token_range_optional&
      token_range () const;

      token_range_optional&
      token_range ();

      void
      token_range (const token_range_type& x);

      void
      token_range (const token_range_optional& x);

      void
      token_range (::std::unique_ptr< token_range_type > p);

      // Constructors.
      //
      trauma_severity_range ();

      trauma_severity_range (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      trauma_severity_range (const trauma_severity_range& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual trauma_severity_range*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      trauma_severity_range&
      operator= (const trauma_severity_range& x);

      virtual 
      ~trauma_severity_range ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      numeric_range_optional numeric_range_;
      token_range_optional token_range_;
    };

    class numeric_range: public ::xml_schema::type
    {
      public:
      // min
      //
      typedef ::xml_schema::double_ min_type;
      typedef ::xsd::cxx::tree::traits< min_type, char, ::xsd::cxx::tree::schema_type::double_ > min_traits;

      const min_type&
      min () const;

      min_type&
      min ();

      void
      min (const min_type& x);

      // max
      //
      typedef ::xml_schema::double_ max_type;
      typedef ::xsd::cxx::tree::traits< max_type, char, ::xsd::cxx::tree::schema_type::double_ > max_traits;

      const max_type&
      max () const;

      max_type&
      max ();

      void
      max (const max_type& x);

      // median
      //
      typedef ::xml_schema::double_ median_type;
      typedef ::xsd::cxx::tree::optional< median_type > median_optional;
      typedef ::xsd::cxx::tree::traits< median_type, char, ::xsd::cxx::tree::schema_type::double_ > median_traits;

      const median_optional&
      median () const;

      median_optional&
      median ();

      void
      median (const median_type& x);

      void
      median (const median_optional& x);

      // unit
      //
      typedef ::xml_schema::string unit_type;
      typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
      typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

      const unit_optional&
      unit () const;

      unit_optional&
      unit ();

      void
      unit (const unit_type& x);

      void
      unit (const unit_optional& x);

      void
      unit (::std::unique_ptr< unit_type > p);

      // Constructors.
      //
      numeric_range (const min_type&,
                     const max_type&);

      numeric_range (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      numeric_range (const numeric_range& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual numeric_range*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      numeric_range&
      operator= (const numeric_range& x);

      virtual 
      ~numeric_range ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< min_type > min_;
      ::xsd::cxx::tree::one< max_type > max_;
      median_optional median_;
      unit_optional unit_;
    };

    class token_range: public ::xml_schema::type
    {
      public:
      // token
      //
      typedef ::xml_schema::ncname token_type;
      typedef ::xsd::cxx::tree::sequence< token_type > token_sequence;
      typedef token_sequence::iterator token_iterator;
      typedef token_sequence::const_iterator token_const_iterator;
      typedef ::xsd::cxx::tree::traits< token_type, char > token_traits;

      const token_sequence&
      token () const;

      token_sequence&
      token ();

      void
      token (const token_sequence& s);

      // Constructors.
      //
      token_range ();

      token_range (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      token_range (const token_range& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual token_range*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      token_range&
      operator= (const token_range& x);

      virtual 
      ~token_range ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      token_sequence token_;
    };

    class citation_ref_list: public ::xml_schema::type
    {
      public:
      // citation-ref
      //
      typedef ::xml_schema::string citation_ref_type;
      typedef ::xsd::cxx::tree::sequence< citation_ref_type > citation_ref_sequence;
      typedef citation_ref_sequence::iterator citation_ref_iterator;
      typedef citation_ref_sequence::const_iterator citation_ref_const_iterator;
      typedef ::xsd::cxx::tree::traits< citation_ref_type, char > citation_ref_traits;

      const citation_ref_sequence&
      citation_ref () const;

      citation_ref_sequence&
      citation_ref ();

      void
      citation_ref (const citation_ref_sequence& s);

      // Constructors.
      //
      citation_ref_list ();

      citation_ref_list (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      citation_ref_list (const citation_ref_list& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual citation_ref_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      citation_ref_list&
      operator= (const citation_ref_list& x);

      virtual 
      ~citation_ref_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      citation_ref_sequence citation_ref_;
    };

    class treatment_plan_definition_list: public ::xml_schema::type
    {
      public:
      // treatment-plan
      //
      typedef ::pfc::schema::treatment_plan treatment_plan_type;
      typedef ::xsd::cxx::tree::sequence< treatment_plan_type > treatment_plan_sequence;
      typedef treatment_plan_sequence::iterator treatment_plan_iterator;
      typedef treatment_plan_sequence::const_iterator treatment_plan_const_iterator;
      typedef ::xsd::cxx::tree::traits< treatment_plan_type, char > treatment_plan_traits;

      const treatment_plan_sequence&
      treatment_plan () const;

      treatment_plan_sequence&
      treatment_plan ();

      void
      treatment_plan (const treatment_plan_sequence& s);

      // Constructors.
      //
      treatment_plan_definition_list ();

      treatment_plan_definition_list (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      treatment_plan_definition_list (const treatment_plan_definition_list& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual treatment_plan_definition_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      treatment_plan_definition_list&
      operator= (const treatment_plan_definition_list& x);

      virtual 
      ~treatment_plan_definition_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      treatment_plan_sequence treatment_plan_;
    };

    class treatment_plan: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::string id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // common-name
      //
      typedef ::xml_schema::string common_name_type;
      typedef ::xsd::cxx::tree::optional< common_name_type > common_name_optional;
      typedef ::xsd::cxx::tree::traits< common_name_type, char > common_name_traits;

      const common_name_optional&
      common_name () const;

      common_name_optional&
      common_name ();

      void
      common_name (const common_name_type& x);

      void
      common_name (const common_name_optional& x);

      void
      common_name (::std::unique_ptr< common_name_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // required-equipment
      //
      typedef ::pfc::schema::equipment_ref_list required_equipment_type;
      typedef ::xsd::cxx::tree::traits< required_equipment_type, char > required_equipment_traits;

      const required_equipment_type&
      required_equipment () const;

      required_equipment_type&
      required_equipment ();

      void
      required_equipment (const required_equipment_type& x);

      void
      required_equipment (::std::unique_ptr< required_equipment_type > p);

      // references
      //
      typedef ::pfc::schema::medical_reference_list references_type;
      typedef ::xsd::cxx::tree::traits< references_type, char > references_traits;

      const references_type&
      references () const;

      references_type&
      references ();

      void
      references (const references_type& x);

      void
      references (::std::unique_ptr< references_type > p);

      // Constructors.
      //
      treatment_plan (const id_type&,
                      const description_type&,
                      const required_equipment_type&,
                      const references_type&);

      treatment_plan (const id_type&,
                      const description_type&,
                      ::std::unique_ptr< required_equipment_type >,
                      ::std::unique_ptr< references_type >);

      treatment_plan (::std::unique_ptr< id_type >,
                      ::std::unique_ptr< description_type >,
                      ::std::unique_ptr< required_equipment_type >,
                      ::std::unique_ptr< references_type >);

      treatment_plan (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      treatment_plan (const treatment_plan& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual treatment_plan*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      treatment_plan&
      operator= (const treatment_plan& x);

      virtual 
      ~treatment_plan ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      common_name_optional common_name_;
      ::xsd::cxx::tree::one< description_type > description_;
      ::xsd::cxx::tree::one< required_equipment_type > required_equipment_;
      ::xsd::cxx::tree::one< references_type > references_;
    };

    class equipment_ref_list: public ::xml_schema::type
    {
      public:
      // equipment-refs
      //
      typedef ::xml_schema::string equipment_refs_type;
      typedef ::xsd::cxx::tree::sequence< equipment_refs_type > equipment_refs_sequence;
      typedef equipment_refs_sequence::iterator equipment_refs_iterator;
      typedef equipment_refs_sequence::const_iterator equipment_refs_const_iterator;
      typedef ::xsd::cxx::tree::traits< equipment_refs_type, char > equipment_refs_traits;

      const equipment_refs_sequence&
      equipment_refs () const;

      equipment_refs_sequence&
      equipment_refs ();

      void
      equipment_refs (const equipment_refs_sequence& s);

      // Constructors.
      //
      equipment_ref_list ();

      equipment_ref_list (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      equipment_ref_list (const equipment_ref_list& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual equipment_ref_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      equipment_ref_list&
      operator= (const equipment_ref_list& x);

      virtual 
      ~equipment_ref_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      equipment_refs_sequence equipment_refs_;
    };

    class medical_reference_list: public ::xml_schema::type
    {
      public:
      // citations
      //
      typedef ::pfc::schema::citation_ref_list citations_type;
      typedef ::xsd::cxx::tree::traits< citations_type, char > citations_traits;

      const citations_type&
      citations () const;

      citations_type&
      citations ();

      void
      citations (const citations_type& x);

      void
      citations (::std::unique_ptr< citations_type > p);

      // cpgs
      //
      typedef ::pfc::schema::cpg_ref_list cpgs_type;
      typedef ::xsd::cxx::tree::traits< cpgs_type, char > cpgs_traits;

      const cpgs_type&
      cpgs () const;

      cpgs_type&
      cpgs ();

      void
      cpgs (const cpgs_type& x);

      void
      cpgs (::std::unique_ptr< cpgs_type > p);

      // Constructors.
      //
      medical_reference_list (const citations_type&,
                              const cpgs_type&);

      medical_reference_list (::std::unique_ptr< citations_type >,
                              ::std::unique_ptr< cpgs_type >);

      medical_reference_list (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      medical_reference_list (const medical_reference_list& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual medical_reference_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      medical_reference_list&
      operator= (const medical_reference_list& x);

      virtual 
      ~medical_reference_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< citations_type > citations_;
      ::xsd::cxx::tree::one< cpgs_type > cpgs_;
    };

    class cpg_ref_list: public ::xml_schema::type
    {
      public:
      // cpg-ref
      //
      typedef ::xml_schema::string cpg_ref_type;
      typedef ::xsd::cxx::tree::sequence< cpg_ref_type > cpg_ref_sequence;
      typedef cpg_ref_sequence::iterator cpg_ref_iterator;
      typedef cpg_ref_sequence::const_iterator cpg_ref_const_iterator;
      typedef ::xsd::cxx::tree::traits< cpg_ref_type, char > cpg_ref_traits;

      const cpg_ref_sequence&
      cpg_ref () const;

      cpg_ref_sequence&
      cpg_ref ();

      void
      cpg_ref (const cpg_ref_sequence& s);

      // Constructors.
      //
      cpg_ref_list ();

      cpg_ref_list (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      cpg_ref_list (const cpg_ref_list& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual cpg_ref_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      cpg_ref_list&
      operator= (const cpg_ref_list& x);

      virtual 
      ~cpg_ref_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      cpg_ref_sequence cpg_ref_;
    };

    class cpg_list: public ::xml_schema::type
    {
      public:
      // cpg
      //
      typedef ::pfc::schema::cpg cpg_type;
      typedef ::xsd::cxx::tree::sequence< cpg_type > cpg_sequence;
      typedef cpg_sequence::iterator cpg_iterator;
      typedef cpg_sequence::const_iterator cpg_const_iterator;
      typedef ::xsd::cxx::tree::traits< cpg_type, char > cpg_traits;

      const cpg_sequence&
      cpg () const;

      cpg_sequence&
      cpg ();

      void
      cpg (const cpg_sequence& s);

      // Constructors.
      //
      cpg_list ();

      cpg_list (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      cpg_list (const cpg_list& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual cpg_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      cpg_list&
      operator= (const cpg_list& x);

      virtual 
      ~cpg_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      cpg_sequence cpg_;
    };

    class cpg: public ::xml_schema::type
    {
      public:
      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // citation-ref
      //
      typedef ::xml_schema::string citation_ref_type;
      typedef ::xsd::cxx::tree::traits< citation_ref_type, char > citation_ref_traits;

      const citation_ref_type&
      citation_ref () const;

      citation_ref_type&
      citation_ref ();

      void
      citation_ref (const citation_ref_type& x);

      void
      citation_ref (::std::unique_ptr< citation_ref_type > p);

      // Constructors.
      //
      cpg (const name_type&,
           const description_type&,
           const citation_ref_type&);

      cpg (::std::unique_ptr< name_type >,
           ::std::unique_ptr< description_type >,
           ::std::unique_ptr< citation_ref_type >);

      cpg (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

      cpg (const cpg& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

      virtual cpg*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      cpg&
      operator= (const cpg& x);

      virtual 
      ~cpg ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< name_type > name_;
      ::xsd::cxx::tree::one< description_type > description_;
      ::xsd::cxx::tree::one< citation_ref_type > citation_ref_;
    };

    class learning_objective_reference_list: public ::xml_schema::type
    {
      public:
      // objective
      //
      typedef ::xml_schema::string objective_type;
      typedef ::xsd::cxx::tree::sequence< objective_type > objective_sequence;
      typedef objective_sequence::iterator objective_iterator;
      typedef objective_sequence::const_iterator objective_const_iterator;
      typedef ::xsd::cxx::tree::traits< objective_type, char > objective_traits;

      const objective_sequence&
      objective () const;

      objective_sequence&
      objective ();

      void
      objective (const objective_sequence& s);

      // Constructors.
      //
      learning_objective_reference_list ();

      learning_objective_reference_list (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      learning_objective_reference_list (const learning_objective_reference_list& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual learning_objective_reference_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      learning_objective_reference_list&
      operator= (const learning_objective_reference_list& x);

      virtual 
      ~learning_objective_reference_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      objective_sequence objective_;
    };

    class treatment_plan_ref_list: public ::xml_schema::type
    {
      public:
      // treatment-plan
      //
      typedef ::xml_schema::string treatment_plan_type;
      typedef ::xsd::cxx::tree::sequence< treatment_plan_type > treatment_plan_sequence;
      typedef treatment_plan_sequence::iterator treatment_plan_iterator;
      typedef treatment_plan_sequence::const_iterator treatment_plan_const_iterator;
      typedef ::xsd::cxx::tree::traits< treatment_plan_type, char > treatment_plan_traits;

      const treatment_plan_sequence&
      treatment_plan () const;

      treatment_plan_sequence&
      treatment_plan ();

      void
      treatment_plan (const treatment_plan_sequence& s);

      // Constructors.
      //
      treatment_plan_ref_list ();

      treatment_plan_ref_list (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      treatment_plan_ref_list (const treatment_plan_ref_list& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual treatment_plan_ref_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      treatment_plan_ref_list&
      operator= (const treatment_plan_ref_list& x);

      virtual 
      ~treatment_plan_ref_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      treatment_plan_sequence treatment_plan_;
    };

    class trauma_profile_list: public ::xml_schema::type
    {
      public:
      // trauma-profile
      //
      typedef ::pfc::schema::trauma_profile trauma_profile_type;
      typedef ::xsd::cxx::tree::sequence< trauma_profile_type > trauma_profile_sequence;
      typedef trauma_profile_sequence::iterator trauma_profile_iterator;
      typedef trauma_profile_sequence::const_iterator trauma_profile_const_iterator;
      typedef ::xsd::cxx::tree::traits< trauma_profile_type, char > trauma_profile_traits;

      const trauma_profile_sequence&
      trauma_profile () const;

      trauma_profile_sequence&
      trauma_profile ();

      void
      trauma_profile (const trauma_profile_sequence& s);

      // Constructors.
      //
      trauma_profile_list ();

      trauma_profile_list (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      trauma_profile_list (const trauma_profile_list& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual trauma_profile_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      trauma_profile_list&
      operator= (const trauma_profile_list& x);

      virtual 
      ~trauma_profile_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      trauma_profile_sequence trauma_profile_;
    };

    class trauma_profile: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::string id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // physiology-state
      //
      typedef ::xml_schema::string physiology_state_type;
      typedef ::xsd::cxx::tree::optional< physiology_state_type > physiology_state_optional;
      typedef ::xsd::cxx::tree::traits< physiology_state_type, char > physiology_state_traits;

      const physiology_state_optional&
      physiology_state () const;

      physiology_state_optional&
      physiology_state ();

      void
      physiology_state (const physiology_state_type& x);

      void
      physiology_state (const physiology_state_optional& x);

      void
      physiology_state (::std::unique_ptr< physiology_state_type > p);

      // injuries
      //
      typedef ::pfc::schema::trauma_occurence_list injuries_type;
      typedef ::xsd::cxx::tree::traits< injuries_type, char > injuries_traits;

      const injuries_type&
      injuries () const;

      injuries_type&
      injuries ();

      void
      injuries (const injuries_type& x);

      void
      injuries (::std::unique_ptr< injuries_type > p);

      // treatments
      //
      typedef ::pfc::schema::treatment_plan_ref_list treatments_type;
      typedef ::xsd::cxx::tree::traits< treatments_type, char > treatments_traits;

      const treatments_type&
      treatments () const;

      treatments_type&
      treatments ();

      void
      treatments (const treatments_type& x);

      void
      treatments (::std::unique_ptr< treatments_type > p);

      // Constructors.
      //
      trauma_profile (const id_type&,
                      const name_type&,
                      const injuries_type&,
                      const treatments_type&);

      trauma_profile (const id_type&,
                      const name_type&,
                      ::std::unique_ptr< injuries_type >,
                      ::std::unique_ptr< treatments_type >);

      trauma_profile (::std::unique_ptr< id_type >,
                      ::std::unique_ptr< name_type >,
                      ::std::unique_ptr< injuries_type >,
                      ::std::unique_ptr< treatments_type >);

      trauma_profile (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      trauma_profile (const trauma_profile& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual trauma_profile*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      trauma_profile&
      operator= (const trauma_profile& x);

      virtual 
      ~trauma_profile ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< name_type > name_;
      physiology_state_optional physiology_state_;
      ::xsd::cxx::tree::one< injuries_type > injuries_;
      ::xsd::cxx::tree::one< treatments_type > treatments_;
    };

    class trauma_profile_ref_list: public ::xml_schema::type
    {
      public:
      // trauma-profile
      //
      typedef ::xml_schema::string trauma_profile_type;
      typedef ::xsd::cxx::tree::sequence< trauma_profile_type > trauma_profile_sequence;
      typedef trauma_profile_sequence::iterator trauma_profile_iterator;
      typedef trauma_profile_sequence::const_iterator trauma_profile_const_iterator;
      typedef ::xsd::cxx::tree::traits< trauma_profile_type, char > trauma_profile_traits;

      const trauma_profile_sequence&
      trauma_profile () const;

      trauma_profile_sequence&
      trauma_profile ();

      void
      trauma_profile (const trauma_profile_sequence& s);

      // Constructors.
      //
      trauma_profile_ref_list ();

      trauma_profile_ref_list (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      trauma_profile_ref_list (const trauma_profile_ref_list& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual trauma_profile_ref_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      trauma_profile_ref_list&
      operator= (const trauma_profile_ref_list& x);

      virtual 
      ~trauma_profile_ref_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      trauma_profile_sequence trauma_profile_;
    };

    class trauma_occurence_list: public ::xml_schema::type
    {
      public:
      // trauma
      //
      typedef ::pfc::schema::trauma_occurence trauma_type;
      typedef ::xsd::cxx::tree::sequence< trauma_type > trauma_sequence;
      typedef trauma_sequence::iterator trauma_iterator;
      typedef trauma_sequence::const_iterator trauma_const_iterator;
      typedef ::xsd::cxx::tree::traits< trauma_type, char > trauma_traits;

      const trauma_sequence&
      trauma () const;

      trauma_sequence&
      trauma ();

      void
      trauma (const trauma_sequence& s);

      // Constructors.
      //
      trauma_occurence_list ();

      trauma_occurence_list (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      trauma_occurence_list (const trauma_occurence_list& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual trauma_occurence_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      trauma_occurence_list&
      operator= (const trauma_occurence_list& x);

      virtual 
      ~trauma_occurence_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      trauma_sequence trauma_;
    };

    class trauma_occurence: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::string id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // location
      //
      typedef ::xml_schema::string location_type;
      typedef ::xsd::cxx::tree::traits< location_type, char > location_traits;

      const location_type&
      location () const;

      location_type&
      location ();

      void
      location (const location_type& x);

      void
      location (::std::unique_ptr< location_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // severity
      //
      typedef ::xml_schema::string severity_type;
      typedef ::xsd::cxx::tree::traits< severity_type, char > severity_traits;

      const severity_type&
      severity () const;

      severity_type&
      severity ();

      void
      severity (const severity_type& x);

      void
      severity (::std::unique_ptr< severity_type > p);

      // Constructors.
      //
      trauma_occurence (const id_type&,
                        const location_type&,
                        const description_type&,
                        const severity_type&);

      trauma_occurence (::std::unique_ptr< id_type >,
                        ::std::unique_ptr< location_type >,
                        ::std::unique_ptr< description_type >,
                        ::std::unique_ptr< severity_type >);

      trauma_occurence (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      trauma_occurence (const trauma_occurence& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual trauma_occurence*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      trauma_occurence&
      operator= (const trauma_occurence& x);

      virtual 
      ~trauma_occurence ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< location_type > location_;
      ::xsd::cxx::tree::one< description_type > description_;
      ::xsd::cxx::tree::one< severity_type > severity_;
    };

    class medical_scenario_syllabus: public ::xml_schema::type
    {
      public:
      // learning-objectives
      //
      typedef ::pfc::schema::learning_objective_list learning_objectives_type;
      typedef ::xsd::cxx::tree::traits< learning_objectives_type, char > learning_objectives_traits;

      const learning_objectives_type&
      learning_objectives () const;

      learning_objectives_type&
      learning_objectives ();

      void
      learning_objectives (const learning_objectives_type& x);

      void
      learning_objectives (::std::unique_ptr< learning_objectives_type > p);

      // learning-assessments
      //
      typedef ::pfc::schema::assessment_list learning_assessments_type;
      typedef ::xsd::cxx::tree::traits< learning_assessments_type, char > learning_assessments_traits;

      const learning_assessments_type&
      learning_assessments () const;

      learning_assessments_type&
      learning_assessments ();

      void
      learning_assessments (const learning_assessments_type& x);

      void
      learning_assessments (::std::unique_ptr< learning_assessments_type > p);

      // Constructors.
      //
      medical_scenario_syllabus (const learning_objectives_type&,
                                 const learning_assessments_type&);

      medical_scenario_syllabus (::std::unique_ptr< learning_objectives_type >,
                                 ::std::unique_ptr< learning_assessments_type >);

      medical_scenario_syllabus (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      medical_scenario_syllabus (const medical_scenario_syllabus& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual medical_scenario_syllabus*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      medical_scenario_syllabus&
      operator= (const medical_scenario_syllabus& x);

      virtual 
      ~medical_scenario_syllabus ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< learning_objectives_type > learning_objectives_;
      ::xsd::cxx::tree::one< learning_assessments_type > learning_assessments_;
    };

    class learning_objective_list: public ::xml_schema::type
    {
      public:
      // objective
      //
      typedef ::pfc::schema::learning_objective objective_type;
      typedef ::xsd::cxx::tree::sequence< objective_type > objective_sequence;
      typedef objective_sequence::iterator objective_iterator;
      typedef objective_sequence::const_iterator objective_const_iterator;
      typedef ::xsd::cxx::tree::traits< objective_type, char > objective_traits;

      const objective_sequence&
      objective () const;

      objective_sequence&
      objective ();

      void
      objective (const objective_sequence& s);

      // Constructors.
      //
      learning_objective_list ();

      learning_objective_list (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      learning_objective_list (const learning_objective_list& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual learning_objective_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      learning_objective_list&
      operator= (const learning_objective_list& x);

      virtual 
      ~learning_objective_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      objective_sequence objective_;
    };

    class learning_objective: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::string id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // references
      //
      typedef ::pfc::schema::medical_reference_list references_type;
      typedef ::xsd::cxx::tree::traits< references_type, char > references_traits;

      const references_type&
      references () const;

      references_type&
      references ();

      void
      references (const references_type& x);

      void
      references (::std::unique_ptr< references_type > p);

      // relates-to
      //
      typedef ::pfc::schema::relates_to relates_to_type;
      typedef ::xsd::cxx::tree::traits< relates_to_type, char > relates_to_traits;

      const relates_to_type&
      relates_to () const;

      relates_to_type&
      relates_to ();

      void
      relates_to (const relates_to_type& x);

      void
      relates_to (::std::unique_ptr< relates_to_type > p);

      // Constructors.
      //
      learning_objective (const id_type&,
                          const name_type&,
                          const description_type&,
                          const references_type&,
                          const relates_to_type&);

      learning_objective (const id_type&,
                          const name_type&,
                          const description_type&,
                          ::std::unique_ptr< references_type >,
                          ::std::unique_ptr< relates_to_type >);

      learning_objective (::std::unique_ptr< id_type >,
                          ::std::unique_ptr< name_type >,
                          ::std::unique_ptr< description_type >,
                          ::std::unique_ptr< references_type >,
                          ::std::unique_ptr< relates_to_type >);

      learning_objective (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      learning_objective (const learning_objective& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual learning_objective*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      learning_objective&
      operator= (const learning_objective& x);

      virtual 
      ~learning_objective ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< name_type > name_;
      ::xsd::cxx::tree::one< description_type > description_;
      ::xsd::cxx::tree::one< references_type > references_;
      ::xsd::cxx::tree::one< relates_to_type > relates_to_;
    };

    class assessment_list: public ::xml_schema::type
    {
      public:
      // total-points
      //
      typedef ::xml_schema::integer total_points_type;
      typedef ::xsd::cxx::tree::traits< total_points_type, char > total_points_traits;

      const total_points_type&
      total_points () const;

      total_points_type&
      total_points ();

      void
      total_points (const total_points_type& x);

      static total_points_type
      total_points_default_value ();

      // assessment
      //
      typedef ::pfc::schema::assessment assessment_type;
      typedef ::xsd::cxx::tree::sequence< assessment_type > assessment_sequence;
      typedef assessment_sequence::iterator assessment_iterator;
      typedef assessment_sequence::const_iterator assessment_const_iterator;
      typedef ::xsd::cxx::tree::traits< assessment_type, char > assessment_traits;

      const assessment_sequence&
      assessment () const;

      assessment_sequence&
      assessment ();

      void
      assessment (const assessment_sequence& s);

      // Constructors.
      //
      assessment_list (const total_points_type&);

      assessment_list (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      assessment_list (const assessment_list& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual assessment_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      assessment_list&
      operator= (const assessment_list& x);

      virtual 
      ~assessment_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< total_points_type > total_points_;
      assessment_sequence assessment_;
    };

    class assessment: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::string id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // objective-id
      //
      typedef ::xml_schema::string objective_id_type;
      typedef ::xsd::cxx::tree::traits< objective_id_type, char > objective_id_traits;

      const objective_id_type&
      objective_id () const;

      objective_id_type&
      objective_id ();

      void
      objective_id (const objective_id_type& x);

      void
      objective_id (::std::unique_ptr< objective_id_type > p);

      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // points-avaiable
      //
      typedef ::xml_schema::integer points_avaiable_type;
      typedef ::xsd::cxx::tree::traits< points_avaiable_type, char > points_avaiable_traits;

      const points_avaiable_type&
      points_avaiable () const;

      points_avaiable_type&
      points_avaiable ();

      void
      points_avaiable (const points_avaiable_type& x);

      // criteria
      //
      typedef ::xml_schema::string criteria_type;
      typedef ::xsd::cxx::tree::traits< criteria_type, char > criteria_traits;

      const criteria_type&
      criteria () const;

      criteria_type&
      criteria ();

      void
      criteria (const criteria_type& x);

      void
      criteria (::std::unique_ptr< criteria_type > p);

      // Constructors.
      //
      assessment (const id_type&,
                  const objective_id_type&,
                  const name_type&,
                  const description_type&,
                  const points_avaiable_type&,
                  const criteria_type&);

      assessment (::std::unique_ptr< id_type >,
                  ::std::unique_ptr< objective_id_type >,
                  ::std::unique_ptr< name_type >,
                  ::std::unique_ptr< description_type >,
                  const points_avaiable_type&,
                  ::std::unique_ptr< criteria_type >);

      assessment (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      assessment (const assessment& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual assessment*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      assessment&
      operator= (const assessment& x);

      virtual 
      ~assessment ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< objective_id_type > objective_id_;
      ::xsd::cxx::tree::one< name_type > name_;
      ::xsd::cxx::tree::one< description_type > description_;
      ::xsd::cxx::tree::one< points_avaiable_type > points_avaiable_;
      ::xsd::cxx::tree::one< criteria_type > criteria_;
    };

    class medical_scenario: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::string id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // roles
      //
      typedef ::pfc::schema::role_list roles_type;
      typedef ::xsd::cxx::tree::traits< roles_type, char > roles_traits;

      const roles_type&
      roles () const;

      roles_type&
      roles ();

      void
      roles (const roles_type& x);

      void
      roles (::std::unique_ptr< roles_type > p);

      // training-script
      //
      typedef ::pfc::schema::scene_list training_script_type;
      typedef ::xsd::cxx::tree::traits< training_script_type, char > training_script_traits;

      const training_script_type&
      training_script () const;

      training_script_type&
      training_script ();

      void
      training_script (const training_script_type& x);

      void
      training_script (::std::unique_ptr< training_script_type > p);

      // Constructors.
      //
      medical_scenario (const id_type&,
                        const roles_type&,
                        const training_script_type&);

      medical_scenario (const id_type&,
                        ::std::unique_ptr< roles_type >,
                        ::std::unique_ptr< training_script_type >);

      medical_scenario (::std::unique_ptr< id_type >,
                        ::std::unique_ptr< roles_type >,
                        ::std::unique_ptr< training_script_type >);

      medical_scenario (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      medical_scenario (const medical_scenario& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual medical_scenario*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      medical_scenario&
      operator= (const medical_scenario& x);

      virtual 
      ~medical_scenario ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< roles_type > roles_;
      ::xsd::cxx::tree::one< training_script_type > training_script_;
    };

    class role_list: public ::xml_schema::type
    {
      public:
      // role
      //
      typedef ::pfc::schema::role role_type;
      typedef ::xsd::cxx::tree::sequence< role_type > role_sequence;
      typedef role_sequence::iterator role_iterator;
      typedef role_sequence::const_iterator role_const_iterator;
      typedef ::xsd::cxx::tree::traits< role_type, char > role_traits;

      const role_sequence&
      role () const;

      role_sequence&
      role ();

      void
      role (const role_sequence& s);

      // Constructors.
      //
      role_list ();

      role_list (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      role_list (const role_list& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual role_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      role_list&
      operator= (const role_list& x);

      virtual 
      ~role_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      role_sequence role_;
    };

    class role: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::string id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // short-name
      //
      typedef ::xml_schema::string short_name_type;
      typedef ::xsd::cxx::tree::traits< short_name_type, char > short_name_traits;

      const short_name_type&
      short_name () const;

      short_name_type&
      short_name ();

      void
      short_name (const short_name_type& x);

      void
      short_name (::std::unique_ptr< short_name_type > p);

      // trauma-profile-ref
      //
      typedef ::xml_schema::string trauma_profile_ref_type;
      typedef ::xsd::cxx::tree::optional< trauma_profile_ref_type > trauma_profile_ref_optional;
      typedef ::xsd::cxx::tree::traits< trauma_profile_ref_type, char > trauma_profile_ref_traits;

      const trauma_profile_ref_optional&
      trauma_profile_ref () const;

      trauma_profile_ref_optional&
      trauma_profile_ref ();

      void
      trauma_profile_ref (const trauma_profile_ref_type& x);

      void
      trauma_profile_ref (const trauma_profile_ref_optional& x);

      void
      trauma_profile_ref (::std::unique_ptr< trauma_profile_ref_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // Constructors.
      //
      role (const id_type&,
            const name_type&,
            const short_name_type&,
            const description_type&);

      role (::std::unique_ptr< id_type >,
            ::std::unique_ptr< name_type >,
            ::std::unique_ptr< short_name_type >,
            ::std::unique_ptr< description_type >);

      role (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      role (const role& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      virtual role*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      role&
      operator= (const role& x);

      virtual 
      ~role ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< name_type > name_;
      ::xsd::cxx::tree::one< short_name_type > short_name_;
      trauma_profile_ref_optional trauma_profile_ref_;
      ::xsd::cxx::tree::one< description_type > description_;
    };

    class role_ref_list: public ::xml_schema::type
    {
      public:
      // role-ref
      //
      typedef ::xml_schema::string role_ref_type;
      typedef ::xsd::cxx::tree::sequence< role_ref_type > role_ref_sequence;
      typedef role_ref_sequence::iterator role_ref_iterator;
      typedef role_ref_sequence::const_iterator role_ref_const_iterator;
      typedef ::xsd::cxx::tree::traits< role_ref_type, char > role_ref_traits;

      const role_ref_sequence&
      role_ref () const;

      role_ref_sequence&
      role_ref ();

      void
      role_ref (const role_ref_sequence& s);

      // Constructors.
      //
      role_ref_list ();

      role_ref_list (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      role_ref_list (const role_ref_list& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual role_ref_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      role_ref_list&
      operator= (const role_ref_list& x);

      virtual 
      ~role_ref_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      role_ref_sequence role_ref_;
    };

    class item_list: public ::xml_schema::type
    {
      public:
      // item
      //
      typedef ::pfc::schema::item item_type;
      typedef ::xsd::cxx::tree::sequence< item_type > item_sequence;
      typedef item_sequence::iterator item_iterator;
      typedef item_sequence::const_iterator item_const_iterator;
      typedef ::xsd::cxx::tree::traits< item_type, char > item_traits;

      const item_sequence&
      item () const;

      item_sequence&
      item ();

      void
      item (const item_sequence& s);

      // Constructors.
      //
      item_list ();

      item_list (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      item_list (const item_list& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual item_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      item_list&
      operator= (const item_list& x);

      virtual 
      ~item_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      item_sequence item_;
    };

    class item: public ::xml_schema::type
    {
      public:
      // short-name
      //
      typedef ::xml_schema::string short_name_type;
      typedef ::xsd::cxx::tree::traits< short_name_type, char > short_name_traits;

      const short_name_type&
      short_name () const;

      short_name_type&
      short_name ();

      void
      short_name (const short_name_type& x);

      void
      short_name (::std::unique_ptr< short_name_type > p);

      // equipment-id
      //
      typedef ::xml_schema::string equipment_id_type;
      typedef ::xsd::cxx::tree::traits< equipment_id_type, char > equipment_id_traits;

      const equipment_id_type&
      equipment_id () const;

      equipment_id_type&
      equipment_id ();

      void
      equipment_id (const equipment_id_type& x);

      void
      equipment_id (::std::unique_ptr< equipment_id_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // properties
      //
      typedef ::pfc::schema::property_value_list properties_type;
      typedef ::xsd::cxx::tree::traits< properties_type, char > properties_traits;

      const properties_type&
      properties () const;

      properties_type&
      properties ();

      void
      properties (const properties_type& x);

      void
      properties (::std::unique_ptr< properties_type > p);

      // Constructors.
      //
      item (const short_name_type&,
            const equipment_id_type&,
            const description_type&,
            const properties_type&);

      item (const short_name_type&,
            const equipment_id_type&,
            const description_type&,
            ::std::unique_ptr< properties_type >);

      item (::std::unique_ptr< short_name_type >,
            ::std::unique_ptr< equipment_id_type >,
            ::std::unique_ptr< description_type >,
            ::std::unique_ptr< properties_type >);

      item (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      item (const item& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      virtual item*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      item&
      operator= (const item& x);

      virtual 
      ~item ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< short_name_type > short_name_;
      ::xsd::cxx::tree::one< equipment_id_type > equipment_id_;
      ::xsd::cxx::tree::one< description_type > description_;
      ::xsd::cxx::tree::one< properties_type > properties_;
    };

    class scene_list: public ::xml_schema::type
    {
      public:
      // scene
      //
      typedef ::pfc::schema::scene scene_type;
      typedef ::xsd::cxx::tree::sequence< scene_type > scene_sequence;
      typedef scene_sequence::iterator scene_iterator;
      typedef scene_sequence::const_iterator scene_const_iterator;
      typedef ::xsd::cxx::tree::traits< scene_type, char > scene_traits;

      const scene_sequence&
      scene () const;

      scene_sequence&
      scene ();

      void
      scene (const scene_sequence& s);

      // Constructors.
      //
      scene_list ();

      scene_list (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      scene_list (const scene_list& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual scene_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      scene_list&
      operator= (const scene_list& x);

      virtual 
      ~scene_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      scene_sequence scene_;
    };

    class scene: public ::xml_schema::type
    {
      public:
      // location-id
      //
      typedef ::xml_schema::string location_id_type;
      typedef ::xsd::cxx::tree::traits< location_id_type, char > location_id_traits;

      const location_id_type&
      location_id () const;

      location_id_type&
      location_id ();

      void
      location_id (const location_id_type& x);

      void
      location_id (::std::unique_ptr< location_id_type > p);

      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // time-of-day
      //
      typedef ::xml_schema::time time_of_day_type;
      typedef ::xsd::cxx::tree::traits< time_of_day_type, char > time_of_day_traits;

      const time_of_day_type&
      time_of_day () const;

      time_of_day_type&
      time_of_day ();

      void
      time_of_day (const time_of_day_type& x);

      void
      time_of_day (::std::unique_ptr< time_of_day_type > p);

      // time-in-simulation
      //
      typedef ::xml_schema::integer time_in_simulation_type;
      typedef ::xsd::cxx::tree::traits< time_in_simulation_type, char > time_in_simulation_traits;

      const time_in_simulation_type&
      time_in_simulation () const;

      time_in_simulation_type&
      time_in_simulation ();

      void
      time_in_simulation (const time_in_simulation_type& x);

      // events
      //
      typedef ::pfc::schema::event_list events_type;
      typedef ::xsd::cxx::tree::traits< events_type, char > events_traits;

      const events_type&
      events () const;

      events_type&
      events ();

      void
      events (const events_type& x);

      void
      events (::std::unique_ptr< events_type > p);

      // items
      //
      typedef ::pfc::schema::item_list items_type;
      typedef ::xsd::cxx::tree::traits< items_type, char > items_traits;

      const items_type&
      items () const;

      items_type&
      items ();

      void
      items (const items_type& x);

      void
      items (::std::unique_ptr< items_type > p);

      // roles
      //
      typedef ::pfc::schema::role_ref_list roles_type;
      typedef ::xsd::cxx::tree::traits< roles_type, char > roles_traits;

      const roles_type&
      roles () const;

      roles_type&
      roles ();

      void
      roles (const roles_type& x);

      void
      roles (::std::unique_ptr< roles_type > p);

      // Constructors.
      //
      scene (const location_id_type&,
             const name_type&,
             const description_type&,
             const time_of_day_type&,
             const time_in_simulation_type&,
             const events_type&,
             const items_type&,
             const roles_type&);

      scene (const location_id_type&,
             const name_type&,
             const description_type&,
             const time_of_day_type&,
             const time_in_simulation_type&,
             ::std::unique_ptr< events_type >,
             ::std::unique_ptr< items_type >,
             ::std::unique_ptr< roles_type >);

      scene (::std::unique_ptr< location_id_type >,
             ::std::unique_ptr< name_type >,
             ::std::unique_ptr< description_type >,
             ::std::unique_ptr< time_of_day_type >,
             const time_in_simulation_type&,
             ::std::unique_ptr< events_type >,
             ::std::unique_ptr< items_type >,
             ::std::unique_ptr< roles_type >);

      scene (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      scene (const scene& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      virtual scene*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      scene&
      operator= (const scene& x);

      virtual 
      ~scene ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< location_id_type > location_id_;
      ::xsd::cxx::tree::one< name_type > name_;
      ::xsd::cxx::tree::one< description_type > description_;
      ::xsd::cxx::tree::one< time_of_day_type > time_of_day_;
      ::xsd::cxx::tree::one< time_in_simulation_type > time_in_simulation_;
      ::xsd::cxx::tree::one< events_type > events_;
      ::xsd::cxx::tree::one< items_type > items_;
      ::xsd::cxx::tree::one< roles_type > roles_;
    };

    class event_list: public ::xml_schema::type
    {
      public:
      // event
      //
      typedef ::pfc::schema::event event_type;
      typedef ::xsd::cxx::tree::sequence< event_type > event_sequence;
      typedef event_sequence::iterator event_iterator;
      typedef event_sequence::const_iterator event_const_iterator;
      typedef ::xsd::cxx::tree::traits< event_type, char > event_traits;

      const event_sequence&
      event () const;

      event_sequence&
      event ();

      void
      event (const event_sequence& s);

      // Constructors.
      //
      event_list ();

      event_list (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      event_list (const event_list& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual event_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      event_list&
      operator= (const event_list& x);

      virtual 
      ~event_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      event_sequence event_;
    };

    class event: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::string id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // category
      //
      typedef ::pfc::schema::event_category_enum category_type;
      typedef ::xsd::cxx::tree::traits< category_type, char > category_traits;

      const category_type&
      category () const;

      category_type&
      category ();

      void
      category (const category_type& x);

      void
      category (::std::unique_ptr< category_type > p);

      // fidelity
      //
      typedef ::pfc::schema::event_fidelity_enum fidelity_type;
      typedef ::xsd::cxx::tree::traits< fidelity_type, char > fidelity_traits;

      const fidelity_type&
      fidelity () const;

      fidelity_type&
      fidelity ();

      void
      fidelity (const fidelity_type& x);

      void
      fidelity (::std::unique_ptr< fidelity_type > p);

      // actor_1
      //
      typedef ::xml_schema::string actor_1_type;
      typedef ::xsd::cxx::tree::traits< actor_1_type, char > actor_1_traits;

      const actor_1_type&
      actor_1 () const;

      actor_1_type&
      actor_1 ();

      void
      actor_1 (const actor_1_type& x);

      void
      actor_1 (::std::unique_ptr< actor_1_type > p);

      // actor_2
      //
      typedef ::xml_schema::string actor_2_type;
      typedef ::xsd::cxx::tree::traits< actor_2_type, char > actor_2_traits;

      const actor_2_type&
      actor_2 () const;

      actor_2_type&
      actor_2 ();

      void
      actor_2 (const actor_2_type& x);

      void
      actor_2 (::std::unique_ptr< actor_2_type > p);

      // equipment
      //
      typedef ::xml_schema::string equipment_type;
      typedef ::xsd::cxx::tree::traits< equipment_type, char > equipment_traits;

      const equipment_type&
      equipment () const;

      equipment_type&
      equipment ();

      void
      equipment (const equipment_type& x);

      void
      equipment (::std::unique_ptr< equipment_type > p);

      // details
      //
      typedef ::xml_schema::string details_type;
      typedef ::xsd::cxx::tree::traits< details_type, char > details_traits;

      const details_type&
      details () const;

      details_type&
      details ();

      void
      details (const details_type& x);

      void
      details (::std::unique_ptr< details_type > p);

      // Constructors.
      //
      event (const id_type&,
             const name_type&,
             const category_type&,
             const fidelity_type&,
             const actor_1_type&,
             const actor_2_type&,
             const equipment_type&,
             const details_type&);

      event (::std::unique_ptr< id_type >,
             ::std::unique_ptr< name_type >,
             ::std::unique_ptr< category_type >,
             ::std::unique_ptr< fidelity_type >,
             ::std::unique_ptr< actor_1_type >,
             ::std::unique_ptr< actor_2_type >,
             ::std::unique_ptr< equipment_type >,
             ::std::unique_ptr< details_type >);

      event (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      event (const event& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      virtual event*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      event&
      operator= (const event& x);

      virtual 
      ~event ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< name_type > name_;
      ::xsd::cxx::tree::one< category_type > category_;
      ::xsd::cxx::tree::one< fidelity_type > fidelity_;
      ::xsd::cxx::tree::one< actor_1_type > actor_1_;
      ::xsd::cxx::tree::one< actor_2_type > actor_2_;
      ::xsd::cxx::tree::one< equipment_type > equipment_;
      ::xsd::cxx::tree::one< details_type > details_;
    };

    class event_category_enum: public ::xml_schema::string
    {
      public:
      enum value
      {
        ACTION,
        DIALOG,
        MOVMENT,
        SOUND,
        ENVIRONMENT
      };

      event_category_enum (value v);

      event_category_enum (const char* v);

      event_category_enum (const ::std::string& v);

      event_category_enum (const ::xml_schema::string& v);

      event_category_enum (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      event_category_enum (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      event_category_enum (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      event_category_enum (const event_category_enum& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual event_category_enum*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      event_category_enum&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_event_category_enum_convert ();
      }

      protected:
      value
      _xsd_event_category_enum_convert () const;

      public:
      static const char* const _xsd_event_category_enum_literals_[5];
      static const value _xsd_event_category_enum_indexes_[5];
    };

    class event_fidelity_enum: public ::xml_schema::string
    {
      public:
      enum value
      {
        LOW,
        MEDIUM,
        HIGH
      };

      event_fidelity_enum (value v);

      event_fidelity_enum (const char* v);

      event_fidelity_enum (const ::std::string& v);

      event_fidelity_enum (const ::xml_schema::string& v);

      event_fidelity_enum (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      event_fidelity_enum (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      event_fidelity_enum (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      event_fidelity_enum (const event_fidelity_enum& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual event_fidelity_enum*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      event_fidelity_enum&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_event_fidelity_enum_convert ();
      }

      protected:
      value
      _xsd_event_fidelity_enum_convert () const;

      public:
      static const char* const _xsd_event_fidelity_enum_literals_[3];
      static const value _xsd_event_fidelity_enum_indexes_[3];
    };

    class citation_list: public ::xml_schema::type
    {
      public:
      // citation
      //
      typedef ::pfc::schema::citation citation_type;
      typedef ::xsd::cxx::tree::sequence< citation_type > citation_sequence;
      typedef citation_sequence::iterator citation_iterator;
      typedef citation_sequence::const_iterator citation_const_iterator;
      typedef ::xsd::cxx::tree::traits< citation_type, char > citation_traits;

      const citation_sequence&
      citation () const;

      citation_sequence&
      citation ();

      void
      citation (const citation_sequence& s);

      // Constructors.
      //
      citation_list ();

      citation_list (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      citation_list (const citation_list& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual citation_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      citation_list&
      operator= (const citation_list& x);

      virtual 
      ~citation_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      citation_sequence citation_;
    };

    class citation: public ::xml_schema::type
    {
      public:
      // uuid
      //
      typedef ::xml_schema::string uuid_type;
      typedef ::xsd::cxx::tree::traits< uuid_type, char > uuid_traits;

      const uuid_type&
      uuid () const;

      uuid_type&
      uuid ();

      void
      uuid (const uuid_type& x);

      void
      uuid (::std::unique_ptr< uuid_type > p);

      // authors
      //
      typedef ::xml_schema::string authors_type;
      typedef ::xsd::cxx::tree::sequence< authors_type > authors_sequence;
      typedef authors_sequence::iterator authors_iterator;
      typedef authors_sequence::const_iterator authors_const_iterator;
      typedef ::xsd::cxx::tree::traits< authors_type, char > authors_traits;

      const authors_sequence&
      authors () const;

      authors_sequence&
      authors ();

      void
      authors (const authors_sequence& s);

      // title
      //
      typedef ::xml_schema::string title_type;
      typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

      const title_type&
      title () const;

      title_type&
      title ();

      void
      title (const title_type& x);

      void
      title (::std::unique_ptr< title_type > p);

      // date
      //
      typedef ::xml_schema::string date_type;
      typedef ::xsd::cxx::tree::traits< date_type, char > date_traits;

      const date_type&
      date () const;

      date_type&
      date ();

      void
      date (const date_type& x);

      void
      date (::std::unique_ptr< date_type > p);

      // page
      //
      typedef ::xml_schema::string page_type;
      typedef ::xsd::cxx::tree::optional< page_type > page_optional;
      typedef ::xsd::cxx::tree::traits< page_type, char > page_traits;

      const page_optional&
      page () const;

      page_optional&
      page ();

      void
      page (const page_type& x);

      void
      page (const page_optional& x);

      void
      page (::std::unique_ptr< page_type > p);

      // accessed
      //
      typedef ::xml_schema::string accessed_type;
      typedef ::xsd::cxx::tree::optional< accessed_type > accessed_optional;
      typedef ::xsd::cxx::tree::traits< accessed_type, char > accessed_traits;

      const accessed_optional&
      accessed () const;

      accessed_optional&
      accessed ();

      void
      accessed (const accessed_type& x);

      void
      accessed (const accessed_optional& x);

      void
      accessed (::std::unique_ptr< accessed_type > p);

      // Constructors.
      //
      citation (const uuid_type&,
                const title_type&,
                const date_type&);

      citation (::std::unique_ptr< uuid_type >,
                ::std::unique_ptr< title_type >,
                ::std::unique_ptr< date_type >);

      citation (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      citation (const citation& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual citation*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      citation&
      operator= (const citation& x);

      virtual 
      ~citation ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< uuid_type > uuid_;
      authors_sequence authors_;
      ::xsd::cxx::tree::one< title_type > title_;
      ::xsd::cxx::tree::one< date_type > date_;
      page_optional page_;
      accessed_optional accessed_;
    };

    class properties_list: public ::xml_schema::type
    {
      public:
      // property
      //
      typedef ::pfc::schema::property property_type;
      typedef ::xsd::cxx::tree::sequence< property_type > property_sequence;
      typedef property_sequence::iterator property_iterator;
      typedef property_sequence::const_iterator property_const_iterator;
      typedef ::xsd::cxx::tree::traits< property_type, char > property_traits;

      const property_sequence&
      property () const;

      property_sequence&
      property ();

      void
      property (const property_sequence& s);

      // Constructors.
      //
      properties_list ();

      properties_list (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      properties_list (const properties_list& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual properties_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      properties_list&
      operator= (const properties_list& x);

      virtual 
      ~properties_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      property_sequence property_;
    };

    class property: public ::xml_schema::type
    {
      public:
      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // type
      //
      typedef ::xml_schema::string type_type;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_type&
      type () const;

      type_type&
      type ();

      void
      type (const type_type& x);

      void
      type (::std::unique_ptr< type_type > p);

      // Constructors.
      //
      property (const name_type&,
                const type_type&);

      property (::std::unique_ptr< name_type >,
                ::std::unique_ptr< type_type >);

      property (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      property (const property& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual property*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      property&
      operator= (const property& x);

      virtual 
      ~property ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< name_type > name_;
      ::xsd::cxx::tree::one< type_type > type_;
    };

    class property_value_list: public ::xml_schema::type
    {
      public:
      // value
      //
      typedef ::pfc::schema::property_value value_type;
      typedef ::xsd::cxx::tree::sequence< value_type > value_sequence;
      typedef value_sequence::iterator value_iterator;
      typedef value_sequence::const_iterator value_const_iterator;
      typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

      const value_sequence&
      value () const;

      value_sequence&
      value ();

      void
      value (const value_sequence& s);

      // Constructors.
      //
      property_value_list ();

      property_value_list (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      property_value_list (const property_value_list& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual property_value_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      property_value_list&
      operator= (const property_value_list& x);

      virtual 
      ~property_value_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      value_sequence value_;
    };

    class property_value: public ::xml_schema::type
    {
      public:
      // value
      //
      typedef ::xml_schema::string value_type;
      typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      void
      value (::std::unique_ptr< value_type > p);

      // Constructors.
      //
      property_value (const value_type&);

      property_value (::std::unique_ptr< value_type >);

      property_value (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      property_value (const property_value& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual property_value*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      property_value&
      operator= (const property_value& x);

      virtual 
      ~property_value ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class relates_to: public ::xml_schema::type
    {
      public:
      // treatment-plans
      //
      typedef ::pfc::schema::treatment_plan_ref_list treatment_plans_type;
      typedef ::xsd::cxx::tree::traits< treatment_plans_type, char > treatment_plans_traits;

      const treatment_plans_type&
      treatment_plans () const;

      treatment_plans_type&
      treatment_plans ();

      void
      treatment_plans (const treatment_plans_type& x);

      void
      treatment_plans (::std::unique_ptr< treatment_plans_type > p);

      // trauma-profiles
      //
      typedef ::pfc::schema::trauma_profile_ref_list trauma_profiles_type;
      typedef ::xsd::cxx::tree::traits< trauma_profiles_type, char > trauma_profiles_traits;

      const trauma_profiles_type&
      trauma_profiles () const;

      trauma_profiles_type&
      trauma_profiles ();

      void
      trauma_profiles (const trauma_profiles_type& x);

      void
      trauma_profiles (::std::unique_ptr< trauma_profiles_type > p);

      // Constructors.
      //
      relates_to (const treatment_plans_type&,
                  const trauma_profiles_type&);

      relates_to (::std::unique_ptr< treatment_plans_type >,
                  ::std::unique_ptr< trauma_profiles_type >);

      relates_to (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      relates_to (const relates_to& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual relates_to*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      relates_to&
      operator= (const relates_to& x);

      virtual 
      ~relates_to ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< treatment_plans_type > treatment_plans_;
      ::xsd::cxx::tree::one< trauma_profiles_type > trauma_profiles_;
    };
  }
}

#include <iosfwd>

namespace pfc
{
  namespace schema
  {
    ::std::ostream&
    operator<< (::std::ostream&, const equipment_definition_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const equipment&);

    ::std::ostream&
    operator<< (::std::ostream&, const trauma_definition_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const trauma&);

    ::std::ostream&
    operator<< (::std::ostream&, const trauma_severity_range&);

    ::std::ostream&
    operator<< (::std::ostream&, const numeric_range&);

    ::std::ostream&
    operator<< (::std::ostream&, const token_range&);

    ::std::ostream&
    operator<< (::std::ostream&, const citation_ref_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const treatment_plan_definition_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const treatment_plan&);

    ::std::ostream&
    operator<< (::std::ostream&, const equipment_ref_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const medical_reference_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const cpg_ref_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const cpg_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const cpg&);

    ::std::ostream&
    operator<< (::std::ostream&, const learning_objective_reference_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const treatment_plan_ref_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const trauma_profile_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const trauma_profile&);

    ::std::ostream&
    operator<< (::std::ostream&, const trauma_profile_ref_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const trauma_occurence_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const trauma_occurence&);

    ::std::ostream&
    operator<< (::std::ostream&, const medical_scenario_syllabus&);

    ::std::ostream&
    operator<< (::std::ostream&, const learning_objective_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const learning_objective&);

    ::std::ostream&
    operator<< (::std::ostream&, const assessment_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const assessment&);

    ::std::ostream&
    operator<< (::std::ostream&, const medical_scenario&);

    ::std::ostream&
    operator<< (::std::ostream&, const role_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const role&);

    ::std::ostream&
    operator<< (::std::ostream&, const role_ref_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const item_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const item&);

    ::std::ostream&
    operator<< (::std::ostream&, const scene_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const scene&);

    ::std::ostream&
    operator<< (::std::ostream&, const event_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const event&);

    ::std::ostream&
    operator<< (::std::ostream&, event_category_enum::value);

    ::std::ostream&
    operator<< (::std::ostream&, const event_category_enum&);

    ::std::ostream&
    operator<< (::std::ostream&, event_fidelity_enum::value);

    ::std::ostream&
    operator<< (::std::ostream&, const event_fidelity_enum&);

    ::std::ostream&
    operator<< (::std::ostream&, const citation_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const citation&);

    ::std::ostream&
    operator<< (::std::ostream&, const properties_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const property&);

    ::std::ostream&
    operator<< (::std::ostream&, const property_value_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const property_value&);

    ::std::ostream&
    operator<< (::std::ostream&, const relates_to&);
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace pfc
{
  namespace schema
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace pfc
{
  namespace schema
  {
    void
    operator<< (::xercesc::DOMElement&, const equipment_definition_list&);

    void
    operator<< (::xercesc::DOMElement&, const equipment&);

    void
    operator<< (::xercesc::DOMElement&, const trauma_definition_list&);

    void
    operator<< (::xercesc::DOMElement&, const trauma&);

    void
    operator<< (::xercesc::DOMElement&, const trauma_severity_range&);

    void
    operator<< (::xercesc::DOMElement&, const numeric_range&);

    void
    operator<< (::xercesc::DOMElement&, const token_range&);

    void
    operator<< (::xercesc::DOMElement&, const citation_ref_list&);

    void
    operator<< (::xercesc::DOMElement&, const treatment_plan_definition_list&);

    void
    operator<< (::xercesc::DOMElement&, const treatment_plan&);

    void
    operator<< (::xercesc::DOMElement&, const equipment_ref_list&);

    void
    operator<< (::xercesc::DOMElement&, const medical_reference_list&);

    void
    operator<< (::xercesc::DOMElement&, const cpg_ref_list&);

    void
    operator<< (::xercesc::DOMElement&, const cpg_list&);

    void
    operator<< (::xercesc::DOMElement&, const cpg&);

    void
    operator<< (::xercesc::DOMElement&, const learning_objective_reference_list&);

    void
    operator<< (::xercesc::DOMElement&, const treatment_plan_ref_list&);

    void
    operator<< (::xercesc::DOMElement&, const trauma_profile_list&);

    void
    operator<< (::xercesc::DOMElement&, const trauma_profile&);

    void
    operator<< (::xercesc::DOMElement&, const trauma_profile_ref_list&);

    void
    operator<< (::xercesc::DOMElement&, const trauma_occurence_list&);

    void
    operator<< (::xercesc::DOMElement&, const trauma_occurence&);

    void
    operator<< (::xercesc::DOMElement&, const medical_scenario_syllabus&);

    void
    operator<< (::xercesc::DOMElement&, const learning_objective_list&);

    void
    operator<< (::xercesc::DOMElement&, const learning_objective&);

    void
    operator<< (::xercesc::DOMElement&, const assessment_list&);

    void
    operator<< (::xercesc::DOMElement&, const assessment&);

    void
    operator<< (::xercesc::DOMElement&, const medical_scenario&);

    void
    operator<< (::xercesc::DOMElement&, const role_list&);

    void
    operator<< (::xercesc::DOMElement&, const role&);

    void
    operator<< (::xercesc::DOMElement&, const role_ref_list&);

    void
    operator<< (::xercesc::DOMElement&, const item_list&);

    void
    operator<< (::xercesc::DOMElement&, const item&);

    void
    operator<< (::xercesc::DOMElement&, const scene_list&);

    void
    operator<< (::xercesc::DOMElement&, const scene&);

    void
    operator<< (::xercesc::DOMElement&, const event_list&);

    void
    operator<< (::xercesc::DOMElement&, const event&);

    void
    operator<< (::xercesc::DOMElement&, const event_category_enum&);

    void
    operator<< (::xercesc::DOMAttr&, const event_category_enum&);

    void
    operator<< (::xml_schema::list_stream&,
                const event_category_enum&);

    void
    operator<< (::xercesc::DOMElement&, const event_fidelity_enum&);

    void
    operator<< (::xercesc::DOMAttr&, const event_fidelity_enum&);

    void
    operator<< (::xml_schema::list_stream&,
                const event_fidelity_enum&);

    void
    operator<< (::xercesc::DOMElement&, const citation_list&);

    void
    operator<< (::xercesc::DOMElement&, const citation&);

    void
    operator<< (::xercesc::DOMElement&, const properties_list&);

    void
    operator<< (::xercesc::DOMElement&, const property&);

    void
    operator<< (::xercesc::DOMElement&, const property_value_list&);

    void
    operator<< (::xercesc::DOMElement&, const property_value&);

    void
    operator<< (::xercesc::DOMElement&, const relates_to&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // PFC_SCENARIO_COMPLEX_TYPES_0_1_HXX
