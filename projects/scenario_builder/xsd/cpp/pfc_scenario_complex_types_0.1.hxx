// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef PFC_SCENARIO_COMPLEX_TYPES_0_1_HXX
#define PFC_SCENARIO_COMPLEX_TYPES_0_1_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace pfc
{
  namespace schema
  {
    class injury_definition_list;
    class injury;
    class injury_severity_range;
    class numeric_range;
    class token_range;
    class citation_ref_list;
    class treatment_plan_definition_list;
    class treatment_plan;
    class medical_equipment_list;
    class treatment_plan_citation_ref_list;
    class cpg_list;
    class learning_objective_reference_list;
    class treatment_plan_reference_list;
    class injury_profile_list;
    class injury_profile;
    class injury_profile_reference_list;
    class injury_occurance_list;
    class medical_scenario_syllabus;
    class learning_objective_list;
    class learning_objective;
    class assessment_criteria_list;
    class assessment;
    class medical_scenario;
    class role_list;
    class role;
    class prop_list;
    class prop;
    class scene_list;
    class scene;
    class event_list;
    class event;
    class event_category_enum;
    class event_fedelity_enum;
    class citation_list;
    class citation;
    class relates_to;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "militaryscenario_1.0.0.hxx"

namespace pfc
{
  namespace schema
  {
    class injury_definition_list: public ::xml_schema::type
    {
      public:
      // injury
      //
      typedef ::pfc::schema::injury injury_type;
      typedef ::xsd::cxx::tree::sequence< injury_type > injury_sequence;
      typedef injury_sequence::iterator injury_iterator;
      typedef injury_sequence::const_iterator injury_const_iterator;
      typedef ::xsd::cxx::tree::traits< injury_type, char > injury_traits;

      const injury_sequence&
      injury () const;

      injury_sequence&
      injury ();

      void
      injury (const injury_sequence& s);

      // Constructors.
      //
      injury_definition_list ();

      injury_definition_list (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      injury_definition_list (const injury_definition_list& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual injury_definition_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      injury_definition_list&
      operator= (const injury_definition_list& x);

      virtual 
      ~injury_definition_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      injury_sequence injury_;
    };

    class injury: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // common-name
      //
      typedef ::xml_schema::string common_name_type;
      typedef ::xsd::cxx::tree::optional< common_name_type > common_name_optional;
      typedef ::xsd::cxx::tree::traits< common_name_type, char > common_name_traits;

      const common_name_optional&
      common_name () const;

      common_name_optional&
      common_name ();

      void
      common_name (const common_name_type& x);

      void
      common_name (const common_name_optional& x);

      void
      common_name (::std::unique_ptr< common_name_type > p);

      // medical-name
      //
      typedef ::xml_schema::string medical_name_type;
      typedef ::xsd::cxx::tree::traits< medical_name_type, char > medical_name_traits;

      const medical_name_type&
      medical_name () const;

      medical_name_type&
      medical_name ();

      void
      medical_name (const medical_name_type& x);

      void
      medical_name (::std::unique_ptr< medical_name_type > p);

      // citations
      //
      typedef ::pfc::schema::citation_ref_list citations_type;
      typedef ::xsd::cxx::tree::optional< citations_type > citations_optional;
      typedef ::xsd::cxx::tree::traits< citations_type, char > citations_traits;

      const citations_optional&
      citations () const;

      citations_optional&
      citations ();

      void
      citations (const citations_type& x);

      void
      citations (const citations_optional& x);

      void
      citations (::std::unique_ptr< citations_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // severity-range
      //
      typedef ::pfc::schema::injury_severity_range severity_range_type;
      typedef ::xsd::cxx::tree::traits< severity_range_type, char > severity_range_traits;

      const severity_range_type&
      severity_range () const;

      severity_range_type&
      severity_range ();

      void
      severity_range (const severity_range_type& x);

      void
      severity_range (::std::unique_ptr< severity_range_type > p);

      // Constructors.
      //
      injury (const id_type&,
              const medical_name_type&,
              const description_type&,
              const severity_range_type&);

      injury (const id_type&,
              const medical_name_type&,
              const description_type&,
              ::std::unique_ptr< severity_range_type >);

      injury (::std::unique_ptr< id_type >,
              ::std::unique_ptr< medical_name_type >,
              ::std::unique_ptr< description_type >,
              ::std::unique_ptr< severity_range_type >);

      injury (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      injury (const injury& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual injury*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      injury&
      operator= (const injury& x);

      virtual 
      ~injury ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      common_name_optional common_name_;
      ::xsd::cxx::tree::one< medical_name_type > medical_name_;
      citations_optional citations_;
      ::xsd::cxx::tree::one< description_type > description_;
      ::xsd::cxx::tree::one< severity_range_type > severity_range_;
    };

    class injury_severity_range: public ::xml_schema::type
    {
      public:
      // numeric-range
      //
      typedef ::pfc::schema::numeric_range numeric_range_type;
      typedef ::xsd::cxx::tree::optional< numeric_range_type > numeric_range_optional;
      typedef ::xsd::cxx::tree::traits< numeric_range_type, char > numeric_range_traits;

      const numeric_range_optional&
      numeric_range () const;

      numeric_range_optional&
      numeric_range ();

      void
      numeric_range (const numeric_range_type& x);

      void
      numeric_range (const numeric_range_optional& x);

      void
      numeric_range (::std::unique_ptr< numeric_range_type > p);

      // token-range
      //
      typedef ::pfc::schema::token_range token_range_type;
      typedef ::xsd::cxx::tree::optional< token_range_type > token_range_optional;
      typedef ::xsd::cxx::tree::traits< token_range_type, char > token_range_traits;

      const token_range_optional&
      token_range () const;

      token_range_optional&
      token_range ();

      void
      token_range (const token_range_type& x);

      void
      token_range (const token_range_optional& x);

      void
      token_range (::std::unique_ptr< token_range_type > p);

      // Constructors.
      //
      injury_severity_range ();

      injury_severity_range (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      injury_severity_range (const injury_severity_range& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual injury_severity_range*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      injury_severity_range&
      operator= (const injury_severity_range& x);

      virtual 
      ~injury_severity_range ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      numeric_range_optional numeric_range_;
      token_range_optional token_range_;
    };

    class numeric_range: public ::xml_schema::type
    {
      public:
      // min
      //
      typedef ::xml_schema::double_ min_type;
      typedef ::xsd::cxx::tree::traits< min_type, char, ::xsd::cxx::tree::schema_type::double_ > min_traits;

      const min_type&
      min () const;

      min_type&
      min ();

      void
      min (const min_type& x);

      // max
      //
      typedef ::xml_schema::double_ max_type;
      typedef ::xsd::cxx::tree::traits< max_type, char, ::xsd::cxx::tree::schema_type::double_ > max_traits;

      const max_type&
      max () const;

      max_type&
      max ();

      void
      max (const max_type& x);

      // median
      //
      typedef ::xml_schema::double_ median_type;
      typedef ::xsd::cxx::tree::optional< median_type > median_optional;
      typedef ::xsd::cxx::tree::traits< median_type, char, ::xsd::cxx::tree::schema_type::double_ > median_traits;

      const median_optional&
      median () const;

      median_optional&
      median ();

      void
      median (const median_type& x);

      void
      median (const median_optional& x);

      // unit
      //
      typedef ::xml_schema::string unit_type;
      typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
      typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

      const unit_optional&
      unit () const;

      unit_optional&
      unit ();

      void
      unit (const unit_type& x);

      void
      unit (const unit_optional& x);

      void
      unit (::std::unique_ptr< unit_type > p);

      // Constructors.
      //
      numeric_range (const min_type&,
                     const max_type&);

      numeric_range (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      numeric_range (const numeric_range& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual numeric_range*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      numeric_range&
      operator= (const numeric_range& x);

      virtual 
      ~numeric_range ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< min_type > min_;
      ::xsd::cxx::tree::one< max_type > max_;
      median_optional median_;
      unit_optional unit_;
    };

    class token_range: public ::xml_schema::type
    {
      public:
      // token
      //
      typedef ::xml_schema::ncname token_type;
      typedef ::xsd::cxx::tree::sequence< token_type > token_sequence;
      typedef token_sequence::iterator token_iterator;
      typedef token_sequence::const_iterator token_const_iterator;
      typedef ::xsd::cxx::tree::traits< token_type, char > token_traits;

      const token_sequence&
      token () const;

      token_sequence&
      token ();

      void
      token (const token_sequence& s);

      // Constructors.
      //
      token_range ();

      token_range (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      token_range (const token_range& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual token_range*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      token_range&
      operator= (const token_range& x);

      virtual 
      ~token_range ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      token_sequence token_;
    };

    class citation_ref_list: public ::xml_schema::type
    {
      public:
      // citation-ref
      //
      typedef ::xml_schema::string citation_ref_type;
      typedef ::xsd::cxx::tree::sequence< citation_ref_type > citation_ref_sequence;
      typedef citation_ref_sequence::iterator citation_ref_iterator;
      typedef citation_ref_sequence::const_iterator citation_ref_const_iterator;
      typedef ::xsd::cxx::tree::traits< citation_ref_type, char > citation_ref_traits;

      const citation_ref_sequence&
      citation_ref () const;

      citation_ref_sequence&
      citation_ref ();

      void
      citation_ref (const citation_ref_sequence& s);

      // Constructors.
      //
      citation_ref_list ();

      citation_ref_list (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      citation_ref_list (const citation_ref_list& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual citation_ref_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      citation_ref_list&
      operator= (const citation_ref_list& x);

      virtual 
      ~citation_ref_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      citation_ref_sequence citation_ref_;
    };

    class treatment_plan_definition_list: public ::xml_schema::type
    {
      public:
      // treatment-plan
      //
      typedef ::pfc::schema::treatment_plan treatment_plan_type;
      typedef ::xsd::cxx::tree::sequence< treatment_plan_type > treatment_plan_sequence;
      typedef treatment_plan_sequence::iterator treatment_plan_iterator;
      typedef treatment_plan_sequence::const_iterator treatment_plan_const_iterator;
      typedef ::xsd::cxx::tree::traits< treatment_plan_type, char > treatment_plan_traits;

      const treatment_plan_sequence&
      treatment_plan () const;

      treatment_plan_sequence&
      treatment_plan ();

      void
      treatment_plan (const treatment_plan_sequence& s);

      // Constructors.
      //
      treatment_plan_definition_list ();

      treatment_plan_definition_list (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      treatment_plan_definition_list (const treatment_plan_definition_list& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual treatment_plan_definition_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      treatment_plan_definition_list&
      operator= (const treatment_plan_definition_list& x);

      virtual 
      ~treatment_plan_definition_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      treatment_plan_sequence treatment_plan_;
    };

    class treatment_plan: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // common-name
      //
      typedef ::xml_schema::string common_name_type;
      typedef ::xsd::cxx::tree::optional< common_name_type > common_name_optional;
      typedef ::xsd::cxx::tree::traits< common_name_type, char > common_name_traits;

      const common_name_optional&
      common_name () const;

      common_name_optional&
      common_name ();

      void
      common_name (const common_name_type& x);

      void
      common_name (const common_name_optional& x);

      void
      common_name (::std::unique_ptr< common_name_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // required-equipment
      //
      typedef ::pfc::schema::medical_equipment_list required_equipment_type;
      typedef ::xsd::cxx::tree::traits< required_equipment_type, char > required_equipment_traits;

      const required_equipment_type&
      required_equipment () const;

      required_equipment_type&
      required_equipment ();

      void
      required_equipment (const required_equipment_type& x);

      void
      required_equipment (::std::unique_ptr< required_equipment_type > p);

      // references
      //
      typedef ::pfc::schema::treatment_plan_citation_ref_list references_type;
      typedef ::xsd::cxx::tree::optional< references_type > references_optional;
      typedef ::xsd::cxx::tree::traits< references_type, char > references_traits;

      const references_optional&
      references () const;

      references_optional&
      references ();

      void
      references (const references_type& x);

      void
      references (const references_optional& x);

      void
      references (::std::unique_ptr< references_type > p);

      // Constructors.
      //
      treatment_plan (const id_type&,
                      const description_type&,
                      const required_equipment_type&);

      treatment_plan (const id_type&,
                      const description_type&,
                      ::std::unique_ptr< required_equipment_type >);

      treatment_plan (::std::unique_ptr< id_type >,
                      ::std::unique_ptr< description_type >,
                      ::std::unique_ptr< required_equipment_type >);

      treatment_plan (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      treatment_plan (const treatment_plan& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual treatment_plan*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      treatment_plan&
      operator= (const treatment_plan& x);

      virtual 
      ~treatment_plan ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      common_name_optional common_name_;
      ::xsd::cxx::tree::one< description_type > description_;
      ::xsd::cxx::tree::one< required_equipment_type > required_equipment_;
      references_optional references_;
    };

    class medical_equipment_list: public ::xml_schema::type
    {
      public:
      // equipment-refs
      //
      typedef ::xml_schema::idref equipment_refs_type;
      typedef ::xsd::cxx::tree::sequence< equipment_refs_type > equipment_refs_sequence;
      typedef equipment_refs_sequence::iterator equipment_refs_iterator;
      typedef equipment_refs_sequence::const_iterator equipment_refs_const_iterator;
      typedef ::xsd::cxx::tree::traits< equipment_refs_type, char > equipment_refs_traits;

      const equipment_refs_sequence&
      equipment_refs () const;

      equipment_refs_sequence&
      equipment_refs ();

      void
      equipment_refs (const equipment_refs_sequence& s);

      // Constructors.
      //
      medical_equipment_list ();

      medical_equipment_list (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      medical_equipment_list (const medical_equipment_list& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual medical_equipment_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      medical_equipment_list&
      operator= (const medical_equipment_list& x);

      virtual 
      ~medical_equipment_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      equipment_refs_sequence equipment_refs_;
    };

    class treatment_plan_citation_ref_list: public ::xml_schema::type
    {
      public:
      // citations
      //
      typedef ::pfc::schema::citation_ref_list citations_type;
      typedef ::xsd::cxx::tree::traits< citations_type, char > citations_traits;

      const citations_type&
      citations () const;

      citations_type&
      citations ();

      void
      citations (const citations_type& x);

      void
      citations (::std::unique_ptr< citations_type > p);

      // cpgs
      //
      typedef ::pfc::schema::cpg_list cpgs_type;
      typedef ::xsd::cxx::tree::traits< cpgs_type, char > cpgs_traits;

      const cpgs_type&
      cpgs () const;

      cpgs_type&
      cpgs ();

      void
      cpgs (const cpgs_type& x);

      void
      cpgs (::std::unique_ptr< cpgs_type > p);

      // Constructors.
      //
      treatment_plan_citation_ref_list (const citations_type&,
                                        const cpgs_type&);

      treatment_plan_citation_ref_list (::std::unique_ptr< citations_type >,
                                        ::std::unique_ptr< cpgs_type >);

      treatment_plan_citation_ref_list (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      treatment_plan_citation_ref_list (const treatment_plan_citation_ref_list& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual treatment_plan_citation_ref_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      treatment_plan_citation_ref_list&
      operator= (const treatment_plan_citation_ref_list& x);

      virtual 
      ~treatment_plan_citation_ref_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< citations_type > citations_;
      ::xsd::cxx::tree::one< cpgs_type > cpgs_;
    };

    class cpg_list: public ::xml_schema::type
    {
      public:
      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // citation-ref
      //
      typedef ::xml_schema::string citation_ref_type;
      typedef ::xsd::cxx::tree::traits< citation_ref_type, char > citation_ref_traits;

      const citation_ref_type&
      citation_ref () const;

      citation_ref_type&
      citation_ref ();

      void
      citation_ref (const citation_ref_type& x);

      void
      citation_ref (::std::unique_ptr< citation_ref_type > p);

      // Constructors.
      //
      cpg_list (const name_type&,
                const citation_ref_type&);

      cpg_list (::std::unique_ptr< name_type >,
                ::std::unique_ptr< citation_ref_type >);

      cpg_list (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      cpg_list (const cpg_list& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual cpg_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      cpg_list&
      operator= (const cpg_list& x);

      virtual 
      ~cpg_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< name_type > name_;
      ::xsd::cxx::tree::one< citation_ref_type > citation_ref_;
    };

    class learning_objective_reference_list: public ::xml_schema::type
    {
      public:
      // objective
      //
      typedef ::xml_schema::idref objective_type;
      typedef ::xsd::cxx::tree::sequence< objective_type > objective_sequence;
      typedef objective_sequence::iterator objective_iterator;
      typedef objective_sequence::const_iterator objective_const_iterator;
      typedef ::xsd::cxx::tree::traits< objective_type, char > objective_traits;

      const objective_sequence&
      objective () const;

      objective_sequence&
      objective ();

      void
      objective (const objective_sequence& s);

      // Constructors.
      //
      learning_objective_reference_list ();

      learning_objective_reference_list (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      learning_objective_reference_list (const learning_objective_reference_list& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual learning_objective_reference_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      learning_objective_reference_list&
      operator= (const learning_objective_reference_list& x);

      virtual 
      ~learning_objective_reference_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      objective_sequence objective_;
    };

    class treatment_plan_reference_list: public ::xml_schema::type
    {
      public:
      // treatment-plan
      //
      typedef ::xml_schema::idref treatment_plan_type;
      typedef ::xsd::cxx::tree::sequence< treatment_plan_type > treatment_plan_sequence;
      typedef treatment_plan_sequence::iterator treatment_plan_iterator;
      typedef treatment_plan_sequence::const_iterator treatment_plan_const_iterator;
      typedef ::xsd::cxx::tree::traits< treatment_plan_type, char > treatment_plan_traits;

      const treatment_plan_sequence&
      treatment_plan () const;

      treatment_plan_sequence&
      treatment_plan ();

      void
      treatment_plan (const treatment_plan_sequence& s);

      // Constructors.
      //
      treatment_plan_reference_list ();

      treatment_plan_reference_list (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      treatment_plan_reference_list (const treatment_plan_reference_list& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual treatment_plan_reference_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      treatment_plan_reference_list&
      operator= (const treatment_plan_reference_list& x);

      virtual 
      ~treatment_plan_reference_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      treatment_plan_sequence treatment_plan_;
    };

    class injury_profile_list: public ::xml_schema::type
    {
      public:
      // injury-profile
      //
      typedef ::pfc::schema::injury_profile injury_profile_type;
      typedef ::xsd::cxx::tree::sequence< injury_profile_type > injury_profile_sequence;
      typedef injury_profile_sequence::iterator injury_profile_iterator;
      typedef injury_profile_sequence::const_iterator injury_profile_const_iterator;
      typedef ::xsd::cxx::tree::traits< injury_profile_type, char > injury_profile_traits;

      const injury_profile_sequence&
      injury_profile () const;

      injury_profile_sequence&
      injury_profile ();

      void
      injury_profile (const injury_profile_sequence& s);

      // Constructors.
      //
      injury_profile_list ();

      injury_profile_list (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      injury_profile_list (const injury_profile_list& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual injury_profile_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      injury_profile_list&
      operator= (const injury_profile_list& x);

      virtual 
      ~injury_profile_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      injury_profile_sequence injury_profile_;
    };

    class injury_profile: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // physiology-state
      //
      typedef ::xml_schema::string physiology_state_type;
      typedef ::xsd::cxx::tree::optional< physiology_state_type > physiology_state_optional;
      typedef ::xsd::cxx::tree::traits< physiology_state_type, char > physiology_state_traits;

      const physiology_state_optional&
      physiology_state () const;

      physiology_state_optional&
      physiology_state ();

      void
      physiology_state (const physiology_state_type& x);

      void
      physiology_state (const physiology_state_optional& x);

      void
      physiology_state (::std::unique_ptr< physiology_state_type > p);

      // injuries
      //
      typedef ::pfc::schema::injury_occurance_list injuries_type;
      typedef ::xsd::cxx::tree::sequence< injuries_type > injuries_sequence;
      typedef injuries_sequence::iterator injuries_iterator;
      typedef injuries_sequence::const_iterator injuries_const_iterator;
      typedef ::xsd::cxx::tree::traits< injuries_type, char > injuries_traits;

      const injuries_sequence&
      injuries () const;

      injuries_sequence&
      injuries ();

      void
      injuries (const injuries_sequence& s);

      // treatments
      //
      typedef ::pfc::schema::treatment_plan_reference_list treatments_type;
      typedef ::xsd::cxx::tree::traits< treatments_type, char > treatments_traits;

      const treatments_type&
      treatments () const;

      treatments_type&
      treatments ();

      void
      treatments (const treatments_type& x);

      void
      treatments (::std::unique_ptr< treatments_type > p);

      // Constructors.
      //
      injury_profile (const id_type&,
                      const name_type&,
                      const treatments_type&);

      injury_profile (const id_type&,
                      const name_type&,
                      ::std::unique_ptr< treatments_type >);

      injury_profile (::std::unique_ptr< id_type >,
                      ::std::unique_ptr< name_type >,
                      ::std::unique_ptr< treatments_type >);

      injury_profile (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      injury_profile (const injury_profile& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual injury_profile*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      injury_profile&
      operator= (const injury_profile& x);

      virtual 
      ~injury_profile ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< name_type > name_;
      physiology_state_optional physiology_state_;
      injuries_sequence injuries_;
      ::xsd::cxx::tree::one< treatments_type > treatments_;
    };

    class injury_profile_reference_list: public ::xml_schema::type
    {
      public:
      // injury-profile
      //
      typedef ::xml_schema::idref injury_profile_type;
      typedef ::xsd::cxx::tree::sequence< injury_profile_type > injury_profile_sequence;
      typedef injury_profile_sequence::iterator injury_profile_iterator;
      typedef injury_profile_sequence::const_iterator injury_profile_const_iterator;
      typedef ::xsd::cxx::tree::traits< injury_profile_type, char > injury_profile_traits;

      const injury_profile_sequence&
      injury_profile () const;

      injury_profile_sequence&
      injury_profile ();

      void
      injury_profile (const injury_profile_sequence& s);

      // Constructors.
      //
      injury_profile_reference_list ();

      injury_profile_reference_list (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      injury_profile_reference_list (const injury_profile_reference_list& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual injury_profile_reference_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      injury_profile_reference_list&
      operator= (const injury_profile_reference_list& x);

      virtual 
      ~injury_profile_reference_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      injury_profile_sequence injury_profile_;
    };

    class injury_occurance_list: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::idref id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // location
      //
      typedef ::xml_schema::string location_type;
      typedef ::xsd::cxx::tree::traits< location_type, char > location_traits;

      const location_type&
      location () const;

      location_type&
      location ();

      void
      location (const location_type& x);

      void
      location (::std::unique_ptr< location_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // severity
      //
      typedef ::xml_schema::string severity_type;
      typedef ::xsd::cxx::tree::traits< severity_type, char > severity_traits;

      const severity_type&
      severity () const;

      severity_type&
      severity ();

      void
      severity (const severity_type& x);

      void
      severity (::std::unique_ptr< severity_type > p);

      // Constructors.
      //
      injury_occurance_list (const id_type&,
                             const location_type&,
                             const description_type&,
                             const severity_type&);

      injury_occurance_list (::std::unique_ptr< id_type >,
                             ::std::unique_ptr< location_type >,
                             ::std::unique_ptr< description_type >,
                             ::std::unique_ptr< severity_type >);

      injury_occurance_list (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      injury_occurance_list (const injury_occurance_list& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual injury_occurance_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      injury_occurance_list&
      operator= (const injury_occurance_list& x);

      virtual 
      ~injury_occurance_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< location_type > location_;
      ::xsd::cxx::tree::one< description_type > description_;
      ::xsd::cxx::tree::one< severity_type > severity_;
    };

    class medical_scenario_syllabus: public ::xml_schema::type
    {
      public:
      // learning-objectives
      //
      typedef ::pfc::schema::learning_objective_list learning_objectives_type;
      typedef ::xsd::cxx::tree::traits< learning_objectives_type, char > learning_objectives_traits;

      const learning_objectives_type&
      learning_objectives () const;

      learning_objectives_type&
      learning_objectives ();

      void
      learning_objectives (const learning_objectives_type& x);

      void
      learning_objectives (::std::unique_ptr< learning_objectives_type > p);

      // learning-assessments
      //
      typedef ::pfc::schema::assessment learning_assessments_type;
      typedef ::xsd::cxx::tree::sequence< learning_assessments_type > learning_assessments_sequence;
      typedef learning_assessments_sequence::iterator learning_assessments_iterator;
      typedef learning_assessments_sequence::const_iterator learning_assessments_const_iterator;
      typedef ::xsd::cxx::tree::traits< learning_assessments_type, char > learning_assessments_traits;

      const learning_assessments_sequence&
      learning_assessments () const;

      learning_assessments_sequence&
      learning_assessments ();

      void
      learning_assessments (const learning_assessments_sequence& s);

      // Constructors.
      //
      medical_scenario_syllabus (const learning_objectives_type&);

      medical_scenario_syllabus (::std::unique_ptr< learning_objectives_type >);

      medical_scenario_syllabus (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      medical_scenario_syllabus (const medical_scenario_syllabus& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual medical_scenario_syllabus*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      medical_scenario_syllabus&
      operator= (const medical_scenario_syllabus& x);

      virtual 
      ~medical_scenario_syllabus ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< learning_objectives_type > learning_objectives_;
      learning_assessments_sequence learning_assessments_;
    };

    class learning_objective_list: public ::xml_schema::type
    {
      public:
      // objective
      //
      typedef ::pfc::schema::learning_objective objective_type;
      typedef ::xsd::cxx::tree::sequence< objective_type > objective_sequence;
      typedef objective_sequence::iterator objective_iterator;
      typedef objective_sequence::const_iterator objective_const_iterator;
      typedef ::xsd::cxx::tree::traits< objective_type, char > objective_traits;

      const objective_sequence&
      objective () const;

      objective_sequence&
      objective ();

      void
      objective (const objective_sequence& s);

      // Constructors.
      //
      learning_objective_list ();

      learning_objective_list (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      learning_objective_list (const learning_objective_list& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual learning_objective_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      learning_objective_list&
      operator= (const learning_objective_list& x);

      virtual 
      ~learning_objective_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      objective_sequence objective_;
    };

    class learning_objective: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // references
      //
      typedef ::pfc::schema::treatment_plan_citation_ref_list references_type;
      typedef ::xsd::cxx::tree::traits< references_type, char > references_traits;

      const references_type&
      references () const;

      references_type&
      references ();

      void
      references (const references_type& x);

      void
      references (::std::unique_ptr< references_type > p);

      // relates-to
      //
      typedef ::pfc::schema::relates_to relates_to_type;
      typedef ::xsd::cxx::tree::traits< relates_to_type, char > relates_to_traits;

      const relates_to_type&
      relates_to () const;

      relates_to_type&
      relates_to ();

      void
      relates_to (const relates_to_type& x);

      void
      relates_to (::std::unique_ptr< relates_to_type > p);

      // Constructors.
      //
      learning_objective (const id_type&,
                          const name_type&,
                          const references_type&,
                          const relates_to_type&);

      learning_objective (const id_type&,
                          const name_type&,
                          ::std::unique_ptr< references_type >,
                          ::std::unique_ptr< relates_to_type >);

      learning_objective (::std::unique_ptr< id_type >,
                          ::std::unique_ptr< name_type >,
                          ::std::unique_ptr< references_type >,
                          ::std::unique_ptr< relates_to_type >);

      learning_objective (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      learning_objective (const learning_objective& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual learning_objective*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      learning_objective&
      operator= (const learning_objective& x);

      virtual 
      ~learning_objective ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< name_type > name_;
      ::xsd::cxx::tree::one< references_type > references_;
      ::xsd::cxx::tree::one< relates_to_type > relates_to_;
    };

    class assessment_criteria_list: public ::xml_schema::type
    {
      public:
      // total-points
      //
      typedef ::xml_schema::integer total_points_type;
      typedef ::xsd::cxx::tree::traits< total_points_type, char > total_points_traits;

      const total_points_type&
      total_points () const;

      total_points_type&
      total_points ();

      void
      total_points (const total_points_type& x);

      // assessment
      //
      typedef ::pfc::schema::assessment assessment_type;
      typedef ::xsd::cxx::tree::sequence< assessment_type > assessment_sequence;
      typedef assessment_sequence::iterator assessment_iterator;
      typedef assessment_sequence::const_iterator assessment_const_iterator;
      typedef ::xsd::cxx::tree::traits< assessment_type, char > assessment_traits;

      const assessment_sequence&
      assessment () const;

      assessment_sequence&
      assessment ();

      void
      assessment (const assessment_sequence& s);

      // Constructors.
      //
      assessment_criteria_list (const total_points_type&);

      assessment_criteria_list (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      assessment_criteria_list (const assessment_criteria_list& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual assessment_criteria_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      assessment_criteria_list&
      operator= (const assessment_criteria_list& x);

      virtual 
      ~assessment_criteria_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< total_points_type > total_points_;
      assessment_sequence assessment_;
    };

    class assessment: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // objective-id
      //
      typedef ::xml_schema::idref objective_id_type;
      typedef ::xsd::cxx::tree::traits< objective_id_type, char > objective_id_traits;

      const objective_id_type&
      objective_id () const;

      objective_id_type&
      objective_id ();

      void
      objective_id (const objective_id_type& x);

      void
      objective_id (::std::unique_ptr< objective_id_type > p);

      // points-avaiable
      //
      typedef ::xml_schema::integer points_avaiable_type;
      typedef ::xsd::cxx::tree::traits< points_avaiable_type, char > points_avaiable_traits;

      const points_avaiable_type&
      points_avaiable () const;

      points_avaiable_type&
      points_avaiable ();

      void
      points_avaiable (const points_avaiable_type& x);

      // criteria
      //
      typedef ::xml_schema::string criteria_type;
      typedef ::xsd::cxx::tree::traits< criteria_type, char > criteria_traits;

      const criteria_type&
      criteria () const;

      criteria_type&
      criteria ();

      void
      criteria (const criteria_type& x);

      void
      criteria (::std::unique_ptr< criteria_type > p);

      // Constructors.
      //
      assessment (const id_type&,
                  const objective_id_type&,
                  const points_avaiable_type&,
                  const criteria_type&);

      assessment (::std::unique_ptr< id_type >,
                  ::std::unique_ptr< objective_id_type >,
                  const points_avaiable_type&,
                  ::std::unique_ptr< criteria_type >);

      assessment (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      assessment (const assessment& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual assessment*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      assessment&
      operator= (const assessment& x);

      virtual 
      ~assessment ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< objective_id_type > objective_id_;
      ::xsd::cxx::tree::one< points_avaiable_type > points_avaiable_;
      ::xsd::cxx::tree::one< criteria_type > criteria_;
    };

    class medical_scenario: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xml_schema::id id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // roles
      //
      typedef ::pfc::schema::role_list roles_type;
      typedef ::xsd::cxx::tree::traits< roles_type, char > roles_traits;

      const roles_type&
      roles () const;

      roles_type&
      roles ();

      void
      roles (const roles_type& x);

      void
      roles (::std::unique_ptr< roles_type > p);

      // props
      //
      typedef ::pfc::schema::prop_list props_type;
      typedef ::xsd::cxx::tree::traits< props_type, char > props_traits;

      const props_type&
      props () const;

      props_type&
      props ();

      void
      props (const props_type& x);

      void
      props (::std::unique_ptr< props_type > p);

      // training-script
      //
      typedef ::pfc::schema::scene_list training_script_type;
      typedef ::xsd::cxx::tree::traits< training_script_type, char > training_script_traits;

      const training_script_type&
      training_script () const;

      training_script_type&
      training_script ();

      void
      training_script (const training_script_type& x);

      void
      training_script (::std::unique_ptr< training_script_type > p);

      // Constructors.
      //
      medical_scenario (const id_type&,
                        const roles_type&,
                        const props_type&,
                        const training_script_type&);

      medical_scenario (const id_type&,
                        ::std::unique_ptr< roles_type >,
                        ::std::unique_ptr< props_type >,
                        ::std::unique_ptr< training_script_type >);

      medical_scenario (::std::unique_ptr< id_type >,
                        ::std::unique_ptr< roles_type >,
                        ::std::unique_ptr< props_type >,
                        ::std::unique_ptr< training_script_type >);

      medical_scenario (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      medical_scenario (const medical_scenario& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual medical_scenario*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      medical_scenario&
      operator= (const medical_scenario& x);

      virtual 
      ~medical_scenario ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
      ::xsd::cxx::tree::one< roles_type > roles_;
      ::xsd::cxx::tree::one< props_type > props_;
      ::xsd::cxx::tree::one< training_script_type > training_script_;
    };

    class role_list: public ::xml_schema::type
    {
      public:
      // role
      //
      typedef ::pfc::schema::role role_type;
      typedef ::xsd::cxx::tree::sequence< role_type > role_sequence;
      typedef role_sequence::iterator role_iterator;
      typedef role_sequence::const_iterator role_const_iterator;
      typedef ::xsd::cxx::tree::traits< role_type, char > role_traits;

      const role_sequence&
      role () const;

      role_sequence&
      role ();

      void
      role (const role_sequence& s);

      // Constructors.
      //
      role_list ();

      role_list (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      role_list (const role_list& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual role_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      role_list&
      operator= (const role_list& x);

      virtual 
      ~role_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      role_sequence role_;
    };

    class role: public ::xml_schema::type
    {
      public:
      // short-name
      //
      typedef ::xml_schema::string short_name_type;
      typedef ::xsd::cxx::tree::traits< short_name_type, char > short_name_traits;

      const short_name_type&
      short_name () const;

      short_name_type&
      short_name ();

      void
      short_name (const short_name_type& x);

      void
      short_name (::std::unique_ptr< short_name_type > p);

      // unit-id
      //
      typedef ::xml_schema::idref unit_id_type;
      typedef ::xsd::cxx::tree::traits< unit_id_type, char > unit_id_traits;

      const unit_id_type&
      unit_id () const;

      unit_id_type&
      unit_id ();

      void
      unit_id (const unit_id_type& x);

      void
      unit_id (::std::unique_ptr< unit_id_type > p);

      // injury-profile-id
      //
      typedef ::xml_schema::idref injury_profile_id_type;
      typedef ::xsd::cxx::tree::optional< injury_profile_id_type > injury_profile_id_optional;
      typedef ::xsd::cxx::tree::traits< injury_profile_id_type, char > injury_profile_id_traits;

      const injury_profile_id_optional&
      injury_profile_id () const;

      injury_profile_id_optional&
      injury_profile_id ();

      void
      injury_profile_id (const injury_profile_id_type& x);

      void
      injury_profile_id (const injury_profile_id_optional& x);

      void
      injury_profile_id (::std::unique_ptr< injury_profile_id_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // Constructors.
      //
      role (const short_name_type&,
            const unit_id_type&,
            const description_type&);

      role (::std::unique_ptr< short_name_type >,
            ::std::unique_ptr< unit_id_type >,
            ::std::unique_ptr< description_type >);

      role (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      role (const role& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      virtual role*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      role&
      operator= (const role& x);

      virtual 
      ~role ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< short_name_type > short_name_;
      ::xsd::cxx::tree::one< unit_id_type > unit_id_;
      injury_profile_id_optional injury_profile_id_;
      ::xsd::cxx::tree::one< description_type > description_;
    };

    class prop_list: public ::xml_schema::type
    {
      public:
      // prop
      //
      typedef ::pfc::schema::prop prop_type;
      typedef ::xsd::cxx::tree::sequence< prop_type > prop_sequence;
      typedef prop_sequence::iterator prop_iterator;
      typedef prop_sequence::const_iterator prop_const_iterator;
      typedef ::xsd::cxx::tree::traits< prop_type, char > prop_traits;

      const prop_sequence&
      prop () const;

      prop_sequence&
      prop ();

      void
      prop (const prop_sequence& s);

      // Constructors.
      //
      prop_list ();

      prop_list (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      prop_list (const prop_list& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual prop_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      prop_list&
      operator= (const prop_list& x);

      virtual 
      ~prop_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      prop_sequence prop_;
    };

    class prop: public ::xml_schema::type
    {
      public:
      // short-name
      //
      typedef ::xml_schema::string short_name_type;
      typedef ::xsd::cxx::tree::traits< short_name_type, char > short_name_traits;

      const short_name_type&
      short_name () const;

      short_name_type&
      short_name ();

      void
      short_name (const short_name_type& x);

      void
      short_name (::std::unique_ptr< short_name_type > p);

      // equipment-id
      //
      typedef ::xml_schema::idref equipment_id_type;
      typedef ::xsd::cxx::tree::traits< equipment_id_type, char > equipment_id_traits;

      const equipment_id_type&
      equipment_id () const;

      equipment_id_type&
      equipment_id ();

      void
      equipment_id (const equipment_id_type& x);

      void
      equipment_id (::std::unique_ptr< equipment_id_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // Constructors.
      //
      prop (const short_name_type&,
            const equipment_id_type&,
            const description_type&);

      prop (::std::unique_ptr< short_name_type >,
            ::std::unique_ptr< equipment_id_type >,
            ::std::unique_ptr< description_type >);

      prop (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      prop (const prop& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      virtual prop*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      prop&
      operator= (const prop& x);

      virtual 
      ~prop ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< short_name_type > short_name_;
      ::xsd::cxx::tree::one< equipment_id_type > equipment_id_;
      ::xsd::cxx::tree::one< description_type > description_;
    };

    class scene_list: public ::xml_schema::type
    {
      public:
      // scene
      //
      typedef ::pfc::schema::scene scene_type;
      typedef ::xsd::cxx::tree::sequence< scene_type > scene_sequence;
      typedef scene_sequence::iterator scene_iterator;
      typedef scene_sequence::const_iterator scene_const_iterator;
      typedef ::xsd::cxx::tree::traits< scene_type, char > scene_traits;

      const scene_sequence&
      scene () const;

      scene_sequence&
      scene ();

      void
      scene (const scene_sequence& s);

      // Constructors.
      //
      scene_list ();

      scene_list (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      scene_list (const scene_list& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual scene_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      scene_list&
      operator= (const scene_list& x);

      virtual 
      ~scene_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      scene_sequence scene_;
    };

    class scene: public ::xml_schema::type
    {
      public:
      // location-id
      //
      typedef ::xml_schema::idref location_id_type;
      typedef ::xsd::cxx::tree::traits< location_id_type, char > location_id_traits;

      const location_id_type&
      location_id () const;

      location_id_type&
      location_id ();

      void
      location_id (const location_id_type& x);

      void
      location_id (::std::unique_ptr< location_id_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::unique_ptr< description_type > p);

      // time-of-day
      //
      typedef ::xml_schema::time time_of_day_type;
      typedef ::xsd::cxx::tree::traits< time_of_day_type, char > time_of_day_traits;

      const time_of_day_type&
      time_of_day () const;

      time_of_day_type&
      time_of_day ();

      void
      time_of_day (const time_of_day_type& x);

      void
      time_of_day (::std::unique_ptr< time_of_day_type > p);

      // time-in-simulation
      //
      typedef ::xml_schema::integer time_in_simulation_type;
      typedef ::xsd::cxx::tree::traits< time_in_simulation_type, char > time_in_simulation_traits;

      const time_in_simulation_type&
      time_in_simulation () const;

      time_in_simulation_type&
      time_in_simulation ();

      void
      time_in_simulation (const time_in_simulation_type& x);

      // events
      //
      typedef ::pfc::schema::event_list events_type;
      typedef ::xsd::cxx::tree::traits< events_type, char > events_traits;

      const events_type&
      events () const;

      events_type&
      events ();

      void
      events (const events_type& x);

      void
      events (::std::unique_ptr< events_type > p);

      // Constructors.
      //
      scene (const location_id_type&,
             const description_type&,
             const time_of_day_type&,
             const time_in_simulation_type&,
             const events_type&);

      scene (const location_id_type&,
             const description_type&,
             const time_of_day_type&,
             const time_in_simulation_type&,
             ::std::unique_ptr< events_type >);

      scene (::std::unique_ptr< location_id_type >,
             ::std::unique_ptr< description_type >,
             ::std::unique_ptr< time_of_day_type >,
             const time_in_simulation_type&,
             ::std::unique_ptr< events_type >);

      scene (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      scene (const scene& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      virtual scene*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      scene&
      operator= (const scene& x);

      virtual 
      ~scene ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< location_id_type > location_id_;
      ::xsd::cxx::tree::one< description_type > description_;
      ::xsd::cxx::tree::one< time_of_day_type > time_of_day_;
      ::xsd::cxx::tree::one< time_in_simulation_type > time_in_simulation_;
      ::xsd::cxx::tree::one< events_type > events_;
    };

    class event_list: public ::xml_schema::type
    {
      public:
      // event
      //
      typedef ::pfc::schema::event event_type;
      typedef ::xsd::cxx::tree::sequence< event_type > event_sequence;
      typedef event_sequence::iterator event_iterator;
      typedef event_sequence::const_iterator event_const_iterator;
      typedef ::xsd::cxx::tree::traits< event_type, char > event_traits;

      const event_sequence&
      event () const;

      event_sequence&
      event ();

      void
      event (const event_sequence& s);

      // Constructors.
      //
      event_list ();

      event_list (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      event_list (const event_list& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual event_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      event_list&
      operator= (const event_list& x);

      virtual 
      ~event_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      event_sequence event_;
    };

    class event: public ::xml_schema::type
    {
      public:
      // category
      //
      typedef ::pfc::schema::event_category_enum category_type;
      typedef ::xsd::cxx::tree::traits< category_type, char > category_traits;

      const category_type&
      category () const;

      category_type&
      category ();

      void
      category (const category_type& x);

      void
      category (::std::unique_ptr< category_type > p);

      // fedelity
      //
      typedef ::pfc::schema::event_fedelity_enum fedelity_type;
      typedef ::xsd::cxx::tree::traits< fedelity_type, char > fedelity_traits;

      const fedelity_type&
      fedelity () const;

      fedelity_type&
      fedelity ();

      void
      fedelity (const fedelity_type& x);

      void
      fedelity (::std::unique_ptr< fedelity_type > p);

      // details
      //
      typedef ::xml_schema::string details_type;
      typedef ::xsd::cxx::tree::traits< details_type, char > details_traits;

      const details_type&
      details () const;

      details_type&
      details ();

      void
      details (const details_type& x);

      void
      details (::std::unique_ptr< details_type > p);

      // Constructors.
      //
      event (const category_type&,
             const fedelity_type&,
             const details_type&);

      event (::std::unique_ptr< category_type >,
             ::std::unique_ptr< fedelity_type >,
             ::std::unique_ptr< details_type >);

      event (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      event (const event& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      virtual event*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      event&
      operator= (const event& x);

      virtual 
      ~event ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< category_type > category_;
      ::xsd::cxx::tree::one< fedelity_type > fedelity_;
      ::xsd::cxx::tree::one< details_type > details_;
    };

    class event_category_enum: public ::xml_schema::string
    {
      public:
      enum value
      {
        ACTION,
        DIALOG,
        MOVMENT,
        SOUND,
        ENVIRONMENT
      };

      event_category_enum (value v);

      event_category_enum (const char* v);

      event_category_enum (const ::std::string& v);

      event_category_enum (const ::xml_schema::string& v);

      event_category_enum (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      event_category_enum (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      event_category_enum (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      event_category_enum (const event_category_enum& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual event_category_enum*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      event_category_enum&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_event_category_enum_convert ();
      }

      protected:
      value
      _xsd_event_category_enum_convert () const;

      public:
      static const char* const _xsd_event_category_enum_literals_[5];
      static const value _xsd_event_category_enum_indexes_[5];
    };

    class event_fedelity_enum: public ::xml_schema::string
    {
      public:
      enum value
      {
        LOW,
        MEDIUM,
        HIGH
      };

      event_fedelity_enum (value v);

      event_fedelity_enum (const char* v);

      event_fedelity_enum (const ::std::string& v);

      event_fedelity_enum (const ::xml_schema::string& v);

      event_fedelity_enum (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      event_fedelity_enum (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      event_fedelity_enum (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      event_fedelity_enum (const event_fedelity_enum& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual event_fedelity_enum*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      event_fedelity_enum&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_event_fedelity_enum_convert ();
      }

      protected:
      value
      _xsd_event_fedelity_enum_convert () const;

      public:
      static const char* const _xsd_event_fedelity_enum_literals_[3];
      static const value _xsd_event_fedelity_enum_indexes_[3];
    };

    class citation_list: public ::xml_schema::type
    {
      public:
      // citation
      //
      typedef ::pfc::schema::citation citation_type;
      typedef ::xsd::cxx::tree::sequence< citation_type > citation_sequence;
      typedef citation_sequence::iterator citation_iterator;
      typedef citation_sequence::const_iterator citation_const_iterator;
      typedef ::xsd::cxx::tree::traits< citation_type, char > citation_traits;

      const citation_sequence&
      citation () const;

      citation_sequence&
      citation ();

      void
      citation (const citation_sequence& s);

      // Constructors.
      //
      citation_list ();

      citation_list (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      citation_list (const citation_list& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual citation_list*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      citation_list&
      operator= (const citation_list& x);

      virtual 
      ~citation_list ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      citation_sequence citation_;
    };

    class citation: public ::xml_schema::type
    {
      public:
      // uuid
      //
      typedef ::xml_schema::string uuid_type;
      typedef ::xsd::cxx::tree::traits< uuid_type, char > uuid_traits;

      const uuid_type&
      uuid () const;

      uuid_type&
      uuid ();

      void
      uuid (const uuid_type& x);

      void
      uuid (::std::unique_ptr< uuid_type > p);

      // authors
      //
      typedef ::xml_schema::string authors_type;
      typedef ::xsd::cxx::tree::sequence< authors_type > authors_sequence;
      typedef authors_sequence::iterator authors_iterator;
      typedef authors_sequence::const_iterator authors_const_iterator;
      typedef ::xsd::cxx::tree::traits< authors_type, char > authors_traits;

      const authors_sequence&
      authors () const;

      authors_sequence&
      authors ();

      void
      authors (const authors_sequence& s);

      // title
      //
      typedef ::xml_schema::string title_type;
      typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

      const title_type&
      title () const;

      title_type&
      title ();

      void
      title (const title_type& x);

      void
      title (::std::unique_ptr< title_type > p);

      // date
      //
      typedef ::xml_schema::string date_type;
      typedef ::xsd::cxx::tree::traits< date_type, char > date_traits;

      const date_type&
      date () const;

      date_type&
      date ();

      void
      date (const date_type& x);

      void
      date (::std::unique_ptr< date_type > p);

      // page
      //
      typedef ::xml_schema::string page_type;
      typedef ::xsd::cxx::tree::optional< page_type > page_optional;
      typedef ::xsd::cxx::tree::traits< page_type, char > page_traits;

      const page_optional&
      page () const;

      page_optional&
      page ();

      void
      page (const page_type& x);

      void
      page (const page_optional& x);

      void
      page (::std::unique_ptr< page_type > p);

      // accessed
      //
      typedef ::xml_schema::string accessed_type;
      typedef ::xsd::cxx::tree::optional< accessed_type > accessed_optional;
      typedef ::xsd::cxx::tree::traits< accessed_type, char > accessed_traits;

      const accessed_optional&
      accessed () const;

      accessed_optional&
      accessed ();

      void
      accessed (const accessed_type& x);

      void
      accessed (const accessed_optional& x);

      void
      accessed (::std::unique_ptr< accessed_type > p);

      // Constructors.
      //
      citation (const uuid_type&,
                const title_type&,
                const date_type&);

      citation (::std::unique_ptr< uuid_type >,
                ::std::unique_ptr< title_type >,
                ::std::unique_ptr< date_type >);

      citation (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      citation (const citation& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual citation*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      citation&
      operator= (const citation& x);

      virtual 
      ~citation ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< uuid_type > uuid_;
      authors_sequence authors_;
      ::xsd::cxx::tree::one< title_type > title_;
      ::xsd::cxx::tree::one< date_type > date_;
      page_optional page_;
      accessed_optional accessed_;
    };

    class relates_to: public ::xml_schema::type
    {
      public:
      // treatment-plans
      //
      typedef ::pfc::schema::treatment_plan_reference_list treatment_plans_type;
      typedef ::xsd::cxx::tree::traits< treatment_plans_type, char > treatment_plans_traits;

      const treatment_plans_type&
      treatment_plans () const;

      treatment_plans_type&
      treatment_plans ();

      void
      treatment_plans (const treatment_plans_type& x);

      void
      treatment_plans (::std::unique_ptr< treatment_plans_type > p);

      // injury-profiles
      //
      typedef ::pfc::schema::injury_profile_reference_list injury_profiles_type;
      typedef ::xsd::cxx::tree::traits< injury_profiles_type, char > injury_profiles_traits;

      const injury_profiles_type&
      injury_profiles () const;

      injury_profiles_type&
      injury_profiles ();

      void
      injury_profiles (const injury_profiles_type& x);

      void
      injury_profiles (::std::unique_ptr< injury_profiles_type > p);

      // Constructors.
      //
      relates_to (const treatment_plans_type&,
                  const injury_profiles_type&);

      relates_to (::std::unique_ptr< treatment_plans_type >,
                  ::std::unique_ptr< injury_profiles_type >);

      relates_to (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      relates_to (const relates_to& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual relates_to*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      relates_to&
      operator= (const relates_to& x);

      virtual 
      ~relates_to ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< treatment_plans_type > treatment_plans_;
      ::xsd::cxx::tree::one< injury_profiles_type > injury_profiles_;
    };
  }
}

#include <iosfwd>

namespace pfc
{
  namespace schema
  {
    ::std::ostream&
    operator<< (::std::ostream&, const injury_definition_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const injury&);

    ::std::ostream&
    operator<< (::std::ostream&, const injury_severity_range&);

    ::std::ostream&
    operator<< (::std::ostream&, const numeric_range&);

    ::std::ostream&
    operator<< (::std::ostream&, const token_range&);

    ::std::ostream&
    operator<< (::std::ostream&, const citation_ref_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const treatment_plan_definition_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const treatment_plan&);

    ::std::ostream&
    operator<< (::std::ostream&, const medical_equipment_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const treatment_plan_citation_ref_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const cpg_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const learning_objective_reference_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const treatment_plan_reference_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const injury_profile_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const injury_profile&);

    ::std::ostream&
    operator<< (::std::ostream&, const injury_profile_reference_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const injury_occurance_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const medical_scenario_syllabus&);

    ::std::ostream&
    operator<< (::std::ostream&, const learning_objective_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const learning_objective&);

    ::std::ostream&
    operator<< (::std::ostream&, const assessment_criteria_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const assessment&);

    ::std::ostream&
    operator<< (::std::ostream&, const medical_scenario&);

    ::std::ostream&
    operator<< (::std::ostream&, const role_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const role&);

    ::std::ostream&
    operator<< (::std::ostream&, const prop_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const prop&);

    ::std::ostream&
    operator<< (::std::ostream&, const scene_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const scene&);

    ::std::ostream&
    operator<< (::std::ostream&, const event_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const event&);

    ::std::ostream&
    operator<< (::std::ostream&, event_category_enum::value);

    ::std::ostream&
    operator<< (::std::ostream&, const event_category_enum&);

    ::std::ostream&
    operator<< (::std::ostream&, event_fedelity_enum::value);

    ::std::ostream&
    operator<< (::std::ostream&, const event_fedelity_enum&);

    ::std::ostream&
    operator<< (::std::ostream&, const citation_list&);

    ::std::ostream&
    operator<< (::std::ostream&, const citation&);

    ::std::ostream&
    operator<< (::std::ostream&, const relates_to&);
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace pfc
{
  namespace schema
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace pfc
{
  namespace schema
  {
    void
    operator<< (::xercesc::DOMElement&, const injury_definition_list&);

    void
    operator<< (::xercesc::DOMElement&, const injury&);

    void
    operator<< (::xercesc::DOMElement&, const injury_severity_range&);

    void
    operator<< (::xercesc::DOMElement&, const numeric_range&);

    void
    operator<< (::xercesc::DOMElement&, const token_range&);

    void
    operator<< (::xercesc::DOMElement&, const citation_ref_list&);

    void
    operator<< (::xercesc::DOMElement&, const treatment_plan_definition_list&);

    void
    operator<< (::xercesc::DOMElement&, const treatment_plan&);

    void
    operator<< (::xercesc::DOMElement&, const medical_equipment_list&);

    void
    operator<< (::xercesc::DOMElement&, const treatment_plan_citation_ref_list&);

    void
    operator<< (::xercesc::DOMElement&, const cpg_list&);

    void
    operator<< (::xercesc::DOMElement&, const learning_objective_reference_list&);

    void
    operator<< (::xercesc::DOMElement&, const treatment_plan_reference_list&);

    void
    operator<< (::xercesc::DOMElement&, const injury_profile_list&);

    void
    operator<< (::xercesc::DOMElement&, const injury_profile&);

    void
    operator<< (::xercesc::DOMElement&, const injury_profile_reference_list&);

    void
    operator<< (::xercesc::DOMElement&, const injury_occurance_list&);

    void
    operator<< (::xercesc::DOMElement&, const medical_scenario_syllabus&);

    void
    operator<< (::xercesc::DOMElement&, const learning_objective_list&);

    void
    operator<< (::xercesc::DOMElement&, const learning_objective&);

    void
    operator<< (::xercesc::DOMElement&, const assessment_criteria_list&);

    void
    operator<< (::xercesc::DOMElement&, const assessment&);

    void
    operator<< (::xercesc::DOMElement&, const medical_scenario&);

    void
    operator<< (::xercesc::DOMElement&, const role_list&);

    void
    operator<< (::xercesc::DOMElement&, const role&);

    void
    operator<< (::xercesc::DOMElement&, const prop_list&);

    void
    operator<< (::xercesc::DOMElement&, const prop&);

    void
    operator<< (::xercesc::DOMElement&, const scene_list&);

    void
    operator<< (::xercesc::DOMElement&, const scene&);

    void
    operator<< (::xercesc::DOMElement&, const event_list&);

    void
    operator<< (::xercesc::DOMElement&, const event&);

    void
    operator<< (::xercesc::DOMElement&, const event_category_enum&);

    void
    operator<< (::xercesc::DOMAttr&, const event_category_enum&);

    void
    operator<< (::xml_schema::list_stream&,
                const event_category_enum&);

    void
    operator<< (::xercesc::DOMElement&, const event_fedelity_enum&);

    void
    operator<< (::xercesc::DOMAttr&, const event_fedelity_enum&);

    void
    operator<< (::xml_schema::list_stream&,
                const event_fedelity_enum&);

    void
    operator<< (::xercesc::DOMElement&, const citation_list&);

    void
    operator<< (::xercesc::DOMElement&, const citation&);

    void
    operator<< (::xercesc::DOMElement&, const relates_to&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // PFC_SCENARIO_COMPLEX_TYPES_0_1_HXX
