// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#if defined(__clang__)
  #define SUSTAIN_XSD_API
#elif defined(__gnu_linux__) 
  #define SUSTAIN_XSD_API __attribute__ ((visibility ("default")))
#elif defined(_WIN32)
 // ifdef SUSTAIN_XSD_EXPORTS
    #define SUSTAIN_XSD_API __declspec(dllexport)
 // #else
 //   #define SUSTAIN_XSD_API __declspec(dllimport)
 // #endif
#else 
  #define SUSTAIN_XSD_API
#endif
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "pfc_scenario_0.3.hxx"

namespace pfc
{
  namespace schema
  {
    // ScenarioSchema
    // 

    const ScenarioSchema::summary_type& ScenarioSchema::
    summary () const
    {
      return this->summary_.get ();
    }

    ScenarioSchema::summary_type& ScenarioSchema::
    summary ()
    {
      return this->summary_.get ();
    }

    void ScenarioSchema::
    summary (const summary_type& x)
    {
      this->summary_.set (x);
    }

    void ScenarioSchema::
    summary (::std::unique_ptr< summary_type > x)
    {
      this->summary_.set (std::move (x));
    }

    const ScenarioSchema::author_type& ScenarioSchema::
    author () const
    {
      return this->author_.get ();
    }

    ScenarioSchema::author_type& ScenarioSchema::
    author ()
    {
      return this->author_.get ();
    }

    void ScenarioSchema::
    author (const author_type& x)
    {
      this->author_.set (x);
    }

    void ScenarioSchema::
    author (::std::unique_ptr< author_type > x)
    {
      this->author_.set (std::move (x));
    }

    const ScenarioSchema::equipment_type& ScenarioSchema::
    equipment () const
    {
      return this->equipment_.get ();
    }

    ScenarioSchema::equipment_type& ScenarioSchema::
    equipment ()
    {
      return this->equipment_.get ();
    }

    void ScenarioSchema::
    equipment (const equipment_type& x)
    {
      this->equipment_.set (x);
    }

    void ScenarioSchema::
    equipment (::std::unique_ptr< equipment_type > x)
    {
      this->equipment_.set (std::move (x));
    }

    const ScenarioSchema::trauma_definitions_type& ScenarioSchema::
    trauma_definitions () const
    {
      return this->trauma_definitions_.get ();
    }

    ScenarioSchema::trauma_definitions_type& ScenarioSchema::
    trauma_definitions ()
    {
      return this->trauma_definitions_.get ();
    }

    void ScenarioSchema::
    trauma_definitions (const trauma_definitions_type& x)
    {
      this->trauma_definitions_.set (x);
    }

    void ScenarioSchema::
    trauma_definitions (::std::unique_ptr< trauma_definitions_type > x)
    {
      this->trauma_definitions_.set (std::move (x));
    }

    const ScenarioSchema::treatment_plans_type& ScenarioSchema::
    treatment_plans () const
    {
      return this->treatment_plans_.get ();
    }

    ScenarioSchema::treatment_plans_type& ScenarioSchema::
    treatment_plans ()
    {
      return this->treatment_plans_.get ();
    }

    void ScenarioSchema::
    treatment_plans (const treatment_plans_type& x)
    {
      this->treatment_plans_.set (x);
    }

    void ScenarioSchema::
    treatment_plans (::std::unique_ptr< treatment_plans_type > x)
    {
      this->treatment_plans_.set (std::move (x));
    }

    const ScenarioSchema::trauma_sets_type& ScenarioSchema::
    trauma_sets () const
    {
      return this->trauma_sets_.get ();
    }

    ScenarioSchema::trauma_sets_type& ScenarioSchema::
    trauma_sets ()
    {
      return this->trauma_sets_.get ();
    }

    void ScenarioSchema::
    trauma_sets (const trauma_sets_type& x)
    {
      this->trauma_sets_.set (x);
    }

    void ScenarioSchema::
    trauma_sets (::std::unique_ptr< trauma_sets_type > x)
    {
      this->trauma_sets_.set (std::move (x));
    }

    const ScenarioSchema::syllabus_type& ScenarioSchema::
    syllabus () const
    {
      return this->syllabus_.get ();
    }

    ScenarioSchema::syllabus_type& ScenarioSchema::
    syllabus ()
    {
      return this->syllabus_.get ();
    }

    void ScenarioSchema::
    syllabus (const syllabus_type& x)
    {
      this->syllabus_.set (x);
    }

    void ScenarioSchema::
    syllabus (::std::unique_ptr< syllabus_type > x)
    {
      this->syllabus_.set (std::move (x));
    }

    const ScenarioSchema::medical_scenario_type& ScenarioSchema::
    medical_scenario () const
    {
      return this->medical_scenario_.get ();
    }

    ScenarioSchema::medical_scenario_type& ScenarioSchema::
    medical_scenario ()
    {
      return this->medical_scenario_.get ();
    }

    void ScenarioSchema::
    medical_scenario (const medical_scenario_type& x)
    {
      this->medical_scenario_.set (x);
    }

    void ScenarioSchema::
    medical_scenario (::std::unique_ptr< medical_scenario_type > x)
    {
      this->medical_scenario_.set (std::move (x));
    }

    const ScenarioSchema::works_cited_type& ScenarioSchema::
    works_cited () const
    {
      return this->works_cited_.get ();
    }

    ScenarioSchema::works_cited_type& ScenarioSchema::
    works_cited ()
    {
      return this->works_cited_.get ();
    }

    void ScenarioSchema::
    works_cited (const works_cited_type& x)
    {
      this->works_cited_.set (x);
    }

    void ScenarioSchema::
    works_cited (::std::unique_ptr< works_cited_type > x)
    {
      this->works_cited_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace pfc
{
  namespace schema
  {
    // ScenarioSchema
    //

    ScenarioSchema::
    ScenarioSchema (const summary_type& summary,
                    const author_type& author,
                    const equipment_type& equipment,
                    const trauma_definitions_type& trauma_definitions,
                    const treatment_plans_type& treatment_plans,
                    const trauma_sets_type& trauma_sets,
                    const syllabus_type& syllabus,
                    const medical_scenario_type& medical_scenario,
                    const works_cited_type& works_cited)
    : ::xml_schema::type (),
      summary_ (summary, this),
      author_ (author, this),
      equipment_ (equipment, this),
      trauma_definitions_ (trauma_definitions, this),
      treatment_plans_ (treatment_plans, this),
      trauma_sets_ (trauma_sets, this),
      syllabus_ (syllabus, this),
      medical_scenario_ (medical_scenario, this),
      works_cited_ (works_cited, this)
    {
    }

    ScenarioSchema::
    ScenarioSchema (::std::unique_ptr< summary_type > summary,
                    ::std::unique_ptr< author_type > author,
                    ::std::unique_ptr< equipment_type > equipment,
                    ::std::unique_ptr< trauma_definitions_type > trauma_definitions,
                    ::std::unique_ptr< treatment_plans_type > treatment_plans,
                    ::std::unique_ptr< trauma_sets_type > trauma_sets,
                    ::std::unique_ptr< syllabus_type > syllabus,
                    ::std::unique_ptr< medical_scenario_type > medical_scenario,
                    ::std::unique_ptr< works_cited_type > works_cited)
    : ::xml_schema::type (),
      summary_ (std::move (summary), this),
      author_ (std::move (author), this),
      equipment_ (std::move (equipment), this),
      trauma_definitions_ (std::move (trauma_definitions), this),
      treatment_plans_ (std::move (treatment_plans), this),
      trauma_sets_ (std::move (trauma_sets), this),
      syllabus_ (std::move (syllabus), this),
      medical_scenario_ (std::move (medical_scenario), this),
      works_cited_ (std::move (works_cited), this)
    {
    }

    ScenarioSchema::
    ScenarioSchema (const ScenarioSchema& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      summary_ (x.summary_, f, this),
      author_ (x.author_, f, this),
      equipment_ (x.equipment_, f, this),
      trauma_definitions_ (x.trauma_definitions_, f, this),
      treatment_plans_ (x.treatment_plans_, f, this),
      trauma_sets_ (x.trauma_sets_, f, this),
      syllabus_ (x.syllabus_, f, this),
      medical_scenario_ (x.medical_scenario_, f, this),
      works_cited_ (x.works_cited_, f, this)
    {
    }

    ScenarioSchema::
    ScenarioSchema (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      summary_ (this),
      author_ (this),
      equipment_ (this),
      trauma_definitions_ (this),
      treatment_plans_ (this),
      trauma_sets_ (this),
      syllabus_ (this),
      medical_scenario_ (this),
      works_cited_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ScenarioSchema::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // summary
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "summary",
              "",
              &::xsd::cxx::tree::factory_impl< summary_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!summary_.present ())
            {
              ::std::unique_ptr< summary_type > r (
                dynamic_cast< summary_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->summary_.set (::std::move (r));
              continue;
            }
          }
        }

        // author
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "author",
              "",
              &::xsd::cxx::tree::factory_impl< author_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!author_.present ())
            {
              ::std::unique_ptr< author_type > r (
                dynamic_cast< author_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->author_.set (::std::move (r));
              continue;
            }
          }
        }

        // equipment
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "equipment",
              "",
              &::xsd::cxx::tree::factory_impl< equipment_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!equipment_.present ())
            {
              ::std::unique_ptr< equipment_type > r (
                dynamic_cast< equipment_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->equipment_.set (::std::move (r));
              continue;
            }
          }
        }

        // trauma-definitions
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "trauma-definitions",
              "",
              &::xsd::cxx::tree::factory_impl< trauma_definitions_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!trauma_definitions_.present ())
            {
              ::std::unique_ptr< trauma_definitions_type > r (
                dynamic_cast< trauma_definitions_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->trauma_definitions_.set (::std::move (r));
              continue;
            }
          }
        }

        // treatment-plans
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "treatment-plans",
              "",
              &::xsd::cxx::tree::factory_impl< treatment_plans_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!treatment_plans_.present ())
            {
              ::std::unique_ptr< treatment_plans_type > r (
                dynamic_cast< treatment_plans_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->treatment_plans_.set (::std::move (r));
              continue;
            }
          }
        }

        // trauma-sets
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "trauma-sets",
              "",
              &::xsd::cxx::tree::factory_impl< trauma_sets_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!trauma_sets_.present ())
            {
              ::std::unique_ptr< trauma_sets_type > r (
                dynamic_cast< trauma_sets_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->trauma_sets_.set (::std::move (r));
              continue;
            }
          }
        }

        // syllabus
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "syllabus",
              "",
              &::xsd::cxx::tree::factory_impl< syllabus_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!syllabus_.present ())
            {
              ::std::unique_ptr< syllabus_type > r (
                dynamic_cast< syllabus_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->syllabus_.set (::std::move (r));
              continue;
            }
          }
        }

        // medical-scenario
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "medical-scenario",
              "",
              &::xsd::cxx::tree::factory_impl< medical_scenario_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!medical_scenario_.present ())
            {
              ::std::unique_ptr< medical_scenario_type > r (
                dynamic_cast< medical_scenario_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->medical_scenario_.set (::std::move (r));
              continue;
            }
          }
        }

        // works-cited
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "works-cited",
              "",
              &::xsd::cxx::tree::factory_impl< works_cited_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!works_cited_.present ())
            {
              ::std::unique_ptr< works_cited_type > r (
                dynamic_cast< works_cited_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->works_cited_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!summary_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "summary",
          "");
      }

      if (!author_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "author",
          "");
      }

      if (!equipment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "equipment",
          "");
      }

      if (!trauma_definitions_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "trauma-definitions",
          "");
      }

      if (!treatment_plans_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "treatment-plans",
          "");
      }

      if (!trauma_sets_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "trauma-sets",
          "");
      }

      if (!syllabus_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "syllabus",
          "");
      }

      if (!medical_scenario_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "medical-scenario",
          "");
      }

      if (!works_cited_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "works-cited",
          "");
      }
    }

    ScenarioSchema* ScenarioSchema::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ScenarioSchema (*this, f, c);
    }

    ScenarioSchema& ScenarioSchema::
    operator= (const ScenarioSchema& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->summary_ = x.summary_;
        this->author_ = x.author_;
        this->equipment_ = x.equipment_;
        this->trauma_definitions_ = x.trauma_definitions_;
        this->treatment_plans_ = x.treatment_plans_;
        this->trauma_sets_ = x.trauma_sets_;
        this->syllabus_ = x.syllabus_;
        this->medical_scenario_ = x.medical_scenario_;
        this->works_cited_ = x.works_cited_;
      }

      return *this;
    }

    ScenarioSchema::
    ~ScenarioSchema ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ScenarioSchema >
    _xsd_ScenarioSchema_type_factory_init (
      "ScenarioSchema",
      "com:ara:pfc:training:1");
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace pfc
{
  namespace schema
  {
    ::std::ostream&
    operator<< (::std::ostream& o, const ScenarioSchema& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "summary: ";
        om.insert (o, i.summary ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "author: ";
        om.insert (o, i.author ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "equipment: ";
        om.insert (o, i.equipment ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "trauma-definitions: ";
        om.insert (o, i.trauma_definitions ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "treatment-plans: ";
        om.insert (o, i.treatment_plans ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "trauma-sets: ";
        om.insert (o, i.trauma_sets ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "syllabus: ";
        om.insert (o, i.syllabus ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "medical-scenario: ";
        om.insert (o, i.medical_scenario ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "works-cited: ";
        om.insert (o, i.works_cited ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ScenarioSchema >
    _xsd_ScenarioSchema_std_ostream_init;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace pfc
{
  namespace schema
  {
    ::std::unique_ptr< ::pfc::schema::ScenarioSchema >
    Scenario (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::pfc::schema::ScenarioSchema > (
        ::pfc::schema::Scenario (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::pfc::schema::ScenarioSchema >
    Scenario (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::pfc::schema::ScenarioSchema > (
        ::pfc::schema::Scenario (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::pfc::schema::ScenarioSchema >
    Scenario (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::pfc::schema::ScenarioSchema > (
        ::pfc::schema::Scenario (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::pfc::schema::ScenarioSchema >
    Scenario (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::pfc::schema::Scenario (isrc, f, p);
    }

    ::std::unique_ptr< ::pfc::schema::ScenarioSchema >
    Scenario (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::pfc::schema::Scenario (isrc, h, f, p);
    }

    ::std::unique_ptr< ::pfc::schema::ScenarioSchema >
    Scenario (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::pfc::schema::Scenario (isrc, h, f, p);
    }

    ::std::unique_ptr< ::pfc::schema::ScenarioSchema >
    Scenario (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::pfc::schema::Scenario (isrc, f, p);
    }

    ::std::unique_ptr< ::pfc::schema::ScenarioSchema >
    Scenario (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::pfc::schema::Scenario (isrc, h, f, p);
    }

    ::std::unique_ptr< ::pfc::schema::ScenarioSchema >
    Scenario (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::pfc::schema::Scenario (isrc, h, f, p);
    }

    ::std::unique_ptr< ::pfc::schema::ScenarioSchema >
    Scenario (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::pfc::schema::ScenarioSchema > (
        ::pfc::schema::Scenario (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::pfc::schema::ScenarioSchema >
    Scenario (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::pfc::schema::ScenarioSchema > (
        ::pfc::schema::Scenario (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::pfc::schema::ScenarioSchema >
    Scenario (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::pfc::schema::ScenarioSchema > (
        ::pfc::schema::Scenario (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::pfc::schema::ScenarioSchema >
    Scenario (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::pfc::schema::ScenarioSchema > (
          ::pfc::schema::Scenario (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Scenario",
          "com:ara:pfc:training:1",
          &::xsd::cxx::tree::factory_impl< ::pfc::schema::ScenarioSchema >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::pfc::schema::ScenarioSchema > r (
          dynamic_cast< ::pfc::schema::ScenarioSchema* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Scenario",
        "com:ara:pfc:training:1");
    }

    ::std::unique_ptr< ::pfc::schema::ScenarioSchema >
    Scenario (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Scenario",
          "com:ara:pfc:training:1",
          &::xsd::cxx::tree::factory_impl< ::pfc::schema::ScenarioSchema >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::pfc::schema::ScenarioSchema > r (
          dynamic_cast< ::pfc::schema::ScenarioSchema* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Scenario",
        "com:ara:pfc:training:1");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace pfc
{
  namespace schema
  {
    void
    operator<< (::xercesc::DOMElement& e, const ScenarioSchema& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // summary
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ScenarioSchema::summary_type& x (i.summary ());
        if (typeid (ScenarioSchema::summary_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "summary",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "summary",
            "",
            false, false, e, x);
      }

      // author
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ScenarioSchema::author_type& x (i.author ());
        if (typeid (ScenarioSchema::author_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "author",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "author",
            "",
            false, false, e, x);
      }

      // equipment
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ScenarioSchema::equipment_type& x (i.equipment ());
        if (typeid (ScenarioSchema::equipment_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "equipment",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "equipment",
            "",
            false, false, e, x);
      }

      // trauma-definitions
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ScenarioSchema::trauma_definitions_type& x (i.trauma_definitions ());
        if (typeid (ScenarioSchema::trauma_definitions_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "trauma-definitions",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "trauma-definitions",
            "",
            false, false, e, x);
      }

      // treatment-plans
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ScenarioSchema::treatment_plans_type& x (i.treatment_plans ());
        if (typeid (ScenarioSchema::treatment_plans_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "treatment-plans",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "treatment-plans",
            "",
            false, false, e, x);
      }

      // trauma-sets
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ScenarioSchema::trauma_sets_type& x (i.trauma_sets ());
        if (typeid (ScenarioSchema::trauma_sets_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "trauma-sets",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "trauma-sets",
            "",
            false, false, e, x);
      }

      // syllabus
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ScenarioSchema::syllabus_type& x (i.syllabus ());
        if (typeid (ScenarioSchema::syllabus_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "syllabus",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "syllabus",
            "",
            false, false, e, x);
      }

      // medical-scenario
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ScenarioSchema::medical_scenario_type& x (i.medical_scenario ());
        if (typeid (ScenarioSchema::medical_scenario_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "medical-scenario",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "medical-scenario",
            "",
            false, false, e, x);
      }

      // works-cited
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ScenarioSchema::works_cited_type& x (i.works_cited ());
        if (typeid (ScenarioSchema::works_cited_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "works-cited",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "works-cited",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ScenarioSchema >
    _xsd_ScenarioSchema_type_serializer_init (
      "ScenarioSchema",
      "com:ara:pfc:training:1");


    void
    Scenario (::std::ostream& o,
              const ::pfc::schema::ScenarioSchema& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::pfc::schema::Scenario (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Scenario (::std::ostream& o,
              const ::pfc::schema::ScenarioSchema& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::pfc::schema::Scenario (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Scenario (::std::ostream& o,
              const ::pfc::schema::ScenarioSchema& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::pfc::schema::Scenario (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Scenario (::xercesc::XMLFormatTarget& t,
              const ::pfc::schema::ScenarioSchema& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::pfc::schema::Scenario (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Scenario (::xercesc::XMLFormatTarget& t,
              const ::pfc::schema::ScenarioSchema& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::pfc::schema::Scenario (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Scenario (::xercesc::XMLFormatTarget& t,
              const ::pfc::schema::ScenarioSchema& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::pfc::schema::Scenario (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Scenario (::xercesc::DOMDocument& d,
              const ::pfc::schema::ScenarioSchema& s,
              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::pfc::schema::ScenarioSchema) == typeid (s))
      {
        if (n.name () == "Scenario" &&
            n.namespace_ () == "com:ara:pfc:training:1")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Scenario",
            "com:ara:pfc:training:1");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Scenario",
          "com:ara:pfc:training:1",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    Scenario (const ::pfc::schema::ScenarioSchema& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::pfc::schema::ScenarioSchema) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Scenario",
          "com:ara:pfc:training:1",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Scenario",
          "com:ara:pfc:training:1",
          m, s, f);
      }

      ::pfc::schema::Scenario (*d, s, f);
      return d;
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

