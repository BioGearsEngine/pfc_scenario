// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "pfc_scenario_complex_types_0.1.hxx"

namespace pfc
{
  namespace schema
  {
    // equipment_definition_list
    // 

    const equipment_definition_list::equipment_sequence& equipment_definition_list::
    equipment () const
    {
      return this->equipment_;
    }

    equipment_definition_list::equipment_sequence& equipment_definition_list::
    equipment ()
    {
      return this->equipment_;
    }

    void equipment_definition_list::
    equipment (const equipment_sequence& s)
    {
      this->equipment_ = s;
    }


    // equipment
    // 

    const equipment::id_type& equipment::
    id () const
    {
      return this->id_.get ();
    }

    equipment::id_type& equipment::
    id ()
    {
      return this->id_.get ();
    }

    void equipment::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void equipment::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const equipment::name_type& equipment::
    name () const
    {
      return this->name_.get ();
    }

    equipment::name_type& equipment::
    name ()
    {
      return this->name_.get ();
    }

    void equipment::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void equipment::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const equipment::type_optional& equipment::
    type () const
    {
      return this->type_;
    }

    equipment::type_optional& equipment::
    type ()
    {
      return this->type_;
    }

    void equipment::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void equipment::
    type (const type_optional& x)
    {
      this->type_ = x;
    }

    const equipment::description_type& equipment::
    description () const
    {
      return this->description_.get ();
    }

    equipment::description_type& equipment::
    description ()
    {
      return this->description_.get ();
    }

    void equipment::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void equipment::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const equipment::citations_type& equipment::
    citations () const
    {
      return this->citations_.get ();
    }

    equipment::citations_type& equipment::
    citations ()
    {
      return this->citations_.get ();
    }

    void equipment::
    citations (const citations_type& x)
    {
      this->citations_.set (x);
    }

    void equipment::
    citations (::std::unique_ptr< citations_type > x)
    {
      this->citations_.set (std::move (x));
    }

    const equipment::image_optional& equipment::
    image () const
    {
      return this->image_;
    }

    equipment::image_optional& equipment::
    image ()
    {
      return this->image_;
    }

    void equipment::
    image (const image_type& x)
    {
      this->image_.set (x);
    }

    void equipment::
    image (const image_optional& x)
    {
      this->image_ = x;
    }

    void equipment::
    image (::std::unique_ptr< image_type > x)
    {
      this->image_.set (std::move (x));
    }

    const equipment::properties_type& equipment::
    properties () const
    {
      return this->properties_.get ();
    }

    equipment::properties_type& equipment::
    properties ()
    {
      return this->properties_.get ();
    }

    void equipment::
    properties (const properties_type& x)
    {
      this->properties_.set (x);
    }

    void equipment::
    properties (::std::unique_ptr< properties_type > x)
    {
      this->properties_.set (std::move (x));
    }


    // injury_definition_list
    // 

    const injury_definition_list::injury_sequence& injury_definition_list::
    injury () const
    {
      return this->injury_;
    }

    injury_definition_list::injury_sequence& injury_definition_list::
    injury ()
    {
      return this->injury_;
    }

    void injury_definition_list::
    injury (const injury_sequence& s)
    {
      this->injury_ = s;
    }


    // injury
    // 

    const injury::id_type& injury::
    id () const
    {
      return this->id_.get ();
    }

    injury::id_type& injury::
    id ()
    {
      return this->id_.get ();
    }

    void injury::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void injury::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const injury::common_name_optional& injury::
    common_name () const
    {
      return this->common_name_;
    }

    injury::common_name_optional& injury::
    common_name ()
    {
      return this->common_name_;
    }

    void injury::
    common_name (const common_name_type& x)
    {
      this->common_name_.set (x);
    }

    void injury::
    common_name (const common_name_optional& x)
    {
      this->common_name_ = x;
    }

    void injury::
    common_name (::std::unique_ptr< common_name_type > x)
    {
      this->common_name_.set (std::move (x));
    }

    const injury::medical_name_type& injury::
    medical_name () const
    {
      return this->medical_name_.get ();
    }

    injury::medical_name_type& injury::
    medical_name ()
    {
      return this->medical_name_.get ();
    }

    void injury::
    medical_name (const medical_name_type& x)
    {
      this->medical_name_.set (x);
    }

    void injury::
    medical_name (::std::unique_ptr< medical_name_type > x)
    {
      this->medical_name_.set (std::move (x));
    }

    const injury::citations_type& injury::
    citations () const
    {
      return this->citations_.get ();
    }

    injury::citations_type& injury::
    citations ()
    {
      return this->citations_.get ();
    }

    void injury::
    citations (const citations_type& x)
    {
      this->citations_.set (x);
    }

    void injury::
    citations (::std::unique_ptr< citations_type > x)
    {
      this->citations_.set (std::move (x));
    }

    const injury::description_type& injury::
    description () const
    {
      return this->description_.get ();
    }

    injury::description_type& injury::
    description ()
    {
      return this->description_.get ();
    }

    void injury::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void injury::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const injury::severity_range_type& injury::
    severity_range () const
    {
      return this->severity_range_.get ();
    }

    injury::severity_range_type& injury::
    severity_range ()
    {
      return this->severity_range_.get ();
    }

    void injury::
    severity_range (const severity_range_type& x)
    {
      this->severity_range_.set (x);
    }

    void injury::
    severity_range (::std::unique_ptr< severity_range_type > x)
    {
      this->severity_range_.set (std::move (x));
    }


    // injury_severity_range
    // 

    const injury_severity_range::numeric_range_optional& injury_severity_range::
    numeric_range () const
    {
      return this->numeric_range_;
    }

    injury_severity_range::numeric_range_optional& injury_severity_range::
    numeric_range ()
    {
      return this->numeric_range_;
    }

    void injury_severity_range::
    numeric_range (const numeric_range_type& x)
    {
      this->numeric_range_.set (x);
    }

    void injury_severity_range::
    numeric_range (const numeric_range_optional& x)
    {
      this->numeric_range_ = x;
    }

    void injury_severity_range::
    numeric_range (::std::unique_ptr< numeric_range_type > x)
    {
      this->numeric_range_.set (std::move (x));
    }

    const injury_severity_range::token_range_optional& injury_severity_range::
    token_range () const
    {
      return this->token_range_;
    }

    injury_severity_range::token_range_optional& injury_severity_range::
    token_range ()
    {
      return this->token_range_;
    }

    void injury_severity_range::
    token_range (const token_range_type& x)
    {
      this->token_range_.set (x);
    }

    void injury_severity_range::
    token_range (const token_range_optional& x)
    {
      this->token_range_ = x;
    }

    void injury_severity_range::
    token_range (::std::unique_ptr< token_range_type > x)
    {
      this->token_range_.set (std::move (x));
    }


    // numeric_range
    // 

    const numeric_range::min_type& numeric_range::
    min () const
    {
      return this->min_.get ();
    }

    numeric_range::min_type& numeric_range::
    min ()
    {
      return this->min_.get ();
    }

    void numeric_range::
    min (const min_type& x)
    {
      this->min_.set (x);
    }

    const numeric_range::max_type& numeric_range::
    max () const
    {
      return this->max_.get ();
    }

    numeric_range::max_type& numeric_range::
    max ()
    {
      return this->max_.get ();
    }

    void numeric_range::
    max (const max_type& x)
    {
      this->max_.set (x);
    }

    const numeric_range::median_optional& numeric_range::
    median () const
    {
      return this->median_;
    }

    numeric_range::median_optional& numeric_range::
    median ()
    {
      return this->median_;
    }

    void numeric_range::
    median (const median_type& x)
    {
      this->median_.set (x);
    }

    void numeric_range::
    median (const median_optional& x)
    {
      this->median_ = x;
    }

    const numeric_range::unit_optional& numeric_range::
    unit () const
    {
      return this->unit_;
    }

    numeric_range::unit_optional& numeric_range::
    unit ()
    {
      return this->unit_;
    }

    void numeric_range::
    unit (const unit_type& x)
    {
      this->unit_.set (x);
    }

    void numeric_range::
    unit (const unit_optional& x)
    {
      this->unit_ = x;
    }

    void numeric_range::
    unit (::std::unique_ptr< unit_type > x)
    {
      this->unit_.set (std::move (x));
    }


    // token_range
    // 

    const token_range::token_sequence& token_range::
    token () const
    {
      return this->token_;
    }

    token_range::token_sequence& token_range::
    token ()
    {
      return this->token_;
    }

    void token_range::
    token (const token_sequence& s)
    {
      this->token_ = s;
    }


    // citation_ref_list
    // 

    const citation_ref_list::citation_ref_sequence& citation_ref_list::
    citation_ref () const
    {
      return this->citation_ref_;
    }

    citation_ref_list::citation_ref_sequence& citation_ref_list::
    citation_ref ()
    {
      return this->citation_ref_;
    }

    void citation_ref_list::
    citation_ref (const citation_ref_sequence& s)
    {
      this->citation_ref_ = s;
    }


    // treatment_plan_definition_list
    // 

    const treatment_plan_definition_list::treatment_plan_sequence& treatment_plan_definition_list::
    treatment_plan () const
    {
      return this->treatment_plan_;
    }

    treatment_plan_definition_list::treatment_plan_sequence& treatment_plan_definition_list::
    treatment_plan ()
    {
      return this->treatment_plan_;
    }

    void treatment_plan_definition_list::
    treatment_plan (const treatment_plan_sequence& s)
    {
      this->treatment_plan_ = s;
    }


    // treatment_plan
    // 

    const treatment_plan::id_type& treatment_plan::
    id () const
    {
      return this->id_.get ();
    }

    treatment_plan::id_type& treatment_plan::
    id ()
    {
      return this->id_.get ();
    }

    void treatment_plan::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void treatment_plan::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const treatment_plan::common_name_optional& treatment_plan::
    common_name () const
    {
      return this->common_name_;
    }

    treatment_plan::common_name_optional& treatment_plan::
    common_name ()
    {
      return this->common_name_;
    }

    void treatment_plan::
    common_name (const common_name_type& x)
    {
      this->common_name_.set (x);
    }

    void treatment_plan::
    common_name (const common_name_optional& x)
    {
      this->common_name_ = x;
    }

    void treatment_plan::
    common_name (::std::unique_ptr< common_name_type > x)
    {
      this->common_name_.set (std::move (x));
    }

    const treatment_plan::description_type& treatment_plan::
    description () const
    {
      return this->description_.get ();
    }

    treatment_plan::description_type& treatment_plan::
    description ()
    {
      return this->description_.get ();
    }

    void treatment_plan::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void treatment_plan::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const treatment_plan::required_equipment_type& treatment_plan::
    required_equipment () const
    {
      return this->required_equipment_.get ();
    }

    treatment_plan::required_equipment_type& treatment_plan::
    required_equipment ()
    {
      return this->required_equipment_.get ();
    }

    void treatment_plan::
    required_equipment (const required_equipment_type& x)
    {
      this->required_equipment_.set (x);
    }

    void treatment_plan::
    required_equipment (::std::unique_ptr< required_equipment_type > x)
    {
      this->required_equipment_.set (std::move (x));
    }

    const treatment_plan::references_type& treatment_plan::
    references () const
    {
      return this->references_.get ();
    }

    treatment_plan::references_type& treatment_plan::
    references ()
    {
      return this->references_.get ();
    }

    void treatment_plan::
    references (const references_type& x)
    {
      this->references_.set (x);
    }

    void treatment_plan::
    references (::std::unique_ptr< references_type > x)
    {
      this->references_.set (std::move (x));
    }


    // equipment_ref_list
    // 

    const equipment_ref_list::equipment_refs_sequence& equipment_ref_list::
    equipment_refs () const
    {
      return this->equipment_refs_;
    }

    equipment_ref_list::equipment_refs_sequence& equipment_ref_list::
    equipment_refs ()
    {
      return this->equipment_refs_;
    }

    void equipment_ref_list::
    equipment_refs (const equipment_refs_sequence& s)
    {
      this->equipment_refs_ = s;
    }


    // medical_reference_list
    // 

    const medical_reference_list::citations_type& medical_reference_list::
    citations () const
    {
      return this->citations_.get ();
    }

    medical_reference_list::citations_type& medical_reference_list::
    citations ()
    {
      return this->citations_.get ();
    }

    void medical_reference_list::
    citations (const citations_type& x)
    {
      this->citations_.set (x);
    }

    void medical_reference_list::
    citations (::std::unique_ptr< citations_type > x)
    {
      this->citations_.set (std::move (x));
    }

    const medical_reference_list::cpgs_type& medical_reference_list::
    cpgs () const
    {
      return this->cpgs_.get ();
    }

    medical_reference_list::cpgs_type& medical_reference_list::
    cpgs ()
    {
      return this->cpgs_.get ();
    }

    void medical_reference_list::
    cpgs (const cpgs_type& x)
    {
      this->cpgs_.set (x);
    }

    void medical_reference_list::
    cpgs (::std::unique_ptr< cpgs_type > x)
    {
      this->cpgs_.set (std::move (x));
    }


    // cpg_ref_list
    // 

    const cpg_ref_list::cpg_ref_sequence& cpg_ref_list::
    cpg_ref () const
    {
      return this->cpg_ref_;
    }

    cpg_ref_list::cpg_ref_sequence& cpg_ref_list::
    cpg_ref ()
    {
      return this->cpg_ref_;
    }

    void cpg_ref_list::
    cpg_ref (const cpg_ref_sequence& s)
    {
      this->cpg_ref_ = s;
    }


    // cpg_list
    // 

    const cpg_list::cpg_sequence& cpg_list::
    cpg () const
    {
      return this->cpg_;
    }

    cpg_list::cpg_sequence& cpg_list::
    cpg ()
    {
      return this->cpg_;
    }

    void cpg_list::
    cpg (const cpg_sequence& s)
    {
      this->cpg_ = s;
    }


    // cpg
    // 

    const cpg::name_type& cpg::
    name () const
    {
      return this->name_.get ();
    }

    cpg::name_type& cpg::
    name ()
    {
      return this->name_.get ();
    }

    void cpg::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void cpg::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const cpg::description_type& cpg::
    description () const
    {
      return this->description_.get ();
    }

    cpg::description_type& cpg::
    description ()
    {
      return this->description_.get ();
    }

    void cpg::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void cpg::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const cpg::citation_ref_type& cpg::
    citation_ref () const
    {
      return this->citation_ref_.get ();
    }

    cpg::citation_ref_type& cpg::
    citation_ref ()
    {
      return this->citation_ref_.get ();
    }

    void cpg::
    citation_ref (const citation_ref_type& x)
    {
      this->citation_ref_.set (x);
    }

    void cpg::
    citation_ref (::std::unique_ptr< citation_ref_type > x)
    {
      this->citation_ref_.set (std::move (x));
    }


    // learning_objective_reference_list
    // 

    const learning_objective_reference_list::objective_sequence& learning_objective_reference_list::
    objective () const
    {
      return this->objective_;
    }

    learning_objective_reference_list::objective_sequence& learning_objective_reference_list::
    objective ()
    {
      return this->objective_;
    }

    void learning_objective_reference_list::
    objective (const objective_sequence& s)
    {
      this->objective_ = s;
    }


    // treatment_plan_ref_list
    // 

    const treatment_plan_ref_list::treatment_plan_sequence& treatment_plan_ref_list::
    treatment_plan () const
    {
      return this->treatment_plan_;
    }

    treatment_plan_ref_list::treatment_plan_sequence& treatment_plan_ref_list::
    treatment_plan ()
    {
      return this->treatment_plan_;
    }

    void treatment_plan_ref_list::
    treatment_plan (const treatment_plan_sequence& s)
    {
      this->treatment_plan_ = s;
    }


    // injury_profile_list
    // 

    const injury_profile_list::injury_profile_sequence& injury_profile_list::
    injury_profile () const
    {
      return this->injury_profile_;
    }

    injury_profile_list::injury_profile_sequence& injury_profile_list::
    injury_profile ()
    {
      return this->injury_profile_;
    }

    void injury_profile_list::
    injury_profile (const injury_profile_sequence& s)
    {
      this->injury_profile_ = s;
    }


    // injury_profile
    // 

    const injury_profile::id_type& injury_profile::
    id () const
    {
      return this->id_.get ();
    }

    injury_profile::id_type& injury_profile::
    id ()
    {
      return this->id_.get ();
    }

    void injury_profile::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void injury_profile::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const injury_profile::name_type& injury_profile::
    name () const
    {
      return this->name_.get ();
    }

    injury_profile::name_type& injury_profile::
    name ()
    {
      return this->name_.get ();
    }

    void injury_profile::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void injury_profile::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const injury_profile::physiology_state_optional& injury_profile::
    physiology_state () const
    {
      return this->physiology_state_;
    }

    injury_profile::physiology_state_optional& injury_profile::
    physiology_state ()
    {
      return this->physiology_state_;
    }

    void injury_profile::
    physiology_state (const physiology_state_type& x)
    {
      this->physiology_state_.set (x);
    }

    void injury_profile::
    physiology_state (const physiology_state_optional& x)
    {
      this->physiology_state_ = x;
    }

    void injury_profile::
    physiology_state (::std::unique_ptr< physiology_state_type > x)
    {
      this->physiology_state_.set (std::move (x));
    }

    const injury_profile::injuries_sequence& injury_profile::
    injuries () const
    {
      return this->injuries_;
    }

    injury_profile::injuries_sequence& injury_profile::
    injuries ()
    {
      return this->injuries_;
    }

    void injury_profile::
    injuries (const injuries_sequence& s)
    {
      this->injuries_ = s;
    }

    const injury_profile::treatments_type& injury_profile::
    treatments () const
    {
      return this->treatments_.get ();
    }

    injury_profile::treatments_type& injury_profile::
    treatments ()
    {
      return this->treatments_.get ();
    }

    void injury_profile::
    treatments (const treatments_type& x)
    {
      this->treatments_.set (x);
    }

    void injury_profile::
    treatments (::std::unique_ptr< treatments_type > x)
    {
      this->treatments_.set (std::move (x));
    }


    // injury_profile_ref_list
    // 

    const injury_profile_ref_list::injury_profile_sequence& injury_profile_ref_list::
    injury_profile () const
    {
      return this->injury_profile_;
    }

    injury_profile_ref_list::injury_profile_sequence& injury_profile_ref_list::
    injury_profile ()
    {
      return this->injury_profile_;
    }

    void injury_profile_ref_list::
    injury_profile (const injury_profile_sequence& s)
    {
      this->injury_profile_ = s;
    }


    // injury_occurance_list
    // 

    const injury_occurance_list::id_type& injury_occurance_list::
    id () const
    {
      return this->id_.get ();
    }

    injury_occurance_list::id_type& injury_occurance_list::
    id ()
    {
      return this->id_.get ();
    }

    void injury_occurance_list::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void injury_occurance_list::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const injury_occurance_list::location_type& injury_occurance_list::
    location () const
    {
      return this->location_.get ();
    }

    injury_occurance_list::location_type& injury_occurance_list::
    location ()
    {
      return this->location_.get ();
    }

    void injury_occurance_list::
    location (const location_type& x)
    {
      this->location_.set (x);
    }

    void injury_occurance_list::
    location (::std::unique_ptr< location_type > x)
    {
      this->location_.set (std::move (x));
    }

    const injury_occurance_list::description_type& injury_occurance_list::
    description () const
    {
      return this->description_.get ();
    }

    injury_occurance_list::description_type& injury_occurance_list::
    description ()
    {
      return this->description_.get ();
    }

    void injury_occurance_list::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void injury_occurance_list::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const injury_occurance_list::severity_type& injury_occurance_list::
    severity () const
    {
      return this->severity_.get ();
    }

    injury_occurance_list::severity_type& injury_occurance_list::
    severity ()
    {
      return this->severity_.get ();
    }

    void injury_occurance_list::
    severity (const severity_type& x)
    {
      this->severity_.set (x);
    }

    void injury_occurance_list::
    severity (::std::unique_ptr< severity_type > x)
    {
      this->severity_.set (std::move (x));
    }


    // medical_scenario_syllabus
    // 

    const medical_scenario_syllabus::learning_objectives_type& medical_scenario_syllabus::
    learning_objectives () const
    {
      return this->learning_objectives_.get ();
    }

    medical_scenario_syllabus::learning_objectives_type& medical_scenario_syllabus::
    learning_objectives ()
    {
      return this->learning_objectives_.get ();
    }

    void medical_scenario_syllabus::
    learning_objectives (const learning_objectives_type& x)
    {
      this->learning_objectives_.set (x);
    }

    void medical_scenario_syllabus::
    learning_objectives (::std::unique_ptr< learning_objectives_type > x)
    {
      this->learning_objectives_.set (std::move (x));
    }

    const medical_scenario_syllabus::learning_assessments_type& medical_scenario_syllabus::
    learning_assessments () const
    {
      return this->learning_assessments_.get ();
    }

    medical_scenario_syllabus::learning_assessments_type& medical_scenario_syllabus::
    learning_assessments ()
    {
      return this->learning_assessments_.get ();
    }

    void medical_scenario_syllabus::
    learning_assessments (const learning_assessments_type& x)
    {
      this->learning_assessments_.set (x);
    }

    void medical_scenario_syllabus::
    learning_assessments (::std::unique_ptr< learning_assessments_type > x)
    {
      this->learning_assessments_.set (std::move (x));
    }


    // learning_objective_list
    // 

    const learning_objective_list::objective_sequence& learning_objective_list::
    objective () const
    {
      return this->objective_;
    }

    learning_objective_list::objective_sequence& learning_objective_list::
    objective ()
    {
      return this->objective_;
    }

    void learning_objective_list::
    objective (const objective_sequence& s)
    {
      this->objective_ = s;
    }


    // learning_objective
    // 

    const learning_objective::id_type& learning_objective::
    id () const
    {
      return this->id_.get ();
    }

    learning_objective::id_type& learning_objective::
    id ()
    {
      return this->id_.get ();
    }

    void learning_objective::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void learning_objective::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const learning_objective::name_type& learning_objective::
    name () const
    {
      return this->name_.get ();
    }

    learning_objective::name_type& learning_objective::
    name ()
    {
      return this->name_.get ();
    }

    void learning_objective::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void learning_objective::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const learning_objective::description_type& learning_objective::
    description () const
    {
      return this->description_.get ();
    }

    learning_objective::description_type& learning_objective::
    description ()
    {
      return this->description_.get ();
    }

    void learning_objective::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void learning_objective::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const learning_objective::references_type& learning_objective::
    references () const
    {
      return this->references_.get ();
    }

    learning_objective::references_type& learning_objective::
    references ()
    {
      return this->references_.get ();
    }

    void learning_objective::
    references (const references_type& x)
    {
      this->references_.set (x);
    }

    void learning_objective::
    references (::std::unique_ptr< references_type > x)
    {
      this->references_.set (std::move (x));
    }

    const learning_objective::relates_to_type& learning_objective::
    relates_to () const
    {
      return this->relates_to_.get ();
    }

    learning_objective::relates_to_type& learning_objective::
    relates_to ()
    {
      return this->relates_to_.get ();
    }

    void learning_objective::
    relates_to (const relates_to_type& x)
    {
      this->relates_to_.set (x);
    }

    void learning_objective::
    relates_to (::std::unique_ptr< relates_to_type > x)
    {
      this->relates_to_.set (std::move (x));
    }


    // assessment_list
    // 

    const assessment_list::total_points_type& assessment_list::
    total_points () const
    {
      return this->total_points_.get ();
    }

    assessment_list::total_points_type& assessment_list::
    total_points ()
    {
      return this->total_points_.get ();
    }

    void assessment_list::
    total_points (const total_points_type& x)
    {
      this->total_points_.set (x);
    }

    assessment_list::total_points_type assessment_list::
    total_points_default_value ()
    {
      return total_points_type (0LL);
    }

    const assessment_list::assessment_sequence& assessment_list::
    assessment () const
    {
      return this->assessment_;
    }

    assessment_list::assessment_sequence& assessment_list::
    assessment ()
    {
      return this->assessment_;
    }

    void assessment_list::
    assessment (const assessment_sequence& s)
    {
      this->assessment_ = s;
    }


    // assessment
    // 

    const assessment::id_type& assessment::
    id () const
    {
      return this->id_.get ();
    }

    assessment::id_type& assessment::
    id ()
    {
      return this->id_.get ();
    }

    void assessment::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void assessment::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const assessment::objective_id_type& assessment::
    objective_id () const
    {
      return this->objective_id_.get ();
    }

    assessment::objective_id_type& assessment::
    objective_id ()
    {
      return this->objective_id_.get ();
    }

    void assessment::
    objective_id (const objective_id_type& x)
    {
      this->objective_id_.set (x);
    }

    void assessment::
    objective_id (::std::unique_ptr< objective_id_type > x)
    {
      this->objective_id_.set (std::move (x));
    }

    const assessment::points_avaiable_type& assessment::
    points_avaiable () const
    {
      return this->points_avaiable_.get ();
    }

    assessment::points_avaiable_type& assessment::
    points_avaiable ()
    {
      return this->points_avaiable_.get ();
    }

    void assessment::
    points_avaiable (const points_avaiable_type& x)
    {
      this->points_avaiable_.set (x);
    }

    const assessment::criteria_type& assessment::
    criteria () const
    {
      return this->criteria_.get ();
    }

    assessment::criteria_type& assessment::
    criteria ()
    {
      return this->criteria_.get ();
    }

    void assessment::
    criteria (const criteria_type& x)
    {
      this->criteria_.set (x);
    }

    void assessment::
    criteria (::std::unique_ptr< criteria_type > x)
    {
      this->criteria_.set (std::move (x));
    }


    // medical_scenario
    // 

    const medical_scenario::id_type& medical_scenario::
    id () const
    {
      return this->id_.get ();
    }

    medical_scenario::id_type& medical_scenario::
    id ()
    {
      return this->id_.get ();
    }

    void medical_scenario::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void medical_scenario::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const medical_scenario::roles_type& medical_scenario::
    roles () const
    {
      return this->roles_.get ();
    }

    medical_scenario::roles_type& medical_scenario::
    roles ()
    {
      return this->roles_.get ();
    }

    void medical_scenario::
    roles (const roles_type& x)
    {
      this->roles_.set (x);
    }

    void medical_scenario::
    roles (::std::unique_ptr< roles_type > x)
    {
      this->roles_.set (std::move (x));
    }

    const medical_scenario::props_type& medical_scenario::
    props () const
    {
      return this->props_.get ();
    }

    medical_scenario::props_type& medical_scenario::
    props ()
    {
      return this->props_.get ();
    }

    void medical_scenario::
    props (const props_type& x)
    {
      this->props_.set (x);
    }

    void medical_scenario::
    props (::std::unique_ptr< props_type > x)
    {
      this->props_.set (std::move (x));
    }

    const medical_scenario::training_script_type& medical_scenario::
    training_script () const
    {
      return this->training_script_.get ();
    }

    medical_scenario::training_script_type& medical_scenario::
    training_script ()
    {
      return this->training_script_.get ();
    }

    void medical_scenario::
    training_script (const training_script_type& x)
    {
      this->training_script_.set (x);
    }

    void medical_scenario::
    training_script (::std::unique_ptr< training_script_type > x)
    {
      this->training_script_.set (std::move (x));
    }


    // role_list
    // 

    const role_list::role_sequence& role_list::
    role () const
    {
      return this->role_;
    }

    role_list::role_sequence& role_list::
    role ()
    {
      return this->role_;
    }

    void role_list::
    role (const role_sequence& s)
    {
      this->role_ = s;
    }


    // role
    // 

    const role::short_name_type& role::
    short_name () const
    {
      return this->short_name_.get ();
    }

    role::short_name_type& role::
    short_name ()
    {
      return this->short_name_.get ();
    }

    void role::
    short_name (const short_name_type& x)
    {
      this->short_name_.set (x);
    }

    void role::
    short_name (::std::unique_ptr< short_name_type > x)
    {
      this->short_name_.set (std::move (x));
    }

    const role::unit_id_type& role::
    unit_id () const
    {
      return this->unit_id_.get ();
    }

    role::unit_id_type& role::
    unit_id ()
    {
      return this->unit_id_.get ();
    }

    void role::
    unit_id (const unit_id_type& x)
    {
      this->unit_id_.set (x);
    }

    void role::
    unit_id (::std::unique_ptr< unit_id_type > x)
    {
      this->unit_id_.set (std::move (x));
    }

    const role::injury_profile_id_optional& role::
    injury_profile_id () const
    {
      return this->injury_profile_id_;
    }

    role::injury_profile_id_optional& role::
    injury_profile_id ()
    {
      return this->injury_profile_id_;
    }

    void role::
    injury_profile_id (const injury_profile_id_type& x)
    {
      this->injury_profile_id_.set (x);
    }

    void role::
    injury_profile_id (const injury_profile_id_optional& x)
    {
      this->injury_profile_id_ = x;
    }

    void role::
    injury_profile_id (::std::unique_ptr< injury_profile_id_type > x)
    {
      this->injury_profile_id_.set (std::move (x));
    }

    const role::description_type& role::
    description () const
    {
      return this->description_.get ();
    }

    role::description_type& role::
    description ()
    {
      return this->description_.get ();
    }

    void role::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void role::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }


    // prop_list
    // 

    const prop_list::prop_sequence& prop_list::
    prop () const
    {
      return this->prop_;
    }

    prop_list::prop_sequence& prop_list::
    prop ()
    {
      return this->prop_;
    }

    void prop_list::
    prop (const prop_sequence& s)
    {
      this->prop_ = s;
    }


    // prop
    // 

    const prop::short_name_type& prop::
    short_name () const
    {
      return this->short_name_.get ();
    }

    prop::short_name_type& prop::
    short_name ()
    {
      return this->short_name_.get ();
    }

    void prop::
    short_name (const short_name_type& x)
    {
      this->short_name_.set (x);
    }

    void prop::
    short_name (::std::unique_ptr< short_name_type > x)
    {
      this->short_name_.set (std::move (x));
    }

    const prop::equipment_id_type& prop::
    equipment_id () const
    {
      return this->equipment_id_.get ();
    }

    prop::equipment_id_type& prop::
    equipment_id ()
    {
      return this->equipment_id_.get ();
    }

    void prop::
    equipment_id (const equipment_id_type& x)
    {
      this->equipment_id_.set (x);
    }

    void prop::
    equipment_id (::std::unique_ptr< equipment_id_type > x)
    {
      this->equipment_id_.set (std::move (x));
    }

    const prop::description_type& prop::
    description () const
    {
      return this->description_.get ();
    }

    prop::description_type& prop::
    description ()
    {
      return this->description_.get ();
    }

    void prop::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void prop::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }


    // scene_list
    // 

    const scene_list::scene_sequence& scene_list::
    scene () const
    {
      return this->scene_;
    }

    scene_list::scene_sequence& scene_list::
    scene ()
    {
      return this->scene_;
    }

    void scene_list::
    scene (const scene_sequence& s)
    {
      this->scene_ = s;
    }


    // scene
    // 

    const scene::location_id_type& scene::
    location_id () const
    {
      return this->location_id_.get ();
    }

    scene::location_id_type& scene::
    location_id ()
    {
      return this->location_id_.get ();
    }

    void scene::
    location_id (const location_id_type& x)
    {
      this->location_id_.set (x);
    }

    void scene::
    location_id (::std::unique_ptr< location_id_type > x)
    {
      this->location_id_.set (std::move (x));
    }

    const scene::name_type& scene::
    name () const
    {
      return this->name_.get ();
    }

    scene::name_type& scene::
    name ()
    {
      return this->name_.get ();
    }

    void scene::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void scene::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const scene::description_type& scene::
    description () const
    {
      return this->description_.get ();
    }

    scene::description_type& scene::
    description ()
    {
      return this->description_.get ();
    }

    void scene::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void scene::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const scene::time_of_day_type& scene::
    time_of_day () const
    {
      return this->time_of_day_.get ();
    }

    scene::time_of_day_type& scene::
    time_of_day ()
    {
      return this->time_of_day_.get ();
    }

    void scene::
    time_of_day (const time_of_day_type& x)
    {
      this->time_of_day_.set (x);
    }

    void scene::
    time_of_day (::std::unique_ptr< time_of_day_type > x)
    {
      this->time_of_day_.set (std::move (x));
    }

    const scene::time_in_simulation_type& scene::
    time_in_simulation () const
    {
      return this->time_in_simulation_.get ();
    }

    scene::time_in_simulation_type& scene::
    time_in_simulation ()
    {
      return this->time_in_simulation_.get ();
    }

    void scene::
    time_in_simulation (const time_in_simulation_type& x)
    {
      this->time_in_simulation_.set (x);
    }

    const scene::events_type& scene::
    events () const
    {
      return this->events_.get ();
    }

    scene::events_type& scene::
    events ()
    {
      return this->events_.get ();
    }

    void scene::
    events (const events_type& x)
    {
      this->events_.set (x);
    }

    void scene::
    events (::std::unique_ptr< events_type > x)
    {
      this->events_.set (std::move (x));
    }


    // event_list
    // 

    const event_list::event_sequence& event_list::
    event () const
    {
      return this->event_;
    }

    event_list::event_sequence& event_list::
    event ()
    {
      return this->event_;
    }

    void event_list::
    event (const event_sequence& s)
    {
      this->event_ = s;
    }


    // event
    // 

    const event::category_type& event::
    category () const
    {
      return this->category_.get ();
    }

    event::category_type& event::
    category ()
    {
      return this->category_.get ();
    }

    void event::
    category (const category_type& x)
    {
      this->category_.set (x);
    }

    void event::
    category (::std::unique_ptr< category_type > x)
    {
      this->category_.set (std::move (x));
    }

    const event::fidelity_type& event::
    fidelity () const
    {
      return this->fidelity_.get ();
    }

    event::fidelity_type& event::
    fidelity ()
    {
      return this->fidelity_.get ();
    }

    void event::
    fidelity (const fidelity_type& x)
    {
      this->fidelity_.set (x);
    }

    void event::
    fidelity (::std::unique_ptr< fidelity_type > x)
    {
      this->fidelity_.set (std::move (x));
    }

    const event::details_type& event::
    details () const
    {
      return this->details_.get ();
    }

    event::details_type& event::
    details ()
    {
      return this->details_.get ();
    }

    void event::
    details (const details_type& x)
    {
      this->details_.set (x);
    }

    void event::
    details (::std::unique_ptr< details_type > x)
    {
      this->details_.set (std::move (x));
    }


    // event_category_enum
    // 

    event_category_enum::
    event_category_enum (value v)
    : ::xml_schema::string (_xsd_event_category_enum_literals_[v])
    {
    }

    event_category_enum::
    event_category_enum (const char* v)
    : ::xml_schema::string (v)
    {
    }

    event_category_enum::
    event_category_enum (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    event_category_enum::
    event_category_enum (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    event_category_enum::
    event_category_enum (const event_category_enum& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    event_category_enum& event_category_enum::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_event_category_enum_literals_[v]);

      return *this;
    }


    // event_fidelity_enum
    // 

    event_fidelity_enum::
    event_fidelity_enum (value v)
    : ::xml_schema::string (_xsd_event_fidelity_enum_literals_[v])
    {
    }

    event_fidelity_enum::
    event_fidelity_enum (const char* v)
    : ::xml_schema::string (v)
    {
    }

    event_fidelity_enum::
    event_fidelity_enum (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    event_fidelity_enum::
    event_fidelity_enum (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    event_fidelity_enum::
    event_fidelity_enum (const event_fidelity_enum& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    event_fidelity_enum& event_fidelity_enum::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_event_fidelity_enum_literals_[v]);

      return *this;
    }


    // citation_list
    // 

    const citation_list::citation_sequence& citation_list::
    citation () const
    {
      return this->citation_;
    }

    citation_list::citation_sequence& citation_list::
    citation ()
    {
      return this->citation_;
    }

    void citation_list::
    citation (const citation_sequence& s)
    {
      this->citation_ = s;
    }


    // citation
    // 

    const citation::uuid_type& citation::
    uuid () const
    {
      return this->uuid_.get ();
    }

    citation::uuid_type& citation::
    uuid ()
    {
      return this->uuid_.get ();
    }

    void citation::
    uuid (const uuid_type& x)
    {
      this->uuid_.set (x);
    }

    void citation::
    uuid (::std::unique_ptr< uuid_type > x)
    {
      this->uuid_.set (std::move (x));
    }

    const citation::authors_sequence& citation::
    authors () const
    {
      return this->authors_;
    }

    citation::authors_sequence& citation::
    authors ()
    {
      return this->authors_;
    }

    void citation::
    authors (const authors_sequence& s)
    {
      this->authors_ = s;
    }

    const citation::title_type& citation::
    title () const
    {
      return this->title_.get ();
    }

    citation::title_type& citation::
    title ()
    {
      return this->title_.get ();
    }

    void citation::
    title (const title_type& x)
    {
      this->title_.set (x);
    }

    void citation::
    title (::std::unique_ptr< title_type > x)
    {
      this->title_.set (std::move (x));
    }

    const citation::date_type& citation::
    date () const
    {
      return this->date_.get ();
    }

    citation::date_type& citation::
    date ()
    {
      return this->date_.get ();
    }

    void citation::
    date (const date_type& x)
    {
      this->date_.set (x);
    }

    void citation::
    date (::std::unique_ptr< date_type > x)
    {
      this->date_.set (std::move (x));
    }

    const citation::page_optional& citation::
    page () const
    {
      return this->page_;
    }

    citation::page_optional& citation::
    page ()
    {
      return this->page_;
    }

    void citation::
    page (const page_type& x)
    {
      this->page_.set (x);
    }

    void citation::
    page (const page_optional& x)
    {
      this->page_ = x;
    }

    void citation::
    page (::std::unique_ptr< page_type > x)
    {
      this->page_.set (std::move (x));
    }

    const citation::accessed_optional& citation::
    accessed () const
    {
      return this->accessed_;
    }

    citation::accessed_optional& citation::
    accessed ()
    {
      return this->accessed_;
    }

    void citation::
    accessed (const accessed_type& x)
    {
      this->accessed_.set (x);
    }

    void citation::
    accessed (const accessed_optional& x)
    {
      this->accessed_ = x;
    }

    void citation::
    accessed (::std::unique_ptr< accessed_type > x)
    {
      this->accessed_.set (std::move (x));
    }


    // properties_list
    // 

    const properties_list::property_sequence& properties_list::
    property () const
    {
      return this->property_;
    }

    properties_list::property_sequence& properties_list::
    property ()
    {
      return this->property_;
    }

    void properties_list::
    property (const property_sequence& s)
    {
      this->property_ = s;
    }


    // property
    // 

    const property::name_type& property::
    name () const
    {
      return this->name_.get ();
    }

    property::name_type& property::
    name ()
    {
      return this->name_.get ();
    }

    void property::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void property::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const property::type_type& property::
    type () const
    {
      return this->type_.get ();
    }

    property::type_type& property::
    type ()
    {
      return this->type_.get ();
    }

    void property::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void property::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }


    // relates_to
    // 

    const relates_to::treatment_plans_type& relates_to::
    treatment_plans () const
    {
      return this->treatment_plans_.get ();
    }

    relates_to::treatment_plans_type& relates_to::
    treatment_plans ()
    {
      return this->treatment_plans_.get ();
    }

    void relates_to::
    treatment_plans (const treatment_plans_type& x)
    {
      this->treatment_plans_.set (x);
    }

    void relates_to::
    treatment_plans (::std::unique_ptr< treatment_plans_type > x)
    {
      this->treatment_plans_.set (std::move (x));
    }

    const relates_to::injury_profiles_type& relates_to::
    injury_profiles () const
    {
      return this->injury_profiles_.get ();
    }

    relates_to::injury_profiles_type& relates_to::
    injury_profiles ()
    {
      return this->injury_profiles_.get ();
    }

    void relates_to::
    injury_profiles (const injury_profiles_type& x)
    {
      this->injury_profiles_.set (x);
    }

    void relates_to::
    injury_profiles (::std::unique_ptr< injury_profiles_type > x)
    {
      this->injury_profiles_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace pfc
{
  namespace schema
  {
    // equipment_definition_list
    //

    equipment_definition_list::
    equipment_definition_list ()
    : ::xml_schema::type (),
      equipment_ (this)
    {
    }

    equipment_definition_list::
    equipment_definition_list (const equipment_definition_list& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      equipment_ (x.equipment_, f, this)
    {
    }

    equipment_definition_list::
    equipment_definition_list (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      equipment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void equipment_definition_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // equipment
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "equipment",
              "",
              &::xsd::cxx::tree::factory_impl< equipment_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< equipment_type > r (
              dynamic_cast< equipment_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->equipment_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    equipment_definition_list* equipment_definition_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class equipment_definition_list (*this, f, c);
    }

    equipment_definition_list& equipment_definition_list::
    operator= (const equipment_definition_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->equipment_ = x.equipment_;
      }

      return *this;
    }

    equipment_definition_list::
    ~equipment_definition_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, equipment_definition_list >
    _xsd_equipment_definition_list_type_factory_init (
      "equipment-definition-list",
      "com:ara:pfc:training:1");

    // equipment
    //

    equipment::
    equipment (const id_type& id,
               const name_type& name,
               const description_type& description,
               const citations_type& citations,
               const properties_type& properties)
    : ::xml_schema::type (),
      id_ (id, this),
      name_ (name, this),
      type_ (this),
      description_ (description, this),
      citations_ (citations, this),
      image_ (this),
      properties_ (properties, this)
    {
    }

    equipment::
    equipment (const id_type& id,
               const name_type& name,
               const description_type& description,
               ::std::unique_ptr< citations_type > citations,
               ::std::unique_ptr< properties_type > properties)
    : ::xml_schema::type (),
      id_ (id, this),
      name_ (name, this),
      type_ (this),
      description_ (description, this),
      citations_ (std::move (citations), this),
      image_ (this),
      properties_ (std::move (properties), this)
    {
    }

    equipment::
    equipment (::std::unique_ptr< id_type > id,
               ::std::unique_ptr< name_type > name,
               ::std::unique_ptr< description_type > description,
               ::std::unique_ptr< citations_type > citations,
               ::std::unique_ptr< properties_type > properties)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      name_ (std::move (name), this),
      type_ (this),
      description_ (std::move (description), this),
      citations_ (std::move (citations), this),
      image_ (this),
      properties_ (std::move (properties), this)
    {
    }

    equipment::
    equipment (const equipment& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this),
      description_ (x.description_, f, this),
      citations_ (x.citations_, f, this),
      image_ (x.image_, f, this),
      properties_ (x.properties_, f, this)
    {
    }

    equipment::
    equipment (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      name_ (this),
      type_ (this),
      description_ (this),
      citations_ (this),
      image_ (this),
      properties_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void equipment::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // type
        //
        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          if (!this->type_)
          {
            this->type_.set (type_traits::create (i, f, this));
            continue;
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // citations
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "citations",
              "",
              &::xsd::cxx::tree::factory_impl< citations_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!citations_.present ())
            {
              ::std::unique_ptr< citations_type > r (
                dynamic_cast< citations_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->citations_.set (::std::move (r));
              continue;
            }
          }
        }

        // image
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "image",
              "",
              &::xsd::cxx::tree::factory_impl< image_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->image_)
            {
              ::std::unique_ptr< image_type > r (
                dynamic_cast< image_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->image_.set (::std::move (r));
              continue;
            }
          }
        }

        // properties
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "properties",
              "",
              &::xsd::cxx::tree::factory_impl< properties_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!properties_.present ())
            {
              ::std::unique_ptr< properties_type > r (
                dynamic_cast< properties_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->properties_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!citations_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "citations",
          "");
      }

      if (!properties_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "properties",
          "");
      }
    }

    equipment* equipment::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class equipment (*this, f, c);
    }

    equipment& equipment::
    operator= (const equipment& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->name_ = x.name_;
        this->type_ = x.type_;
        this->description_ = x.description_;
        this->citations_ = x.citations_;
        this->image_ = x.image_;
        this->properties_ = x.properties_;
      }

      return *this;
    }

    equipment::
    ~equipment ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, equipment >
    _xsd_equipment_type_factory_init (
      "equipment",
      "com:ara:pfc:training:1");

    // injury_definition_list
    //

    injury_definition_list::
    injury_definition_list ()
    : ::xml_schema::type (),
      injury_ (this)
    {
    }

    injury_definition_list::
    injury_definition_list (const injury_definition_list& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      injury_ (x.injury_, f, this)
    {
    }

    injury_definition_list::
    injury_definition_list (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      injury_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void injury_definition_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // injury
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "injury",
              "",
              &::xsd::cxx::tree::factory_impl< injury_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< injury_type > r (
              dynamic_cast< injury_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->injury_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    injury_definition_list* injury_definition_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class injury_definition_list (*this, f, c);
    }

    injury_definition_list& injury_definition_list::
    operator= (const injury_definition_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->injury_ = x.injury_;
      }

      return *this;
    }

    injury_definition_list::
    ~injury_definition_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, injury_definition_list >
    _xsd_injury_definition_list_type_factory_init (
      "injury-definition-list",
      "com:ara:pfc:training:1");

    // injury
    //

    injury::
    injury (const id_type& id,
            const medical_name_type& medical_name,
            const citations_type& citations,
            const description_type& description,
            const severity_range_type& severity_range)
    : ::xml_schema::type (),
      id_ (id, this),
      common_name_ (this),
      medical_name_ (medical_name, this),
      citations_ (citations, this),
      description_ (description, this),
      severity_range_ (severity_range, this)
    {
    }

    injury::
    injury (const id_type& id,
            const medical_name_type& medical_name,
            ::std::unique_ptr< citations_type > citations,
            const description_type& description,
            ::std::unique_ptr< severity_range_type > severity_range)
    : ::xml_schema::type (),
      id_ (id, this),
      common_name_ (this),
      medical_name_ (medical_name, this),
      citations_ (std::move (citations), this),
      description_ (description, this),
      severity_range_ (std::move (severity_range), this)
    {
    }

    injury::
    injury (::std::unique_ptr< id_type > id,
            ::std::unique_ptr< medical_name_type > medical_name,
            ::std::unique_ptr< citations_type > citations,
            ::std::unique_ptr< description_type > description,
            ::std::unique_ptr< severity_range_type > severity_range)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      common_name_ (this),
      medical_name_ (std::move (medical_name), this),
      citations_ (std::move (citations), this),
      description_ (std::move (description), this),
      severity_range_ (std::move (severity_range), this)
    {
    }

    injury::
    injury (const injury& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      common_name_ (x.common_name_, f, this),
      medical_name_ (x.medical_name_, f, this),
      citations_ (x.citations_, f, this),
      description_ (x.description_, f, this),
      severity_range_ (x.severity_range_, f, this)
    {
    }

    injury::
    injury (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      common_name_ (this),
      medical_name_ (this),
      citations_ (this),
      description_ (this),
      severity_range_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void injury::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // common-name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "common-name",
              "",
              &::xsd::cxx::tree::factory_impl< common_name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->common_name_)
            {
              ::std::unique_ptr< common_name_type > r (
                dynamic_cast< common_name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->common_name_.set (::std::move (r));
              continue;
            }
          }
        }

        // medical-name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "medical-name",
              "",
              &::xsd::cxx::tree::factory_impl< medical_name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!medical_name_.present ())
            {
              ::std::unique_ptr< medical_name_type > r (
                dynamic_cast< medical_name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->medical_name_.set (::std::move (r));
              continue;
            }
          }
        }

        // citations
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "citations",
              "",
              &::xsd::cxx::tree::factory_impl< citations_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!citations_.present ())
            {
              ::std::unique_ptr< citations_type > r (
                dynamic_cast< citations_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->citations_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // severity-range
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "severity-range",
              "",
              &::xsd::cxx::tree::factory_impl< severity_range_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!severity_range_.present ())
            {
              ::std::unique_ptr< severity_range_type > r (
                dynamic_cast< severity_range_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->severity_range_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!medical_name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "medical-name",
          "");
      }

      if (!citations_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "citations",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!severity_range_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "severity-range",
          "");
      }
    }

    injury* injury::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class injury (*this, f, c);
    }

    injury& injury::
    operator= (const injury& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->common_name_ = x.common_name_;
        this->medical_name_ = x.medical_name_;
        this->citations_ = x.citations_;
        this->description_ = x.description_;
        this->severity_range_ = x.severity_range_;
      }

      return *this;
    }

    injury::
    ~injury ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, injury >
    _xsd_injury_type_factory_init (
      "injury",
      "com:ara:pfc:training:1");

    // injury_severity_range
    //

    injury_severity_range::
    injury_severity_range ()
    : ::xml_schema::type (),
      numeric_range_ (this),
      token_range_ (this)
    {
    }

    injury_severity_range::
    injury_severity_range (const injury_severity_range& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      numeric_range_ (x.numeric_range_, f, this),
      token_range_ (x.token_range_, f, this)
    {
    }

    injury_severity_range::
    injury_severity_range (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      numeric_range_ (this),
      token_range_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void injury_severity_range::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // numeric-range
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "numeric-range",
              "",
              &::xsd::cxx::tree::factory_impl< numeric_range_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->numeric_range_)
            {
              ::std::unique_ptr< numeric_range_type > r (
                dynamic_cast< numeric_range_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->numeric_range_.set (::std::move (r));
              continue;
            }
          }
        }

        // token-range
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "token-range",
              "",
              &::xsd::cxx::tree::factory_impl< token_range_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->token_range_)
            {
              ::std::unique_ptr< token_range_type > r (
                dynamic_cast< token_range_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->token_range_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    injury_severity_range* injury_severity_range::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class injury_severity_range (*this, f, c);
    }

    injury_severity_range& injury_severity_range::
    operator= (const injury_severity_range& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->numeric_range_ = x.numeric_range_;
        this->token_range_ = x.token_range_;
      }

      return *this;
    }

    injury_severity_range::
    ~injury_severity_range ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, injury_severity_range >
    _xsd_injury_severity_range_type_factory_init (
      "injury-severity-range",
      "com:ara:pfc:training:1");

    // numeric_range
    //

    numeric_range::
    numeric_range (const min_type& min,
                   const max_type& max)
    : ::xml_schema::type (),
      min_ (min, this),
      max_ (max, this),
      median_ (this),
      unit_ (this)
    {
    }

    numeric_range::
    numeric_range (const numeric_range& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      min_ (x.min_, f, this),
      max_ (x.max_, f, this),
      median_ (x.median_, f, this),
      unit_ (x.unit_, f, this)
    {
    }

    numeric_range::
    numeric_range (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      min_ (this),
      max_ (this),
      median_ (this),
      unit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void numeric_range::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // min
        //
        if (n.name () == "min" && n.namespace_ ().empty ())
        {
          if (!min_.present ())
          {
            this->min_.set (min_traits::create (i, f, this));
            continue;
          }
        }

        // max
        //
        if (n.name () == "max" && n.namespace_ ().empty ())
        {
          if (!max_.present ())
          {
            this->max_.set (max_traits::create (i, f, this));
            continue;
          }
        }

        // median
        //
        if (n.name () == "median" && n.namespace_ ().empty ())
        {
          if (!this->median_)
          {
            this->median_.set (median_traits::create (i, f, this));
            continue;
          }
        }

        // unit
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "unit",
              "",
              &::xsd::cxx::tree::factory_impl< unit_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->unit_)
            {
              ::std::unique_ptr< unit_type > r (
                dynamic_cast< unit_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->unit_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!min_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "min",
          "");
      }

      if (!max_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "max",
          "");
      }
    }

    numeric_range* numeric_range::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class numeric_range (*this, f, c);
    }

    numeric_range& numeric_range::
    operator= (const numeric_range& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->min_ = x.min_;
        this->max_ = x.max_;
        this->median_ = x.median_;
        this->unit_ = x.unit_;
      }

      return *this;
    }

    numeric_range::
    ~numeric_range ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, numeric_range >
    _xsd_numeric_range_type_factory_init (
      "numeric-range",
      "com:ara:pfc:training:1");

    // token_range
    //

    token_range::
    token_range ()
    : ::xml_schema::type (),
      token_ (this)
    {
    }

    token_range::
    token_range (const token_range& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      token_ (x.token_, f, this)
    {
    }

    token_range::
    token_range (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      token_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void token_range::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // token
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "token",
              "",
              &::xsd::cxx::tree::factory_impl< token_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< token_type > r (
              dynamic_cast< token_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->token_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    token_range* token_range::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class token_range (*this, f, c);
    }

    token_range& token_range::
    operator= (const token_range& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->token_ = x.token_;
      }

      return *this;
    }

    token_range::
    ~token_range ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, token_range >
    _xsd_token_range_type_factory_init (
      "token-range",
      "com:ara:pfc:training:1");

    // citation_ref_list
    //

    citation_ref_list::
    citation_ref_list ()
    : ::xml_schema::type (),
      citation_ref_ (this)
    {
    }

    citation_ref_list::
    citation_ref_list (const citation_ref_list& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      citation_ref_ (x.citation_ref_, f, this)
    {
    }

    citation_ref_list::
    citation_ref_list (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      citation_ref_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void citation_ref_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // citation-ref
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "citation-ref",
              "",
              &::xsd::cxx::tree::factory_impl< citation_ref_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< citation_ref_type > r (
              dynamic_cast< citation_ref_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->citation_ref_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    citation_ref_list* citation_ref_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class citation_ref_list (*this, f, c);
    }

    citation_ref_list& citation_ref_list::
    operator= (const citation_ref_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->citation_ref_ = x.citation_ref_;
      }

      return *this;
    }

    citation_ref_list::
    ~citation_ref_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, citation_ref_list >
    _xsd_citation_ref_list_type_factory_init (
      "citation-ref-list",
      "com:ara:pfc:training:1");

    // treatment_plan_definition_list
    //

    treatment_plan_definition_list::
    treatment_plan_definition_list ()
    : ::xml_schema::type (),
      treatment_plan_ (this)
    {
    }

    treatment_plan_definition_list::
    treatment_plan_definition_list (const treatment_plan_definition_list& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      treatment_plan_ (x.treatment_plan_, f, this)
    {
    }

    treatment_plan_definition_list::
    treatment_plan_definition_list (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      treatment_plan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void treatment_plan_definition_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // treatment-plan
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "treatment-plan",
              "",
              &::xsd::cxx::tree::factory_impl< treatment_plan_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< treatment_plan_type > r (
              dynamic_cast< treatment_plan_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->treatment_plan_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    treatment_plan_definition_list* treatment_plan_definition_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class treatment_plan_definition_list (*this, f, c);
    }

    treatment_plan_definition_list& treatment_plan_definition_list::
    operator= (const treatment_plan_definition_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->treatment_plan_ = x.treatment_plan_;
      }

      return *this;
    }

    treatment_plan_definition_list::
    ~treatment_plan_definition_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, treatment_plan_definition_list >
    _xsd_treatment_plan_definition_list_type_factory_init (
      "treatment-plan-definition-list",
      "com:ara:pfc:training:1");

    // treatment_plan
    //

    treatment_plan::
    treatment_plan (const id_type& id,
                    const description_type& description,
                    const required_equipment_type& required_equipment,
                    const references_type& references)
    : ::xml_schema::type (),
      id_ (id, this),
      common_name_ (this),
      description_ (description, this),
      required_equipment_ (required_equipment, this),
      references_ (references, this)
    {
    }

    treatment_plan::
    treatment_plan (const id_type& id,
                    const description_type& description,
                    ::std::unique_ptr< required_equipment_type > required_equipment,
                    ::std::unique_ptr< references_type > references)
    : ::xml_schema::type (),
      id_ (id, this),
      common_name_ (this),
      description_ (description, this),
      required_equipment_ (std::move (required_equipment), this),
      references_ (std::move (references), this)
    {
    }

    treatment_plan::
    treatment_plan (::std::unique_ptr< id_type > id,
                    ::std::unique_ptr< description_type > description,
                    ::std::unique_ptr< required_equipment_type > required_equipment,
                    ::std::unique_ptr< references_type > references)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      common_name_ (this),
      description_ (std::move (description), this),
      required_equipment_ (std::move (required_equipment), this),
      references_ (std::move (references), this)
    {
    }

    treatment_plan::
    treatment_plan (const treatment_plan& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      common_name_ (x.common_name_, f, this),
      description_ (x.description_, f, this),
      required_equipment_ (x.required_equipment_, f, this),
      references_ (x.references_, f, this)
    {
    }

    treatment_plan::
    treatment_plan (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      common_name_ (this),
      description_ (this),
      required_equipment_ (this),
      references_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void treatment_plan::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // common-name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "common-name",
              "",
              &::xsd::cxx::tree::factory_impl< common_name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->common_name_)
            {
              ::std::unique_ptr< common_name_type > r (
                dynamic_cast< common_name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->common_name_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // required-equipment
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "required-equipment",
              "",
              &::xsd::cxx::tree::factory_impl< required_equipment_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!required_equipment_.present ())
            {
              ::std::unique_ptr< required_equipment_type > r (
                dynamic_cast< required_equipment_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->required_equipment_.set (::std::move (r));
              continue;
            }
          }
        }

        // references
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "references",
              "",
              &::xsd::cxx::tree::factory_impl< references_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!references_.present ())
            {
              ::std::unique_ptr< references_type > r (
                dynamic_cast< references_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->references_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!required_equipment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "required-equipment",
          "");
      }

      if (!references_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "references",
          "");
      }
    }

    treatment_plan* treatment_plan::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class treatment_plan (*this, f, c);
    }

    treatment_plan& treatment_plan::
    operator= (const treatment_plan& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->common_name_ = x.common_name_;
        this->description_ = x.description_;
        this->required_equipment_ = x.required_equipment_;
        this->references_ = x.references_;
      }

      return *this;
    }

    treatment_plan::
    ~treatment_plan ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, treatment_plan >
    _xsd_treatment_plan_type_factory_init (
      "treatment-plan",
      "com:ara:pfc:training:1");

    // equipment_ref_list
    //

    equipment_ref_list::
    equipment_ref_list ()
    : ::xml_schema::type (),
      equipment_refs_ (this)
    {
    }

    equipment_ref_list::
    equipment_ref_list (const equipment_ref_list& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      equipment_refs_ (x.equipment_refs_, f, this)
    {
    }

    equipment_ref_list::
    equipment_ref_list (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      equipment_refs_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void equipment_ref_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // equipment-refs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "equipment-refs",
              "",
              &::xsd::cxx::tree::factory_impl< equipment_refs_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< equipment_refs_type > r (
              dynamic_cast< equipment_refs_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->equipment_refs_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    equipment_ref_list* equipment_ref_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class equipment_ref_list (*this, f, c);
    }

    equipment_ref_list& equipment_ref_list::
    operator= (const equipment_ref_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->equipment_refs_ = x.equipment_refs_;
      }

      return *this;
    }

    equipment_ref_list::
    ~equipment_ref_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, equipment_ref_list >
    _xsd_equipment_ref_list_type_factory_init (
      "equipment-ref-list",
      "com:ara:pfc:training:1");

    // medical_reference_list
    //

    medical_reference_list::
    medical_reference_list (const citations_type& citations,
                            const cpgs_type& cpgs)
    : ::xml_schema::type (),
      citations_ (citations, this),
      cpgs_ (cpgs, this)
    {
    }

    medical_reference_list::
    medical_reference_list (::std::unique_ptr< citations_type > citations,
                            ::std::unique_ptr< cpgs_type > cpgs)
    : ::xml_schema::type (),
      citations_ (std::move (citations), this),
      cpgs_ (std::move (cpgs), this)
    {
    }

    medical_reference_list::
    medical_reference_list (const medical_reference_list& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      citations_ (x.citations_, f, this),
      cpgs_ (x.cpgs_, f, this)
    {
    }

    medical_reference_list::
    medical_reference_list (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      citations_ (this),
      cpgs_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void medical_reference_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // citations
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "citations",
              "",
              &::xsd::cxx::tree::factory_impl< citations_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!citations_.present ())
            {
              ::std::unique_ptr< citations_type > r (
                dynamic_cast< citations_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->citations_.set (::std::move (r));
              continue;
            }
          }
        }

        // cpgs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "cpgs",
              "",
              &::xsd::cxx::tree::factory_impl< cpgs_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!cpgs_.present ())
            {
              ::std::unique_ptr< cpgs_type > r (
                dynamic_cast< cpgs_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->cpgs_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!citations_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "citations",
          "");
      }

      if (!cpgs_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "cpgs",
          "");
      }
    }

    medical_reference_list* medical_reference_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class medical_reference_list (*this, f, c);
    }

    medical_reference_list& medical_reference_list::
    operator= (const medical_reference_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->citations_ = x.citations_;
        this->cpgs_ = x.cpgs_;
      }

      return *this;
    }

    medical_reference_list::
    ~medical_reference_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, medical_reference_list >
    _xsd_medical_reference_list_type_factory_init (
      "medical-reference-list",
      "com:ara:pfc:training:1");

    // cpg_ref_list
    //

    cpg_ref_list::
    cpg_ref_list ()
    : ::xml_schema::type (),
      cpg_ref_ (this)
    {
    }

    cpg_ref_list::
    cpg_ref_list (const cpg_ref_list& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      cpg_ref_ (x.cpg_ref_, f, this)
    {
    }

    cpg_ref_list::
    cpg_ref_list (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      cpg_ref_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void cpg_ref_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // cpg-ref
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "cpg-ref",
              "",
              &::xsd::cxx::tree::factory_impl< cpg_ref_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< cpg_ref_type > r (
              dynamic_cast< cpg_ref_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->cpg_ref_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    cpg_ref_list* cpg_ref_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class cpg_ref_list (*this, f, c);
    }

    cpg_ref_list& cpg_ref_list::
    operator= (const cpg_ref_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->cpg_ref_ = x.cpg_ref_;
      }

      return *this;
    }

    cpg_ref_list::
    ~cpg_ref_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, cpg_ref_list >
    _xsd_cpg_ref_list_type_factory_init (
      "cpg-ref-list",
      "com:ara:pfc:training:1");

    // cpg_list
    //

    cpg_list::
    cpg_list ()
    : ::xml_schema::type (),
      cpg_ (this)
    {
    }

    cpg_list::
    cpg_list (const cpg_list& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      cpg_ (x.cpg_, f, this)
    {
    }

    cpg_list::
    cpg_list (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      cpg_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void cpg_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // cpg
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "cpg",
              "",
              &::xsd::cxx::tree::factory_impl< cpg_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< cpg_type > r (
              dynamic_cast< cpg_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->cpg_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    cpg_list* cpg_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class cpg_list (*this, f, c);
    }

    cpg_list& cpg_list::
    operator= (const cpg_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->cpg_ = x.cpg_;
      }

      return *this;
    }

    cpg_list::
    ~cpg_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, cpg_list >
    _xsd_cpg_list_type_factory_init (
      "cpg-list",
      "com:ara:pfc:training:1");

    // cpg
    //

    cpg::
    cpg (const name_type& name,
         const description_type& description,
         const citation_ref_type& citation_ref)
    : ::xml_schema::type (),
      name_ (name, this),
      description_ (description, this),
      citation_ref_ (citation_ref, this)
    {
    }

    cpg::
    cpg (::std::unique_ptr< name_type > name,
         ::std::unique_ptr< description_type > description,
         ::std::unique_ptr< citation_ref_type > citation_ref)
    : ::xml_schema::type (),
      name_ (std::move (name), this),
      description_ (std::move (description), this),
      citation_ref_ (std::move (citation_ref), this)
    {
    }

    cpg::
    cpg (const cpg& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      description_ (x.description_, f, this),
      citation_ref_ (x.citation_ref_, f, this)
    {
    }

    cpg::
    cpg (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      description_ (this),
      citation_ref_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void cpg::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // citation-ref
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "citation-ref",
              "",
              &::xsd::cxx::tree::factory_impl< citation_ref_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!citation_ref_.present ())
            {
              ::std::unique_ptr< citation_ref_type > r (
                dynamic_cast< citation_ref_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->citation_ref_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!citation_ref_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "citation-ref",
          "");
      }
    }

    cpg* cpg::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class cpg (*this, f, c);
    }

    cpg& cpg::
    operator= (const cpg& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->description_ = x.description_;
        this->citation_ref_ = x.citation_ref_;
      }

      return *this;
    }

    cpg::
    ~cpg ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, cpg >
    _xsd_cpg_type_factory_init (
      "cpg",
      "com:ara:pfc:training:1");

    // learning_objective_reference_list
    //

    learning_objective_reference_list::
    learning_objective_reference_list ()
    : ::xml_schema::type (),
      objective_ (this)
    {
    }

    learning_objective_reference_list::
    learning_objective_reference_list (const learning_objective_reference_list& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      objective_ (x.objective_, f, this)
    {
    }

    learning_objective_reference_list::
    learning_objective_reference_list (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      objective_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void learning_objective_reference_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // objective
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "objective",
              "",
              &::xsd::cxx::tree::factory_impl< objective_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< objective_type > r (
              dynamic_cast< objective_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->objective_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    learning_objective_reference_list* learning_objective_reference_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class learning_objective_reference_list (*this, f, c);
    }

    learning_objective_reference_list& learning_objective_reference_list::
    operator= (const learning_objective_reference_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->objective_ = x.objective_;
      }

      return *this;
    }

    learning_objective_reference_list::
    ~learning_objective_reference_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, learning_objective_reference_list >
    _xsd_learning_objective_reference_list_type_factory_init (
      "learning-objective-reference-list",
      "com:ara:pfc:training:1");

    // treatment_plan_ref_list
    //

    treatment_plan_ref_list::
    treatment_plan_ref_list ()
    : ::xml_schema::type (),
      treatment_plan_ (this)
    {
    }

    treatment_plan_ref_list::
    treatment_plan_ref_list (const treatment_plan_ref_list& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      treatment_plan_ (x.treatment_plan_, f, this)
    {
    }

    treatment_plan_ref_list::
    treatment_plan_ref_list (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      treatment_plan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void treatment_plan_ref_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // treatment-plan
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "treatment-plan",
              "",
              &::xsd::cxx::tree::factory_impl< treatment_plan_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< treatment_plan_type > r (
              dynamic_cast< treatment_plan_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->treatment_plan_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    treatment_plan_ref_list* treatment_plan_ref_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class treatment_plan_ref_list (*this, f, c);
    }

    treatment_plan_ref_list& treatment_plan_ref_list::
    operator= (const treatment_plan_ref_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->treatment_plan_ = x.treatment_plan_;
      }

      return *this;
    }

    treatment_plan_ref_list::
    ~treatment_plan_ref_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, treatment_plan_ref_list >
    _xsd_treatment_plan_ref_list_type_factory_init (
      "treatment-plan-ref-list",
      "com:ara:pfc:training:1");

    // injury_profile_list
    //

    injury_profile_list::
    injury_profile_list ()
    : ::xml_schema::type (),
      injury_profile_ (this)
    {
    }

    injury_profile_list::
    injury_profile_list (const injury_profile_list& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      injury_profile_ (x.injury_profile_, f, this)
    {
    }

    injury_profile_list::
    injury_profile_list (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      injury_profile_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void injury_profile_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // injury-profile
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "injury-profile",
              "",
              &::xsd::cxx::tree::factory_impl< injury_profile_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< injury_profile_type > r (
              dynamic_cast< injury_profile_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->injury_profile_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    injury_profile_list* injury_profile_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class injury_profile_list (*this, f, c);
    }

    injury_profile_list& injury_profile_list::
    operator= (const injury_profile_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->injury_profile_ = x.injury_profile_;
      }

      return *this;
    }

    injury_profile_list::
    ~injury_profile_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, injury_profile_list >
    _xsd_injury_profile_list_type_factory_init (
      "injury-profile-list",
      "com:ara:pfc:training:1");

    // injury_profile
    //

    injury_profile::
    injury_profile (const id_type& id,
                    const name_type& name,
                    const treatments_type& treatments)
    : ::xml_schema::type (),
      id_ (id, this),
      name_ (name, this),
      physiology_state_ (this),
      injuries_ (this),
      treatments_ (treatments, this)
    {
    }

    injury_profile::
    injury_profile (const id_type& id,
                    const name_type& name,
                    ::std::unique_ptr< treatments_type > treatments)
    : ::xml_schema::type (),
      id_ (id, this),
      name_ (name, this),
      physiology_state_ (this),
      injuries_ (this),
      treatments_ (std::move (treatments), this)
    {
    }

    injury_profile::
    injury_profile (::std::unique_ptr< id_type > id,
                    ::std::unique_ptr< name_type > name,
                    ::std::unique_ptr< treatments_type > treatments)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      name_ (std::move (name), this),
      physiology_state_ (this),
      injuries_ (this),
      treatments_ (std::move (treatments), this)
    {
    }

    injury_profile::
    injury_profile (const injury_profile& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      name_ (x.name_, f, this),
      physiology_state_ (x.physiology_state_, f, this),
      injuries_ (x.injuries_, f, this),
      treatments_ (x.treatments_, f, this)
    {
    }

    injury_profile::
    injury_profile (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      name_ (this),
      physiology_state_ (this),
      injuries_ (this),
      treatments_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void injury_profile::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // physiology-state
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "physiology-state",
              "",
              &::xsd::cxx::tree::factory_impl< physiology_state_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->physiology_state_)
            {
              ::std::unique_ptr< physiology_state_type > r (
                dynamic_cast< physiology_state_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->physiology_state_.set (::std::move (r));
              continue;
            }
          }
        }

        // injuries
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "injuries",
              "",
              &::xsd::cxx::tree::factory_impl< injuries_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< injuries_type > r (
              dynamic_cast< injuries_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->injuries_.push_back (::std::move (r));
            continue;
          }
        }

        // treatments
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "treatments",
              "",
              &::xsd::cxx::tree::factory_impl< treatments_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!treatments_.present ())
            {
              ::std::unique_ptr< treatments_type > r (
                dynamic_cast< treatments_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->treatments_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!treatments_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "treatments",
          "");
      }
    }

    injury_profile* injury_profile::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class injury_profile (*this, f, c);
    }

    injury_profile& injury_profile::
    operator= (const injury_profile& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->name_ = x.name_;
        this->physiology_state_ = x.physiology_state_;
        this->injuries_ = x.injuries_;
        this->treatments_ = x.treatments_;
      }

      return *this;
    }

    injury_profile::
    ~injury_profile ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, injury_profile >
    _xsd_injury_profile_type_factory_init (
      "injury-profile",
      "com:ara:pfc:training:1");

    // injury_profile_ref_list
    //

    injury_profile_ref_list::
    injury_profile_ref_list ()
    : ::xml_schema::type (),
      injury_profile_ (this)
    {
    }

    injury_profile_ref_list::
    injury_profile_ref_list (const injury_profile_ref_list& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      injury_profile_ (x.injury_profile_, f, this)
    {
    }

    injury_profile_ref_list::
    injury_profile_ref_list (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      injury_profile_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void injury_profile_ref_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // injury-profile
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "injury-profile",
              "",
              &::xsd::cxx::tree::factory_impl< injury_profile_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< injury_profile_type > r (
              dynamic_cast< injury_profile_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->injury_profile_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    injury_profile_ref_list* injury_profile_ref_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class injury_profile_ref_list (*this, f, c);
    }

    injury_profile_ref_list& injury_profile_ref_list::
    operator= (const injury_profile_ref_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->injury_profile_ = x.injury_profile_;
      }

      return *this;
    }

    injury_profile_ref_list::
    ~injury_profile_ref_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, injury_profile_ref_list >
    _xsd_injury_profile_ref_list_type_factory_init (
      "injury-profile-ref-list",
      "com:ara:pfc:training:1");

    // injury_occurance_list
    //

    injury_occurance_list::
    injury_occurance_list (const id_type& id,
                           const location_type& location,
                           const description_type& description,
                           const severity_type& severity)
    : ::xml_schema::type (),
      id_ (id, this),
      location_ (location, this),
      description_ (description, this),
      severity_ (severity, this)
    {
    }

    injury_occurance_list::
    injury_occurance_list (::std::unique_ptr< id_type > id,
                           ::std::unique_ptr< location_type > location,
                           ::std::unique_ptr< description_type > description,
                           ::std::unique_ptr< severity_type > severity)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      location_ (std::move (location), this),
      description_ (std::move (description), this),
      severity_ (std::move (severity), this)
    {
    }

    injury_occurance_list::
    injury_occurance_list (const injury_occurance_list& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      location_ (x.location_, f, this),
      description_ (x.description_, f, this),
      severity_ (x.severity_, f, this)
    {
    }

    injury_occurance_list::
    injury_occurance_list (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      location_ (this),
      description_ (this),
      severity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void injury_occurance_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // location
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "location",
              "",
              &::xsd::cxx::tree::factory_impl< location_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!location_.present ())
            {
              ::std::unique_ptr< location_type > r (
                dynamic_cast< location_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->location_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // severity
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "severity",
              "",
              &::xsd::cxx::tree::factory_impl< severity_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!severity_.present ())
            {
              ::std::unique_ptr< severity_type > r (
                dynamic_cast< severity_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->severity_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "location",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!severity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "severity",
          "");
      }
    }

    injury_occurance_list* injury_occurance_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class injury_occurance_list (*this, f, c);
    }

    injury_occurance_list& injury_occurance_list::
    operator= (const injury_occurance_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->location_ = x.location_;
        this->description_ = x.description_;
        this->severity_ = x.severity_;
      }

      return *this;
    }

    injury_occurance_list::
    ~injury_occurance_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, injury_occurance_list >
    _xsd_injury_occurance_list_type_factory_init (
      "injury-occurance-list",
      "com:ara:pfc:training:1");

    // medical_scenario_syllabus
    //

    medical_scenario_syllabus::
    medical_scenario_syllabus (const learning_objectives_type& learning_objectives,
                               const learning_assessments_type& learning_assessments)
    : ::xml_schema::type (),
      learning_objectives_ (learning_objectives, this),
      learning_assessments_ (learning_assessments, this)
    {
    }

    medical_scenario_syllabus::
    medical_scenario_syllabus (::std::unique_ptr< learning_objectives_type > learning_objectives,
                               ::std::unique_ptr< learning_assessments_type > learning_assessments)
    : ::xml_schema::type (),
      learning_objectives_ (std::move (learning_objectives), this),
      learning_assessments_ (std::move (learning_assessments), this)
    {
    }

    medical_scenario_syllabus::
    medical_scenario_syllabus (const medical_scenario_syllabus& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      learning_objectives_ (x.learning_objectives_, f, this),
      learning_assessments_ (x.learning_assessments_, f, this)
    {
    }

    medical_scenario_syllabus::
    medical_scenario_syllabus (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      learning_objectives_ (this),
      learning_assessments_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void medical_scenario_syllabus::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // learning-objectives
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "learning-objectives",
              "",
              &::xsd::cxx::tree::factory_impl< learning_objectives_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!learning_objectives_.present ())
            {
              ::std::unique_ptr< learning_objectives_type > r (
                dynamic_cast< learning_objectives_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->learning_objectives_.set (::std::move (r));
              continue;
            }
          }
        }

        // learning-assessments
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "learning-assessments",
              "",
              &::xsd::cxx::tree::factory_impl< learning_assessments_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!learning_assessments_.present ())
            {
              ::std::unique_ptr< learning_assessments_type > r (
                dynamic_cast< learning_assessments_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->learning_assessments_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!learning_objectives_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "learning-objectives",
          "");
      }

      if (!learning_assessments_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "learning-assessments",
          "");
      }
    }

    medical_scenario_syllabus* medical_scenario_syllabus::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class medical_scenario_syllabus (*this, f, c);
    }

    medical_scenario_syllabus& medical_scenario_syllabus::
    operator= (const medical_scenario_syllabus& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->learning_objectives_ = x.learning_objectives_;
        this->learning_assessments_ = x.learning_assessments_;
      }

      return *this;
    }

    medical_scenario_syllabus::
    ~medical_scenario_syllabus ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, medical_scenario_syllabus >
    _xsd_medical_scenario_syllabus_type_factory_init (
      "medical-scenario-syllabus",
      "com:ara:pfc:training:1");

    // learning_objective_list
    //

    learning_objective_list::
    learning_objective_list ()
    : ::xml_schema::type (),
      objective_ (this)
    {
    }

    learning_objective_list::
    learning_objective_list (const learning_objective_list& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      objective_ (x.objective_, f, this)
    {
    }

    learning_objective_list::
    learning_objective_list (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      objective_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void learning_objective_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // objective
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "objective",
              "",
              &::xsd::cxx::tree::factory_impl< objective_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< objective_type > r (
              dynamic_cast< objective_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->objective_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    learning_objective_list* learning_objective_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class learning_objective_list (*this, f, c);
    }

    learning_objective_list& learning_objective_list::
    operator= (const learning_objective_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->objective_ = x.objective_;
      }

      return *this;
    }

    learning_objective_list::
    ~learning_objective_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, learning_objective_list >
    _xsd_learning_objective_list_type_factory_init (
      "learning-objective-list",
      "com:ara:pfc:training:1");

    // learning_objective
    //

    learning_objective::
    learning_objective (const id_type& id,
                        const name_type& name,
                        const description_type& description,
                        const references_type& references,
                        const relates_to_type& relates_to)
    : ::xml_schema::type (),
      id_ (id, this),
      name_ (name, this),
      description_ (description, this),
      references_ (references, this),
      relates_to_ (relates_to, this)
    {
    }

    learning_objective::
    learning_objective (const id_type& id,
                        const name_type& name,
                        const description_type& description,
                        ::std::unique_ptr< references_type > references,
                        ::std::unique_ptr< relates_to_type > relates_to)
    : ::xml_schema::type (),
      id_ (id, this),
      name_ (name, this),
      description_ (description, this),
      references_ (std::move (references), this),
      relates_to_ (std::move (relates_to), this)
    {
    }

    learning_objective::
    learning_objective (::std::unique_ptr< id_type > id,
                        ::std::unique_ptr< name_type > name,
                        ::std::unique_ptr< description_type > description,
                        ::std::unique_ptr< references_type > references,
                        ::std::unique_ptr< relates_to_type > relates_to)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      name_ (std::move (name), this),
      description_ (std::move (description), this),
      references_ (std::move (references), this),
      relates_to_ (std::move (relates_to), this)
    {
    }

    learning_objective::
    learning_objective (const learning_objective& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      name_ (x.name_, f, this),
      description_ (x.description_, f, this),
      references_ (x.references_, f, this),
      relates_to_ (x.relates_to_, f, this)
    {
    }

    learning_objective::
    learning_objective (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      name_ (this),
      description_ (this),
      references_ (this),
      relates_to_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void learning_objective::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // references
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "references",
              "",
              &::xsd::cxx::tree::factory_impl< references_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!references_.present ())
            {
              ::std::unique_ptr< references_type > r (
                dynamic_cast< references_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->references_.set (::std::move (r));
              continue;
            }
          }
        }

        // relates-to
        //
        if (n.name () == "relates-to" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< relates_to_type > r (
            relates_to_traits::create (i, f, this));

          if (!relates_to_.present ())
          {
            this->relates_to_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!references_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "references",
          "");
      }

      if (!relates_to_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "relates-to",
          "");
      }
    }

    learning_objective* learning_objective::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class learning_objective (*this, f, c);
    }

    learning_objective& learning_objective::
    operator= (const learning_objective& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->name_ = x.name_;
        this->description_ = x.description_;
        this->references_ = x.references_;
        this->relates_to_ = x.relates_to_;
      }

      return *this;
    }

    learning_objective::
    ~learning_objective ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, learning_objective >
    _xsd_learning_objective_type_factory_init (
      "learning-objective",
      "com:ara:pfc:training:1");

    // assessment_list
    //

    assessment_list::
    assessment_list (const total_points_type& total_points)
    : ::xml_schema::type (),
      total_points_ (total_points, this),
      assessment_ (this)
    {
    }

    assessment_list::
    assessment_list (const assessment_list& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      total_points_ (x.total_points_, f, this),
      assessment_ (x.assessment_, f, this)
    {
    }

    assessment_list::
    assessment_list (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      total_points_ (this),
      assessment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void assessment_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // total-points
        //
        if (n.name () == "total-points" && n.namespace_ ().empty ())
        {
          if (!total_points_.present ())
          {
            this->total_points_.set (total_points_traits::create (i, f, this));
            continue;
          }
        }

        // assessment
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "assessment",
              "",
              &::xsd::cxx::tree::factory_impl< assessment_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< assessment_type > r (
              dynamic_cast< assessment_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->assessment_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!total_points_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "total-points",
          "");
      }
    }

    assessment_list* assessment_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class assessment_list (*this, f, c);
    }

    assessment_list& assessment_list::
    operator= (const assessment_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->total_points_ = x.total_points_;
        this->assessment_ = x.assessment_;
      }

      return *this;
    }

    assessment_list::
    ~assessment_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, assessment_list >
    _xsd_assessment_list_type_factory_init (
      "assessment-list",
      "com:ara:pfc:training:1");

    // assessment
    //

    assessment::
    assessment (const id_type& id,
                const objective_id_type& objective_id,
                const points_avaiable_type& points_avaiable,
                const criteria_type& criteria)
    : ::xml_schema::type (),
      id_ (id, this),
      objective_id_ (objective_id, this),
      points_avaiable_ (points_avaiable, this),
      criteria_ (criteria, this)
    {
    }

    assessment::
    assessment (::std::unique_ptr< id_type > id,
                ::std::unique_ptr< objective_id_type > objective_id,
                const points_avaiable_type& points_avaiable,
                ::std::unique_ptr< criteria_type > criteria)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      objective_id_ (std::move (objective_id), this),
      points_avaiable_ (points_avaiable, this),
      criteria_ (std::move (criteria), this)
    {
    }

    assessment::
    assessment (const assessment& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      objective_id_ (x.objective_id_, f, this),
      points_avaiable_ (x.points_avaiable_, f, this),
      criteria_ (x.criteria_, f, this)
    {
    }

    assessment::
    assessment (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      objective_id_ (this),
      points_avaiable_ (this),
      criteria_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void assessment::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // objective-id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "objective-id",
              "",
              &::xsd::cxx::tree::factory_impl< objective_id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!objective_id_.present ())
            {
              ::std::unique_ptr< objective_id_type > r (
                dynamic_cast< objective_id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->objective_id_.set (::std::move (r));
              continue;
            }
          }
        }

        // points-avaiable
        //
        if (n.name () == "points-avaiable" && n.namespace_ ().empty ())
        {
          if (!points_avaiable_.present ())
          {
            this->points_avaiable_.set (points_avaiable_traits::create (i, f, this));
            continue;
          }
        }

        // criteria
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "criteria",
              "",
              &::xsd::cxx::tree::factory_impl< criteria_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!criteria_.present ())
            {
              ::std::unique_ptr< criteria_type > r (
                dynamic_cast< criteria_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->criteria_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!objective_id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "objective-id",
          "");
      }

      if (!points_avaiable_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "points-avaiable",
          "");
      }

      if (!criteria_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "criteria",
          "");
      }
    }

    assessment* assessment::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class assessment (*this, f, c);
    }

    assessment& assessment::
    operator= (const assessment& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->objective_id_ = x.objective_id_;
        this->points_avaiable_ = x.points_avaiable_;
        this->criteria_ = x.criteria_;
      }

      return *this;
    }

    assessment::
    ~assessment ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, assessment >
    _xsd_assessment_type_factory_init (
      "assessment",
      "com:ara:pfc:training:1");

    // medical_scenario
    //

    medical_scenario::
    medical_scenario (const id_type& id,
                      const roles_type& roles,
                      const props_type& props,
                      const training_script_type& training_script)
    : ::xml_schema::type (),
      id_ (id, this),
      roles_ (roles, this),
      props_ (props, this),
      training_script_ (training_script, this)
    {
    }

    medical_scenario::
    medical_scenario (const id_type& id,
                      ::std::unique_ptr< roles_type > roles,
                      ::std::unique_ptr< props_type > props,
                      ::std::unique_ptr< training_script_type > training_script)
    : ::xml_schema::type (),
      id_ (id, this),
      roles_ (std::move (roles), this),
      props_ (std::move (props), this),
      training_script_ (std::move (training_script), this)
    {
    }

    medical_scenario::
    medical_scenario (::std::unique_ptr< id_type > id,
                      ::std::unique_ptr< roles_type > roles,
                      ::std::unique_ptr< props_type > props,
                      ::std::unique_ptr< training_script_type > training_script)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      roles_ (std::move (roles), this),
      props_ (std::move (props), this),
      training_script_ (std::move (training_script), this)
    {
    }

    medical_scenario::
    medical_scenario (const medical_scenario& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      roles_ (x.roles_, f, this),
      props_ (x.props_, f, this),
      training_script_ (x.training_script_, f, this)
    {
    }

    medical_scenario::
    medical_scenario (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      roles_ (this),
      props_ (this),
      training_script_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void medical_scenario::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // roles
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "roles",
              "",
              &::xsd::cxx::tree::factory_impl< roles_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!roles_.present ())
            {
              ::std::unique_ptr< roles_type > r (
                dynamic_cast< roles_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->roles_.set (::std::move (r));
              continue;
            }
          }
        }

        // props
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "props",
              "",
              &::xsd::cxx::tree::factory_impl< props_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!props_.present ())
            {
              ::std::unique_ptr< props_type > r (
                dynamic_cast< props_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->props_.set (::std::move (r));
              continue;
            }
          }
        }

        // training-script
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "training-script",
              "",
              &::xsd::cxx::tree::factory_impl< training_script_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!training_script_.present ())
            {
              ::std::unique_ptr< training_script_type > r (
                dynamic_cast< training_script_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->training_script_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!roles_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "roles",
          "");
      }

      if (!props_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "props",
          "");
      }

      if (!training_script_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "training-script",
          "");
      }
    }

    medical_scenario* medical_scenario::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class medical_scenario (*this, f, c);
    }

    medical_scenario& medical_scenario::
    operator= (const medical_scenario& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->roles_ = x.roles_;
        this->props_ = x.props_;
        this->training_script_ = x.training_script_;
      }

      return *this;
    }

    medical_scenario::
    ~medical_scenario ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, medical_scenario >
    _xsd_medical_scenario_type_factory_init (
      "medical-scenario",
      "com:ara:pfc:training:1");

    // role_list
    //

    role_list::
    role_list ()
    : ::xml_schema::type (),
      role_ (this)
    {
    }

    role_list::
    role_list (const role_list& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      role_ (x.role_, f, this)
    {
    }

    role_list::
    role_list (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      role_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void role_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // role
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "role",
              "",
              &::xsd::cxx::tree::factory_impl< role_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< role_type > r (
              dynamic_cast< role_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->role_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    role_list* role_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class role_list (*this, f, c);
    }

    role_list& role_list::
    operator= (const role_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->role_ = x.role_;
      }

      return *this;
    }

    role_list::
    ~role_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, role_list >
    _xsd_role_list_type_factory_init (
      "role-list",
      "com:ara:pfc:training:1");

    // role
    //

    role::
    role (const short_name_type& short_name,
          const unit_id_type& unit_id,
          const description_type& description)
    : ::xml_schema::type (),
      short_name_ (short_name, this),
      unit_id_ (unit_id, this),
      injury_profile_id_ (this),
      description_ (description, this)
    {
    }

    role::
    role (::std::unique_ptr< short_name_type > short_name,
          ::std::unique_ptr< unit_id_type > unit_id,
          ::std::unique_ptr< description_type > description)
    : ::xml_schema::type (),
      short_name_ (std::move (short_name), this),
      unit_id_ (std::move (unit_id), this),
      injury_profile_id_ (this),
      description_ (std::move (description), this)
    {
    }

    role::
    role (const role& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      short_name_ (x.short_name_, f, this),
      unit_id_ (x.unit_id_, f, this),
      injury_profile_id_ (x.injury_profile_id_, f, this),
      description_ (x.description_, f, this)
    {
    }

    role::
    role (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      short_name_ (this),
      unit_id_ (this),
      injury_profile_id_ (this),
      description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void role::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // short-name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "short-name",
              "",
              &::xsd::cxx::tree::factory_impl< short_name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!short_name_.present ())
            {
              ::std::unique_ptr< short_name_type > r (
                dynamic_cast< short_name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->short_name_.set (::std::move (r));
              continue;
            }
          }
        }

        // unit-id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "unit-id",
              "",
              &::xsd::cxx::tree::factory_impl< unit_id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!unit_id_.present ())
            {
              ::std::unique_ptr< unit_id_type > r (
                dynamic_cast< unit_id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->unit_id_.set (::std::move (r));
              continue;
            }
          }
        }

        // injury-profile-id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "injury-profile-id",
              "",
              &::xsd::cxx::tree::factory_impl< injury_profile_id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->injury_profile_id_)
            {
              ::std::unique_ptr< injury_profile_id_type > r (
                dynamic_cast< injury_profile_id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->injury_profile_id_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!short_name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "short-name",
          "");
      }

      if (!unit_id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "unit-id",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }
    }

    role* role::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class role (*this, f, c);
    }

    role& role::
    operator= (const role& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->short_name_ = x.short_name_;
        this->unit_id_ = x.unit_id_;
        this->injury_profile_id_ = x.injury_profile_id_;
        this->description_ = x.description_;
      }

      return *this;
    }

    role::
    ~role ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, role >
    _xsd_role_type_factory_init (
      "role",
      "com:ara:pfc:training:1");

    // prop_list
    //

    prop_list::
    prop_list ()
    : ::xml_schema::type (),
      prop_ (this)
    {
    }

    prop_list::
    prop_list (const prop_list& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      prop_ (x.prop_, f, this)
    {
    }

    prop_list::
    prop_list (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      prop_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void prop_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // prop
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "prop",
              "",
              &::xsd::cxx::tree::factory_impl< prop_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< prop_type > r (
              dynamic_cast< prop_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->prop_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    prop_list* prop_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class prop_list (*this, f, c);
    }

    prop_list& prop_list::
    operator= (const prop_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->prop_ = x.prop_;
      }

      return *this;
    }

    prop_list::
    ~prop_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, prop_list >
    _xsd_prop_list_type_factory_init (
      "prop-list",
      "com:ara:pfc:training:1");

    // prop
    //

    prop::
    prop (const short_name_type& short_name,
          const equipment_id_type& equipment_id,
          const description_type& description)
    : ::xml_schema::type (),
      short_name_ (short_name, this),
      equipment_id_ (equipment_id, this),
      description_ (description, this)
    {
    }

    prop::
    prop (::std::unique_ptr< short_name_type > short_name,
          ::std::unique_ptr< equipment_id_type > equipment_id,
          ::std::unique_ptr< description_type > description)
    : ::xml_schema::type (),
      short_name_ (std::move (short_name), this),
      equipment_id_ (std::move (equipment_id), this),
      description_ (std::move (description), this)
    {
    }

    prop::
    prop (const prop& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      short_name_ (x.short_name_, f, this),
      equipment_id_ (x.equipment_id_, f, this),
      description_ (x.description_, f, this)
    {
    }

    prop::
    prop (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      short_name_ (this),
      equipment_id_ (this),
      description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void prop::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // short-name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "short-name",
              "",
              &::xsd::cxx::tree::factory_impl< short_name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!short_name_.present ())
            {
              ::std::unique_ptr< short_name_type > r (
                dynamic_cast< short_name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->short_name_.set (::std::move (r));
              continue;
            }
          }
        }

        // equipment-id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "equipment-id",
              "",
              &::xsd::cxx::tree::factory_impl< equipment_id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!equipment_id_.present ())
            {
              ::std::unique_ptr< equipment_id_type > r (
                dynamic_cast< equipment_id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->equipment_id_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!short_name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "short-name",
          "");
      }

      if (!equipment_id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "equipment-id",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }
    }

    prop* prop::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class prop (*this, f, c);
    }

    prop& prop::
    operator= (const prop& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->short_name_ = x.short_name_;
        this->equipment_id_ = x.equipment_id_;
        this->description_ = x.description_;
      }

      return *this;
    }

    prop::
    ~prop ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, prop >
    _xsd_prop_type_factory_init (
      "prop",
      "com:ara:pfc:training:1");

    // scene_list
    //

    scene_list::
    scene_list ()
    : ::xml_schema::type (),
      scene_ (this)
    {
    }

    scene_list::
    scene_list (const scene_list& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      scene_ (x.scene_, f, this)
    {
    }

    scene_list::
    scene_list (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      scene_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void scene_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // scene
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "scene",
              "",
              &::xsd::cxx::tree::factory_impl< scene_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< scene_type > r (
              dynamic_cast< scene_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->scene_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    scene_list* scene_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class scene_list (*this, f, c);
    }

    scene_list& scene_list::
    operator= (const scene_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->scene_ = x.scene_;
      }

      return *this;
    }

    scene_list::
    ~scene_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, scene_list >
    _xsd_scene_list_type_factory_init (
      "scene-list",
      "com:ara:pfc:training:1");

    // scene
    //

    scene::
    scene (const location_id_type& location_id,
           const name_type& name,
           const description_type& description,
           const time_of_day_type& time_of_day,
           const time_in_simulation_type& time_in_simulation,
           const events_type& events)
    : ::xml_schema::type (),
      location_id_ (location_id, this),
      name_ (name, this),
      description_ (description, this),
      time_of_day_ (time_of_day, this),
      time_in_simulation_ (time_in_simulation, this),
      events_ (events, this)
    {
    }

    scene::
    scene (const location_id_type& location_id,
           const name_type& name,
           const description_type& description,
           const time_of_day_type& time_of_day,
           const time_in_simulation_type& time_in_simulation,
           ::std::unique_ptr< events_type > events)
    : ::xml_schema::type (),
      location_id_ (location_id, this),
      name_ (name, this),
      description_ (description, this),
      time_of_day_ (time_of_day, this),
      time_in_simulation_ (time_in_simulation, this),
      events_ (std::move (events), this)
    {
    }

    scene::
    scene (::std::unique_ptr< location_id_type > location_id,
           ::std::unique_ptr< name_type > name,
           ::std::unique_ptr< description_type > description,
           ::std::unique_ptr< time_of_day_type > time_of_day,
           const time_in_simulation_type& time_in_simulation,
           ::std::unique_ptr< events_type > events)
    : ::xml_schema::type (),
      location_id_ (std::move (location_id), this),
      name_ (std::move (name), this),
      description_ (std::move (description), this),
      time_of_day_ (std::move (time_of_day), this),
      time_in_simulation_ (time_in_simulation, this),
      events_ (std::move (events), this)
    {
    }

    scene::
    scene (const scene& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      location_id_ (x.location_id_, f, this),
      name_ (x.name_, f, this),
      description_ (x.description_, f, this),
      time_of_day_ (x.time_of_day_, f, this),
      time_in_simulation_ (x.time_in_simulation_, f, this),
      events_ (x.events_, f, this)
    {
    }

    scene::
    scene (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      location_id_ (this),
      name_ (this),
      description_ (this),
      time_of_day_ (this),
      time_in_simulation_ (this),
      events_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void scene::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // location-id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "location-id",
              "",
              &::xsd::cxx::tree::factory_impl< location_id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!location_id_.present ())
            {
              ::std::unique_ptr< location_id_type > r (
                dynamic_cast< location_id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->location_id_.set (::std::move (r));
              continue;
            }
          }
        }

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // time-of-day
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "time-of-day",
              "",
              &::xsd::cxx::tree::factory_impl< time_of_day_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!time_of_day_.present ())
            {
              ::std::unique_ptr< time_of_day_type > r (
                dynamic_cast< time_of_day_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->time_of_day_.set (::std::move (r));
              continue;
            }
          }
        }

        // time-in-simulation
        //
        if (n.name () == "time-in-simulation" && n.namespace_ ().empty ())
        {
          if (!time_in_simulation_.present ())
          {
            this->time_in_simulation_.set (time_in_simulation_traits::create (i, f, this));
            continue;
          }
        }

        // events
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "events",
              "",
              &::xsd::cxx::tree::factory_impl< events_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!events_.present ())
            {
              ::std::unique_ptr< events_type > r (
                dynamic_cast< events_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->events_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!location_id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "location-id",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!time_of_day_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "time-of-day",
          "");
      }

      if (!time_in_simulation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "time-in-simulation",
          "");
      }

      if (!events_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "events",
          "");
      }
    }

    scene* scene::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class scene (*this, f, c);
    }

    scene& scene::
    operator= (const scene& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->location_id_ = x.location_id_;
        this->name_ = x.name_;
        this->description_ = x.description_;
        this->time_of_day_ = x.time_of_day_;
        this->time_in_simulation_ = x.time_in_simulation_;
        this->events_ = x.events_;
      }

      return *this;
    }

    scene::
    ~scene ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, scene >
    _xsd_scene_type_factory_init (
      "scene",
      "com:ara:pfc:training:1");

    // event_list
    //

    event_list::
    event_list ()
    : ::xml_schema::type (),
      event_ (this)
    {
    }

    event_list::
    event_list (const event_list& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      event_ (x.event_, f, this)
    {
    }

    event_list::
    event_list (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      event_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void event_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // event
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "event",
              "",
              &::xsd::cxx::tree::factory_impl< event_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< event_type > r (
              dynamic_cast< event_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->event_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    event_list* event_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class event_list (*this, f, c);
    }

    event_list& event_list::
    operator= (const event_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->event_ = x.event_;
      }

      return *this;
    }

    event_list::
    ~event_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, event_list >
    _xsd_event_list_type_factory_init (
      "event-list",
      "com:ara:pfc:training:1");

    // event
    //

    event::
    event (const category_type& category,
           const fidelity_type& fidelity,
           const details_type& details)
    : ::xml_schema::type (),
      category_ (category, this),
      fidelity_ (fidelity, this),
      details_ (details, this)
    {
    }

    event::
    event (::std::unique_ptr< category_type > category,
           ::std::unique_ptr< fidelity_type > fidelity,
           ::std::unique_ptr< details_type > details)
    : ::xml_schema::type (),
      category_ (std::move (category), this),
      fidelity_ (std::move (fidelity), this),
      details_ (std::move (details), this)
    {
    }

    event::
    event (const event& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      category_ (x.category_, f, this),
      fidelity_ (x.fidelity_, f, this),
      details_ (x.details_, f, this)
    {
    }

    event::
    event (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      category_ (this),
      fidelity_ (this),
      details_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void event::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // category
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "category",
              "",
              &::xsd::cxx::tree::factory_impl< category_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!category_.present ())
            {
              ::std::unique_ptr< category_type > r (
                dynamic_cast< category_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->category_.set (::std::move (r));
              continue;
            }
          }
        }

        // fidelity
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "fidelity",
              "",
              &::xsd::cxx::tree::factory_impl< fidelity_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!fidelity_.present ())
            {
              ::std::unique_ptr< fidelity_type > r (
                dynamic_cast< fidelity_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->fidelity_.set (::std::move (r));
              continue;
            }
          }
        }

        // details
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "details",
              "",
              &::xsd::cxx::tree::factory_impl< details_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!details_.present ())
            {
              ::std::unique_ptr< details_type > r (
                dynamic_cast< details_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->details_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!category_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "category",
          "");
      }

      if (!fidelity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "fidelity",
          "");
      }

      if (!details_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "details",
          "");
      }
    }

    event* event::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class event (*this, f, c);
    }

    event& event::
    operator= (const event& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->category_ = x.category_;
        this->fidelity_ = x.fidelity_;
        this->details_ = x.details_;
      }

      return *this;
    }

    event::
    ~event ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, event >
    _xsd_event_type_factory_init (
      "event",
      "com:ara:pfc:training:1");

    // event_category_enum
    //

    event_category_enum::
    event_category_enum (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_event_category_enum_convert ();
    }

    event_category_enum::
    event_category_enum (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_event_category_enum_convert ();
    }

    event_category_enum::
    event_category_enum (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_event_category_enum_convert ();
    }

    event_category_enum* event_category_enum::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class event_category_enum (*this, f, c);
    }

    event_category_enum::value event_category_enum::
    _xsd_event_category_enum_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_event_category_enum_literals_);
      const value* i (::std::lower_bound (
                        _xsd_event_category_enum_indexes_,
                        _xsd_event_category_enum_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_event_category_enum_indexes_ + 5 || _xsd_event_category_enum_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const event_category_enum::
    _xsd_event_category_enum_literals_[5] =
    {
      "ACTION",
      "DIALOG",
      "MOVMENT",
      "SOUND",
      "ENVIRONMENT"
    };

    const event_category_enum::value event_category_enum::
    _xsd_event_category_enum_indexes_[5] =
    {
      ::pfc::schema::event_category_enum::ACTION,
      ::pfc::schema::event_category_enum::DIALOG,
      ::pfc::schema::event_category_enum::ENVIRONMENT,
      ::pfc::schema::event_category_enum::MOVMENT,
      ::pfc::schema::event_category_enum::SOUND
    };

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, event_category_enum >
    _xsd_event_category_enum_type_factory_init (
      "event-category-enum",
      "com:ara:pfc:training:1");

    // event_fidelity_enum
    //

    event_fidelity_enum::
    event_fidelity_enum (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_event_fidelity_enum_convert ();
    }

    event_fidelity_enum::
    event_fidelity_enum (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_event_fidelity_enum_convert ();
    }

    event_fidelity_enum::
    event_fidelity_enum (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_event_fidelity_enum_convert ();
    }

    event_fidelity_enum* event_fidelity_enum::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class event_fidelity_enum (*this, f, c);
    }

    event_fidelity_enum::value event_fidelity_enum::
    _xsd_event_fidelity_enum_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_event_fidelity_enum_literals_);
      const value* i (::std::lower_bound (
                        _xsd_event_fidelity_enum_indexes_,
                        _xsd_event_fidelity_enum_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_event_fidelity_enum_indexes_ + 3 || _xsd_event_fidelity_enum_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const event_fidelity_enum::
    _xsd_event_fidelity_enum_literals_[3] =
    {
      "LOW",
      "MEDIUM",
      "HIGH"
    };

    const event_fidelity_enum::value event_fidelity_enum::
    _xsd_event_fidelity_enum_indexes_[3] =
    {
      ::pfc::schema::event_fidelity_enum::HIGH,
      ::pfc::schema::event_fidelity_enum::LOW,
      ::pfc::schema::event_fidelity_enum::MEDIUM
    };

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, event_fidelity_enum >
    _xsd_event_fidelity_enum_type_factory_init (
      "event-fidelity-enum",
      "com:ara:pfc:training:1");

    // citation_list
    //

    citation_list::
    citation_list ()
    : ::xml_schema::type (),
      citation_ (this)
    {
    }

    citation_list::
    citation_list (const citation_list& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      citation_ (x.citation_, f, this)
    {
    }

    citation_list::
    citation_list (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      citation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void citation_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // citation
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "citation",
              "",
              &::xsd::cxx::tree::factory_impl< citation_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< citation_type > r (
              dynamic_cast< citation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->citation_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    citation_list* citation_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class citation_list (*this, f, c);
    }

    citation_list& citation_list::
    operator= (const citation_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->citation_ = x.citation_;
      }

      return *this;
    }

    citation_list::
    ~citation_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, citation_list >
    _xsd_citation_list_type_factory_init (
      "citation-list",
      "com:ara:pfc:training:1");

    // citation
    //

    citation::
    citation (const uuid_type& uuid,
              const title_type& title,
              const date_type& date)
    : ::xml_schema::type (),
      uuid_ (uuid, this),
      authors_ (this),
      title_ (title, this),
      date_ (date, this),
      page_ (this),
      accessed_ (this)
    {
    }

    citation::
    citation (::std::unique_ptr< uuid_type > uuid,
              ::std::unique_ptr< title_type > title,
              ::std::unique_ptr< date_type > date)
    : ::xml_schema::type (),
      uuid_ (std::move (uuid), this),
      authors_ (this),
      title_ (std::move (title), this),
      date_ (std::move (date), this),
      page_ (this),
      accessed_ (this)
    {
    }

    citation::
    citation (const citation& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uuid_ (x.uuid_, f, this),
      authors_ (x.authors_, f, this),
      title_ (x.title_, f, this),
      date_ (x.date_, f, this),
      page_ (x.page_, f, this),
      accessed_ (x.accessed_, f, this)
    {
    }

    citation::
    citation (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uuid_ (this),
      authors_ (this),
      title_ (this),
      date_ (this),
      page_ (this),
      accessed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void citation::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uuid
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "uuid",
              "",
              &::xsd::cxx::tree::factory_impl< uuid_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!uuid_.present ())
            {
              ::std::unique_ptr< uuid_type > r (
                dynamic_cast< uuid_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->uuid_.set (::std::move (r));
              continue;
            }
          }
        }

        // authors
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "authors",
              "",
              &::xsd::cxx::tree::factory_impl< authors_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< authors_type > r (
              dynamic_cast< authors_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->authors_.push_back (::std::move (r));
            continue;
          }
        }

        // title
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "title",
              "",
              &::xsd::cxx::tree::factory_impl< title_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!title_.present ())
            {
              ::std::unique_ptr< title_type > r (
                dynamic_cast< title_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->title_.set (::std::move (r));
              continue;
            }
          }
        }

        // date
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "date",
              "",
              &::xsd::cxx::tree::factory_impl< date_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!date_.present ())
            {
              ::std::unique_ptr< date_type > r (
                dynamic_cast< date_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->date_.set (::std::move (r));
              continue;
            }
          }
        }

        // page
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "page",
              "",
              &::xsd::cxx::tree::factory_impl< page_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->page_)
            {
              ::std::unique_ptr< page_type > r (
                dynamic_cast< page_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->page_.set (::std::move (r));
              continue;
            }
          }
        }

        // accessed
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "accessed",
              "",
              &::xsd::cxx::tree::factory_impl< accessed_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->accessed_)
            {
              ::std::unique_ptr< accessed_type > r (
                dynamic_cast< accessed_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->accessed_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!uuid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "uuid",
          "");
      }

      if (!title_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "title",
          "");
      }

      if (!date_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "date",
          "");
      }
    }

    citation* citation::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class citation (*this, f, c);
    }

    citation& citation::
    operator= (const citation& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->uuid_ = x.uuid_;
        this->authors_ = x.authors_;
        this->title_ = x.title_;
        this->date_ = x.date_;
        this->page_ = x.page_;
        this->accessed_ = x.accessed_;
      }

      return *this;
    }

    citation::
    ~citation ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, citation >
    _xsd_citation_type_factory_init (
      "citation",
      "com:ara:pfc:training:1");

    // properties_list
    //

    properties_list::
    properties_list ()
    : ::xml_schema::type (),
      property_ (this)
    {
    }

    properties_list::
    properties_list (const properties_list& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      property_ (x.property_, f, this)
    {
    }

    properties_list::
    properties_list (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      property_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void properties_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // property
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "property",
              "",
              &::xsd::cxx::tree::factory_impl< property_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< property_type > r (
              dynamic_cast< property_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->property_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    properties_list* properties_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class properties_list (*this, f, c);
    }

    properties_list& properties_list::
    operator= (const properties_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->property_ = x.property_;
      }

      return *this;
    }

    properties_list::
    ~properties_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, properties_list >
    _xsd_properties_list_type_factory_init (
      "properties-list",
      "com:ara:pfc:training:1");

    // property
    //

    property::
    property (const name_type& name,
              const type_type& type)
    : ::xml_schema::type (),
      name_ (name, this),
      type_ (type, this)
    {
    }

    property::
    property (::std::unique_ptr< name_type > name,
              ::std::unique_ptr< type_type > type)
    : ::xml_schema::type (),
      name_ (std::move (name), this),
      type_ (std::move (type), this)
    {
    }

    property::
    property (const property& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this)
    {
    }

    property::
    property (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void property::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // type
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "type",
              "",
              &::xsd::cxx::tree::factory_impl< type_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!type_.present ())
            {
              ::std::unique_ptr< type_type > r (
                dynamic_cast< type_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->type_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "type",
          "");
      }
    }

    property* property::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class property (*this, f, c);
    }

    property& property::
    operator= (const property& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->type_ = x.type_;
      }

      return *this;
    }

    property::
    ~property ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, property >
    _xsd_property_type_factory_init (
      "property",
      "com:ara:pfc:training:1");

    // relates_to
    //

    relates_to::
    relates_to (const treatment_plans_type& treatment_plans,
                const injury_profiles_type& injury_profiles)
    : ::xml_schema::type (),
      treatment_plans_ (treatment_plans, this),
      injury_profiles_ (injury_profiles, this)
    {
    }

    relates_to::
    relates_to (::std::unique_ptr< treatment_plans_type > treatment_plans,
                ::std::unique_ptr< injury_profiles_type > injury_profiles)
    : ::xml_schema::type (),
      treatment_plans_ (std::move (treatment_plans), this),
      injury_profiles_ (std::move (injury_profiles), this)
    {
    }

    relates_to::
    relates_to (const relates_to& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      treatment_plans_ (x.treatment_plans_, f, this),
      injury_profiles_ (x.injury_profiles_, f, this)
    {
    }

    relates_to::
    relates_to (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      treatment_plans_ (this),
      injury_profiles_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void relates_to::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // treatment-plans
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "treatment-plans",
              "",
              &::xsd::cxx::tree::factory_impl< treatment_plans_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!treatment_plans_.present ())
            {
              ::std::unique_ptr< treatment_plans_type > r (
                dynamic_cast< treatment_plans_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->treatment_plans_.set (::std::move (r));
              continue;
            }
          }
        }

        // injury-profiles
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "injury-profiles",
              "",
              &::xsd::cxx::tree::factory_impl< injury_profiles_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!injury_profiles_.present ())
            {
              ::std::unique_ptr< injury_profiles_type > r (
                dynamic_cast< injury_profiles_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->injury_profiles_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!treatment_plans_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "treatment-plans",
          "");
      }

      if (!injury_profiles_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "injury-profiles",
          "");
      }
    }

    relates_to* relates_to::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class relates_to (*this, f, c);
    }

    relates_to& relates_to::
    operator= (const relates_to& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->treatment_plans_ = x.treatment_plans_;
        this->injury_profiles_ = x.injury_profiles_;
      }

      return *this;
    }

    relates_to::
    ~relates_to ()
    {
    }
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace pfc
{
  namespace schema
  {
    ::std::ostream&
    operator<< (::std::ostream& o, const equipment_definition_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (equipment_definition_list::equipment_const_iterator
             b (i.equipment ().begin ()), e (i.equipment ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "equipment: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, equipment_definition_list >
    _xsd_equipment_definition_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const equipment& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      if (i.type ())
      {
        o << ::std::endl << "type: " << *i.type ();
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "citations: ";
        om.insert (o, i.citations ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.image ())
        {
          o << ::std::endl << "image: ";
          om.insert (o, *i.image ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "properties: ";
        om.insert (o, i.properties ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, equipment >
    _xsd_equipment_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const injury_definition_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (injury_definition_list::injury_const_iterator
             b (i.injury ().begin ()), e (i.injury ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "injury: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, injury_definition_list >
    _xsd_injury_definition_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const injury& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.common_name ())
        {
          o << ::std::endl << "common-name: ";
          om.insert (o, *i.common_name ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "medical-name: ";
        om.insert (o, i.medical_name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "citations: ";
        om.insert (o, i.citations ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "severity-range: ";
        om.insert (o, i.severity_range ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, injury >
    _xsd_injury_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const injury_severity_range& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.numeric_range ())
        {
          o << ::std::endl << "numeric-range: ";
          om.insert (o, *i.numeric_range ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.token_range ())
        {
          o << ::std::endl << "token-range: ";
          om.insert (o, *i.token_range ());
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, injury_severity_range >
    _xsd_injury_severity_range_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const numeric_range& i)
    {
      o << ::std::endl << "min: " << i.min ();
      o << ::std::endl << "max: " << i.max ();
      if (i.median ())
      {
        o << ::std::endl << "median: " << *i.median ();
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.unit ())
        {
          o << ::std::endl << "unit: ";
          om.insert (o, *i.unit ());
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, numeric_range >
    _xsd_numeric_range_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const token_range& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (token_range::token_const_iterator
             b (i.token ().begin ()), e (i.token ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "token: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, token_range >
    _xsd_token_range_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const citation_ref_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (citation_ref_list::citation_ref_const_iterator
             b (i.citation_ref ().begin ()), e (i.citation_ref ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "citation-ref: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, citation_ref_list >
    _xsd_citation_ref_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const treatment_plan_definition_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (treatment_plan_definition_list::treatment_plan_const_iterator
             b (i.treatment_plan ().begin ()), e (i.treatment_plan ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "treatment-plan: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, treatment_plan_definition_list >
    _xsd_treatment_plan_definition_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const treatment_plan& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.common_name ())
        {
          o << ::std::endl << "common-name: ";
          om.insert (o, *i.common_name ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "required-equipment: ";
        om.insert (o, i.required_equipment ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "references: ";
        om.insert (o, i.references ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, treatment_plan >
    _xsd_treatment_plan_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const equipment_ref_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (equipment_ref_list::equipment_refs_const_iterator
             b (i.equipment_refs ().begin ()), e (i.equipment_refs ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "equipment-refs: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, equipment_ref_list >
    _xsd_equipment_ref_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const medical_reference_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "citations: ";
        om.insert (o, i.citations ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "cpgs: ";
        om.insert (o, i.cpgs ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, medical_reference_list >
    _xsd_medical_reference_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const cpg_ref_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (cpg_ref_list::cpg_ref_const_iterator
             b (i.cpg_ref ().begin ()), e (i.cpg_ref ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "cpg-ref: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, cpg_ref_list >
    _xsd_cpg_ref_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const cpg_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (cpg_list::cpg_const_iterator
             b (i.cpg ().begin ()), e (i.cpg ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "cpg: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, cpg_list >
    _xsd_cpg_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const cpg& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "citation-ref: ";
        om.insert (o, i.citation_ref ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, cpg >
    _xsd_cpg_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const learning_objective_reference_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (learning_objective_reference_list::objective_const_iterator
             b (i.objective ().begin ()), e (i.objective ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "objective: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, learning_objective_reference_list >
    _xsd_learning_objective_reference_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const treatment_plan_ref_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (treatment_plan_ref_list::treatment_plan_const_iterator
             b (i.treatment_plan ().begin ()), e (i.treatment_plan ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "treatment-plan: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, treatment_plan_ref_list >
    _xsd_treatment_plan_ref_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const injury_profile_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (injury_profile_list::injury_profile_const_iterator
             b (i.injury_profile ().begin ()), e (i.injury_profile ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "injury-profile: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, injury_profile_list >
    _xsd_injury_profile_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const injury_profile& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.physiology_state ())
        {
          o << ::std::endl << "physiology-state: ";
          om.insert (o, *i.physiology_state ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (injury_profile::injuries_const_iterator
             b (i.injuries ().begin ()), e (i.injuries ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "injuries: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "treatments: ";
        om.insert (o, i.treatments ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, injury_profile >
    _xsd_injury_profile_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const injury_profile_ref_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (injury_profile_ref_list::injury_profile_const_iterator
             b (i.injury_profile ().begin ()), e (i.injury_profile ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "injury-profile: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, injury_profile_ref_list >
    _xsd_injury_profile_ref_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const injury_occurance_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "location: ";
        om.insert (o, i.location ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "severity: ";
        om.insert (o, i.severity ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, injury_occurance_list >
    _xsd_injury_occurance_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const medical_scenario_syllabus& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "learning-objectives: ";
        om.insert (o, i.learning_objectives ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "learning-assessments: ";
        om.insert (o, i.learning_assessments ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, medical_scenario_syllabus >
    _xsd_medical_scenario_syllabus_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const learning_objective_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (learning_objective_list::objective_const_iterator
             b (i.objective ().begin ()), e (i.objective ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "objective: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, learning_objective_list >
    _xsd_learning_objective_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const learning_objective& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "references: ";
        om.insert (o, i.references ());
      }

      o << ::std::endl << "relates-to: " << i.relates_to ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, learning_objective >
    _xsd_learning_objective_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const assessment_list& i)
    {
      o << ::std::endl << "total-points: " << i.total_points ();
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (assessment_list::assessment_const_iterator
             b (i.assessment ().begin ()), e (i.assessment ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "assessment: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, assessment_list >
    _xsd_assessment_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const assessment& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "objective-id: ";
        om.insert (o, i.objective_id ());
      }

      o << ::std::endl << "points-avaiable: " << i.points_avaiable ();
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "criteria: ";
        om.insert (o, i.criteria ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, assessment >
    _xsd_assessment_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const medical_scenario& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "roles: ";
        om.insert (o, i.roles ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "props: ";
        om.insert (o, i.props ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "training-script: ";
        om.insert (o, i.training_script ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, medical_scenario >
    _xsd_medical_scenario_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const role_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (role_list::role_const_iterator
             b (i.role ().begin ()), e (i.role ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "role: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, role_list >
    _xsd_role_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const role& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "short-name: ";
        om.insert (o, i.short_name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "unit-id: ";
        om.insert (o, i.unit_id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.injury_profile_id ())
        {
          o << ::std::endl << "injury-profile-id: ";
          om.insert (o, *i.injury_profile_id ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, role >
    _xsd_role_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const prop_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (prop_list::prop_const_iterator
             b (i.prop ().begin ()), e (i.prop ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "prop: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, prop_list >
    _xsd_prop_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const prop& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "short-name: ";
        om.insert (o, i.short_name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "equipment-id: ";
        om.insert (o, i.equipment_id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, prop >
    _xsd_prop_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const scene_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (scene_list::scene_const_iterator
             b (i.scene ().begin ()), e (i.scene ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "scene: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, scene_list >
    _xsd_scene_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const scene& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "location-id: ";
        om.insert (o, i.location_id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "time-of-day: ";
        om.insert (o, i.time_of_day ());
      }

      o << ::std::endl << "time-in-simulation: " << i.time_in_simulation ();
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "events: ";
        om.insert (o, i.events ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, scene >
    _xsd_scene_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const event_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (event_list::event_const_iterator
             b (i.event ().begin ()), e (i.event ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "event: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, event_list >
    _xsd_event_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const event& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "category: ";
        om.insert (o, i.category ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "fidelity: ";
        om.insert (o, i.fidelity ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "details: ";
        om.insert (o, i.details ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, event >
    _xsd_event_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, event_category_enum::value i)
    {
      return o << event_category_enum::_xsd_event_category_enum_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const event_category_enum& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, event_category_enum >
    _xsd_event_category_enum_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, event_fidelity_enum::value i)
    {
      return o << event_fidelity_enum::_xsd_event_fidelity_enum_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const event_fidelity_enum& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, event_fidelity_enum >
    _xsd_event_fidelity_enum_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const citation_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (citation_list::citation_const_iterator
             b (i.citation ().begin ()), e (i.citation ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "citation: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, citation_list >
    _xsd_citation_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const citation& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "uuid: ";
        om.insert (o, i.uuid ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (citation::authors_const_iterator
             b (i.authors ().begin ()), e (i.authors ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "authors: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "title: ";
        om.insert (o, i.title ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "date: ";
        om.insert (o, i.date ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.page ())
        {
          o << ::std::endl << "page: ";
          om.insert (o, *i.page ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.accessed ())
        {
          o << ::std::endl << "accessed: ";
          om.insert (o, *i.accessed ());
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, citation >
    _xsd_citation_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const properties_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (properties_list::property_const_iterator
             b (i.property ().begin ()), e (i.property ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "property: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, properties_list >
    _xsd_properties_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const property& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "type: ";
        om.insert (o, i.type ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, property >
    _xsd_property_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const relates_to& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "treatment-plans: ";
        om.insert (o, i.treatment_plans ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "injury-profiles: ";
        om.insert (o, i.injury_profiles ());
      }

      return o;
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace pfc
{
  namespace schema
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace pfc
{
  namespace schema
  {
    void
    operator<< (::xercesc::DOMElement& e, const equipment_definition_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // equipment
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (equipment_definition_list::equipment_const_iterator
             b (i.equipment ().begin ()), n (i.equipment ().end ());
             b != n; ++b)
        {
          if (typeid (equipment_definition_list::equipment_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "equipment",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "equipment",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, equipment_definition_list >
    _xsd_equipment_definition_list_type_serializer_init (
      "equipment-definition-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const equipment& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const equipment::id_type& x (i.id ());
        if (typeid (equipment::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const equipment::name_type& x (i.name ());
        if (typeid (equipment::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // type
      //
      if (i.type ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "type",
            e));

        s << *i.type ();
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const equipment::description_type& x (i.description ());
        if (typeid (equipment::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // citations
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const equipment::citations_type& x (i.citations ());
        if (typeid (equipment::citations_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "citations",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "citations",
            "",
            false, false, e, x);
      }

      // image
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.image ())
        {
          const equipment::image_type& x (*i.image ());
          if (typeid (equipment::image_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "image",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "image",
              "",
              false, false, e, x);
        }
      }

      // properties
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const equipment::properties_type& x (i.properties ());
        if (typeid (equipment::properties_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "properties",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "properties",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, equipment >
    _xsd_equipment_type_serializer_init (
      "equipment",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const injury_definition_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // injury
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (injury_definition_list::injury_const_iterator
             b (i.injury ().begin ()), n (i.injury ().end ());
             b != n; ++b)
        {
          if (typeid (injury_definition_list::injury_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "injury",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "injury",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, injury_definition_list >
    _xsd_injury_definition_list_type_serializer_init (
      "injury-definition-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const injury& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const injury::id_type& x (i.id ());
        if (typeid (injury::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // common-name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.common_name ())
        {
          const injury::common_name_type& x (*i.common_name ());
          if (typeid (injury::common_name_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "common-name",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "common-name",
              "",
              false, false, e, x);
        }
      }

      // medical-name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const injury::medical_name_type& x (i.medical_name ());
        if (typeid (injury::medical_name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "medical-name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "medical-name",
            "",
            false, false, e, x);
      }

      // citations
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const injury::citations_type& x (i.citations ());
        if (typeid (injury::citations_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "citations",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "citations",
            "",
            false, false, e, x);
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const injury::description_type& x (i.description ());
        if (typeid (injury::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // severity-range
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const injury::severity_range_type& x (i.severity_range ());
        if (typeid (injury::severity_range_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "severity-range",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "severity-range",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, injury >
    _xsd_injury_type_serializer_init (
      "injury",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const injury_severity_range& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // numeric-range
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.numeric_range ())
        {
          const injury_severity_range::numeric_range_type& x (*i.numeric_range ());
          if (typeid (injury_severity_range::numeric_range_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "numeric-range",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "numeric-range",
              "",
              false, false, e, x);
        }
      }

      // token-range
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.token_range ())
        {
          const injury_severity_range::token_range_type& x (*i.token_range ());
          if (typeid (injury_severity_range::token_range_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "token-range",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "token-range",
              "",
              false, false, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, injury_severity_range >
    _xsd_injury_severity_range_type_serializer_init (
      "injury-severity-range",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const numeric_range& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // min
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "min",
            e));

        s << ::xml_schema::as_double(i.min ());
      }

      // max
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "max",
            e));

        s << ::xml_schema::as_double(i.max ());
      }

      // median
      //
      if (i.median ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "median",
            e));

        s << ::xml_schema::as_double(*i.median ());
      }

      // unit
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.unit ())
        {
          const numeric_range::unit_type& x (*i.unit ());
          if (typeid (numeric_range::unit_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "unit",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "unit",
              "",
              false, false, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, numeric_range >
    _xsd_numeric_range_type_serializer_init (
      "numeric-range",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const token_range& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // token
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (token_range::token_const_iterator
             b (i.token ().begin ()), n (i.token ().end ());
             b != n; ++b)
        {
          if (typeid (token_range::token_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "token",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "token",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, token_range >
    _xsd_token_range_type_serializer_init (
      "token-range",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const citation_ref_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // citation-ref
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (citation_ref_list::citation_ref_const_iterator
             b (i.citation_ref ().begin ()), n (i.citation_ref ().end ());
             b != n; ++b)
        {
          if (typeid (citation_ref_list::citation_ref_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "citation-ref",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "citation-ref",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, citation_ref_list >
    _xsd_citation_ref_list_type_serializer_init (
      "citation-ref-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const treatment_plan_definition_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // treatment-plan
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (treatment_plan_definition_list::treatment_plan_const_iterator
             b (i.treatment_plan ().begin ()), n (i.treatment_plan ().end ());
             b != n; ++b)
        {
          if (typeid (treatment_plan_definition_list::treatment_plan_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "treatment-plan",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "treatment-plan",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, treatment_plan_definition_list >
    _xsd_treatment_plan_definition_list_type_serializer_init (
      "treatment-plan-definition-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const treatment_plan& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const treatment_plan::id_type& x (i.id ());
        if (typeid (treatment_plan::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // common-name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.common_name ())
        {
          const treatment_plan::common_name_type& x (*i.common_name ());
          if (typeid (treatment_plan::common_name_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "common-name",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "common-name",
              "",
              false, false, e, x);
        }
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const treatment_plan::description_type& x (i.description ());
        if (typeid (treatment_plan::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // required-equipment
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const treatment_plan::required_equipment_type& x (i.required_equipment ());
        if (typeid (treatment_plan::required_equipment_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "required-equipment",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "required-equipment",
            "",
            false, false, e, x);
      }

      // references
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const treatment_plan::references_type& x (i.references ());
        if (typeid (treatment_plan::references_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "references",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "references",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, treatment_plan >
    _xsd_treatment_plan_type_serializer_init (
      "treatment-plan",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const equipment_ref_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // equipment-refs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (equipment_ref_list::equipment_refs_const_iterator
             b (i.equipment_refs ().begin ()), n (i.equipment_refs ().end ());
             b != n; ++b)
        {
          if (typeid (equipment_ref_list::equipment_refs_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "equipment-refs",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "equipment-refs",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, equipment_ref_list >
    _xsd_equipment_ref_list_type_serializer_init (
      "equipment-ref-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const medical_reference_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // citations
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_reference_list::citations_type& x (i.citations ());
        if (typeid (medical_reference_list::citations_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "citations",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "citations",
            "",
            false, false, e, x);
      }

      // cpgs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_reference_list::cpgs_type& x (i.cpgs ());
        if (typeid (medical_reference_list::cpgs_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "cpgs",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "cpgs",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, medical_reference_list >
    _xsd_medical_reference_list_type_serializer_init (
      "medical-reference-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const cpg_ref_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // cpg-ref
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (cpg_ref_list::cpg_ref_const_iterator
             b (i.cpg_ref ().begin ()), n (i.cpg_ref ().end ());
             b != n; ++b)
        {
          if (typeid (cpg_ref_list::cpg_ref_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "cpg-ref",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "cpg-ref",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, cpg_ref_list >
    _xsd_cpg_ref_list_type_serializer_init (
      "cpg-ref-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const cpg_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // cpg
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (cpg_list::cpg_const_iterator
             b (i.cpg ().begin ()), n (i.cpg ().end ());
             b != n; ++b)
        {
          if (typeid (cpg_list::cpg_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "cpg",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "cpg",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, cpg_list >
    _xsd_cpg_list_type_serializer_init (
      "cpg-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const cpg& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const cpg::name_type& x (i.name ());
        if (typeid (cpg::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const cpg::description_type& x (i.description ());
        if (typeid (cpg::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // citation-ref
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const cpg::citation_ref_type& x (i.citation_ref ());
        if (typeid (cpg::citation_ref_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "citation-ref",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "citation-ref",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, cpg >
    _xsd_cpg_type_serializer_init (
      "cpg",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const learning_objective_reference_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // objective
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (learning_objective_reference_list::objective_const_iterator
             b (i.objective ().begin ()), n (i.objective ().end ());
             b != n; ++b)
        {
          if (typeid (learning_objective_reference_list::objective_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "objective",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "objective",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, learning_objective_reference_list >
    _xsd_learning_objective_reference_list_type_serializer_init (
      "learning-objective-reference-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const treatment_plan_ref_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // treatment-plan
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (treatment_plan_ref_list::treatment_plan_const_iterator
             b (i.treatment_plan ().begin ()), n (i.treatment_plan ().end ());
             b != n; ++b)
        {
          if (typeid (treatment_plan_ref_list::treatment_plan_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "treatment-plan",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "treatment-plan",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, treatment_plan_ref_list >
    _xsd_treatment_plan_ref_list_type_serializer_init (
      "treatment-plan-ref-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const injury_profile_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // injury-profile
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (injury_profile_list::injury_profile_const_iterator
             b (i.injury_profile ().begin ()), n (i.injury_profile ().end ());
             b != n; ++b)
        {
          if (typeid (injury_profile_list::injury_profile_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "injury-profile",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "injury-profile",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, injury_profile_list >
    _xsd_injury_profile_list_type_serializer_init (
      "injury-profile-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const injury_profile& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const injury_profile::id_type& x (i.id ());
        if (typeid (injury_profile::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const injury_profile::name_type& x (i.name ());
        if (typeid (injury_profile::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // physiology-state
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.physiology_state ())
        {
          const injury_profile::physiology_state_type& x (*i.physiology_state ());
          if (typeid (injury_profile::physiology_state_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "physiology-state",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "physiology-state",
              "",
              false, false, e, x);
        }
      }

      // injuries
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (injury_profile::injuries_const_iterator
             b (i.injuries ().begin ()), n (i.injuries ().end ());
             b != n; ++b)
        {
          if (typeid (injury_profile::injuries_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "injuries",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "injuries",
              "",
              false, false, e, *b);
        }
      }

      // treatments
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const injury_profile::treatments_type& x (i.treatments ());
        if (typeid (injury_profile::treatments_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "treatments",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "treatments",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, injury_profile >
    _xsd_injury_profile_type_serializer_init (
      "injury-profile",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const injury_profile_ref_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // injury-profile
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (injury_profile_ref_list::injury_profile_const_iterator
             b (i.injury_profile ().begin ()), n (i.injury_profile ().end ());
             b != n; ++b)
        {
          if (typeid (injury_profile_ref_list::injury_profile_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "injury-profile",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "injury-profile",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, injury_profile_ref_list >
    _xsd_injury_profile_ref_list_type_serializer_init (
      "injury-profile-ref-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const injury_occurance_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const injury_occurance_list::id_type& x (i.id ());
        if (typeid (injury_occurance_list::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // location
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const injury_occurance_list::location_type& x (i.location ());
        if (typeid (injury_occurance_list::location_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "location",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "location",
            "",
            false, false, e, x);
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const injury_occurance_list::description_type& x (i.description ());
        if (typeid (injury_occurance_list::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // severity
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const injury_occurance_list::severity_type& x (i.severity ());
        if (typeid (injury_occurance_list::severity_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "severity",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "severity",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, injury_occurance_list >
    _xsd_injury_occurance_list_type_serializer_init (
      "injury-occurance-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const medical_scenario_syllabus& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // learning-objectives
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_scenario_syllabus::learning_objectives_type& x (i.learning_objectives ());
        if (typeid (medical_scenario_syllabus::learning_objectives_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "learning-objectives",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "learning-objectives",
            "",
            false, false, e, x);
      }

      // learning-assessments
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_scenario_syllabus::learning_assessments_type& x (i.learning_assessments ());
        if (typeid (medical_scenario_syllabus::learning_assessments_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "learning-assessments",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "learning-assessments",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, medical_scenario_syllabus >
    _xsd_medical_scenario_syllabus_type_serializer_init (
      "medical-scenario-syllabus",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const learning_objective_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // objective
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (learning_objective_list::objective_const_iterator
             b (i.objective ().begin ()), n (i.objective ().end ());
             b != n; ++b)
        {
          if (typeid (learning_objective_list::objective_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "objective",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "objective",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, learning_objective_list >
    _xsd_learning_objective_list_type_serializer_init (
      "learning-objective-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const learning_objective& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const learning_objective::id_type& x (i.id ());
        if (typeid (learning_objective::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const learning_objective::name_type& x (i.name ());
        if (typeid (learning_objective::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const learning_objective::description_type& x (i.description ());
        if (typeid (learning_objective::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // references
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const learning_objective::references_type& x (i.references ());
        if (typeid (learning_objective::references_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "references",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "references",
            "",
            false, false, e, x);
      }

      // relates-to
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "relates-to",
            e));

        s << i.relates_to ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, learning_objective >
    _xsd_learning_objective_type_serializer_init (
      "learning-objective",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const assessment_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // total-points
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "total-points",
            e));

        s << i.total_points ();
      }

      // assessment
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (assessment_list::assessment_const_iterator
             b (i.assessment ().begin ()), n (i.assessment ().end ());
             b != n; ++b)
        {
          if (typeid (assessment_list::assessment_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "assessment",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "assessment",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, assessment_list >
    _xsd_assessment_list_type_serializer_init (
      "assessment-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const assessment& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const assessment::id_type& x (i.id ());
        if (typeid (assessment::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // objective-id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const assessment::objective_id_type& x (i.objective_id ());
        if (typeid (assessment::objective_id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "objective-id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "objective-id",
            "",
            false, false, e, x);
      }

      // points-avaiable
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "points-avaiable",
            e));

        s << i.points_avaiable ();
      }

      // criteria
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const assessment::criteria_type& x (i.criteria ());
        if (typeid (assessment::criteria_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "criteria",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "criteria",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, assessment >
    _xsd_assessment_type_serializer_init (
      "assessment",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const medical_scenario& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_scenario::id_type& x (i.id ());
        if (typeid (medical_scenario::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // roles
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_scenario::roles_type& x (i.roles ());
        if (typeid (medical_scenario::roles_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "roles",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "roles",
            "",
            false, false, e, x);
      }

      // props
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_scenario::props_type& x (i.props ());
        if (typeid (medical_scenario::props_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "props",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "props",
            "",
            false, false, e, x);
      }

      // training-script
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_scenario::training_script_type& x (i.training_script ());
        if (typeid (medical_scenario::training_script_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "training-script",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "training-script",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, medical_scenario >
    _xsd_medical_scenario_type_serializer_init (
      "medical-scenario",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const role_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // role
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (role_list::role_const_iterator
             b (i.role ().begin ()), n (i.role ().end ());
             b != n; ++b)
        {
          if (typeid (role_list::role_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "role",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "role",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, role_list >
    _xsd_role_list_type_serializer_init (
      "role-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const role& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // short-name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const role::short_name_type& x (i.short_name ());
        if (typeid (role::short_name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "short-name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "short-name",
            "",
            false, false, e, x);
      }

      // unit-id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const role::unit_id_type& x (i.unit_id ());
        if (typeid (role::unit_id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "unit-id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "unit-id",
            "",
            false, false, e, x);
      }

      // injury-profile-id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.injury_profile_id ())
        {
          const role::injury_profile_id_type& x (*i.injury_profile_id ());
          if (typeid (role::injury_profile_id_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "injury-profile-id",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "injury-profile-id",
              "",
              false, false, e, x);
        }
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const role::description_type& x (i.description ());
        if (typeid (role::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, role >
    _xsd_role_type_serializer_init (
      "role",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const prop_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // prop
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (prop_list::prop_const_iterator
             b (i.prop ().begin ()), n (i.prop ().end ());
             b != n; ++b)
        {
          if (typeid (prop_list::prop_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "prop",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "prop",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, prop_list >
    _xsd_prop_list_type_serializer_init (
      "prop-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const prop& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // short-name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const prop::short_name_type& x (i.short_name ());
        if (typeid (prop::short_name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "short-name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "short-name",
            "",
            false, false, e, x);
      }

      // equipment-id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const prop::equipment_id_type& x (i.equipment_id ());
        if (typeid (prop::equipment_id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "equipment-id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "equipment-id",
            "",
            false, false, e, x);
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const prop::description_type& x (i.description ());
        if (typeid (prop::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, prop >
    _xsd_prop_type_serializer_init (
      "prop",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const scene_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // scene
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (scene_list::scene_const_iterator
             b (i.scene ().begin ()), n (i.scene ().end ());
             b != n; ++b)
        {
          if (typeid (scene_list::scene_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "scene",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "scene",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, scene_list >
    _xsd_scene_list_type_serializer_init (
      "scene-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const scene& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // location-id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const scene::location_id_type& x (i.location_id ());
        if (typeid (scene::location_id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "location-id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "location-id",
            "",
            false, false, e, x);
      }

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const scene::name_type& x (i.name ());
        if (typeid (scene::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const scene::description_type& x (i.description ());
        if (typeid (scene::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // time-of-day
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const scene::time_of_day_type& x (i.time_of_day ());
        if (typeid (scene::time_of_day_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "time-of-day",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "time-of-day",
            "",
            false, false, e, x);
      }

      // time-in-simulation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "time-in-simulation",
            e));

        s << i.time_in_simulation ();
      }

      // events
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const scene::events_type& x (i.events ());
        if (typeid (scene::events_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "events",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "events",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, scene >
    _xsd_scene_type_serializer_init (
      "scene",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const event_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // event
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (event_list::event_const_iterator
             b (i.event ().begin ()), n (i.event ().end ());
             b != n; ++b)
        {
          if (typeid (event_list::event_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "event",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "event",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, event_list >
    _xsd_event_list_type_serializer_init (
      "event-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const event& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // category
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const event::category_type& x (i.category ());
        if (typeid (event::category_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "category",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "category",
            "",
            false, false, e, x);
      }

      // fidelity
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const event::fidelity_type& x (i.fidelity ());
        if (typeid (event::fidelity_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "fidelity",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "fidelity",
            "",
            false, false, e, x);
      }

      // details
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const event::details_type& x (i.details ());
        if (typeid (event::details_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "details",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "details",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, event >
    _xsd_event_type_serializer_init (
      "event",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const event_category_enum& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const event_category_enum& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const event_category_enum& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, event_category_enum >
    _xsd_event_category_enum_type_serializer_init (
      "event-category-enum",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const event_fidelity_enum& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const event_fidelity_enum& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const event_fidelity_enum& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, event_fidelity_enum >
    _xsd_event_fidelity_enum_type_serializer_init (
      "event-fidelity-enum",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const citation_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // citation
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (citation_list::citation_const_iterator
             b (i.citation ().begin ()), n (i.citation ().end ());
             b != n; ++b)
        {
          if (typeid (citation_list::citation_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "citation",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "citation",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, citation_list >
    _xsd_citation_list_type_serializer_init (
      "citation-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const citation& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // uuid
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const citation::uuid_type& x (i.uuid ());
        if (typeid (citation::uuid_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "uuid",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "uuid",
            "",
            false, false, e, x);
      }

      // authors
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (citation::authors_const_iterator
             b (i.authors ().begin ()), n (i.authors ().end ());
             b != n; ++b)
        {
          if (typeid (citation::authors_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "authors",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "authors",
              "",
              false, false, e, *b);
        }
      }

      // title
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const citation::title_type& x (i.title ());
        if (typeid (citation::title_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "title",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "title",
            "",
            false, false, e, x);
      }

      // date
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const citation::date_type& x (i.date ());
        if (typeid (citation::date_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "date",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "date",
            "",
            false, false, e, x);
      }

      // page
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.page ())
        {
          const citation::page_type& x (*i.page ());
          if (typeid (citation::page_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "page",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "page",
              "",
              false, false, e, x);
        }
      }

      // accessed
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.accessed ())
        {
          const citation::accessed_type& x (*i.accessed ());
          if (typeid (citation::accessed_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "accessed",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "accessed",
              "",
              false, false, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, citation >
    _xsd_citation_type_serializer_init (
      "citation",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const properties_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // property
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (properties_list::property_const_iterator
             b (i.property ().begin ()), n (i.property ().end ());
             b != n; ++b)
        {
          if (typeid (properties_list::property_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "property",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "property",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, properties_list >
    _xsd_properties_list_type_serializer_init (
      "properties-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const property& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const property::name_type& x (i.name ());
        if (typeid (property::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // type
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const property::type_type& x (i.type ());
        if (typeid (property::type_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "type",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "type",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, property >
    _xsd_property_type_serializer_init (
      "property",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const relates_to& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // treatment-plans
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const relates_to::treatment_plans_type& x (i.treatment_plans ());
        if (typeid (relates_to::treatment_plans_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "treatment-plans",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "treatment-plans",
            "",
            false, false, e, x);
      }

      // injury-profiles
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const relates_to::injury_profiles_type& x (i.injury_profiles ());
        if (typeid (relates_to::injury_profiles_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "injury-profiles",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "injury-profiles",
            "",
            false, false, e, x);
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

