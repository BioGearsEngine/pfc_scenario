// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef MSDL_COMPLEX_TYPES_1_0_0_HXX
#define MSDL_COMPLEX_TYPES_1_0_0_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace msdl_1
{
  class AnchorPointType;
  class AnchorPointsType;
  class AnchorType;
  class AreaSymbolModifiersType;
  class AssociatedOverlaysType;
  class AssociationsType;
  class AssociationType;
  class BoundarySymbolModifiersType;
  class CloudCoverItemsType;
  class CommandRelationType;
  class CommunicationNetInstancesType;
  class CommunicationNetInstanceType;
  class CommunicationNetReferencesType;
  class CommunicationNetReferenceType;
  class CoordinateDataStandardType;
  class CoordinatesType;
  class CoordinatePointType;
  class EnvironmentType;
  class EquipmentDispositionType;
  class EquipmentItemType;
  class EquipmentModelType;
  class EquipmentRelationsType;
  class EquipmentSymbolModifiersType;
  class EquipmentType;
  class ForceRelationDataType;
  class ForceRelationType;
  class ForceSidesType;
  class ForceSideType;
  class FormationDataType;
  class FormationPositionType;
  class GCCType;
  class GDCType;
  class InstallationsType;
  class InstallationSymbolModifiersType;
  class InstallationType;
  class LightItemsType;
  class LineSymbolModifiersType;
  class METOCDispositionType;
  class METOCGraphicType;
  class METOCType;
  class MilitaryScenarioType;
  class MGRSType;
  class MOOTWDispositionType;
  class MOOTWGraphicsType;
  class MOOTWGraphicType;
  class MOOTWSymbolModifiersType;
  class NBCEventSymbolModifiersType;
  class OptionsType;
  class OrganicRelationDataType;
  class OrganicRelationType;
  class OrganizationDetailType;
  class OrganizationsType;
  class OverlayHandlesType;
  class OverlaysType;
  class OverlayType;
  class OwnerType;
  class OwnerDataType;
  class OwnFormationType;
  class PointSymbolModifiersType;
  class RectangleAreaType;
  class ScenarioDataStandardsType;
  class ScenarioWeatherType;
  class StatusType;
  class SupportRelationsType;
  class SupportRelationType;
  class SymbolClassModifiersType;
  class SymbologyDataStandardType;
  class TacticalGraphicsType;
  class TacticalGraphicType;
  class TaskSymbolModifiersType;
  class UnitDispositionType;
  class UnitModelType;
  class UnitRelationsType;
  class UnitsType;
  class UnitSymbolModifiersType;
  class UnitType;
  class UTMType;
  class VisibilityItemsType;
  class WindItemsType;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "msdlcodes_1.0.0.hxx"

#include "msdlsimpletypes_1.0.0.hxx"

#include "extern/modelid_v2006_final.hxx"

#include "extern/jc3iedmmeteorological.hxx"

namespace msdl_1
{
  class AnchorPointType: public ::xml_schema::type
  {
    public:
    // AnchorChoice
    //
    typedef ::msdl_1::enumAnchorPointType AnchorChoice_type;
    typedef ::xsd::cxx::tree::traits< AnchorChoice_type, char > AnchorChoice_traits;

    const AnchorChoice_type&
    AnchorChoice () const;

    AnchorChoice_type&
    AnchorChoice ();

    void
    AnchorChoice (const AnchorChoice_type& x);

    void
    AnchorChoice (::std::unique_ptr< AnchorChoice_type > p);

    // Anchor
    //
    typedef ::msdl_1::AnchorType Anchor_type;
    typedef ::xsd::cxx::tree::traits< Anchor_type, char > Anchor_traits;

    const Anchor_type&
    Anchor () const;

    Anchor_type&
    Anchor ();

    void
    Anchor (const Anchor_type& x);

    void
    Anchor (::std::unique_ptr< Anchor_type > p);

    // Constructors.
    //
    AnchorPointType (const AnchorChoice_type&,
                     const Anchor_type&);

    AnchorPointType (const AnchorChoice_type&,
                     ::std::unique_ptr< Anchor_type >);

    AnchorPointType (::std::unique_ptr< AnchorChoice_type >,
                     ::std::unique_ptr< Anchor_type >);

    AnchorPointType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    AnchorPointType (const AnchorPointType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual AnchorPointType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AnchorPointType&
    operator= (const AnchorPointType& x);

    virtual 
    ~AnchorPointType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< AnchorChoice_type > AnchorChoice_;
    ::xsd::cxx::tree::one< Anchor_type > Anchor_;
  };

  class AnchorPointsType: public ::xml_schema::type
  {
    public:
    // AnchorPoint
    //
    typedef ::msdl_1::AnchorPointType AnchorPoint_type;
    typedef ::xsd::cxx::tree::sequence< AnchorPoint_type > AnchorPoint_sequence;
    typedef AnchorPoint_sequence::iterator AnchorPoint_iterator;
    typedef AnchorPoint_sequence::const_iterator AnchorPoint_const_iterator;
    typedef ::xsd::cxx::tree::traits< AnchorPoint_type, char > AnchorPoint_traits;

    const AnchorPoint_sequence&
    AnchorPoint () const;

    AnchorPoint_sequence&
    AnchorPoint ();

    void
    AnchorPoint (const AnchorPoint_sequence& s);

    // Constructors.
    //
    AnchorPointsType ();

    AnchorPointsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    AnchorPointsType (const AnchorPointsType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual AnchorPointsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AnchorPointsType&
    operator= (const AnchorPointsType& x);

    virtual 
    ~AnchorPointsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    AnchorPoint_sequence AnchorPoint_;
  };

  class AnchorType: public ::xml_schema::type
  {
    public:
    // Location
    //
    typedef ::msdl_1::CoordinatesType Location_type;
    typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
    typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

    const Location_optional&
    Location () const;

    Location_optional&
    Location ();

    void
    Location (const Location_type& x);

    void
    Location (const Location_optional& x);

    void
    Location (::std::unique_ptr< Location_type > p);

    // PointSymbolHandle
    //
    typedef ::msdl_1::patternUUIDRef32 PointSymbolHandle_type;
    typedef ::xsd::cxx::tree::optional< PointSymbolHandle_type > PointSymbolHandle_optional;
    typedef ::xsd::cxx::tree::traits< PointSymbolHandle_type, char > PointSymbolHandle_traits;

    const PointSymbolHandle_optional&
    PointSymbolHandle () const;

    PointSymbolHandle_optional&
    PointSymbolHandle ();

    void
    PointSymbolHandle (const PointSymbolHandle_type& x);

    void
    PointSymbolHandle (const PointSymbolHandle_optional& x);

    void
    PointSymbolHandle (::std::unique_ptr< PointSymbolHandle_type > p);

    // Constructors.
    //
    AnchorType ();

    AnchorType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    AnchorType (const AnchorType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual AnchorType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AnchorType&
    operator= (const AnchorType& x);

    virtual 
    ~AnchorType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Location_optional Location_;
    PointSymbolHandle_optional PointSymbolHandle_;
  };

  class AreaSymbolModifiersType: public ::xml_schema::type
  {
    public:
    // Echelon
    //
    typedef ::msdl_1::enumEchelon Echelon_type;
    typedef ::xsd::cxx::tree::optional< Echelon_type > Echelon_optional;
    typedef ::xsd::cxx::tree::traits< Echelon_type, char > Echelon_traits;

    const Echelon_optional&
    Echelon () const;

    Echelon_optional&
    Echelon ();

    void
    Echelon (const Echelon_type& x);

    void
    Echelon (const Echelon_optional& x);

    void
    Echelon (::std::unique_ptr< Echelon_type > p);

    // AdditionalInfo
    //
    typedef ::msdl_1::text20 AdditionalInfo_type;
    typedef ::xsd::cxx::tree::optional< AdditionalInfo_type > AdditionalInfo_optional;
    typedef ::xsd::cxx::tree::traits< AdditionalInfo_type, char > AdditionalInfo_traits;

    const AdditionalInfo_optional&
    AdditionalInfo () const;

    AdditionalInfo_optional&
    AdditionalInfo ();

    void
    AdditionalInfo (const AdditionalInfo_type& x);

    void
    AdditionalInfo (const AdditionalInfo_optional& x);

    void
    AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > p);

    // AdditionalInfo1
    //
    typedef ::msdl_1::text20 AdditionalInfo1_type;
    typedef ::xsd::cxx::tree::optional< AdditionalInfo1_type > AdditionalInfo1_optional;
    typedef ::xsd::cxx::tree::traits< AdditionalInfo1_type, char > AdditionalInfo1_traits;

    const AdditionalInfo1_optional&
    AdditionalInfo1 () const;

    AdditionalInfo1_optional&
    AdditionalInfo1 ();

    void
    AdditionalInfo1 (const AdditionalInfo1_type& x);

    void
    AdditionalInfo1 (const AdditionalInfo1_optional& x);

    void
    AdditionalInfo1 (::std::unique_ptr< AdditionalInfo1_type > p);

    // AdditionalInfo2
    //
    typedef ::msdl_1::text20 AdditionalInfo2_type;
    typedef ::xsd::cxx::tree::optional< AdditionalInfo2_type > AdditionalInfo2_optional;
    typedef ::xsd::cxx::tree::traits< AdditionalInfo2_type, char > AdditionalInfo2_traits;

    const AdditionalInfo2_optional&
    AdditionalInfo2 () const;

    AdditionalInfo2_optional&
    AdditionalInfo2 ();

    void
    AdditionalInfo2 (const AdditionalInfo2_type& x);

    void
    AdditionalInfo2 (const AdditionalInfo2_optional& x);

    void
    AdditionalInfo2 (::std::unique_ptr< AdditionalInfo2_type > p);

    // UniqueDesignation
    //
    typedef ::msdl_1::text21 UniqueDesignation_type;
    typedef ::xsd::cxx::tree::optional< UniqueDesignation_type > UniqueDesignation_optional;
    typedef ::xsd::cxx::tree::traits< UniqueDesignation_type, char > UniqueDesignation_traits;

    const UniqueDesignation_optional&
    UniqueDesignation () const;

    UniqueDesignation_optional&
    UniqueDesignation ();

    void
    UniqueDesignation (const UniqueDesignation_type& x);

    void
    UniqueDesignation (const UniqueDesignation_optional& x);

    void
    UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > p);

    // DateTimeGroup
    //
    typedef ::msdl_1::patternTimeDTGRelative20 DateTimeGroup_type;
    typedef ::xsd::cxx::tree::optional< DateTimeGroup_type > DateTimeGroup_optional;
    typedef ::xsd::cxx::tree::traits< DateTimeGroup_type, char > DateTimeGroup_traits;

    const DateTimeGroup_optional&
    DateTimeGroup () const;

    DateTimeGroup_optional&
    DateTimeGroup ();

    void
    DateTimeGroup (const DateTimeGroup_type& x);

    void
    DateTimeGroup (const DateTimeGroup_optional& x);

    void
    DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > p);

    // DateTimeGroup1
    //
    typedef ::msdl_1::patternTimeDTGRelative20 DateTimeGroup1_type;
    typedef ::xsd::cxx::tree::optional< DateTimeGroup1_type > DateTimeGroup1_optional;
    typedef ::xsd::cxx::tree::traits< DateTimeGroup1_type, char > DateTimeGroup1_traits;

    const DateTimeGroup1_optional&
    DateTimeGroup1 () const;

    DateTimeGroup1_optional&
    DateTimeGroup1 ();

    void
    DateTimeGroup1 (const DateTimeGroup1_type& x);

    void
    DateTimeGroup1 (const DateTimeGroup1_optional& x);

    void
    DateTimeGroup1 (::std::unique_ptr< DateTimeGroup1_type > p);

    // Constructors.
    //
    AreaSymbolModifiersType ();

    AreaSymbolModifiersType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    AreaSymbolModifiersType (const AreaSymbolModifiersType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual AreaSymbolModifiersType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AreaSymbolModifiersType&
    operator= (const AreaSymbolModifiersType& x);

    virtual 
    ~AreaSymbolModifiersType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Echelon_optional Echelon_;
    AdditionalInfo_optional AdditionalInfo_;
    AdditionalInfo1_optional AdditionalInfo1_;
    AdditionalInfo2_optional AdditionalInfo2_;
    UniqueDesignation_optional UniqueDesignation_;
    DateTimeGroup_optional DateTimeGroup_;
    DateTimeGroup1_optional DateTimeGroup1_;
  };

  class AssociatedOverlaysType: public ::xml_schema::type
  {
    public:
    // OverlayHandles
    //
    typedef ::msdl_1::OverlayHandlesType OverlayHandles_type;
    typedef ::xsd::cxx::tree::traits< OverlayHandles_type, char > OverlayHandles_traits;

    const OverlayHandles_type&
    OverlayHandles () const;

    OverlayHandles_type&
    OverlayHandles ();

    void
    OverlayHandles (const OverlayHandles_type& x);

    void
    OverlayHandles (::std::unique_ptr< OverlayHandles_type > p);

    // SourceOverlayType
    //
    typedef ::msdl_1::enumOverlayType SourceOverlayType_type;
    typedef ::xsd::cxx::tree::optional< SourceOverlayType_type > SourceOverlayType_optional;
    typedef ::xsd::cxx::tree::traits< SourceOverlayType_type, char > SourceOverlayType_traits;

    const SourceOverlayType_optional&
    SourceOverlayType () const;

    SourceOverlayType_optional&
    SourceOverlayType ();

    void
    SourceOverlayType (const SourceOverlayType_type& x);

    void
    SourceOverlayType (const SourceOverlayType_optional& x);

    void
    SourceOverlayType (::std::unique_ptr< SourceOverlayType_type > p);

    // Constructors.
    //
    AssociatedOverlaysType (const OverlayHandles_type&);

    AssociatedOverlaysType (::std::unique_ptr< OverlayHandles_type >);

    AssociatedOverlaysType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    AssociatedOverlaysType (const AssociatedOverlaysType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual AssociatedOverlaysType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AssociatedOverlaysType&
    operator= (const AssociatedOverlaysType& x);

    virtual 
    ~AssociatedOverlaysType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< OverlayHandles_type > OverlayHandles_;
    SourceOverlayType_optional SourceOverlayType_;
  };

  class AssociationsType: public ::xml_schema::type
  {
    public:
    // Association
    //
    typedef ::msdl_1::AssociationType Association_type;
    typedef ::xsd::cxx::tree::sequence< Association_type > Association_sequence;
    typedef Association_sequence::iterator Association_iterator;
    typedef Association_sequence::const_iterator Association_const_iterator;
    typedef ::xsd::cxx::tree::traits< Association_type, char > Association_traits;

    const Association_sequence&
    Association () const;

    Association_sequence&
    Association ();

    void
    Association (const Association_sequence& s);

    // Constructors.
    //
    AssociationsType ();

    AssociationsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    AssociationsType (const AssociationsType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual AssociationsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AssociationsType&
    operator= (const AssociationsType& x);

    virtual 
    ~AssociationsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Association_sequence Association_;
  };

  class AssociationType: public ::xml_schema::type
  {
    public:
    // AffiliateHandle
    //
    typedef ::msdl_1::patternUUIDRef32 AffiliateHandle_type;
    typedef ::xsd::cxx::tree::traits< AffiliateHandle_type, char > AffiliateHandle_traits;

    const AffiliateHandle_type&
    AffiliateHandle () const;

    AffiliateHandle_type&
    AffiliateHandle ();

    void
    AffiliateHandle (const AffiliateHandle_type& x);

    void
    AffiliateHandle (::std::unique_ptr< AffiliateHandle_type > p);

    // Relationship
    //
    typedef ::oo_2_0::ObjectItemHostilityStatusCode Relationship_type;
    typedef ::xsd::cxx::tree::traits< Relationship_type, char > Relationship_traits;

    const Relationship_type&
    Relationship () const;

    Relationship_type&
    Relationship ();

    void
    Relationship (const Relationship_type& x);

    void
    Relationship (::std::unique_ptr< Relationship_type > p);

    // Constructors.
    //
    AssociationType (const AffiliateHandle_type&,
                     const Relationship_type&);

    AssociationType (::std::unique_ptr< AffiliateHandle_type >,
                     ::std::unique_ptr< Relationship_type >);

    AssociationType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    AssociationType (const AssociationType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual AssociationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AssociationType&
    operator= (const AssociationType& x);

    virtual 
    ~AssociationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< AffiliateHandle_type > AffiliateHandle_;
    ::xsd::cxx::tree::one< Relationship_type > Relationship_;
  };

  class BoundarySymbolModifiersType: public ::xml_schema::type
  {
    public:
    // Echelon
    //
    typedef ::msdl_1::enumEchelon Echelon_type;
    typedef ::xsd::cxx::tree::optional< Echelon_type > Echelon_optional;
    typedef ::xsd::cxx::tree::traits< Echelon_type, char > Echelon_traits;

    const Echelon_optional&
    Echelon () const;

    Echelon_optional&
    Echelon ();

    void
    Echelon (const Echelon_type& x);

    void
    Echelon (const Echelon_optional& x);

    void
    Echelon (::std::unique_ptr< Echelon_type > p);

    // UniqueDesignation
    //
    typedef ::msdl_1::text21 UniqueDesignation_type;
    typedef ::xsd::cxx::tree::optional< UniqueDesignation_type > UniqueDesignation_optional;
    typedef ::xsd::cxx::tree::traits< UniqueDesignation_type, char > UniqueDesignation_traits;

    const UniqueDesignation_optional&
    UniqueDesignation () const;

    UniqueDesignation_optional&
    UniqueDesignation ();

    void
    UniqueDesignation (const UniqueDesignation_type& x);

    void
    UniqueDesignation (const UniqueDesignation_optional& x);

    void
    UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > p);

    // UniqueDesignation1
    //
    typedef ::msdl_1::text21 UniqueDesignation1_type;
    typedef ::xsd::cxx::tree::optional< UniqueDesignation1_type > UniqueDesignation1_optional;
    typedef ::xsd::cxx::tree::traits< UniqueDesignation1_type, char > UniqueDesignation1_traits;

    const UniqueDesignation1_optional&
    UniqueDesignation1 () const;

    UniqueDesignation1_optional&
    UniqueDesignation1 ();

    void
    UniqueDesignation1 (const UniqueDesignation1_type& x);

    void
    UniqueDesignation1 (const UniqueDesignation1_optional& x);

    void
    UniqueDesignation1 (::std::unique_ptr< UniqueDesignation1_type > p);

    // Constructors.
    //
    BoundarySymbolModifiersType ();

    BoundarySymbolModifiersType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    BoundarySymbolModifiersType (const BoundarySymbolModifiersType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual BoundarySymbolModifiersType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    BoundarySymbolModifiersType&
    operator= (const BoundarySymbolModifiersType& x);

    virtual 
    ~BoundarySymbolModifiersType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Echelon_optional Echelon_;
    UniqueDesignation_optional UniqueDesignation_;
    UniqueDesignation1_optional UniqueDesignation1_;
  };

  class CloudCoverItemsType: public ::xml_schema::type
  {
    public:
    // CloudCover
    //
    typedef ::oo_2_0::CloudCover CloudCover_type;
    typedef ::xsd::cxx::tree::sequence< CloudCover_type > CloudCover_sequence;
    typedef CloudCover_sequence::iterator CloudCover_iterator;
    typedef CloudCover_sequence::const_iterator CloudCover_const_iterator;
    typedef ::xsd::cxx::tree::traits< CloudCover_type, char > CloudCover_traits;

    const CloudCover_sequence&
    CloudCover () const;

    CloudCover_sequence&
    CloudCover ();

    void
    CloudCover (const CloudCover_sequence& s);

    // Constructors.
    //
    CloudCoverItemsType ();

    CloudCoverItemsType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    CloudCoverItemsType (const CloudCoverItemsType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual CloudCoverItemsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CloudCoverItemsType&
    operator= (const CloudCoverItemsType& x);

    virtual 
    ~CloudCoverItemsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    CloudCover_sequence CloudCover_;
  };

  class CommandRelationType: public ::xml_schema::type
  {
    public:
    // CommandingSuperiorHandle
    //
    typedef ::msdl_1::patternUUIDRef32 CommandingSuperiorHandle_type;
    typedef ::xsd::cxx::tree::traits< CommandingSuperiorHandle_type, char > CommandingSuperiorHandle_traits;

    const CommandingSuperiorHandle_type&
    CommandingSuperiorHandle () const;

    CommandingSuperiorHandle_type&
    CommandingSuperiorHandle ();

    void
    CommandingSuperiorHandle (const CommandingSuperiorHandle_type& x);

    void
    CommandingSuperiorHandle (::std::unique_ptr< CommandingSuperiorHandle_type > p);

    // CommandRelationshipType
    //
    typedef ::msdl_1::enumCommandRelationshipType CommandRelationshipType_type;
    typedef ::xsd::cxx::tree::traits< CommandRelationshipType_type, char > CommandRelationshipType_traits;

    const CommandRelationshipType_type&
    CommandRelationshipType () const;

    CommandRelationshipType_type&
    CommandRelationshipType ();

    void
    CommandRelationshipType (const CommandRelationshipType_type& x);

    void
    CommandRelationshipType (::std::unique_ptr< CommandRelationshipType_type > p);

    // Constructors.
    //
    CommandRelationType (const CommandingSuperiorHandle_type&,
                         const CommandRelationshipType_type&);

    CommandRelationType (::std::unique_ptr< CommandingSuperiorHandle_type >,
                         ::std::unique_ptr< CommandRelationshipType_type >);

    CommandRelationType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    CommandRelationType (const CommandRelationType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual CommandRelationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CommandRelationType&
    operator= (const CommandRelationType& x);

    virtual 
    ~CommandRelationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< CommandingSuperiorHandle_type > CommandingSuperiorHandle_;
    ::xsd::cxx::tree::one< CommandRelationshipType_type > CommandRelationshipType_;
  };

  class CommunicationNetInstancesType: public ::xml_schema::type
  {
    public:
    // CommunicationNetInstance
    //
    typedef ::msdl_1::CommunicationNetInstanceType CommunicationNetInstance_type;
    typedef ::xsd::cxx::tree::sequence< CommunicationNetInstance_type > CommunicationNetInstance_sequence;
    typedef CommunicationNetInstance_sequence::iterator CommunicationNetInstance_iterator;
    typedef CommunicationNetInstance_sequence::const_iterator CommunicationNetInstance_const_iterator;
    typedef ::xsd::cxx::tree::traits< CommunicationNetInstance_type, char > CommunicationNetInstance_traits;

    const CommunicationNetInstance_sequence&
    CommunicationNetInstance () const;

    CommunicationNetInstance_sequence&
    CommunicationNetInstance ();

    void
    CommunicationNetInstance (const CommunicationNetInstance_sequence& s);

    // Constructors.
    //
    CommunicationNetInstancesType ();

    CommunicationNetInstancesType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    CommunicationNetInstancesType (const CommunicationNetInstancesType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual CommunicationNetInstancesType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CommunicationNetInstancesType&
    operator= (const CommunicationNetInstancesType& x);

    virtual 
    ~CommunicationNetInstancesType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    CommunicationNetInstance_sequence CommunicationNetInstance_;
  };

  class CommunicationNetInstanceType: public ::xml_schema::type
  {
    public:
    // CommunicationNetType
    //
    typedef ::msdl_1::enumCommunicationNetType CommunicationNetType_type;
    typedef ::xsd::cxx::tree::optional< CommunicationNetType_type > CommunicationNetType_optional;
    typedef ::xsd::cxx::tree::traits< CommunicationNetType_type, char > CommunicationNetType_traits;

    const CommunicationNetType_optional&
    CommunicationNetType () const;

    CommunicationNetType_optional&
    CommunicationNetType ();

    void
    CommunicationNetType (const CommunicationNetType_type& x);

    void
    CommunicationNetType (const CommunicationNetType_optional& x);

    void
    CommunicationNetType (::std::unique_ptr< CommunicationNetType_type > p);

    // CommunicationNetId
    //
    typedef ::msdl_1::textIdentifier64 CommunicationNetId_type;
    typedef ::xsd::cxx::tree::traits< CommunicationNetId_type, char > CommunicationNetId_traits;

    const CommunicationNetId_type&
    CommunicationNetId () const;

    CommunicationNetId_type&
    CommunicationNetId ();

    void
    CommunicationNetId (const CommunicationNetId_type& x);

    void
    CommunicationNetId (::std::unique_ptr< CommunicationNetId_type > p);

    // CommunicationService
    //
    typedef ::msdl_1::enumCommunicationServiceType CommunicationService_type;
    typedef ::xsd::cxx::tree::traits< CommunicationService_type, char > CommunicationService_traits;

    const CommunicationService_type&
    CommunicationService () const;

    CommunicationService_type&
    CommunicationService ();

    void
    CommunicationService (const CommunicationService_type& x);

    void
    CommunicationService (::std::unique_ptr< CommunicationService_type > p);

    // Constructors.
    //
    CommunicationNetInstanceType (const CommunicationNetId_type&,
                                  const CommunicationService_type&);

    CommunicationNetInstanceType (::std::unique_ptr< CommunicationNetId_type >,
                                  ::std::unique_ptr< CommunicationService_type >);

    CommunicationNetInstanceType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    CommunicationNetInstanceType (const CommunicationNetInstanceType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual CommunicationNetInstanceType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CommunicationNetInstanceType&
    operator= (const CommunicationNetInstanceType& x);

    virtual 
    ~CommunicationNetInstanceType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    CommunicationNetType_optional CommunicationNetType_;
    ::xsd::cxx::tree::one< CommunicationNetId_type > CommunicationNetId_;
    ::xsd::cxx::tree::one< CommunicationService_type > CommunicationService_;
  };

  class CommunicationNetReferencesType: public ::xml_schema::type
  {
    public:
    // CommunicationNetReference
    //
    typedef ::msdl_1::CommunicationNetReferenceType CommunicationNetReference_type;
    typedef ::xsd::cxx::tree::sequence< CommunicationNetReference_type > CommunicationNetReference_sequence;
    typedef CommunicationNetReference_sequence::iterator CommunicationNetReference_iterator;
    typedef CommunicationNetReference_sequence::const_iterator CommunicationNetReference_const_iterator;
    typedef ::xsd::cxx::tree::traits< CommunicationNetReference_type, char > CommunicationNetReference_traits;

    const CommunicationNetReference_sequence&
    CommunicationNetReference () const;

    CommunicationNetReference_sequence&
    CommunicationNetReference ();

    void
    CommunicationNetReference (const CommunicationNetReference_sequence& s);

    // Constructors.
    //
    CommunicationNetReferencesType ();

    CommunicationNetReferencesType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    CommunicationNetReferencesType (const CommunicationNetReferencesType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual CommunicationNetReferencesType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CommunicationNetReferencesType&
    operator= (const CommunicationNetReferencesType& x);

    virtual 
    ~CommunicationNetReferencesType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    CommunicationNetReference_sequence CommunicationNetReference_;
  };

  class CommunicationNetReferenceType: public ::xml_schema::type
  {
    public:
    // CommunicationNetId
    //
    typedef ::msdl_1::textIdentifier64 CommunicationNetId_type;
    typedef ::xsd::cxx::tree::traits< CommunicationNetId_type, char > CommunicationNetId_traits;

    const CommunicationNetId_type&
    CommunicationNetId () const;

    CommunicationNetId_type&
    CommunicationNetId ();

    void
    CommunicationNetId (const CommunicationNetId_type& x);

    void
    CommunicationNetId (::std::unique_ptr< CommunicationNetId_type > p);

    // UnitOwnerHandle
    //
    typedef ::msdl_1::patternUUIDRef32 UnitOwnerHandle_type;
    typedef ::xsd::cxx::tree::traits< UnitOwnerHandle_type, char > UnitOwnerHandle_traits;

    const UnitOwnerHandle_type&
    UnitOwnerHandle () const;

    UnitOwnerHandle_type&
    UnitOwnerHandle ();

    void
    UnitOwnerHandle (const UnitOwnerHandle_type& x);

    void
    UnitOwnerHandle (::std::unique_ptr< UnitOwnerHandle_type > p);

    // Constructors.
    //
    CommunicationNetReferenceType (const CommunicationNetId_type&,
                                   const UnitOwnerHandle_type&);

    CommunicationNetReferenceType (::std::unique_ptr< CommunicationNetId_type >,
                                   ::std::unique_ptr< UnitOwnerHandle_type >);

    CommunicationNetReferenceType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    CommunicationNetReferenceType (const CommunicationNetReferenceType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual CommunicationNetReferenceType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CommunicationNetReferenceType&
    operator= (const CommunicationNetReferenceType& x);

    virtual 
    ~CommunicationNetReferenceType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< CommunicationNetId_type > CommunicationNetId_;
    ::xsd::cxx::tree::one< UnitOwnerHandle_type > UnitOwnerHandle_;
  };

  class CoordinateDataStandardType: public ::xml_schema::type
  {
    public:
    // CoordinateSystemType
    //
    typedef ::msdl_1::enumCoordinateSystemType CoordinateSystemType_type;
    typedef ::xsd::cxx::tree::traits< CoordinateSystemType_type, char > CoordinateSystemType_traits;

    const CoordinateSystemType_type&
    CoordinateSystemType () const;

    CoordinateSystemType_type&
    CoordinateSystemType ();

    void
    CoordinateSystemType (const CoordinateSystemType_type& x);

    void
    CoordinateSystemType (::std::unique_ptr< CoordinateSystemType_type > p);

    // CoordinateSystemDatum
    //
    typedef ::msdl_1::textDatum8 CoordinateSystemDatum_type;
    typedef ::xsd::cxx::tree::traits< CoordinateSystemDatum_type, char > CoordinateSystemDatum_traits;

    const CoordinateSystemDatum_type&
    CoordinateSystemDatum () const;

    CoordinateSystemDatum_type&
    CoordinateSystemDatum ();

    void
    CoordinateSystemDatum (const CoordinateSystemDatum_type& x);

    void
    CoordinateSystemDatum (::std::unique_ptr< CoordinateSystemDatum_type > p);

    // Constructors.
    //
    CoordinateDataStandardType (const CoordinateSystemType_type&,
                                const CoordinateSystemDatum_type&);

    CoordinateDataStandardType (::std::unique_ptr< CoordinateSystemType_type >,
                                ::std::unique_ptr< CoordinateSystemDatum_type >);

    CoordinateDataStandardType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    CoordinateDataStandardType (const CoordinateDataStandardType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual CoordinateDataStandardType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CoordinateDataStandardType&
    operator= (const CoordinateDataStandardType& x);

    virtual 
    ~CoordinateDataStandardType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< CoordinateSystemType_type > CoordinateSystemType_;
    ::xsd::cxx::tree::one< CoordinateSystemDatum_type > CoordinateSystemDatum_;
  };

  class CoordinatesType: public ::xml_schema::type
  {
    public:
    // CoordinateChoice
    //
    typedef ::msdl_1::enumCoordinateSystemType CoordinateChoice_type;
    typedef ::xsd::cxx::tree::traits< CoordinateChoice_type, char > CoordinateChoice_traits;

    const CoordinateChoice_type&
    CoordinateChoice () const;

    CoordinateChoice_type&
    CoordinateChoice ();

    void
    CoordinateChoice (const CoordinateChoice_type& x);

    void
    CoordinateChoice (::std::unique_ptr< CoordinateChoice_type > p);

    // CoordinateData
    //
    typedef ::msdl_1::CoordinatePointType CoordinateData_type;
    typedef ::xsd::cxx::tree::traits< CoordinateData_type, char > CoordinateData_traits;

    const CoordinateData_type&
    CoordinateData () const;

    CoordinateData_type&
    CoordinateData ();

    void
    CoordinateData (const CoordinateData_type& x);

    void
    CoordinateData (::std::unique_ptr< CoordinateData_type > p);

    // Constructors.
    //
    CoordinatesType (const CoordinateChoice_type&,
                     const CoordinateData_type&);

    CoordinatesType (const CoordinateChoice_type&,
                     ::std::unique_ptr< CoordinateData_type >);

    CoordinatesType (::std::unique_ptr< CoordinateChoice_type >,
                     ::std::unique_ptr< CoordinateData_type >);

    CoordinatesType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    CoordinatesType (const CoordinatesType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual CoordinatesType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CoordinatesType&
    operator= (const CoordinatesType& x);

    virtual 
    ~CoordinatesType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< CoordinateChoice_type > CoordinateChoice_;
    ::xsd::cxx::tree::one< CoordinateData_type > CoordinateData_;
  };

  class CoordinatePointType: public ::xml_schema::type
  {
    public:
    // MGRS
    //
    typedef ::msdl_1::MGRSType MGRS_type;
    typedef ::xsd::cxx::tree::optional< MGRS_type > MGRS_optional;
    typedef ::xsd::cxx::tree::traits< MGRS_type, char > MGRS_traits;

    const MGRS_optional&
    MGRS () const;

    MGRS_optional&
    MGRS ();

    void
    MGRS (const MGRS_type& x);

    void
    MGRS (const MGRS_optional& x);

    void
    MGRS (::std::unique_ptr< MGRS_type > p);

    // UTM
    //
    typedef ::msdl_1::UTMType UTM_type;
    typedef ::xsd::cxx::tree::optional< UTM_type > UTM_optional;
    typedef ::xsd::cxx::tree::traits< UTM_type, char > UTM_traits;

    const UTM_optional&
    UTM () const;

    UTM_optional&
    UTM ();

    void
    UTM (const UTM_type& x);

    void
    UTM (const UTM_optional& x);

    void
    UTM (::std::unique_ptr< UTM_type > p);

    // GDC
    //
    typedef ::msdl_1::GDCType GDC_type;
    typedef ::xsd::cxx::tree::optional< GDC_type > GDC_optional;
    typedef ::xsd::cxx::tree::traits< GDC_type, char > GDC_traits;

    const GDC_optional&
    GDC () const;

    GDC_optional&
    GDC ();

    void
    GDC (const GDC_type& x);

    void
    GDC (const GDC_optional& x);

    void
    GDC (::std::unique_ptr< GDC_type > p);

    // GCC
    //
    typedef ::msdl_1::GCCType GCC_type;
    typedef ::xsd::cxx::tree::optional< GCC_type > GCC_optional;
    typedef ::xsd::cxx::tree::traits< GCC_type, char > GCC_traits;

    const GCC_optional&
    GCC () const;

    GCC_optional&
    GCC ();

    void
    GCC (const GCC_type& x);

    void
    GCC (const GCC_optional& x);

    void
    GCC (::std::unique_ptr< GCC_type > p);

    // Constructors.
    //
    CoordinatePointType ();

    CoordinatePointType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    CoordinatePointType (const CoordinatePointType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual CoordinatePointType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CoordinatePointType&
    operator= (const CoordinatePointType& x);

    virtual 
    ~CoordinatePointType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    MGRS_optional MGRS_;
    UTM_optional UTM_;
    GDC_optional GDC_;
    GCC_optional GCC_;
  };

  class EnvironmentType: public ::xml_schema::type
  {
    public:
    // ScenarioTime
    //
    typedef ::msdl_1::patternTimeDTG20 ScenarioTime_type;
    typedef ::xsd::cxx::tree::optional< ScenarioTime_type > ScenarioTime_optional;
    typedef ::xsd::cxx::tree::traits< ScenarioTime_type, char > ScenarioTime_traits;

    const ScenarioTime_optional&
    ScenarioTime () const;

    ScenarioTime_optional&
    ScenarioTime ();

    void
    ScenarioTime (const ScenarioTime_type& x);

    void
    ScenarioTime (const ScenarioTime_optional& x);

    void
    ScenarioTime (::std::unique_ptr< ScenarioTime_type > p);

    // AreaOfInterest
    //
    typedef ::msdl_1::RectangleAreaType AreaOfInterest_type;
    typedef ::xsd::cxx::tree::optional< AreaOfInterest_type > AreaOfInterest_optional;
    typedef ::xsd::cxx::tree::traits< AreaOfInterest_type, char > AreaOfInterest_traits;

    const AreaOfInterest_optional&
    AreaOfInterest () const;

    AreaOfInterest_optional&
    AreaOfInterest ();

    void
    AreaOfInterest (const AreaOfInterest_type& x);

    void
    AreaOfInterest (const AreaOfInterest_optional& x);

    void
    AreaOfInterest (::std::unique_ptr< AreaOfInterest_type > p);

    // ScenarioWeather
    //
    typedef ::msdl_1::ScenarioWeatherType ScenarioWeather_type;
    typedef ::xsd::cxx::tree::optional< ScenarioWeather_type > ScenarioWeather_optional;
    typedef ::xsd::cxx::tree::traits< ScenarioWeather_type, char > ScenarioWeather_traits;

    const ScenarioWeather_optional&
    ScenarioWeather () const;

    ScenarioWeather_optional&
    ScenarioWeather ();

    void
    ScenarioWeather (const ScenarioWeather_type& x);

    void
    ScenarioWeather (const ScenarioWeather_optional& x);

    void
    ScenarioWeather (::std::unique_ptr< ScenarioWeather_type > p);

    // METOC
    //
    typedef ::msdl_1::METOCType METOC_type;
    typedef ::xsd::cxx::tree::optional< METOC_type > METOC_optional;
    typedef ::xsd::cxx::tree::traits< METOC_type, char > METOC_traits;

    const METOC_optional&
    METOC () const;

    METOC_optional&
    METOC ();

    void
    METOC (const METOC_type& x);

    void
    METOC (const METOC_optional& x);

    void
    METOC (::std::unique_ptr< METOC_type > p);

    // Constructors.
    //
    EnvironmentType ();

    EnvironmentType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    EnvironmentType (const EnvironmentType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual EnvironmentType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EnvironmentType&
    operator= (const EnvironmentType& x);

    virtual 
    ~EnvironmentType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ScenarioTime_optional ScenarioTime_;
    AreaOfInterest_optional AreaOfInterest_;
    ScenarioWeather_optional ScenarioWeather_;
    METOC_optional METOC_;
  };

  class EquipmentDispositionType: public ::xml_schema::type
  {
    public:
    // Location
    //
    typedef ::msdl_1::CoordinatesType Location_type;
    typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

    const Location_type&
    Location () const;

    Location_type&
    Location ();

    void
    Location (const Location_type& x);

    void
    Location (::std::unique_ptr< Location_type > p);

    // DirectionOfMovement
    //
    typedef ::msdl_1::floatCompassDegrees3_3 DirectionOfMovement_type;
    typedef ::xsd::cxx::tree::optional< DirectionOfMovement_type > DirectionOfMovement_optional;
    typedef ::xsd::cxx::tree::traits< DirectionOfMovement_type, char > DirectionOfMovement_traits;

    const DirectionOfMovement_optional&
    DirectionOfMovement () const;

    DirectionOfMovement_optional&
    DirectionOfMovement ();

    void
    DirectionOfMovement (const DirectionOfMovement_type& x);

    void
    DirectionOfMovement (const DirectionOfMovement_optional& x);

    void
    DirectionOfMovement (::std::unique_ptr< DirectionOfMovement_type > p);

    // Speed
    //
    typedef ::msdl_1::floatSpeed6_2 Speed_type;
    typedef ::xsd::cxx::tree::optional< Speed_type > Speed_optional;
    typedef ::xsd::cxx::tree::traits< Speed_type, char > Speed_traits;

    const Speed_optional&
    Speed () const;

    Speed_optional&
    Speed ();

    void
    Speed (const Speed_type& x);

    void
    Speed (const Speed_optional& x);

    void
    Speed (::std::unique_ptr< Speed_type > p);

    // FormationPosition
    //
    typedef ::msdl_1::FormationPositionType FormationPosition_type;
    typedef ::xsd::cxx::tree::optional< FormationPosition_type > FormationPosition_optional;
    typedef ::xsd::cxx::tree::traits< FormationPosition_type, char > FormationPosition_traits;

    const FormationPosition_optional&
    FormationPosition () const;

    FormationPosition_optional&
    FormationPosition ();

    void
    FormationPosition (const FormationPosition_type& x);

    void
    FormationPosition (const FormationPosition_optional& x);

    void
    FormationPosition (::std::unique_ptr< FormationPosition_type > p);

    // Constructors.
    //
    EquipmentDispositionType (const Location_type&);

    EquipmentDispositionType (::std::unique_ptr< Location_type >);

    EquipmentDispositionType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    EquipmentDispositionType (const EquipmentDispositionType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual EquipmentDispositionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EquipmentDispositionType&
    operator= (const EquipmentDispositionType& x);

    virtual 
    ~EquipmentDispositionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Location_type > Location_;
    DirectionOfMovement_optional DirectionOfMovement_;
    Speed_optional Speed_;
    FormationPosition_optional FormationPosition_;
  };

  class EquipmentItemType: public ::xml_schema::type
  {
    public:
    // ObjectHandle
    //
    typedef ::msdl_1::patternUUID32 ObjectHandle_type;
    typedef ::xsd::cxx::tree::traits< ObjectHandle_type, char > ObjectHandle_traits;

    const ObjectHandle_type&
    ObjectHandle () const;

    ObjectHandle_type&
    ObjectHandle ();

    void
    ObjectHandle (const ObjectHandle_type& x);

    void
    ObjectHandle (::std::unique_ptr< ObjectHandle_type > p);

    // SymbolIdentifier
    //
    typedef ::msdl_1::patternForceSymbolID15 SymbolIdentifier_type;
    typedef ::xsd::cxx::tree::traits< SymbolIdentifier_type, char > SymbolIdentifier_traits;

    const SymbolIdentifier_type&
    SymbolIdentifier () const;

    SymbolIdentifier_type&
    SymbolIdentifier ();

    void
    SymbolIdentifier (const SymbolIdentifier_type& x);

    void
    SymbolIdentifier (::std::unique_ptr< SymbolIdentifier_type > p);

    // Name
    //
    typedef ::msdl_1::textName255 Name_type;
    typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
    typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

    const Name_optional&
    Name () const;

    Name_optional&
    Name ();

    void
    Name (const Name_type& x);

    void
    Name (const Name_optional& x);

    void
    Name (::std::unique_ptr< Name_type > p);

    // EquipmentSymbolModifiers
    //
    typedef ::msdl_1::EquipmentSymbolModifiersType EquipmentSymbolModifiers_type;
    typedef ::xsd::cxx::tree::optional< EquipmentSymbolModifiers_type > EquipmentSymbolModifiers_optional;
    typedef ::xsd::cxx::tree::traits< EquipmentSymbolModifiers_type, char > EquipmentSymbolModifiers_traits;

    const EquipmentSymbolModifiers_optional&
    EquipmentSymbolModifiers () const;

    EquipmentSymbolModifiers_optional&
    EquipmentSymbolModifiers ();

    void
    EquipmentSymbolModifiers (const EquipmentSymbolModifiers_type& x);

    void
    EquipmentSymbolModifiers (const EquipmentSymbolModifiers_optional& x);

    void
    EquipmentSymbolModifiers (::std::unique_ptr< EquipmentSymbolModifiers_type > p);

    // CommunicationNetReferences
    //
    typedef ::msdl_1::CommunicationNetReferencesType CommunicationNetReferences_type;
    typedef ::xsd::cxx::tree::optional< CommunicationNetReferences_type > CommunicationNetReferences_optional;
    typedef ::xsd::cxx::tree::traits< CommunicationNetReferences_type, char > CommunicationNetReferences_traits;

    const CommunicationNetReferences_optional&
    CommunicationNetReferences () const;

    CommunicationNetReferences_optional&
    CommunicationNetReferences ();

    void
    CommunicationNetReferences (const CommunicationNetReferences_type& x);

    void
    CommunicationNetReferences (const CommunicationNetReferences_optional& x);

    void
    CommunicationNetReferences (::std::unique_ptr< CommunicationNetReferences_type > p);

    // Disposition
    //
    typedef ::msdl_1::EquipmentDispositionType Disposition_type;
    typedef ::xsd::cxx::tree::traits< Disposition_type, char > Disposition_traits;

    const Disposition_type&
    Disposition () const;

    Disposition_type&
    Disposition ();

    void
    Disposition (const Disposition_type& x);

    void
    Disposition (::std::unique_ptr< Disposition_type > p);

    // Relations
    //
    typedef ::msdl_1::EquipmentRelationsType Relations_type;
    typedef ::xsd::cxx::tree::traits< Relations_type, char > Relations_traits;

    const Relations_type&
    Relations () const;

    Relations_type&
    Relations ();

    void
    Relations (const Relations_type& x);

    void
    Relations (::std::unique_ptr< Relations_type > p);

    // Model
    //
    typedef ::msdl_1::EquipmentModelType Model_type;
    typedef ::xsd::cxx::tree::optional< Model_type > Model_optional;
    typedef ::xsd::cxx::tree::traits< Model_type, char > Model_traits;

    const Model_optional&
    Model () const;

    Model_optional&
    Model ();

    void
    Model (const Model_type& x);

    void
    Model (const Model_optional& x);

    void
    Model (::std::unique_ptr< Model_type > p);

    // Constructors.
    //
    EquipmentItemType (const ObjectHandle_type&,
                       const SymbolIdentifier_type&,
                       const Disposition_type&,
                       const Relations_type&);

    EquipmentItemType (const ObjectHandle_type&,
                       const SymbolIdentifier_type&,
                       ::std::unique_ptr< Disposition_type >,
                       ::std::unique_ptr< Relations_type >);

    EquipmentItemType (::std::unique_ptr< ObjectHandle_type >,
                       ::std::unique_ptr< SymbolIdentifier_type >,
                       ::std::unique_ptr< Disposition_type >,
                       ::std::unique_ptr< Relations_type >);

    EquipmentItemType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    EquipmentItemType (const EquipmentItemType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual EquipmentItemType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EquipmentItemType&
    operator= (const EquipmentItemType& x);

    virtual 
    ~EquipmentItemType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ObjectHandle_type > ObjectHandle_;
    ::xsd::cxx::tree::one< SymbolIdentifier_type > SymbolIdentifier_;
    Name_optional Name_;
    EquipmentSymbolModifiers_optional EquipmentSymbolModifiers_;
    CommunicationNetReferences_optional CommunicationNetReferences_;
    ::xsd::cxx::tree::one< Disposition_type > Disposition_;
    ::xsd::cxx::tree::one< Relations_type > Relations_;
    Model_optional Model_;
  };

  class EquipmentModelType: public ::xml_schema::type
  {
    public:
    // Resolution
    //
    typedef ::msdl_1::enumModelResolutionType Resolution_type;
    typedef ::xsd::cxx::tree::traits< Resolution_type, char > Resolution_traits;

    const Resolution_type&
    Resolution () const;

    Resolution_type&
    Resolution ();

    void
    Resolution (const Resolution_type& x);

    void
    Resolution (::std::unique_ptr< Resolution_type > p);

    // Constructors.
    //
    EquipmentModelType (const Resolution_type&);

    EquipmentModelType (::std::unique_ptr< Resolution_type >);

    EquipmentModelType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    EquipmentModelType (const EquipmentModelType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual EquipmentModelType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EquipmentModelType&
    operator= (const EquipmentModelType& x);

    virtual 
    ~EquipmentModelType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Resolution_type > Resolution_;
  };

  class EquipmentRelationsType: public ::xml_schema::type
  {
    public:
    // OrganicSuperiorHandle
    //
    typedef ::msdl_1::patternUUIDRef32 OrganicSuperiorHandle_type;
    typedef ::xsd::cxx::tree::optional< OrganicSuperiorHandle_type > OrganicSuperiorHandle_optional;
    typedef ::xsd::cxx::tree::traits< OrganicSuperiorHandle_type, char > OrganicSuperiorHandle_traits;

    const OrganicSuperiorHandle_optional&
    OrganicSuperiorHandle () const;

    OrganicSuperiorHandle_optional&
    OrganicSuperiorHandle ();

    void
    OrganicSuperiorHandle (const OrganicSuperiorHandle_type& x);

    void
    OrganicSuperiorHandle (const OrganicSuperiorHandle_optional& x);

    void
    OrganicSuperiorHandle (::std::unique_ptr< OrganicSuperiorHandle_type > p);

    // HoldingOrganization
    //
    typedef ::msdl_1::OwnerType HoldingOrganization_type;
    typedef ::xsd::cxx::tree::traits< HoldingOrganization_type, char > HoldingOrganization_traits;

    const HoldingOrganization_type&
    HoldingOrganization () const;

    HoldingOrganization_type&
    HoldingOrganization ();

    void
    HoldingOrganization (const HoldingOrganization_type& x);

    void
    HoldingOrganization (::std::unique_ptr< HoldingOrganization_type > p);

    // Constructors.
    //
    EquipmentRelationsType (const HoldingOrganization_type&);

    EquipmentRelationsType (::std::unique_ptr< HoldingOrganization_type >);

    EquipmentRelationsType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    EquipmentRelationsType (const EquipmentRelationsType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual EquipmentRelationsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EquipmentRelationsType&
    operator= (const EquipmentRelationsType& x);

    virtual 
    ~EquipmentRelationsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    OrganicSuperiorHandle_optional OrganicSuperiorHandle_;
    ::xsd::cxx::tree::one< HoldingOrganization_type > HoldingOrganization_;
  };

  class EquipmentSymbolModifiersType: public ::xml_schema::type
  {
    public:
    // Quantity
    //
    typedef ::msdl_1::integerQuantity9 Quantity_type;
    typedef ::xsd::cxx::tree::optional< Quantity_type > Quantity_optional;
    typedef ::xsd::cxx::tree::traits< Quantity_type, char > Quantity_traits;

    const Quantity_optional&
    Quantity () const;

    Quantity_optional&
    Quantity ();

    void
    Quantity (const Quantity_type& x);

    void
    Quantity (const Quantity_optional& x);

    void
    Quantity (::std::unique_ptr< Quantity_type > p);

    // StaffComments
    //
    typedef ::msdl_1::text20 StaffComments_type;
    typedef ::xsd::cxx::tree::optional< StaffComments_type > StaffComments_optional;
    typedef ::xsd::cxx::tree::traits< StaffComments_type, char > StaffComments_traits;

    const StaffComments_optional&
    StaffComments () const;

    StaffComments_optional&
    StaffComments ();

    void
    StaffComments (const StaffComments_type& x);

    void
    StaffComments (const StaffComments_optional& x);

    void
    StaffComments (::std::unique_ptr< StaffComments_type > p);

    // AdditionalInfo
    //
    typedef ::msdl_1::text20 AdditionalInfo_type;
    typedef ::xsd::cxx::tree::optional< AdditionalInfo_type > AdditionalInfo_optional;
    typedef ::xsd::cxx::tree::traits< AdditionalInfo_type, char > AdditionalInfo_traits;

    const AdditionalInfo_optional&
    AdditionalInfo () const;

    AdditionalInfo_optional&
    AdditionalInfo ();

    void
    AdditionalInfo (const AdditionalInfo_type& x);

    void
    AdditionalInfo (const AdditionalInfo_optional& x);

    void
    AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > p);

    // CombatEffectiveness
    //
    typedef ::msdl_1::enumCombatEffectivenessType CombatEffectiveness_type;
    typedef ::xsd::cxx::tree::optional< CombatEffectiveness_type > CombatEffectiveness_optional;
    typedef ::xsd::cxx::tree::traits< CombatEffectiveness_type, char > CombatEffectiveness_traits;

    const CombatEffectiveness_optional&
    CombatEffectiveness () const;

    CombatEffectiveness_optional&
    CombatEffectiveness ();

    void
    CombatEffectiveness (const CombatEffectiveness_type& x);

    void
    CombatEffectiveness (const CombatEffectiveness_optional& x);

    void
    CombatEffectiveness (::std::unique_ptr< CombatEffectiveness_type > p);

    // IFF
    //
    typedef ::msdl_1::textIFF5 IFF_type;
    typedef ::xsd::cxx::tree::optional< IFF_type > IFF_optional;
    typedef ::xsd::cxx::tree::traits< IFF_type, char > IFF_traits;

    const IFF_optional&
    IFF () const;

    IFF_optional&
    IFF ();

    void
    IFF (const IFF_type& x);

    void
    IFF (const IFF_optional& x);

    void
    IFF (::std::unique_ptr< IFF_type > p);

    // UniqueDesignation
    //
    typedef ::msdl_1::text21 UniqueDesignation_type;
    typedef ::xsd::cxx::tree::traits< UniqueDesignation_type, char > UniqueDesignation_traits;

    const UniqueDesignation_type&
    UniqueDesignation () const;

    UniqueDesignation_type&
    UniqueDesignation ();

    void
    UniqueDesignation (const UniqueDesignation_type& x);

    void
    UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > p);

    // EquipmentType
    //
    typedef ::msdl_1::textEquipmentType24 EquipmentType_type;
    typedef ::xsd::cxx::tree::optional< EquipmentType_type > EquipmentType_optional;
    typedef ::xsd::cxx::tree::traits< EquipmentType_type, char > EquipmentType_traits;

    const EquipmentType_optional&
    EquipmentType () const;

    EquipmentType_optional&
    EquipmentType ();

    void
    EquipmentType (const EquipmentType_type& x);

    void
    EquipmentType (const EquipmentType_optional& x);

    void
    EquipmentType (::std::unique_ptr< EquipmentType_type > p);

    // TowedSonarArray
    //
    typedef ::msdl_1::boolean TowedSonarArray_type;
    typedef ::xsd::cxx::tree::optional< TowedSonarArray_type > TowedSonarArray_optional;
    typedef ::xsd::cxx::tree::traits< TowedSonarArray_type, char > TowedSonarArray_traits;

    const TowedSonarArray_optional&
    TowedSonarArray () const;

    TowedSonarArray_optional&
    TowedSonarArray ();

    void
    TowedSonarArray (const TowedSonarArray_type& x);

    void
    TowedSonarArray (const TowedSonarArray_optional& x);

    void
    TowedSonarArray (::std::unique_ptr< TowedSonarArray_type > p);

    // Constructors.
    //
    EquipmentSymbolModifiersType (const UniqueDesignation_type&);

    EquipmentSymbolModifiersType (::std::unique_ptr< UniqueDesignation_type >);

    EquipmentSymbolModifiersType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    EquipmentSymbolModifiersType (const EquipmentSymbolModifiersType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual EquipmentSymbolModifiersType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EquipmentSymbolModifiersType&
    operator= (const EquipmentSymbolModifiersType& x);

    virtual 
    ~EquipmentSymbolModifiersType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Quantity_optional Quantity_;
    StaffComments_optional StaffComments_;
    AdditionalInfo_optional AdditionalInfo_;
    CombatEffectiveness_optional CombatEffectiveness_;
    IFF_optional IFF_;
    ::xsd::cxx::tree::one< UniqueDesignation_type > UniqueDesignation_;
    EquipmentType_optional EquipmentType_;
    TowedSonarArray_optional TowedSonarArray_;
  };

  class EquipmentType: public ::xml_schema::type
  {
    public:
    // EquipmentItem
    //
    typedef ::msdl_1::EquipmentItemType EquipmentItem_type;
    typedef ::xsd::cxx::tree::sequence< EquipmentItem_type > EquipmentItem_sequence;
    typedef EquipmentItem_sequence::iterator EquipmentItem_iterator;
    typedef EquipmentItem_sequence::const_iterator EquipmentItem_const_iterator;
    typedef ::xsd::cxx::tree::traits< EquipmentItem_type, char > EquipmentItem_traits;

    const EquipmentItem_sequence&
    EquipmentItem () const;

    EquipmentItem_sequence&
    EquipmentItem ();

    void
    EquipmentItem (const EquipmentItem_sequence& s);

    // Constructors.
    //
    EquipmentType ();

    EquipmentType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    EquipmentType (const EquipmentType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual EquipmentType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EquipmentType&
    operator= (const EquipmentType& x);

    virtual 
    ~EquipmentType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    EquipmentItem_sequence EquipmentItem_;
  };

  class ForceRelationDataType: public ::xml_schema::type
  {
    public:
    // CommandRelation
    //
    typedef ::msdl_1::CommandRelationType CommandRelation_type;
    typedef ::xsd::cxx::tree::optional< CommandRelation_type > CommandRelation_optional;
    typedef ::xsd::cxx::tree::traits< CommandRelation_type, char > CommandRelation_traits;

    const CommandRelation_optional&
    CommandRelation () const;

    CommandRelation_optional&
    CommandRelation ();

    void
    CommandRelation (const CommandRelation_type& x);

    void
    CommandRelation (const CommandRelation_optional& x);

    void
    CommandRelation (::std::unique_ptr< CommandRelation_type > p);

    // ForceSideHandle
    //
    typedef ::msdl_1::patternUUIDRef32 ForceSideHandle_type;
    typedef ::xsd::cxx::tree::optional< ForceSideHandle_type > ForceSideHandle_optional;
    typedef ::xsd::cxx::tree::traits< ForceSideHandle_type, char > ForceSideHandle_traits;

    const ForceSideHandle_optional&
    ForceSideHandle () const;

    ForceSideHandle_optional&
    ForceSideHandle ();

    void
    ForceSideHandle (const ForceSideHandle_type& x);

    void
    ForceSideHandle (const ForceSideHandle_optional& x);

    void
    ForceSideHandle (::std::unique_ptr< ForceSideHandle_type > p);

    // Constructors.
    //
    ForceRelationDataType ();

    ForceRelationDataType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    ForceRelationDataType (const ForceRelationDataType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual ForceRelationDataType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ForceRelationDataType&
    operator= (const ForceRelationDataType& x);

    virtual 
    ~ForceRelationDataType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    CommandRelation_optional CommandRelation_;
    ForceSideHandle_optional ForceSideHandle_;
  };

  class ForceRelationType: public ::xml_schema::type
  {
    public:
    // ForceRelationChoice
    //
    typedef ::msdl_1::enumForceOwnerType ForceRelationChoice_type;
    typedef ::xsd::cxx::tree::traits< ForceRelationChoice_type, char > ForceRelationChoice_traits;

    const ForceRelationChoice_type&
    ForceRelationChoice () const;

    ForceRelationChoice_type&
    ForceRelationChoice ();

    void
    ForceRelationChoice (const ForceRelationChoice_type& x);

    void
    ForceRelationChoice (::std::unique_ptr< ForceRelationChoice_type > p);

    // ForceRelationData
    //
    typedef ::msdl_1::ForceRelationDataType ForceRelationData_type;
    typedef ::xsd::cxx::tree::traits< ForceRelationData_type, char > ForceRelationData_traits;

    const ForceRelationData_type&
    ForceRelationData () const;

    ForceRelationData_type&
    ForceRelationData ();

    void
    ForceRelationData (const ForceRelationData_type& x);

    void
    ForceRelationData (::std::unique_ptr< ForceRelationData_type > p);

    // Constructors.
    //
    ForceRelationType (const ForceRelationChoice_type&,
                       const ForceRelationData_type&);

    ForceRelationType (const ForceRelationChoice_type&,
                       ::std::unique_ptr< ForceRelationData_type >);

    ForceRelationType (::std::unique_ptr< ForceRelationChoice_type >,
                       ::std::unique_ptr< ForceRelationData_type >);

    ForceRelationType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    ForceRelationType (const ForceRelationType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual ForceRelationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ForceRelationType&
    operator= (const ForceRelationType& x);

    virtual 
    ~ForceRelationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ForceRelationChoice_type > ForceRelationChoice_;
    ::xsd::cxx::tree::one< ForceRelationData_type > ForceRelationData_;
  };

  class ForceSidesType: public ::xml_schema::type
  {
    public:
    // ForceSide
    //
    typedef ::msdl_1::ForceSideType ForceSide_type;
    typedef ::xsd::cxx::tree::sequence< ForceSide_type > ForceSide_sequence;
    typedef ForceSide_sequence::iterator ForceSide_iterator;
    typedef ForceSide_sequence::const_iterator ForceSide_const_iterator;
    typedef ::xsd::cxx::tree::traits< ForceSide_type, char > ForceSide_traits;

    const ForceSide_sequence&
    ForceSide () const;

    ForceSide_sequence&
    ForceSide ();

    void
    ForceSide (const ForceSide_sequence& s);

    // Constructors.
    //
    ForceSidesType ();

    ForceSidesType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    ForceSidesType (const ForceSidesType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual ForceSidesType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ForceSidesType&
    operator= (const ForceSidesType& x);

    virtual 
    ~ForceSidesType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ForceSide_sequence ForceSide_;
  };

  class ForceSideType: public ::xml_schema::type
  {
    public:
    // ObjectHandle
    //
    typedef ::msdl_1::patternUUID32 ObjectHandle_type;
    typedef ::xsd::cxx::tree::traits< ObjectHandle_type, char > ObjectHandle_traits;

    const ObjectHandle_type&
    ObjectHandle () const;

    ObjectHandle_type&
    ObjectHandle ();

    void
    ObjectHandle (const ObjectHandle_type& x);

    void
    ObjectHandle (::std::unique_ptr< ObjectHandle_type > p);

    // ForceSideName
    //
    typedef ::msdl_1::textName255 ForceSideName_type;
    typedef ::xsd::cxx::tree::traits< ForceSideName_type, char > ForceSideName_traits;

    const ForceSideName_type&
    ForceSideName () const;

    ForceSideName_type&
    ForceSideName ();

    void
    ForceSideName (const ForceSideName_type& x);

    void
    ForceSideName (::std::unique_ptr< ForceSideName_type > p);

    // AllegianceHandle
    //
    typedef ::msdl_1::patternUUID32 AllegianceHandle_type;
    typedef ::xsd::cxx::tree::optional< AllegianceHandle_type > AllegianceHandle_optional;
    typedef ::xsd::cxx::tree::traits< AllegianceHandle_type, char > AllegianceHandle_traits;

    const AllegianceHandle_optional&
    AllegianceHandle () const;

    AllegianceHandle_optional&
    AllegianceHandle ();

    void
    AllegianceHandle (const AllegianceHandle_type& x);

    void
    AllegianceHandle (const AllegianceHandle_optional& x);

    void
    AllegianceHandle (::std::unique_ptr< AllegianceHandle_type > p);

    // MilitaryService
    //
    typedef ::oo_2_0::MilitaryOrganisationTypeServiceCode MilitaryService_type;
    typedef ::xsd::cxx::tree::optional< MilitaryService_type > MilitaryService_optional;
    typedef ::xsd::cxx::tree::traits< MilitaryService_type, char > MilitaryService_traits;

    const MilitaryService_optional&
    MilitaryService () const;

    MilitaryService_optional&
    MilitaryService ();

    void
    MilitaryService (const MilitaryService_type& x);

    void
    MilitaryService (const MilitaryService_optional& x);

    void
    MilitaryService (::std::unique_ptr< MilitaryService_type > p);

    // CountryCode
    //
    typedef ::oo_2_0::AffiliationGeopoliticalCode CountryCode_type;
    typedef ::xsd::cxx::tree::optional< CountryCode_type > CountryCode_optional;
    typedef ::xsd::cxx::tree::traits< CountryCode_type, char > CountryCode_traits;

    const CountryCode_optional&
    CountryCode () const;

    CountryCode_optional&
    CountryCode ();

    void
    CountryCode (const CountryCode_type& x);

    void
    CountryCode (const CountryCode_optional& x);

    void
    CountryCode (::std::unique_ptr< CountryCode_type > p);

    // Associations
    //
    typedef ::msdl_1::AssociationsType Associations_type;
    typedef ::xsd::cxx::tree::optional< Associations_type > Associations_optional;
    typedef ::xsd::cxx::tree::traits< Associations_type, char > Associations_traits;

    const Associations_optional&
    Associations () const;

    Associations_optional&
    Associations ();

    void
    Associations (const Associations_type& x);

    void
    Associations (const Associations_optional& x);

    void
    Associations (::std::unique_ptr< Associations_type > p);

    // Constructors.
    //
    ForceSideType (const ObjectHandle_type&,
                   const ForceSideName_type&);

    ForceSideType (::std::unique_ptr< ObjectHandle_type >,
                   ::std::unique_ptr< ForceSideName_type >);

    ForceSideType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    ForceSideType (const ForceSideType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual ForceSideType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ForceSideType&
    operator= (const ForceSideType& x);

    virtual 
    ~ForceSideType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ObjectHandle_type > ObjectHandle_;
    ::xsd::cxx::tree::one< ForceSideName_type > ForceSideName_;
    AllegianceHandle_optional AllegianceHandle_;
    MilitaryService_optional MilitaryService_;
    CountryCode_optional CountryCode_;
    Associations_optional Associations_;
  };

  class FormationDataType: public ::xml_schema::type
  {
    public:
    // GroundFormationType
    //
    typedef ::msdl_1::enumGroundFormationType GroundFormationType_type;
    typedef ::xsd::cxx::tree::optional< GroundFormationType_type > GroundFormationType_optional;
    typedef ::xsd::cxx::tree::traits< GroundFormationType_type, char > GroundFormationType_traits;

    const GroundFormationType_optional&
    GroundFormationType () const;

    GroundFormationType_optional&
    GroundFormationType ();

    void
    GroundFormationType (const GroundFormationType_type& x);

    void
    GroundFormationType (const GroundFormationType_optional& x);

    void
    GroundFormationType (::std::unique_ptr< GroundFormationType_type > p);

    // AirFormationType
    //
    typedef ::msdl_1::enumAirFormationType AirFormationType_type;
    typedef ::xsd::cxx::tree::optional< AirFormationType_type > AirFormationType_optional;
    typedef ::xsd::cxx::tree::traits< AirFormationType_type, char > AirFormationType_traits;

    const AirFormationType_optional&
    AirFormationType () const;

    AirFormationType_optional&
    AirFormationType ();

    void
    AirFormationType (const AirFormationType_type& x);

    void
    AirFormationType (const AirFormationType_optional& x);

    void
    AirFormationType (::std::unique_ptr< AirFormationType_type > p);

    // SurfaceFomationType
    //
    typedef ::msdl_1::enumSurfaceFormationType SurfaceFomationType_type;
    typedef ::xsd::cxx::tree::optional< SurfaceFomationType_type > SurfaceFomationType_optional;
    typedef ::xsd::cxx::tree::traits< SurfaceFomationType_type, char > SurfaceFomationType_traits;

    const SurfaceFomationType_optional&
    SurfaceFomationType () const;

    SurfaceFomationType_optional&
    SurfaceFomationType ();

    void
    SurfaceFomationType (const SurfaceFomationType_type& x);

    void
    SurfaceFomationType (const SurfaceFomationType_optional& x);

    void
    SurfaceFomationType (::std::unique_ptr< SurfaceFomationType_type > p);

    // SubsurfaceFormationType
    //
    typedef ::msdl_1::enumSubsurfaceFormationType SubsurfaceFormationType_type;
    typedef ::xsd::cxx::tree::optional< SubsurfaceFormationType_type > SubsurfaceFormationType_optional;
    typedef ::xsd::cxx::tree::traits< SubsurfaceFormationType_type, char > SubsurfaceFormationType_traits;

    const SubsurfaceFormationType_optional&
    SubsurfaceFormationType () const;

    SubsurfaceFormationType_optional&
    SubsurfaceFormationType ();

    void
    SubsurfaceFormationType (const SubsurfaceFormationType_type& x);

    void
    SubsurfaceFormationType (const SubsurfaceFormationType_optional& x);

    void
    SubsurfaceFormationType (::std::unique_ptr< SubsurfaceFormationType_type > p);

    // Constructors.
    //
    FormationDataType ();

    FormationDataType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    FormationDataType (const FormationDataType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual FormationDataType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FormationDataType&
    operator= (const FormationDataType& x);

    virtual 
    ~FormationDataType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    GroundFormationType_optional GroundFormationType_;
    AirFormationType_optional AirFormationType_;
    SurfaceFomationType_optional SurfaceFomationType_;
    SubsurfaceFormationType_optional SubsurfaceFormationType_;
  };

  class FormationPositionType: public ::xml_schema::type
  {
    public:
    // OutOfFormation
    //
    typedef ::msdl_1::boolean OutOfFormation_type;
    typedef ::xsd::cxx::tree::optional< OutOfFormation_type > OutOfFormation_optional;
    typedef ::xsd::cxx::tree::traits< OutOfFormation_type, char > OutOfFormation_traits;

    const OutOfFormation_optional&
    OutOfFormation () const;

    OutOfFormation_optional&
    OutOfFormation ();

    void
    OutOfFormation (const OutOfFormation_type& x);

    void
    OutOfFormation (const OutOfFormation_optional& x);

    void
    OutOfFormation (::std::unique_ptr< OutOfFormation_type > p);

    // FormationOrder
    //
    typedef ::msdl_1::integerSequence6 FormationOrder_type;
    typedef ::xsd::cxx::tree::optional< FormationOrder_type > FormationOrder_optional;
    typedef ::xsd::cxx::tree::traits< FormationOrder_type, char > FormationOrder_traits;

    const FormationOrder_optional&
    FormationOrder () const;

    FormationOrder_optional&
    FormationOrder ();

    void
    FormationOrder (const FormationOrder_type& x);

    void
    FormationOrder (const FormationOrder_optional& x);

    void
    FormationOrder (::std::unique_ptr< FormationOrder_type > p);

    // SensorOrientation
    //
    typedef ::msdl_1::floatCompassDegrees3_3 SensorOrientation_type;
    typedef ::xsd::cxx::tree::optional< SensorOrientation_type > SensorOrientation_optional;
    typedef ::xsd::cxx::tree::traits< SensorOrientation_type, char > SensorOrientation_traits;

    const SensorOrientation_optional&
    SensorOrientation () const;

    SensorOrientation_optional&
    SensorOrientation ();

    void
    SensorOrientation (const SensorOrientation_type& x);

    void
    SensorOrientation (const SensorOrientation_optional& x);

    void
    SensorOrientation (::std::unique_ptr< SensorOrientation_type > p);

    // Constructors.
    //
    FormationPositionType ();

    FormationPositionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    FormationPositionType (const FormationPositionType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual FormationPositionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FormationPositionType&
    operator= (const FormationPositionType& x);

    virtual 
    ~FormationPositionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    OutOfFormation_optional OutOfFormation_;
    FormationOrder_optional FormationOrder_;
    SensorOrientation_optional SensorOrientation_;
  };

  class GCCType: public ::xml_schema::type
  {
    public:
    // X
    //
    typedef ::msdl_1::floatCartesianValue9_3 X_type;
    typedef ::xsd::cxx::tree::traits< X_type, char > X_traits;

    const X_type&
    X () const;

    X_type&
    X ();

    void
    X (const X_type& x);

    void
    X (::std::unique_ptr< X_type > p);

    // Y
    //
    typedef ::msdl_1::floatCartesianValue9_3 Y_type;
    typedef ::xsd::cxx::tree::traits< Y_type, char > Y_traits;

    const Y_type&
    Y () const;

    Y_type&
    Y ();

    void
    Y (const Y_type& x);

    void
    Y (::std::unique_ptr< Y_type > p);

    // Z
    //
    typedef ::msdl_1::floatCartesianValue9_3 Z_type;
    typedef ::xsd::cxx::tree::traits< Z_type, char > Z_traits;

    const Z_type&
    Z () const;

    Z_type&
    Z ();

    void
    Z (const Z_type& x);

    void
    Z (::std::unique_ptr< Z_type > p);

    // Constructors.
    //
    GCCType (const X_type&,
             const Y_type&,
             const Z_type&);

    GCCType (::std::unique_ptr< X_type >,
             ::std::unique_ptr< Y_type >,
             ::std::unique_ptr< Z_type >);

    GCCType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    GCCType (const GCCType& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual GCCType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GCCType&
    operator= (const GCCType& x);

    virtual 
    ~GCCType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< X_type > X_;
    ::xsd::cxx::tree::one< Y_type > Y_;
    ::xsd::cxx::tree::one< Z_type > Z_;
  };

  class GDCType: public ::xml_schema::type
  {
    public:
    // Latitude
    //
    typedef ::msdl_1::floatLatitudeLongitude3_3 Latitude_type;
    typedef ::xsd::cxx::tree::traits< Latitude_type, char > Latitude_traits;

    const Latitude_type&
    Latitude () const;

    Latitude_type&
    Latitude ();

    void
    Latitude (const Latitude_type& x);

    void
    Latitude (::std::unique_ptr< Latitude_type > p);

    // Longitude
    //
    typedef ::msdl_1::floatLatitudeLongitude3_3 Longitude_type;
    typedef ::xsd::cxx::tree::traits< Longitude_type, char > Longitude_traits;

    const Longitude_type&
    Longitude () const;

    Longitude_type&
    Longitude ();

    void
    Longitude (const Longitude_type& x);

    void
    Longitude (::std::unique_ptr< Longitude_type > p);

    // ElevationAGL
    //
    typedef ::msdl_1::floatElevationAGL6_2 ElevationAGL_type;
    typedef ::xsd::cxx::tree::traits< ElevationAGL_type, char > ElevationAGL_traits;

    const ElevationAGL_type&
    ElevationAGL () const;

    ElevationAGL_type&
    ElevationAGL ();

    void
    ElevationAGL (const ElevationAGL_type& x);

    void
    ElevationAGL (::std::unique_ptr< ElevationAGL_type > p);

    // Constructors.
    //
    GDCType (const Latitude_type&,
             const Longitude_type&,
             const ElevationAGL_type&);

    GDCType (::std::unique_ptr< Latitude_type >,
             ::std::unique_ptr< Longitude_type >,
             ::std::unique_ptr< ElevationAGL_type >);

    GDCType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    GDCType (const GDCType& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual GDCType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GDCType&
    operator= (const GDCType& x);

    virtual 
    ~GDCType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Latitude_type > Latitude_;
    ::xsd::cxx::tree::one< Longitude_type > Longitude_;
    ::xsd::cxx::tree::one< ElevationAGL_type > ElevationAGL_;
  };

  class InstallationsType: public ::xml_schema::type
  {
    public:
    // Installation
    //
    typedef ::msdl_1::InstallationType Installation_type;
    typedef ::xsd::cxx::tree::sequence< Installation_type > Installation_sequence;
    typedef Installation_sequence::iterator Installation_iterator;
    typedef Installation_sequence::const_iterator Installation_const_iterator;
    typedef ::xsd::cxx::tree::traits< Installation_type, char > Installation_traits;

    const Installation_sequence&
    Installation () const;

    Installation_sequence&
    Installation ();

    void
    Installation (const Installation_sequence& s);

    // Constructors.
    //
    InstallationsType ();

    InstallationsType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    InstallationsType (const InstallationsType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual InstallationsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InstallationsType&
    operator= (const InstallationsType& x);

    virtual 
    ~InstallationsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Installation_sequence Installation_;
  };

  class InstallationSymbolModifiersType: public ::xml_schema::type
  {
    public:
    // FrameShapeModifier
    //
    typedef ::msdl_1::enumFrameShapeModifierType FrameShapeModifier_type;
    typedef ::xsd::cxx::tree::optional< FrameShapeModifier_type > FrameShapeModifier_optional;
    typedef ::xsd::cxx::tree::traits< FrameShapeModifier_type, char > FrameShapeModifier_traits;

    const FrameShapeModifier_optional&
    FrameShapeModifier () const;

    FrameShapeModifier_optional&
    FrameShapeModifier ();

    void
    FrameShapeModifier (const FrameShapeModifier_type& x);

    void
    FrameShapeModifier (const FrameShapeModifier_optional& x);

    void
    FrameShapeModifier (::std::unique_ptr< FrameShapeModifier_type > p);

    // StaffComments
    //
    typedef ::msdl_1::text20 StaffComments_type;
    typedef ::xsd::cxx::tree::optional< StaffComments_type > StaffComments_optional;
    typedef ::xsd::cxx::tree::traits< StaffComments_type, char > StaffComments_traits;

    const StaffComments_optional&
    StaffComments () const;

    StaffComments_optional&
    StaffComments ();

    void
    StaffComments (const StaffComments_type& x);

    void
    StaffComments (const StaffComments_optional& x);

    void
    StaffComments (::std::unique_ptr< StaffComments_type > p);

    // AdditionalInfo
    //
    typedef ::msdl_1::text20 AdditionalInfo_type;
    typedef ::xsd::cxx::tree::optional< AdditionalInfo_type > AdditionalInfo_optional;
    typedef ::xsd::cxx::tree::traits< AdditionalInfo_type, char > AdditionalInfo_traits;

    const AdditionalInfo_optional&
    AdditionalInfo () const;

    AdditionalInfo_optional&
    AdditionalInfo ();

    void
    AdditionalInfo (const AdditionalInfo_type& x);

    void
    AdditionalInfo (const AdditionalInfo_optional& x);

    void
    AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > p);

    // CombatEffectiveness
    //
    typedef ::msdl_1::enumCombatEffectivenessType CombatEffectiveness_type;
    typedef ::xsd::cxx::tree::optional< CombatEffectiveness_type > CombatEffectiveness_optional;
    typedef ::xsd::cxx::tree::traits< CombatEffectiveness_type, char > CombatEffectiveness_traits;

    const CombatEffectiveness_optional&
    CombatEffectiveness () const;

    CombatEffectiveness_optional&
    CombatEffectiveness ();

    void
    CombatEffectiveness (const CombatEffectiveness_type& x);

    void
    CombatEffectiveness (const CombatEffectiveness_optional& x);

    void
    CombatEffectiveness (::std::unique_ptr< CombatEffectiveness_type > p);

    // IFF
    //
    typedef ::msdl_1::textIFF5 IFF_type;
    typedef ::xsd::cxx::tree::optional< IFF_type > IFF_optional;
    typedef ::xsd::cxx::tree::traits< IFF_type, char > IFF_traits;

    const IFF_optional&
    IFF () const;

    IFF_optional&
    IFF ();

    void
    IFF (const IFF_type& x);

    void
    IFF (const IFF_optional& x);

    void
    IFF (::std::unique_ptr< IFF_type > p);

    // UniqueDesignation
    //
    typedef ::msdl_1::text21 UniqueDesignation_type;
    typedef ::xsd::cxx::tree::traits< UniqueDesignation_type, char > UniqueDesignation_traits;

    const UniqueDesignation_type&
    UniqueDesignation () const;

    UniqueDesignation_type&
    UniqueDesignation ();

    void
    UniqueDesignation (const UniqueDesignation_type& x);

    void
    UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > p);

    // DateTimeGroup
    //
    typedef ::msdl_1::patternTimeDTGRelative20 DateTimeGroup_type;
    typedef ::xsd::cxx::tree::optional< DateTimeGroup_type > DateTimeGroup_optional;
    typedef ::xsd::cxx::tree::traits< DateTimeGroup_type, char > DateTimeGroup_traits;

    const DateTimeGroup_optional&
    DateTimeGroup () const;

    DateTimeGroup_optional&
    DateTimeGroup ();

    void
    DateTimeGroup (const DateTimeGroup_type& x);

    void
    DateTimeGroup (const DateTimeGroup_optional& x);

    void
    DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > p);

    // Constructors.
    //
    InstallationSymbolModifiersType (const UniqueDesignation_type&);

    InstallationSymbolModifiersType (::std::unique_ptr< UniqueDesignation_type >);

    InstallationSymbolModifiersType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    InstallationSymbolModifiersType (const InstallationSymbolModifiersType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual InstallationSymbolModifiersType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InstallationSymbolModifiersType&
    operator= (const InstallationSymbolModifiersType& x);

    virtual 
    ~InstallationSymbolModifiersType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    FrameShapeModifier_optional FrameShapeModifier_;
    StaffComments_optional StaffComments_;
    AdditionalInfo_optional AdditionalInfo_;
    CombatEffectiveness_optional CombatEffectiveness_;
    IFF_optional IFF_;
    ::xsd::cxx::tree::one< UniqueDesignation_type > UniqueDesignation_;
    DateTimeGroup_optional DateTimeGroup_;
  };

  class InstallationType: public ::xml_schema::type
  {
    public:
    // ObjectHandle
    //
    typedef ::msdl_1::patternUUID32 ObjectHandle_type;
    typedef ::xsd::cxx::tree::traits< ObjectHandle_type, char > ObjectHandle_traits;

    const ObjectHandle_type&
    ObjectHandle () const;

    ObjectHandle_type&
    ObjectHandle ();

    void
    ObjectHandle (const ObjectHandle_type& x);

    void
    ObjectHandle (::std::unique_ptr< ObjectHandle_type > p);

    // SymbolIdentifier
    //
    typedef ::msdl_1::patternInstallationSymbolID15 SymbolIdentifier_type;
    typedef ::xsd::cxx::tree::traits< SymbolIdentifier_type, char > SymbolIdentifier_traits;

    const SymbolIdentifier_type&
    SymbolIdentifier () const;

    SymbolIdentifier_type&
    SymbolIdentifier ();

    void
    SymbolIdentifier (const SymbolIdentifier_type& x);

    void
    SymbolIdentifier (::std::unique_ptr< SymbolIdentifier_type > p);

    // Affiliation
    //
    typedef ::msdl_1::enumBaseAffiliation Affiliation_type;
    typedef ::xsd::cxx::tree::traits< Affiliation_type, char > Affiliation_traits;

    const Affiliation_type&
    Affiliation () const;

    Affiliation_type&
    Affiliation ();

    void
    Affiliation (const Affiliation_type& x);

    void
    Affiliation (::std::unique_ptr< Affiliation_type > p);

    // Owner
    //
    typedef ::msdl_1::OwnerType Owner_type;
    typedef ::xsd::cxx::tree::traits< Owner_type, char > Owner_traits;

    const Owner_type&
    Owner () const;

    Owner_type&
    Owner ();

    void
    Owner (const Owner_type& x);

    void
    Owner (::std::unique_ptr< Owner_type > p);

    // Location
    //
    typedef ::msdl_1::CoordinatesType Location_type;
    typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

    const Location_type&
    Location () const;

    Location_type&
    Location ();

    void
    Location (const Location_type& x);

    void
    Location (::std::unique_ptr< Location_type > p);

    // Orientation
    //
    typedef ::msdl_1::enumOrientationType Orientation_type;
    typedef ::xsd::cxx::tree::optional< Orientation_type > Orientation_optional;
    typedef ::xsd::cxx::tree::traits< Orientation_type, char > Orientation_traits;

    const Orientation_optional&
    Orientation () const;

    Orientation_optional&
    Orientation ();

    void
    Orientation (const Orientation_type& x);

    void
    Orientation (const Orientation_optional& x);

    void
    Orientation (::std::unique_ptr< Orientation_type > p);

    // Name
    //
    typedef ::msdl_1::textName255 Name_type;
    typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
    typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

    const Name_optional&
    Name () const;

    Name_optional&
    Name ();

    void
    Name (const Name_type& x);

    void
    Name (const Name_optional& x);

    void
    Name (::std::unique_ptr< Name_type > p);

    // InstallationSymbolModifiers
    //
    typedef ::msdl_1::InstallationSymbolModifiersType InstallationSymbolModifiers_type;
    typedef ::xsd::cxx::tree::optional< InstallationSymbolModifiers_type > InstallationSymbolModifiers_optional;
    typedef ::xsd::cxx::tree::traits< InstallationSymbolModifiers_type, char > InstallationSymbolModifiers_traits;

    const InstallationSymbolModifiers_optional&
    InstallationSymbolModifiers () const;

    InstallationSymbolModifiers_optional&
    InstallationSymbolModifiers ();

    void
    InstallationSymbolModifiers (const InstallationSymbolModifiers_type& x);

    void
    InstallationSymbolModifiers (const InstallationSymbolModifiers_optional& x);

    void
    InstallationSymbolModifiers (::std::unique_ptr< InstallationSymbolModifiers_type > p);

    // AssociatedOverlays
    //
    typedef ::msdl_1::AssociatedOverlaysType AssociatedOverlays_type;
    typedef ::xsd::cxx::tree::optional< AssociatedOverlays_type > AssociatedOverlays_optional;
    typedef ::xsd::cxx::tree::traits< AssociatedOverlays_type, char > AssociatedOverlays_traits;

    const AssociatedOverlays_optional&
    AssociatedOverlays () const;

    AssociatedOverlays_optional&
    AssociatedOverlays ();

    void
    AssociatedOverlays (const AssociatedOverlays_type& x);

    void
    AssociatedOverlays (const AssociatedOverlays_optional& x);

    void
    AssociatedOverlays (::std::unique_ptr< AssociatedOverlays_type > p);

    // Constructors.
    //
    InstallationType (const ObjectHandle_type&,
                      const SymbolIdentifier_type&,
                      const Affiliation_type&,
                      const Owner_type&,
                      const Location_type&);

    InstallationType (const ObjectHandle_type&,
                      const SymbolIdentifier_type&,
                      const Affiliation_type&,
                      ::std::unique_ptr< Owner_type >,
                      ::std::unique_ptr< Location_type >);

    InstallationType (::std::unique_ptr< ObjectHandle_type >,
                      ::std::unique_ptr< SymbolIdentifier_type >,
                      ::std::unique_ptr< Affiliation_type >,
                      ::std::unique_ptr< Owner_type >,
                      ::std::unique_ptr< Location_type >);

    InstallationType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    InstallationType (const InstallationType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual InstallationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InstallationType&
    operator= (const InstallationType& x);

    virtual 
    ~InstallationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ObjectHandle_type > ObjectHandle_;
    ::xsd::cxx::tree::one< SymbolIdentifier_type > SymbolIdentifier_;
    ::xsd::cxx::tree::one< Affiliation_type > Affiliation_;
    ::xsd::cxx::tree::one< Owner_type > Owner_;
    ::xsd::cxx::tree::one< Location_type > Location_;
    Orientation_optional Orientation_;
    Name_optional Name_;
    InstallationSymbolModifiers_optional InstallationSymbolModifiers_;
    AssociatedOverlays_optional AssociatedOverlays_;
  };

  class LightItemsType: public ::xml_schema::type
  {
    public:
    // Light
    //
    typedef ::oo_2_0::Light Light_type;
    typedef ::xsd::cxx::tree::sequence< Light_type > Light_sequence;
    typedef Light_sequence::iterator Light_iterator;
    typedef Light_sequence::const_iterator Light_const_iterator;
    typedef ::xsd::cxx::tree::traits< Light_type, char > Light_traits;

    const Light_sequence&
    Light () const;

    Light_sequence&
    Light ();

    void
    Light (const Light_sequence& s);

    // Constructors.
    //
    LightItemsType ();

    LightItemsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    LightItemsType (const LightItemsType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual LightItemsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LightItemsType&
    operator= (const LightItemsType& x);

    virtual 
    ~LightItemsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Light_sequence Light_;
  };

  class LineSymbolModifiersType: public ::xml_schema::type
  {
    public:
    // UniqueDesignation
    //
    typedef ::msdl_1::text21 UniqueDesignation_type;
    typedef ::xsd::cxx::tree::optional< UniqueDesignation_type > UniqueDesignation_optional;
    typedef ::xsd::cxx::tree::traits< UniqueDesignation_type, char > UniqueDesignation_traits;

    const UniqueDesignation_optional&
    UniqueDesignation () const;

    UniqueDesignation_optional&
    UniqueDesignation ();

    void
    UniqueDesignation (const UniqueDesignation_type& x);

    void
    UniqueDesignation (const UniqueDesignation_optional& x);

    void
    UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > p);

    // UniqueDesignation1
    //
    typedef ::msdl_1::text21 UniqueDesignation1_type;
    typedef ::xsd::cxx::tree::optional< UniqueDesignation1_type > UniqueDesignation1_optional;
    typedef ::xsd::cxx::tree::traits< UniqueDesignation1_type, char > UniqueDesignation1_traits;

    const UniqueDesignation1_optional&
    UniqueDesignation1 () const;

    UniqueDesignation1_optional&
    UniqueDesignation1 ();

    void
    UniqueDesignation1 (const UniqueDesignation1_type& x);

    void
    UniqueDesignation1 (const UniqueDesignation1_optional& x);

    void
    UniqueDesignation1 (::std::unique_ptr< UniqueDesignation1_type > p);

    // DateTimeGroup
    //
    typedef ::msdl_1::patternTimeDTGRelative20 DateTimeGroup_type;
    typedef ::xsd::cxx::tree::optional< DateTimeGroup_type > DateTimeGroup_optional;
    typedef ::xsd::cxx::tree::traits< DateTimeGroup_type, char > DateTimeGroup_traits;

    const DateTimeGroup_optional&
    DateTimeGroup () const;

    DateTimeGroup_optional&
    DateTimeGroup ();

    void
    DateTimeGroup (const DateTimeGroup_type& x);

    void
    DateTimeGroup (const DateTimeGroup_optional& x);

    void
    DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > p);

    // DateTimeGroup1
    //
    typedef ::msdl_1::patternTimeDTGRelative20 DateTimeGroup1_type;
    typedef ::xsd::cxx::tree::optional< DateTimeGroup1_type > DateTimeGroup1_optional;
    typedef ::xsd::cxx::tree::traits< DateTimeGroup1_type, char > DateTimeGroup1_traits;

    const DateTimeGroup1_optional&
    DateTimeGroup1 () const;

    DateTimeGroup1_optional&
    DateTimeGroup1 ();

    void
    DateTimeGroup1 (const DateTimeGroup1_type& x);

    void
    DateTimeGroup1 (const DateTimeGroup1_optional& x);

    void
    DateTimeGroup1 (::std::unique_ptr< DateTimeGroup1_type > p);

    // Constructors.
    //
    LineSymbolModifiersType ();

    LineSymbolModifiersType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    LineSymbolModifiersType (const LineSymbolModifiersType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual LineSymbolModifiersType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LineSymbolModifiersType&
    operator= (const LineSymbolModifiersType& x);

    virtual 
    ~LineSymbolModifiersType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    UniqueDesignation_optional UniqueDesignation_;
    UniqueDesignation1_optional UniqueDesignation1_;
    DateTimeGroup_optional DateTimeGroup_;
    DateTimeGroup1_optional DateTimeGroup1_;
  };

  class METOCDispositionType: public ::xml_schema::type
  {
    public:
    // AnchorPoints
    //
    typedef ::msdl_1::AnchorPointsType AnchorPoints_type;
    typedef ::xsd::cxx::tree::traits< AnchorPoints_type, char > AnchorPoints_traits;

    const AnchorPoints_type&
    AnchorPoints () const;

    AnchorPoints_type&
    AnchorPoints ();

    void
    AnchorPoints (const AnchorPoints_type& x);

    void
    AnchorPoints (::std::unique_ptr< AnchorPoints_type > p);

    // DirectionOfMovement
    //
    typedef ::msdl_1::floatCompassDegrees3_3 DirectionOfMovement_type;
    typedef ::xsd::cxx::tree::optional< DirectionOfMovement_type > DirectionOfMovement_optional;
    typedef ::xsd::cxx::tree::traits< DirectionOfMovement_type, char > DirectionOfMovement_traits;

    const DirectionOfMovement_optional&
    DirectionOfMovement () const;

    DirectionOfMovement_optional&
    DirectionOfMovement ();

    void
    DirectionOfMovement (const DirectionOfMovement_type& x);

    void
    DirectionOfMovement (const DirectionOfMovement_optional& x);

    void
    DirectionOfMovement (::std::unique_ptr< DirectionOfMovement_type > p);

    // Speed
    //
    typedef ::msdl_1::floatSpeed6_2 Speed_type;
    typedef ::xsd::cxx::tree::optional< Speed_type > Speed_optional;
    typedef ::xsd::cxx::tree::traits< Speed_type, char > Speed_traits;

    const Speed_optional&
    Speed () const;

    Speed_optional&
    Speed ();

    void
    Speed (const Speed_type& x);

    void
    Speed (const Speed_optional& x);

    void
    Speed (::std::unique_ptr< Speed_type > p);

    // Constructors.
    //
    METOCDispositionType (const AnchorPoints_type&);

    METOCDispositionType (::std::unique_ptr< AnchorPoints_type >);

    METOCDispositionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    METOCDispositionType (const METOCDispositionType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual METOCDispositionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    METOCDispositionType&
    operator= (const METOCDispositionType& x);

    virtual 
    ~METOCDispositionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< AnchorPoints_type > AnchorPoints_;
    DirectionOfMovement_optional DirectionOfMovement_;
    Speed_optional Speed_;
  };

  class METOCGraphicType: public ::xml_schema::type
  {
    public:
    // ObjectHandle
    //
    typedef ::msdl_1::patternUUID32 ObjectHandle_type;
    typedef ::xsd::cxx::tree::traits< ObjectHandle_type, char > ObjectHandle_traits;

    const ObjectHandle_type&
    ObjectHandle () const;

    ObjectHandle_type&
    ObjectHandle ();

    void
    ObjectHandle (const ObjectHandle_type& x);

    void
    ObjectHandle (::std::unique_ptr< ObjectHandle_type > p);

    // SymbolIdentifier
    //
    typedef ::msdl_1::patternMETOCSymbolID15 SymbolIdentifier_type;
    typedef ::xsd::cxx::tree::traits< SymbolIdentifier_type, char > SymbolIdentifier_traits;

    const SymbolIdentifier_type&
    SymbolIdentifier () const;

    SymbolIdentifier_type&
    SymbolIdentifier ();

    void
    SymbolIdentifier (const SymbolIdentifier_type& x);

    void
    SymbolIdentifier (::std::unique_ptr< SymbolIdentifier_type > p);

    // UniqueDesignation
    //
    typedef ::msdl_1::text21 UniqueDesignation_type;
    typedef ::xsd::cxx::tree::traits< UniqueDesignation_type, char > UniqueDesignation_traits;

    const UniqueDesignation_type&
    UniqueDesignation () const;

    UniqueDesignation_type&
    UniqueDesignation ();

    void
    UniqueDesignation (const UniqueDesignation_type& x);

    void
    UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > p);

    // DateTimeGroup
    //
    typedef ::msdl_1::patternTimeDTGRelative20 DateTimeGroup_type;
    typedef ::xsd::cxx::tree::optional< DateTimeGroup_type > DateTimeGroup_optional;
    typedef ::xsd::cxx::tree::traits< DateTimeGroup_type, char > DateTimeGroup_traits;

    const DateTimeGroup_optional&
    DateTimeGroup () const;

    DateTimeGroup_optional&
    DateTimeGroup ();

    void
    DateTimeGroup (const DateTimeGroup_type& x);

    void
    DateTimeGroup (const DateTimeGroup_optional& x);

    void
    DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > p);

    // DateTimeGroup1
    //
    typedef ::msdl_1::patternTimeDTGRelative20 DateTimeGroup1_type;
    typedef ::xsd::cxx::tree::optional< DateTimeGroup1_type > DateTimeGroup1_optional;
    typedef ::xsd::cxx::tree::traits< DateTimeGroup1_type, char > DateTimeGroup1_traits;

    const DateTimeGroup1_optional&
    DateTimeGroup1 () const;

    DateTimeGroup1_optional&
    DateTimeGroup1 ();

    void
    DateTimeGroup1 (const DateTimeGroup1_type& x);

    void
    DateTimeGroup1 (const DateTimeGroup1_optional& x);

    void
    DateTimeGroup1 (::std::unique_ptr< DateTimeGroup1_type > p);

    // Quantity
    //
    typedef ::msdl_1::integerQuantity9 Quantity_type;
    typedef ::xsd::cxx::tree::optional< Quantity_type > Quantity_optional;
    typedef ::xsd::cxx::tree::traits< Quantity_type, char > Quantity_traits;

    const Quantity_optional&
    Quantity () const;

    Quantity_optional&
    Quantity ();

    void
    Quantity (const Quantity_type& x);

    void
    Quantity (const Quantity_optional& x);

    void
    Quantity (::std::unique_ptr< Quantity_type > p);

    // AdditionalInfo
    //
    typedef ::msdl_1::text20 AdditionalInfo_type;
    typedef ::xsd::cxx::tree::optional< AdditionalInfo_type > AdditionalInfo_optional;
    typedef ::xsd::cxx::tree::traits< AdditionalInfo_type, char > AdditionalInfo_traits;

    const AdditionalInfo_optional&
    AdditionalInfo () const;

    AdditionalInfo_optional&
    AdditionalInfo ();

    void
    AdditionalInfo (const AdditionalInfo_type& x);

    void
    AdditionalInfo (const AdditionalInfo_optional& x);

    void
    AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > p);

    // Disposition
    //
    typedef ::msdl_1::METOCDispositionType Disposition_type;
    typedef ::xsd::cxx::tree::traits< Disposition_type, char > Disposition_traits;

    const Disposition_type&
    Disposition () const;

    Disposition_type&
    Disposition ();

    void
    Disposition (const Disposition_type& x);

    void
    Disposition (::std::unique_ptr< Disposition_type > p);

    // Constructors.
    //
    METOCGraphicType (const ObjectHandle_type&,
                      const SymbolIdentifier_type&,
                      const UniqueDesignation_type&,
                      const Disposition_type&);

    METOCGraphicType (const ObjectHandle_type&,
                      const SymbolIdentifier_type&,
                      const UniqueDesignation_type&,
                      ::std::unique_ptr< Disposition_type >);

    METOCGraphicType (::std::unique_ptr< ObjectHandle_type >,
                      ::std::unique_ptr< SymbolIdentifier_type >,
                      ::std::unique_ptr< UniqueDesignation_type >,
                      ::std::unique_ptr< Disposition_type >);

    METOCGraphicType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    METOCGraphicType (const METOCGraphicType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual METOCGraphicType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    METOCGraphicType&
    operator= (const METOCGraphicType& x);

    virtual 
    ~METOCGraphicType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ObjectHandle_type > ObjectHandle_;
    ::xsd::cxx::tree::one< SymbolIdentifier_type > SymbolIdentifier_;
    ::xsd::cxx::tree::one< UniqueDesignation_type > UniqueDesignation_;
    DateTimeGroup_optional DateTimeGroup_;
    DateTimeGroup1_optional DateTimeGroup1_;
    Quantity_optional Quantity_;
    AdditionalInfo_optional AdditionalInfo_;
    ::xsd::cxx::tree::one< Disposition_type > Disposition_;
  };

  class METOCType: public ::xml_schema::type
  {
    public:
    // METOCGraphic
    //
    typedef ::msdl_1::METOCGraphicType METOCGraphic_type;
    typedef ::xsd::cxx::tree::sequence< METOCGraphic_type > METOCGraphic_sequence;
    typedef METOCGraphic_sequence::iterator METOCGraphic_iterator;
    typedef METOCGraphic_sequence::const_iterator METOCGraphic_const_iterator;
    typedef ::xsd::cxx::tree::traits< METOCGraphic_type, char > METOCGraphic_traits;

    const METOCGraphic_sequence&
    METOCGraphic () const;

    METOCGraphic_sequence&
    METOCGraphic ();

    void
    METOCGraphic (const METOCGraphic_sequence& s);

    // Constructors.
    //
    METOCType ();

    METOCType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    METOCType (const METOCType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual METOCType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    METOCType&
    operator= (const METOCType& x);

    virtual 
    ~METOCType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    METOCGraphic_sequence METOCGraphic_;
  };

  class MilitaryScenarioType: public ::xml_schema::type
  {
    public:
    // ScenarioID
    //
    typedef ::schemas::modelID::modelIdentificationType ScenarioID_type;
    typedef ::xsd::cxx::tree::traits< ScenarioID_type, char > ScenarioID_traits;

    const ScenarioID_type&
    ScenarioID () const;

    ScenarioID_type&
    ScenarioID ();

    void
    ScenarioID (const ScenarioID_type& x);

    void
    ScenarioID (::std::unique_ptr< ScenarioID_type > p);

    // Options
    //
    typedef ::msdl_1::OptionsType Options_type;
    typedef ::xsd::cxx::tree::traits< Options_type, char > Options_traits;

    const Options_type&
    Options () const;

    Options_type&
    Options ();

    void
    Options (const Options_type& x);

    void
    Options (::std::unique_ptr< Options_type > p);

    // Environment
    //
    typedef ::msdl_1::EnvironmentType Environment_type;
    typedef ::xsd::cxx::tree::optional< Environment_type > Environment_optional;
    typedef ::xsd::cxx::tree::traits< Environment_type, char > Environment_traits;

    const Environment_optional&
    Environment () const;

    Environment_optional&
    Environment ();

    void
    Environment (const Environment_type& x);

    void
    Environment (const Environment_optional& x);

    void
    Environment (::std::unique_ptr< Environment_type > p);

    // ForceSides
    //
    typedef ::msdl_1::ForceSidesType ForceSides_type;
    typedef ::xsd::cxx::tree::traits< ForceSides_type, char > ForceSides_traits;

    const ForceSides_type&
    ForceSides () const;

    ForceSides_type&
    ForceSides ();

    void
    ForceSides (const ForceSides_type& x);

    void
    ForceSides (::std::unique_ptr< ForceSides_type > p);

    // Organizations
    //
    typedef ::msdl_1::OrganizationsType Organizations_type;
    typedef ::xsd::cxx::tree::optional< Organizations_type > Organizations_optional;
    typedef ::xsd::cxx::tree::traits< Organizations_type, char > Organizations_traits;

    const Organizations_optional&
    Organizations () const;

    Organizations_optional&
    Organizations ();

    void
    Organizations (const Organizations_type& x);

    void
    Organizations (const Organizations_optional& x);

    void
    Organizations (::std::unique_ptr< Organizations_type > p);

    // Overlays
    //
    typedef ::msdl_1::OverlaysType Overlays_type;
    typedef ::xsd::cxx::tree::optional< Overlays_type > Overlays_optional;
    typedef ::xsd::cxx::tree::traits< Overlays_type, char > Overlays_traits;

    const Overlays_optional&
    Overlays () const;

    Overlays_optional&
    Overlays ();

    void
    Overlays (const Overlays_type& x);

    void
    Overlays (const Overlays_optional& x);

    void
    Overlays (::std::unique_ptr< Overlays_type > p);

    // Installations
    //
    typedef ::msdl_1::InstallationsType Installations_type;
    typedef ::xsd::cxx::tree::optional< Installations_type > Installations_optional;
    typedef ::xsd::cxx::tree::traits< Installations_type, char > Installations_traits;

    const Installations_optional&
    Installations () const;

    Installations_optional&
    Installations ();

    void
    Installations (const Installations_type& x);

    void
    Installations (const Installations_optional& x);

    void
    Installations (::std::unique_ptr< Installations_type > p);

    // TacticalGraphics
    //
    typedef ::msdl_1::TacticalGraphicsType TacticalGraphics_type;
    typedef ::xsd::cxx::tree::optional< TacticalGraphics_type > TacticalGraphics_optional;
    typedef ::xsd::cxx::tree::traits< TacticalGraphics_type, char > TacticalGraphics_traits;

    const TacticalGraphics_optional&
    TacticalGraphics () const;

    TacticalGraphics_optional&
    TacticalGraphics ();

    void
    TacticalGraphics (const TacticalGraphics_type& x);

    void
    TacticalGraphics (const TacticalGraphics_optional& x);

    void
    TacticalGraphics (::std::unique_ptr< TacticalGraphics_type > p);

    // MOOTWGraphics
    //
    typedef ::msdl_1::MOOTWGraphicsType MOOTWGraphics_type;
    typedef ::xsd::cxx::tree::optional< MOOTWGraphics_type > MOOTWGraphics_optional;
    typedef ::xsd::cxx::tree::traits< MOOTWGraphics_type, char > MOOTWGraphics_traits;

    const MOOTWGraphics_optional&
    MOOTWGraphics () const;

    MOOTWGraphics_optional&
    MOOTWGraphics ();

    void
    MOOTWGraphics (const MOOTWGraphics_type& x);

    void
    MOOTWGraphics (const MOOTWGraphics_optional& x);

    void
    MOOTWGraphics (::std::unique_ptr< MOOTWGraphics_type > p);

    // Constructors.
    //
    MilitaryScenarioType (const ScenarioID_type&,
                          const Options_type&,
                          const ForceSides_type&);

    MilitaryScenarioType (::std::unique_ptr< ScenarioID_type >,
                          ::std::unique_ptr< Options_type >,
                          ::std::unique_ptr< ForceSides_type >);

    MilitaryScenarioType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    MilitaryScenarioType (const MilitaryScenarioType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual MilitaryScenarioType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MilitaryScenarioType&
    operator= (const MilitaryScenarioType& x);

    virtual 
    ~MilitaryScenarioType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ScenarioID_type > ScenarioID_;
    ::xsd::cxx::tree::one< Options_type > Options_;
    Environment_optional Environment_;
    ::xsd::cxx::tree::one< ForceSides_type > ForceSides_;
    Organizations_optional Organizations_;
    Overlays_optional Overlays_;
    Installations_optional Installations_;
    TacticalGraphics_optional TacticalGraphics_;
    MOOTWGraphics_optional MOOTWGraphics_;
  };

  class MGRSType: public ::xml_schema::type
  {
    public:
    // MGRSGridZone
    //
    typedef ::msdl_1::patternMGRSGridSquare2 MGRSGridZone_type;
    typedef ::xsd::cxx::tree::traits< MGRSGridZone_type, char > MGRSGridZone_traits;

    const MGRSGridZone_type&
    MGRSGridZone () const;

    MGRSGridZone_type&
    MGRSGridZone ();

    void
    MGRSGridZone (const MGRSGridZone_type& x);

    void
    MGRSGridZone (::std::unique_ptr< MGRSGridZone_type > p);

    // MGRSGridSquare
    //
    typedef ::msdl_1::patternMGRSGridSquare2 MGRSGridSquare_type;
    typedef ::xsd::cxx::tree::traits< MGRSGridSquare_type, char > MGRSGridSquare_traits;

    const MGRSGridSquare_type&
    MGRSGridSquare () const;

    MGRSGridSquare_type&
    MGRSGridSquare ();

    void
    MGRSGridSquare (const MGRSGridSquare_type& x);

    void
    MGRSGridSquare (::std::unique_ptr< MGRSGridSquare_type > p);

    // MGRSPrecision
    //
    typedef ::msdl_1::integerMGRSPrecision1 MGRSPrecision_type;
    typedef ::xsd::cxx::tree::traits< MGRSPrecision_type, char > MGRSPrecision_traits;

    const MGRSPrecision_type&
    MGRSPrecision () const;

    MGRSPrecision_type&
    MGRSPrecision ();

    void
    MGRSPrecision (const MGRSPrecision_type& x);

    void
    MGRSPrecision (::std::unique_ptr< MGRSPrecision_type > p);

    // MGRSEasting
    //
    typedef ::msdl_1::integerMGRSEasting5 MGRSEasting_type;
    typedef ::xsd::cxx::tree::traits< MGRSEasting_type, char > MGRSEasting_traits;

    const MGRSEasting_type&
    MGRSEasting () const;

    MGRSEasting_type&
    MGRSEasting ();

    void
    MGRSEasting (const MGRSEasting_type& x);

    void
    MGRSEasting (::std::unique_ptr< MGRSEasting_type > p);

    // MGRSNorthing
    //
    typedef ::msdl_1::integerMGRSNorthing5 MGRSNorthing_type;
    typedef ::xsd::cxx::tree::traits< MGRSNorthing_type, char > MGRSNorthing_traits;

    const MGRSNorthing_type&
    MGRSNorthing () const;

    MGRSNorthing_type&
    MGRSNorthing ();

    void
    MGRSNorthing (const MGRSNorthing_type& x);

    void
    MGRSNorthing (::std::unique_ptr< MGRSNorthing_type > p);

    // ElevationAGL
    //
    typedef ::msdl_1::floatElevationAGL6_2 ElevationAGL_type;
    typedef ::xsd::cxx::tree::optional< ElevationAGL_type > ElevationAGL_optional;
    typedef ::xsd::cxx::tree::traits< ElevationAGL_type, char > ElevationAGL_traits;

    const ElevationAGL_optional&
    ElevationAGL () const;

    ElevationAGL_optional&
    ElevationAGL ();

    void
    ElevationAGL (const ElevationAGL_type& x);

    void
    ElevationAGL (const ElevationAGL_optional& x);

    void
    ElevationAGL (::std::unique_ptr< ElevationAGL_type > p);

    // Constructors.
    //
    MGRSType (const MGRSGridZone_type&,
              const MGRSGridSquare_type&,
              const MGRSPrecision_type&,
              const MGRSEasting_type&,
              const MGRSNorthing_type&);

    MGRSType (::std::unique_ptr< MGRSGridZone_type >,
              ::std::unique_ptr< MGRSGridSquare_type >,
              ::std::unique_ptr< MGRSPrecision_type >,
              ::std::unique_ptr< MGRSEasting_type >,
              ::std::unique_ptr< MGRSNorthing_type >);

    MGRSType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    MGRSType (const MGRSType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual MGRSType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MGRSType&
    operator= (const MGRSType& x);

    virtual 
    ~MGRSType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< MGRSGridZone_type > MGRSGridZone_;
    ::xsd::cxx::tree::one< MGRSGridSquare_type > MGRSGridSquare_;
    ::xsd::cxx::tree::one< MGRSPrecision_type > MGRSPrecision_;
    ::xsd::cxx::tree::one< MGRSEasting_type > MGRSEasting_;
    ::xsd::cxx::tree::one< MGRSNorthing_type > MGRSNorthing_;
    ElevationAGL_optional ElevationAGL_;
  };

  class MOOTWDispositionType: public ::xml_schema::type
  {
    public:
    // Location
    //
    typedef ::msdl_1::CoordinatesType Location_type;
    typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

    const Location_type&
    Location () const;

    Location_type&
    Location ();

    void
    Location (const Location_type& x);

    void
    Location (::std::unique_ptr< Location_type > p);

    // DirectionOfMovement
    //
    typedef ::msdl_1::floatCompassDegrees3_3 DirectionOfMovement_type;
    typedef ::xsd::cxx::tree::optional< DirectionOfMovement_type > DirectionOfMovement_optional;
    typedef ::xsd::cxx::tree::traits< DirectionOfMovement_type, char > DirectionOfMovement_traits;

    const DirectionOfMovement_optional&
    DirectionOfMovement () const;

    DirectionOfMovement_optional&
    DirectionOfMovement ();

    void
    DirectionOfMovement (const DirectionOfMovement_type& x);

    void
    DirectionOfMovement (const DirectionOfMovement_optional& x);

    void
    DirectionOfMovement (::std::unique_ptr< DirectionOfMovement_type > p);

    // Speed
    //
    typedef ::msdl_1::floatSpeed6_2 Speed_type;
    typedef ::xsd::cxx::tree::optional< Speed_type > Speed_optional;
    typedef ::xsd::cxx::tree::traits< Speed_type, char > Speed_traits;

    const Speed_optional&
    Speed () const;

    Speed_optional&
    Speed ();

    void
    Speed (const Speed_type& x);

    void
    Speed (const Speed_optional& x);

    void
    Speed (::std::unique_ptr< Speed_type > p);

    // Constructors.
    //
    MOOTWDispositionType (const Location_type&);

    MOOTWDispositionType (::std::unique_ptr< Location_type >);

    MOOTWDispositionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    MOOTWDispositionType (const MOOTWDispositionType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual MOOTWDispositionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MOOTWDispositionType&
    operator= (const MOOTWDispositionType& x);

    virtual 
    ~MOOTWDispositionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Location_type > Location_;
    DirectionOfMovement_optional DirectionOfMovement_;
    Speed_optional Speed_;
  };

  class MOOTWGraphicsType: public ::xml_schema::type
  {
    public:
    // MOOTWGraphic
    //
    typedef ::msdl_1::MOOTWGraphicType MOOTWGraphic_type;
    typedef ::xsd::cxx::tree::sequence< MOOTWGraphic_type > MOOTWGraphic_sequence;
    typedef MOOTWGraphic_sequence::iterator MOOTWGraphic_iterator;
    typedef MOOTWGraphic_sequence::const_iterator MOOTWGraphic_const_iterator;
    typedef ::xsd::cxx::tree::traits< MOOTWGraphic_type, char > MOOTWGraphic_traits;

    const MOOTWGraphic_sequence&
    MOOTWGraphic () const;

    MOOTWGraphic_sequence&
    MOOTWGraphic ();

    void
    MOOTWGraphic (const MOOTWGraphic_sequence& s);

    // Constructors.
    //
    MOOTWGraphicsType ();

    MOOTWGraphicsType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    MOOTWGraphicsType (const MOOTWGraphicsType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual MOOTWGraphicsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MOOTWGraphicsType&
    operator= (const MOOTWGraphicsType& x);

    virtual 
    ~MOOTWGraphicsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    MOOTWGraphic_sequence MOOTWGraphic_;
  };

  class MOOTWGraphicType: public ::xml_schema::type
  {
    public:
    // ObjectHandle
    //
    typedef ::msdl_1::patternUUID32 ObjectHandle_type;
    typedef ::xsd::cxx::tree::traits< ObjectHandle_type, char > ObjectHandle_traits;

    const ObjectHandle_type&
    ObjectHandle () const;

    ObjectHandle_type&
    ObjectHandle ();

    void
    ObjectHandle (const ObjectHandle_type& x);

    void
    ObjectHandle (::std::unique_ptr< ObjectHandle_type > p);

    // SymbolIdentifier
    //
    typedef ::msdl_1::patternMOOTWSymbolID15 SymbolIdentifier_type;
    typedef ::xsd::cxx::tree::traits< SymbolIdentifier_type, char > SymbolIdentifier_traits;

    const SymbolIdentifier_type&
    SymbolIdentifier () const;

    SymbolIdentifier_type&
    SymbolIdentifier ();

    void
    SymbolIdentifier (const SymbolIdentifier_type& x);

    void
    SymbolIdentifier (::std::unique_ptr< SymbolIdentifier_type > p);

    // Affiliation
    //
    typedef ::msdl_1::enumBaseAffiliation Affiliation_type;
    typedef ::xsd::cxx::tree::traits< Affiliation_type, char > Affiliation_traits;

    const Affiliation_type&
    Affiliation () const;

    Affiliation_type&
    Affiliation ();

    void
    Affiliation (const Affiliation_type& x);

    void
    Affiliation (::std::unique_ptr< Affiliation_type > p);

    // Owner
    //
    typedef ::msdl_1::OwnerType Owner_type;
    typedef ::xsd::cxx::tree::traits< Owner_type, char > Owner_traits;

    const Owner_type&
    Owner () const;

    Owner_type&
    Owner ();

    void
    Owner (const Owner_type& x);

    void
    Owner (::std::unique_ptr< Owner_type > p);

    // MOOTWSymbolModifiers
    //
    typedef ::msdl_1::MOOTWSymbolModifiersType MOOTWSymbolModifiers_type;
    typedef ::xsd::cxx::tree::optional< MOOTWSymbolModifiers_type > MOOTWSymbolModifiers_optional;
    typedef ::xsd::cxx::tree::traits< MOOTWSymbolModifiers_type, char > MOOTWSymbolModifiers_traits;

    const MOOTWSymbolModifiers_optional&
    MOOTWSymbolModifiers () const;

    MOOTWSymbolModifiers_optional&
    MOOTWSymbolModifiers ();

    void
    MOOTWSymbolModifiers (const MOOTWSymbolModifiers_type& x);

    void
    MOOTWSymbolModifiers (const MOOTWSymbolModifiers_optional& x);

    void
    MOOTWSymbolModifiers (::std::unique_ptr< MOOTWSymbolModifiers_type > p);

    // AssociatedOverlays
    //
    typedef ::msdl_1::AssociatedOverlaysType AssociatedOverlays_type;
    typedef ::xsd::cxx::tree::optional< AssociatedOverlays_type > AssociatedOverlays_optional;
    typedef ::xsd::cxx::tree::traits< AssociatedOverlays_type, char > AssociatedOverlays_traits;

    const AssociatedOverlays_optional&
    AssociatedOverlays () const;

    AssociatedOverlays_optional&
    AssociatedOverlays ();

    void
    AssociatedOverlays (const AssociatedOverlays_type& x);

    void
    AssociatedOverlays (const AssociatedOverlays_optional& x);

    void
    AssociatedOverlays (::std::unique_ptr< AssociatedOverlays_type > p);

    // Disposition
    //
    typedef ::msdl_1::MOOTWDispositionType Disposition_type;
    typedef ::xsd::cxx::tree::traits< Disposition_type, char > Disposition_traits;

    const Disposition_type&
    Disposition () const;

    Disposition_type&
    Disposition ();

    void
    Disposition (const Disposition_type& x);

    void
    Disposition (::std::unique_ptr< Disposition_type > p);

    // Constructors.
    //
    MOOTWGraphicType (const ObjectHandle_type&,
                      const SymbolIdentifier_type&,
                      const Affiliation_type&,
                      const Owner_type&,
                      const Disposition_type&);

    MOOTWGraphicType (const ObjectHandle_type&,
                      const SymbolIdentifier_type&,
                      const Affiliation_type&,
                      ::std::unique_ptr< Owner_type >,
                      ::std::unique_ptr< Disposition_type >);

    MOOTWGraphicType (::std::unique_ptr< ObjectHandle_type >,
                      ::std::unique_ptr< SymbolIdentifier_type >,
                      ::std::unique_ptr< Affiliation_type >,
                      ::std::unique_ptr< Owner_type >,
                      ::std::unique_ptr< Disposition_type >);

    MOOTWGraphicType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    MOOTWGraphicType (const MOOTWGraphicType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual MOOTWGraphicType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MOOTWGraphicType&
    operator= (const MOOTWGraphicType& x);

    virtual 
    ~MOOTWGraphicType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ObjectHandle_type > ObjectHandle_;
    ::xsd::cxx::tree::one< SymbolIdentifier_type > SymbolIdentifier_;
    ::xsd::cxx::tree::one< Affiliation_type > Affiliation_;
    ::xsd::cxx::tree::one< Owner_type > Owner_;
    MOOTWSymbolModifiers_optional MOOTWSymbolModifiers_;
    AssociatedOverlays_optional AssociatedOverlays_;
    ::xsd::cxx::tree::one< Disposition_type > Disposition_;
  };

  class MOOTWSymbolModifiersType: public ::xml_schema::type
  {
    public:
    // Echelon
    //
    typedef ::msdl_1::enumEchelon Echelon_type;
    typedef ::xsd::cxx::tree::optional< Echelon_type > Echelon_optional;
    typedef ::xsd::cxx::tree::traits< Echelon_type, char > Echelon_traits;

    const Echelon_optional&
    Echelon () const;

    Echelon_optional&
    Echelon ();

    void
    Echelon (const Echelon_type& x);

    void
    Echelon (const Echelon_optional& x);

    void
    Echelon (::std::unique_ptr< Echelon_type > p);

    // ReinforcedReduced
    //
    typedef ::msdl_1::enumReinforcedReducedType ReinforcedReduced_type;
    typedef ::xsd::cxx::tree::optional< ReinforcedReduced_type > ReinforcedReduced_optional;
    typedef ::xsd::cxx::tree::traits< ReinforcedReduced_type, char > ReinforcedReduced_traits;

    const ReinforcedReduced_optional&
    ReinforcedReduced () const;

    ReinforcedReduced_optional&
    ReinforcedReduced ();

    void
    ReinforcedReduced (const ReinforcedReduced_type& x);

    void
    ReinforcedReduced (const ReinforcedReduced_optional& x);

    void
    ReinforcedReduced (::std::unique_ptr< ReinforcedReduced_type > p);

    // FrameShapeModifier
    //
    typedef ::msdl_1::enumFrameShapeModifierType FrameShapeModifier_type;
    typedef ::xsd::cxx::tree::optional< FrameShapeModifier_type > FrameShapeModifier_optional;
    typedef ::xsd::cxx::tree::traits< FrameShapeModifier_type, char > FrameShapeModifier_traits;

    const FrameShapeModifier_optional&
    FrameShapeModifier () const;

    FrameShapeModifier_optional&
    FrameShapeModifier ();

    void
    FrameShapeModifier (const FrameShapeModifier_type& x);

    void
    FrameShapeModifier (const FrameShapeModifier_optional& x);

    void
    FrameShapeModifier (::std::unique_ptr< FrameShapeModifier_type > p);

    // StaffComments
    //
    typedef ::msdl_1::text20 StaffComments_type;
    typedef ::xsd::cxx::tree::optional< StaffComments_type > StaffComments_optional;
    typedef ::xsd::cxx::tree::traits< StaffComments_type, char > StaffComments_traits;

    const StaffComments_optional&
    StaffComments () const;

    StaffComments_optional&
    StaffComments ();

    void
    StaffComments (const StaffComments_type& x);

    void
    StaffComments (const StaffComments_optional& x);

    void
    StaffComments (::std::unique_ptr< StaffComments_type > p);

    // AdditionalInfo
    //
    typedef ::msdl_1::text20 AdditionalInfo_type;
    typedef ::xsd::cxx::tree::optional< AdditionalInfo_type > AdditionalInfo_optional;
    typedef ::xsd::cxx::tree::traits< AdditionalInfo_type, char > AdditionalInfo_traits;

    const AdditionalInfo_optional&
    AdditionalInfo () const;

    AdditionalInfo_optional&
    AdditionalInfo ();

    void
    AdditionalInfo (const AdditionalInfo_type& x);

    void
    AdditionalInfo (const AdditionalInfo_optional& x);

    void
    AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > p);

    // CombatEffectiveness
    //
    typedef ::msdl_1::enumCombatEffectivenessType CombatEffectiveness_type;
    typedef ::xsd::cxx::tree::optional< CombatEffectiveness_type > CombatEffectiveness_optional;
    typedef ::xsd::cxx::tree::traits< CombatEffectiveness_type, char > CombatEffectiveness_traits;

    const CombatEffectiveness_optional&
    CombatEffectiveness () const;

    CombatEffectiveness_optional&
    CombatEffectiveness ();

    void
    CombatEffectiveness (const CombatEffectiveness_type& x);

    void
    CombatEffectiveness (const CombatEffectiveness_optional& x);

    void
    CombatEffectiveness (::std::unique_ptr< CombatEffectiveness_type > p);

    // IFF
    //
    typedef ::msdl_1::textIFF5 IFF_type;
    typedef ::xsd::cxx::tree::optional< IFF_type > IFF_optional;
    typedef ::xsd::cxx::tree::traits< IFF_type, char > IFF_traits;

    const IFF_optional&
    IFF () const;

    IFF_optional&
    IFF ();

    void
    IFF (const IFF_type& x);

    void
    IFF (const IFF_optional& x);

    void
    IFF (::std::unique_ptr< IFF_type > p);

    // UniqueDesignation
    //
    typedef ::msdl_1::text21 UniqueDesignation_type;
    typedef ::xsd::cxx::tree::traits< UniqueDesignation_type, char > UniqueDesignation_traits;

    const UniqueDesignation_type&
    UniqueDesignation () const;

    UniqueDesignation_type&
    UniqueDesignation ();

    void
    UniqueDesignation (const UniqueDesignation_type& x);

    void
    UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > p);

    // DateTimeGroup
    //
    typedef ::msdl_1::patternTimeDTGRelative20 DateTimeGroup_type;
    typedef ::xsd::cxx::tree::optional< DateTimeGroup_type > DateTimeGroup_optional;
    typedef ::xsd::cxx::tree::traits< DateTimeGroup_type, char > DateTimeGroup_traits;

    const DateTimeGroup_optional&
    DateTimeGroup () const;

    DateTimeGroup_optional&
    DateTimeGroup ();

    void
    DateTimeGroup (const DateTimeGroup_type& x);

    void
    DateTimeGroup (const DateTimeGroup_optional& x);

    void
    DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > p);

    // SpecialC2HQ
    //
    typedef ::msdl_1::textSpecialC2HQ9 SpecialC2HQ_type;
    typedef ::xsd::cxx::tree::optional< SpecialC2HQ_type > SpecialC2HQ_optional;
    typedef ::xsd::cxx::tree::traits< SpecialC2HQ_type, char > SpecialC2HQ_traits;

    const SpecialC2HQ_optional&
    SpecialC2HQ () const;

    SpecialC2HQ_optional&
    SpecialC2HQ ();

    void
    SpecialC2HQ (const SpecialC2HQ_type& x);

    void
    SpecialC2HQ (const SpecialC2HQ_optional& x);

    void
    SpecialC2HQ (::std::unique_ptr< SpecialC2HQ_type > p);

    // Constructors.
    //
    MOOTWSymbolModifiersType (const UniqueDesignation_type&);

    MOOTWSymbolModifiersType (::std::unique_ptr< UniqueDesignation_type >);

    MOOTWSymbolModifiersType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    MOOTWSymbolModifiersType (const MOOTWSymbolModifiersType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual MOOTWSymbolModifiersType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MOOTWSymbolModifiersType&
    operator= (const MOOTWSymbolModifiersType& x);

    virtual 
    ~MOOTWSymbolModifiersType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Echelon_optional Echelon_;
    ReinforcedReduced_optional ReinforcedReduced_;
    FrameShapeModifier_optional FrameShapeModifier_;
    StaffComments_optional StaffComments_;
    AdditionalInfo_optional AdditionalInfo_;
    CombatEffectiveness_optional CombatEffectiveness_;
    IFF_optional IFF_;
    ::xsd::cxx::tree::one< UniqueDesignation_type > UniqueDesignation_;
    DateTimeGroup_optional DateTimeGroup_;
    SpecialC2HQ_optional SpecialC2HQ_;
  };

  class NBCEventSymbolModifiersType: public ::xml_schema::type
  {
    public:
    // Quantity
    //
    typedef ::msdl_1::integerQuantity9 Quantity_type;
    typedef ::xsd::cxx::tree::optional< Quantity_type > Quantity_optional;
    typedef ::xsd::cxx::tree::traits< Quantity_type, char > Quantity_traits;

    const Quantity_optional&
    Quantity () const;

    Quantity_optional&
    Quantity ();

    void
    Quantity (const Quantity_type& x);

    void
    Quantity (const Quantity_optional& x);

    void
    Quantity (::std::unique_ptr< Quantity_type > p);

    // AdditionalInfo
    //
    typedef ::msdl_1::text20 AdditionalInfo_type;
    typedef ::xsd::cxx::tree::optional< AdditionalInfo_type > AdditionalInfo_optional;
    typedef ::xsd::cxx::tree::traits< AdditionalInfo_type, char > AdditionalInfo_traits;

    const AdditionalInfo_optional&
    AdditionalInfo () const;

    AdditionalInfo_optional&
    AdditionalInfo ();

    void
    AdditionalInfo (const AdditionalInfo_type& x);

    void
    AdditionalInfo (const AdditionalInfo_optional& x);

    void
    AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > p);

    // UniqueDesignation
    //
    typedef ::msdl_1::text21 UniqueDesignation_type;
    typedef ::xsd::cxx::tree::optional< UniqueDesignation_type > UniqueDesignation_optional;
    typedef ::xsd::cxx::tree::traits< UniqueDesignation_type, char > UniqueDesignation_traits;

    const UniqueDesignation_optional&
    UniqueDesignation () const;

    UniqueDesignation_optional&
    UniqueDesignation ();

    void
    UniqueDesignation (const UniqueDesignation_type& x);

    void
    UniqueDesignation (const UniqueDesignation_optional& x);

    void
    UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > p);

    // NBCType
    //
    typedef ::msdl_1::text20 NBCType_type;
    typedef ::xsd::cxx::tree::optional< NBCType_type > NBCType_optional;
    typedef ::xsd::cxx::tree::traits< NBCType_type, char > NBCType_traits;

    const NBCType_optional&
    NBCType () const;

    NBCType_optional&
    NBCType ();

    void
    NBCType (const NBCType_type& x);

    void
    NBCType (const NBCType_optional& x);

    void
    NBCType (::std::unique_ptr< NBCType_type > p);

    // DateTimeGroup
    //
    typedef ::msdl_1::patternTimeDTGRelative20 DateTimeGroup_type;
    typedef ::xsd::cxx::tree::optional< DateTimeGroup_type > DateTimeGroup_optional;
    typedef ::xsd::cxx::tree::traits< DateTimeGroup_type, char > DateTimeGroup_traits;

    const DateTimeGroup_optional&
    DateTimeGroup () const;

    DateTimeGroup_optional&
    DateTimeGroup ();

    void
    DateTimeGroup (const DateTimeGroup_type& x);

    void
    DateTimeGroup (const DateTimeGroup_optional& x);

    void
    DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > p);

    // Speed
    //
    typedef ::msdl_1::floatSpeed6_2 Speed_type;
    typedef ::xsd::cxx::tree::traits< Speed_type, char > Speed_traits;

    const Speed_type&
    Speed () const;

    Speed_type&
    Speed ();

    void
    Speed (const Speed_type& x);

    void
    Speed (::std::unique_ptr< Speed_type > p);

    // DirectionOfMovement
    //
    typedef ::msdl_1::floatCompassDegrees3_3 DirectionOfMovement_type;
    typedef ::xsd::cxx::tree::traits< DirectionOfMovement_type, char > DirectionOfMovement_traits;

    const DirectionOfMovement_type&
    DirectionOfMovement () const;

    DirectionOfMovement_type&
    DirectionOfMovement ();

    void
    DirectionOfMovement (const DirectionOfMovement_type& x);

    void
    DirectionOfMovement (::std::unique_ptr< DirectionOfMovement_type > p);

    // Constructors.
    //
    NBCEventSymbolModifiersType (const Speed_type&,
                                 const DirectionOfMovement_type&);

    NBCEventSymbolModifiersType (::std::unique_ptr< Speed_type >,
                                 ::std::unique_ptr< DirectionOfMovement_type >);

    NBCEventSymbolModifiersType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    NBCEventSymbolModifiersType (const NBCEventSymbolModifiersType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual NBCEventSymbolModifiersType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NBCEventSymbolModifiersType&
    operator= (const NBCEventSymbolModifiersType& x);

    virtual 
    ~NBCEventSymbolModifiersType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Quantity_optional Quantity_;
    AdditionalInfo_optional AdditionalInfo_;
    UniqueDesignation_optional UniqueDesignation_;
    NBCType_optional NBCType_;
    DateTimeGroup_optional DateTimeGroup_;
    ::xsd::cxx::tree::one< Speed_type > Speed_;
    ::xsd::cxx::tree::one< DirectionOfMovement_type > DirectionOfMovement_;
  };

  class OptionsType: public ::xml_schema::type
  {
    public:
    // MSDLVersion
    //
    typedef ::msdl_1::textIdentifier64 MSDLVersion_type;
    typedef ::xsd::cxx::tree::traits< MSDLVersion_type, char > MSDLVersion_traits;

    const MSDLVersion_type&
    MSDLVersion () const;

    MSDLVersion_type&
    MSDLVersion ();

    void
    MSDLVersion (const MSDLVersion_type& x);

    void
    MSDLVersion (::std::unique_ptr< MSDLVersion_type > p);

    // OrganizationDetail
    //
    typedef ::msdl_1::OrganizationDetailType OrganizationDetail_type;
    typedef ::xsd::cxx::tree::optional< OrganizationDetail_type > OrganizationDetail_optional;
    typedef ::xsd::cxx::tree::traits< OrganizationDetail_type, char > OrganizationDetail_traits;

    const OrganizationDetail_optional&
    OrganizationDetail () const;

    OrganizationDetail_optional&
    OrganizationDetail ();

    void
    OrganizationDetail (const OrganizationDetail_type& x);

    void
    OrganizationDetail (const OrganizationDetail_optional& x);

    void
    OrganizationDetail (::std::unique_ptr< OrganizationDetail_type > p);

    // ScenarioDataStandards
    //
    typedef ::msdl_1::ScenarioDataStandardsType ScenarioDataStandards_type;
    typedef ::xsd::cxx::tree::optional< ScenarioDataStandards_type > ScenarioDataStandards_optional;
    typedef ::xsd::cxx::tree::traits< ScenarioDataStandards_type, char > ScenarioDataStandards_traits;

    const ScenarioDataStandards_optional&
    ScenarioDataStandards () const;

    ScenarioDataStandards_optional&
    ScenarioDataStandards ();

    void
    ScenarioDataStandards (const ScenarioDataStandards_type& x);

    void
    ScenarioDataStandards (const ScenarioDataStandards_optional& x);

    void
    ScenarioDataStandards (::std::unique_ptr< ScenarioDataStandards_type > p);

    // Constructors.
    //
    OptionsType (const MSDLVersion_type&);

    OptionsType (::std::unique_ptr< MSDLVersion_type >);

    OptionsType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    OptionsType (const OptionsType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual OptionsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OptionsType&
    operator= (const OptionsType& x);

    virtual 
    ~OptionsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< MSDLVersion_type > MSDLVersion_;
    OrganizationDetail_optional OrganizationDetail_;
    ScenarioDataStandards_optional ScenarioDataStandards_;
  };

  class OrganicRelationDataType: public ::xml_schema::type
  {
    public:
    // OrganicForceSideHandle
    //
    typedef ::msdl_1::patternUUIDRef32 OrganicForceSideHandle_type;
    typedef ::xsd::cxx::tree::optional< OrganicForceSideHandle_type > OrganicForceSideHandle_optional;
    typedef ::xsd::cxx::tree::traits< OrganicForceSideHandle_type, char > OrganicForceSideHandle_traits;

    const OrganicForceSideHandle_optional&
    OrganicForceSideHandle () const;

    OrganicForceSideHandle_optional&
    OrganicForceSideHandle ();

    void
    OrganicForceSideHandle (const OrganicForceSideHandle_type& x);

    void
    OrganicForceSideHandle (const OrganicForceSideHandle_optional& x);

    void
    OrganicForceSideHandle (::std::unique_ptr< OrganicForceSideHandle_type > p);

    // OrganicSuperiorHandle
    //
    typedef ::msdl_1::patternUUIDRef32 OrganicSuperiorHandle_type;
    typedef ::xsd::cxx::tree::optional< OrganicSuperiorHandle_type > OrganicSuperiorHandle_optional;
    typedef ::xsd::cxx::tree::traits< OrganicSuperiorHandle_type, char > OrganicSuperiorHandle_traits;

    const OrganicSuperiorHandle_optional&
    OrganicSuperiorHandle () const;

    OrganicSuperiorHandle_optional&
    OrganicSuperiorHandle ();

    void
    OrganicSuperiorHandle (const OrganicSuperiorHandle_type& x);

    void
    OrganicSuperiorHandle (const OrganicSuperiorHandle_optional& x);

    void
    OrganicSuperiorHandle (::std::unique_ptr< OrganicSuperiorHandle_type > p);

    // Constructors.
    //
    OrganicRelationDataType ();

    OrganicRelationDataType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    OrganicRelationDataType (const OrganicRelationDataType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual OrganicRelationDataType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganicRelationDataType&
    operator= (const OrganicRelationDataType& x);

    virtual 
    ~OrganicRelationDataType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    OrganicForceSideHandle_optional OrganicForceSideHandle_;
    OrganicSuperiorHandle_optional OrganicSuperiorHandle_;
  };

  class OrganicRelationType: public ::xml_schema::type
  {
    public:
    // OrganicRelationData
    //
    typedef ::msdl_1::OrganicRelationDataType OrganicRelationData_type;
    typedef ::xsd::cxx::tree::traits< OrganicRelationData_type, char > OrganicRelationData_traits;

    const OrganicRelationData_type&
    OrganicRelationData () const;

    OrganicRelationData_type&
    OrganicRelationData ();

    void
    OrganicRelationData (const OrganicRelationData_type& x);

    void
    OrganicRelationData (::std::unique_ptr< OrganicRelationData_type > p);

    // OrganicRelationChoice
    //
    typedef ::msdl_1::enumForceOwnerType OrganicRelationChoice_type;
    typedef ::xsd::cxx::tree::traits< OrganicRelationChoice_type, char > OrganicRelationChoice_traits;

    const OrganicRelationChoice_type&
    OrganicRelationChoice () const;

    OrganicRelationChoice_type&
    OrganicRelationChoice ();

    void
    OrganicRelationChoice (const OrganicRelationChoice_type& x);

    void
    OrganicRelationChoice (::std::unique_ptr< OrganicRelationChoice_type > p);

    // Constructors.
    //
    OrganicRelationType (const OrganicRelationData_type&,
                         const OrganicRelationChoice_type&);

    OrganicRelationType (::std::unique_ptr< OrganicRelationData_type >,
                         const OrganicRelationChoice_type&);

    OrganicRelationType (::std::unique_ptr< OrganicRelationData_type >,
                         ::std::unique_ptr< OrganicRelationChoice_type >);

    OrganicRelationType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    OrganicRelationType (const OrganicRelationType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual OrganicRelationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganicRelationType&
    operator= (const OrganicRelationType& x);

    virtual 
    ~OrganicRelationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< OrganicRelationData_type > OrganicRelationData_;
    ::xsd::cxx::tree::one< OrganicRelationChoice_type > OrganicRelationChoice_;
  };

  class OrganizationDetailType: public ::xml_schema::type
  {
    public:
    // AggregateBased
    //
    typedef ::msdl_1::boolean AggregateBased_type;
    typedef ::xsd::cxx::tree::traits< AggregateBased_type, char > AggregateBased_traits;

    const AggregateBased_type&
    AggregateBased () const;

    AggregateBased_type&
    AggregateBased ();

    void
    AggregateBased (const AggregateBased_type& x);

    void
    AggregateBased (::std::unique_ptr< AggregateBased_type > p);

    // AggregateEchelon
    //
    typedef ::msdl_1::enumEchelon AggregateEchelon_type;
    typedef ::xsd::cxx::tree::optional< AggregateEchelon_type > AggregateEchelon_optional;
    typedef ::xsd::cxx::tree::traits< AggregateEchelon_type, char > AggregateEchelon_traits;

    const AggregateEchelon_optional&
    AggregateEchelon () const;

    AggregateEchelon_optional&
    AggregateEchelon ();

    void
    AggregateEchelon (const AggregateEchelon_type& x);

    void
    AggregateEchelon (const AggregateEchelon_optional& x);

    void
    AggregateEchelon (::std::unique_ptr< AggregateEchelon_type > p);

    // Constructors.
    //
    OrganizationDetailType (const AggregateBased_type&);

    OrganizationDetailType (::std::unique_ptr< AggregateBased_type >);

    OrganizationDetailType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    OrganizationDetailType (const OrganizationDetailType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual OrganizationDetailType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganizationDetailType&
    operator= (const OrganizationDetailType& x);

    virtual 
    ~OrganizationDetailType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< AggregateBased_type > AggregateBased_;
    AggregateEchelon_optional AggregateEchelon_;
  };

  class OrganizationsType: public ::xml_schema::type
  {
    public:
    // Units
    //
    typedef ::msdl_1::UnitsType Units_type;
    typedef ::xsd::cxx::tree::traits< Units_type, char > Units_traits;

    const Units_type&
    Units () const;

    Units_type&
    Units ();

    void
    Units (const Units_type& x);

    void
    Units (::std::unique_ptr< Units_type > p);

    // Equipment
    //
    typedef ::msdl_1::EquipmentType Equipment_type;
    typedef ::xsd::cxx::tree::optional< Equipment_type > Equipment_optional;
    typedef ::xsd::cxx::tree::traits< Equipment_type, char > Equipment_traits;

    const Equipment_optional&
    Equipment () const;

    Equipment_optional&
    Equipment ();

    void
    Equipment (const Equipment_type& x);

    void
    Equipment (const Equipment_optional& x);

    void
    Equipment (::std::unique_ptr< Equipment_type > p);

    // Constructors.
    //
    OrganizationsType (const Units_type&);

    OrganizationsType (::std::unique_ptr< Units_type >);

    OrganizationsType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    OrganizationsType (const OrganizationsType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual OrganizationsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganizationsType&
    operator= (const OrganizationsType& x);

    virtual 
    ~OrganizationsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Units_type > Units_;
    Equipment_optional Equipment_;
  };

  class OverlayHandlesType: public ::xml_schema::type
  {
    public:
    // OverlayHandle
    //
    typedef ::msdl_1::patternUUIDRef32 OverlayHandle_type;
    typedef ::xsd::cxx::tree::sequence< OverlayHandle_type > OverlayHandle_sequence;
    typedef OverlayHandle_sequence::iterator OverlayHandle_iterator;
    typedef OverlayHandle_sequence::const_iterator OverlayHandle_const_iterator;
    typedef ::xsd::cxx::tree::traits< OverlayHandle_type, char > OverlayHandle_traits;

    const OverlayHandle_sequence&
    OverlayHandle () const;

    OverlayHandle_sequence&
    OverlayHandle ();

    void
    OverlayHandle (const OverlayHandle_sequence& s);

    // Constructors.
    //
    OverlayHandlesType ();

    OverlayHandlesType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    OverlayHandlesType (const OverlayHandlesType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual OverlayHandlesType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OverlayHandlesType&
    operator= (const OverlayHandlesType& x);

    virtual 
    ~OverlayHandlesType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    OverlayHandle_sequence OverlayHandle_;
  };

  class OverlaysType: public ::xml_schema::type
  {
    public:
    // Overlay
    //
    typedef ::msdl_1::OverlayType Overlay_type;
    typedef ::xsd::cxx::tree::sequence< Overlay_type > Overlay_sequence;
    typedef Overlay_sequence::iterator Overlay_iterator;
    typedef Overlay_sequence::const_iterator Overlay_const_iterator;
    typedef ::xsd::cxx::tree::traits< Overlay_type, char > Overlay_traits;

    const Overlay_sequence&
    Overlay () const;

    Overlay_sequence&
    Overlay ();

    void
    Overlay (const Overlay_sequence& s);

    // Constructors.
    //
    OverlaysType ();

    OverlaysType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    OverlaysType (const OverlaysType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual OverlaysType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OverlaysType&
    operator= (const OverlaysType& x);

    virtual 
    ~OverlaysType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Overlay_sequence Overlay_;
  };

  class OverlayType: public ::xml_schema::type
  {
    public:
    // ObjectHandle
    //
    typedef ::msdl_1::patternUUID32 ObjectHandle_type;
    typedef ::xsd::cxx::tree::traits< ObjectHandle_type, char > ObjectHandle_traits;

    const ObjectHandle_type&
    ObjectHandle () const;

    ObjectHandle_type&
    ObjectHandle ();

    void
    ObjectHandle (const ObjectHandle_type& x);

    void
    ObjectHandle (::std::unique_ptr< ObjectHandle_type > p);

    // OverlayType
    //
    typedef ::msdl_1::enumOverlayType OverlayType1_type;
    typedef ::xsd::cxx::tree::traits< OverlayType1_type, char > OverlayType1_traits;

    const OverlayType1_type&
    OverlayType1 () const;

    OverlayType1_type&
    OverlayType1 ();

    void
    OverlayType1 (const OverlayType1_type& x);

    void
    OverlayType1 (::std::unique_ptr< OverlayType1_type > p);

    // OverlayName
    //
    typedef ::msdl_1::textName255 OverlayName_type;
    typedef ::xsd::cxx::tree::traits< OverlayName_type, char > OverlayName_traits;

    const OverlayName_type&
    OverlayName () const;

    OverlayName_type&
    OverlayName ();

    void
    OverlayName (const OverlayName_type& x);

    void
    OverlayName (::std::unique_ptr< OverlayName_type > p);

    // Constructors.
    //
    OverlayType (const ObjectHandle_type&,
                 const OverlayType1_type&,
                 const OverlayName_type&);

    OverlayType (::std::unique_ptr< ObjectHandle_type >,
                 ::std::unique_ptr< OverlayType1_type >,
                 ::std::unique_ptr< OverlayName_type >);

    OverlayType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    OverlayType (const OverlayType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual OverlayType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OverlayType&
    operator= (const OverlayType& x);

    virtual 
    ~OverlayType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ObjectHandle_type > ObjectHandle_;
    ::xsd::cxx::tree::one< OverlayType1_type > OverlayType1_;
    ::xsd::cxx::tree::one< OverlayName_type > OverlayName_;
  };

  class OwnerType: public ::xml_schema::type
  {
    public:
    // OwnerChoice
    //
    typedef ::msdl_1::enumForceOwnerType OwnerChoice_type;
    typedef ::xsd::cxx::tree::traits< OwnerChoice_type, char > OwnerChoice_traits;

    const OwnerChoice_type&
    OwnerChoice () const;

    OwnerChoice_type&
    OwnerChoice ();

    void
    OwnerChoice (const OwnerChoice_type& x);

    void
    OwnerChoice (::std::unique_ptr< OwnerChoice_type > p);

    // OwnerData
    //
    typedef ::msdl_1::OwnerDataType OwnerData_type;
    typedef ::xsd::cxx::tree::traits< OwnerData_type, char > OwnerData_traits;

    const OwnerData_type&
    OwnerData () const;

    OwnerData_type&
    OwnerData ();

    void
    OwnerData (const OwnerData_type& x);

    void
    OwnerData (::std::unique_ptr< OwnerData_type > p);

    // Constructors.
    //
    OwnerType (const OwnerChoice_type&,
               const OwnerData_type&);

    OwnerType (const OwnerChoice_type&,
               ::std::unique_ptr< OwnerData_type >);

    OwnerType (::std::unique_ptr< OwnerChoice_type >,
               ::std::unique_ptr< OwnerData_type >);

    OwnerType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    OwnerType (const OwnerType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual OwnerType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OwnerType&
    operator= (const OwnerType& x);

    virtual 
    ~OwnerType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< OwnerChoice_type > OwnerChoice_;
    ::xsd::cxx::tree::one< OwnerData_type > OwnerData_;
  };

  class OwnerDataType: public ::xml_schema::type
  {
    public:
    // UnitOwnerHandle
    //
    typedef ::msdl_1::patternUUIDRef32 UnitOwnerHandle_type;
    typedef ::xsd::cxx::tree::optional< UnitOwnerHandle_type > UnitOwnerHandle_optional;
    typedef ::xsd::cxx::tree::traits< UnitOwnerHandle_type, char > UnitOwnerHandle_traits;

    const UnitOwnerHandle_optional&
    UnitOwnerHandle () const;

    UnitOwnerHandle_optional&
    UnitOwnerHandle ();

    void
    UnitOwnerHandle (const UnitOwnerHandle_type& x);

    void
    UnitOwnerHandle (const UnitOwnerHandle_optional& x);

    void
    UnitOwnerHandle (::std::unique_ptr< UnitOwnerHandle_type > p);

    // ForceOwnerHandle
    //
    typedef ::msdl_1::patternUUIDRef32 ForceOwnerHandle_type;
    typedef ::xsd::cxx::tree::optional< ForceOwnerHandle_type > ForceOwnerHandle_optional;
    typedef ::xsd::cxx::tree::traits< ForceOwnerHandle_type, char > ForceOwnerHandle_traits;

    const ForceOwnerHandle_optional&
    ForceOwnerHandle () const;

    ForceOwnerHandle_optional&
    ForceOwnerHandle ();

    void
    ForceOwnerHandle (const ForceOwnerHandle_type& x);

    void
    ForceOwnerHandle (const ForceOwnerHandle_optional& x);

    void
    ForceOwnerHandle (::std::unique_ptr< ForceOwnerHandle_type > p);

    // Constructors.
    //
    OwnerDataType ();

    OwnerDataType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    OwnerDataType (const OwnerDataType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual OwnerDataType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OwnerDataType&
    operator= (const OwnerDataType& x);

    virtual 
    ~OwnerDataType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    UnitOwnerHandle_optional UnitOwnerHandle_;
    ForceOwnerHandle_optional ForceOwnerHandle_;
  };

  class OwnFormationType: public ::xml_schema::type
  {
    public:
    // FormationLocationType
    //
    typedef ::msdl_1::enumFormationLocationType FormationLocationType_type;
    typedef ::xsd::cxx::tree::traits< FormationLocationType_type, char > FormationLocationType_traits;

    const FormationLocationType_type&
    FormationLocationType () const;

    FormationLocationType_type&
    FormationLocationType ();

    void
    FormationLocationType (const FormationLocationType_type& x);

    void
    FormationLocationType (::std::unique_ptr< FormationLocationType_type > p);

    // FormationSpacing
    //
    typedef ::msdl_1::floatSpacing4_3 FormationSpacing_type;
    typedef ::xsd::cxx::tree::optional< FormationSpacing_type > FormationSpacing_optional;
    typedef ::xsd::cxx::tree::traits< FormationSpacing_type, char > FormationSpacing_traits;

    const FormationSpacing_optional&
    FormationSpacing () const;

    FormationSpacing_optional&
    FormationSpacing ();

    void
    FormationSpacing (const FormationSpacing_type& x);

    void
    FormationSpacing (const FormationSpacing_optional& x);

    void
    FormationSpacing (::std::unique_ptr< FormationSpacing_type > p);

    // FormationOrientation
    //
    typedef ::msdl_1::floatCompassDegrees3_3 FormationOrientation_type;
    typedef ::xsd::cxx::tree::optional< FormationOrientation_type > FormationOrientation_optional;
    typedef ::xsd::cxx::tree::traits< FormationOrientation_type, char > FormationOrientation_traits;

    const FormationOrientation_optional&
    FormationOrientation () const;

    FormationOrientation_optional&
    FormationOrientation ();

    void
    FormationOrientation (const FormationOrientation_type& x);

    void
    FormationOrientation (const FormationOrientation_optional& x);

    void
    FormationOrientation (::std::unique_ptr< FormationOrientation_type > p);

    // FormationChoice
    //
    typedef ::msdl_1::enumFormationType FormationChoice_type;
    typedef ::xsd::cxx::tree::traits< FormationChoice_type, char > FormationChoice_traits;

    const FormationChoice_type&
    FormationChoice () const;

    FormationChoice_type&
    FormationChoice ();

    void
    FormationChoice (const FormationChoice_type& x);

    void
    FormationChoice (::std::unique_ptr< FormationChoice_type > p);

    // FormationData
    //
    typedef ::msdl_1::FormationDataType FormationData_type;
    typedef ::xsd::cxx::tree::traits< FormationData_type, char > FormationData_traits;

    const FormationData_type&
    FormationData () const;

    FormationData_type&
    FormationData ();

    void
    FormationData (const FormationData_type& x);

    void
    FormationData (::std::unique_ptr< FormationData_type > p);

    // Constructors.
    //
    OwnFormationType (const FormationLocationType_type&,
                      const FormationChoice_type&,
                      const FormationData_type&);

    OwnFormationType (const FormationLocationType_type&,
                      const FormationChoice_type&,
                      ::std::unique_ptr< FormationData_type >);

    OwnFormationType (::std::unique_ptr< FormationLocationType_type >,
                      ::std::unique_ptr< FormationChoice_type >,
                      ::std::unique_ptr< FormationData_type >);

    OwnFormationType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    OwnFormationType (const OwnFormationType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual OwnFormationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OwnFormationType&
    operator= (const OwnFormationType& x);

    virtual 
    ~OwnFormationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< FormationLocationType_type > FormationLocationType_;
    FormationSpacing_optional FormationSpacing_;
    FormationOrientation_optional FormationOrientation_;
    ::xsd::cxx::tree::one< FormationChoice_type > FormationChoice_;
    ::xsd::cxx::tree::one< FormationData_type > FormationData_;
  };

  class PointSymbolModifiersType: public ::xml_schema::type
  {
    public:
    // AdditionalInfo
    //
    typedef ::msdl_1::text20 AdditionalInfo_type;
    typedef ::xsd::cxx::tree::optional< AdditionalInfo_type > AdditionalInfo_optional;
    typedef ::xsd::cxx::tree::traits< AdditionalInfo_type, char > AdditionalInfo_traits;

    const AdditionalInfo_optional&
    AdditionalInfo () const;

    AdditionalInfo_optional&
    AdditionalInfo ();

    void
    AdditionalInfo (const AdditionalInfo_type& x);

    void
    AdditionalInfo (const AdditionalInfo_optional& x);

    void
    AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > p);

    // AdditionalInfo1
    //
    typedef ::msdl_1::text20 AdditionalInfo1_type;
    typedef ::xsd::cxx::tree::optional< AdditionalInfo1_type > AdditionalInfo1_optional;
    typedef ::xsd::cxx::tree::traits< AdditionalInfo1_type, char > AdditionalInfo1_traits;

    const AdditionalInfo1_optional&
    AdditionalInfo1 () const;

    AdditionalInfo1_optional&
    AdditionalInfo1 ();

    void
    AdditionalInfo1 (const AdditionalInfo1_type& x);

    void
    AdditionalInfo1 (const AdditionalInfo1_optional& x);

    void
    AdditionalInfo1 (::std::unique_ptr< AdditionalInfo1_type > p);

    // UniqueDesignation
    //
    typedef ::msdl_1::text21 UniqueDesignation_type;
    typedef ::xsd::cxx::tree::traits< UniqueDesignation_type, char > UniqueDesignation_traits;

    const UniqueDesignation_type&
    UniqueDesignation () const;

    UniqueDesignation_type&
    UniqueDesignation ();

    void
    UniqueDesignation (const UniqueDesignation_type& x);

    void
    UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > p);

    // DateTimeGroup
    //
    typedef ::msdl_1::patternTimeDTGRelative20 DateTimeGroup_type;
    typedef ::xsd::cxx::tree::optional< DateTimeGroup_type > DateTimeGroup_optional;
    typedef ::xsd::cxx::tree::traits< DateTimeGroup_type, char > DateTimeGroup_traits;

    const DateTimeGroup_optional&
    DateTimeGroup () const;

    DateTimeGroup_optional&
    DateTimeGroup ();

    void
    DateTimeGroup (const DateTimeGroup_type& x);

    void
    DateTimeGroup (const DateTimeGroup_optional& x);

    void
    DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > p);

    // DateTimeGroup1
    //
    typedef ::msdl_1::patternTimeDTGRelative20 DateTimeGroup1_type;
    typedef ::xsd::cxx::tree::optional< DateTimeGroup1_type > DateTimeGroup1_optional;
    typedef ::xsd::cxx::tree::traits< DateTimeGroup1_type, char > DateTimeGroup1_traits;

    const DateTimeGroup1_optional&
    DateTimeGroup1 () const;

    DateTimeGroup1_optional&
    DateTimeGroup1 ();

    void
    DateTimeGroup1 (const DateTimeGroup1_type& x);

    void
    DateTimeGroup1 (const DateTimeGroup1_optional& x);

    void
    DateTimeGroup1 (::std::unique_ptr< DateTimeGroup1_type > p);

    // Orientation
    //
    typedef ::msdl_1::enumOrientationType Orientation_type;
    typedef ::xsd::cxx::tree::optional< Orientation_type > Orientation_optional;
    typedef ::xsd::cxx::tree::traits< Orientation_type, char > Orientation_traits;

    const Orientation_optional&
    Orientation () const;

    Orientation_optional&
    Orientation ();

    void
    Orientation (const Orientation_type& x);

    void
    Orientation (const Orientation_optional& x);

    void
    Orientation (::std::unique_ptr< Orientation_type > p);

    // Constructors.
    //
    PointSymbolModifiersType (const UniqueDesignation_type&);

    PointSymbolModifiersType (::std::unique_ptr< UniqueDesignation_type >);

    PointSymbolModifiersType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    PointSymbolModifiersType (const PointSymbolModifiersType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual PointSymbolModifiersType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PointSymbolModifiersType&
    operator= (const PointSymbolModifiersType& x);

    virtual 
    ~PointSymbolModifiersType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    AdditionalInfo_optional AdditionalInfo_;
    AdditionalInfo1_optional AdditionalInfo1_;
    ::xsd::cxx::tree::one< UniqueDesignation_type > UniqueDesignation_;
    DateTimeGroup_optional DateTimeGroup_;
    DateTimeGroup1_optional DateTimeGroup1_;
    Orientation_optional Orientation_;
  };

  class RectangleAreaType: public ::xml_schema::type
  {
    public:
    // Name
    //
    typedef ::msdl_1::textName255 Name_type;
    typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
    typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

    const Name_optional&
    Name () const;

    Name_optional&
    Name ();

    void
    Name (const Name_type& x);

    void
    Name (const Name_optional& x);

    void
    Name (::std::unique_ptr< Name_type > p);

    // UpperRight
    //
    typedef ::msdl_1::CoordinatesType UpperRight_type;
    typedef ::xsd::cxx::tree::traits< UpperRight_type, char > UpperRight_traits;

    const UpperRight_type&
    UpperRight () const;

    UpperRight_type&
    UpperRight ();

    void
    UpperRight (const UpperRight_type& x);

    void
    UpperRight (::std::unique_ptr< UpperRight_type > p);

    // LowerLeft
    //
    typedef ::msdl_1::CoordinatesType LowerLeft_type;
    typedef ::xsd::cxx::tree::traits< LowerLeft_type, char > LowerLeft_traits;

    const LowerLeft_type&
    LowerLeft () const;

    LowerLeft_type&
    LowerLeft ();

    void
    LowerLeft (const LowerLeft_type& x);

    void
    LowerLeft (::std::unique_ptr< LowerLeft_type > p);

    // Constructors.
    //
    RectangleAreaType (const UpperRight_type&,
                       const LowerLeft_type&);

    RectangleAreaType (::std::unique_ptr< UpperRight_type >,
                       ::std::unique_ptr< LowerLeft_type >);

    RectangleAreaType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    RectangleAreaType (const RectangleAreaType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual RectangleAreaType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RectangleAreaType&
    operator= (const RectangleAreaType& x);

    virtual 
    ~RectangleAreaType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Name_optional Name_;
    ::xsd::cxx::tree::one< UpperRight_type > UpperRight_;
    ::xsd::cxx::tree::one< LowerLeft_type > LowerLeft_;
  };

  class ScenarioDataStandardsType: public ::xml_schema::type
  {
    public:
    // SymbologyDataStandard
    //
    typedef ::msdl_1::SymbologyDataStandardType SymbologyDataStandard_type;
    typedef ::xsd::cxx::tree::traits< SymbologyDataStandard_type, char > SymbologyDataStandard_traits;

    const SymbologyDataStandard_type&
    SymbologyDataStandard () const;

    SymbologyDataStandard_type&
    SymbologyDataStandard ();

    void
    SymbologyDataStandard (const SymbologyDataStandard_type& x);

    void
    SymbologyDataStandard (::std::unique_ptr< SymbologyDataStandard_type > p);

    // CoordinateDataStandard
    //
    typedef ::msdl_1::CoordinateDataStandardType CoordinateDataStandard_type;
    typedef ::xsd::cxx::tree::traits< CoordinateDataStandard_type, char > CoordinateDataStandard_traits;

    const CoordinateDataStandard_type&
    CoordinateDataStandard () const;

    CoordinateDataStandard_type&
    CoordinateDataStandard ();

    void
    CoordinateDataStandard (const CoordinateDataStandard_type& x);

    void
    CoordinateDataStandard (::std::unique_ptr< CoordinateDataStandard_type > p);

    // Constructors.
    //
    ScenarioDataStandardsType (const SymbologyDataStandard_type&,
                               const CoordinateDataStandard_type&);

    ScenarioDataStandardsType (::std::unique_ptr< SymbologyDataStandard_type >,
                               ::std::unique_ptr< CoordinateDataStandard_type >);

    ScenarioDataStandardsType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ScenarioDataStandardsType (const ScenarioDataStandardsType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual ScenarioDataStandardsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ScenarioDataStandardsType&
    operator= (const ScenarioDataStandardsType& x);

    virtual 
    ~ScenarioDataStandardsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< SymbologyDataStandard_type > SymbologyDataStandard_;
    ::xsd::cxx::tree::one< CoordinateDataStandard_type > CoordinateDataStandard_;
  };

  class ScenarioWeatherType: public ::xml_schema::type
  {
    public:
    // Atmosphere
    //
    typedef ::oo_2_0::Atmosphere Atmosphere_type;
    typedef ::xsd::cxx::tree::optional< Atmosphere_type > Atmosphere_optional;
    typedef ::xsd::cxx::tree::traits< Atmosphere_type, char > Atmosphere_traits;

    const Atmosphere_optional&
    Atmosphere () const;

    Atmosphere_optional&
    Atmosphere ();

    void
    Atmosphere (const Atmosphere_type& x);

    void
    Atmosphere (const Atmosphere_optional& x);

    void
    Atmosphere (::std::unique_ptr< Atmosphere_type > p);

    // CloudCoverItems
    //
    typedef ::msdl_1::CloudCoverItemsType CloudCoverItems_type;
    typedef ::xsd::cxx::tree::optional< CloudCoverItems_type > CloudCoverItems_optional;
    typedef ::xsd::cxx::tree::traits< CloudCoverItems_type, char > CloudCoverItems_traits;

    const CloudCoverItems_optional&
    CloudCoverItems () const;

    CloudCoverItems_optional&
    CloudCoverItems ();

    void
    CloudCoverItems (const CloudCoverItems_type& x);

    void
    CloudCoverItems (const CloudCoverItems_optional& x);

    void
    CloudCoverItems (::std::unique_ptr< CloudCoverItems_type > p);

    // Icing
    //
    typedef ::oo_2_0::Icing Icing_type;
    typedef ::xsd::cxx::tree::optional< Icing_type > Icing_optional;
    typedef ::xsd::cxx::tree::traits< Icing_type, char > Icing_traits;

    const Icing_optional&
    Icing () const;

    Icing_optional&
    Icing ();

    void
    Icing (const Icing_type& x);

    void
    Icing (const Icing_optional& x);

    void
    Icing (::std::unique_ptr< Icing_type > p);

    // LightItems
    //
    typedef ::msdl_1::LightItemsType LightItems_type;
    typedef ::xsd::cxx::tree::optional< LightItems_type > LightItems_optional;
    typedef ::xsd::cxx::tree::traits< LightItems_type, char > LightItems_traits;

    const LightItems_optional&
    LightItems () const;

    LightItems_optional&
    LightItems ();

    void
    LightItems (const LightItems_type& x);

    void
    LightItems (const LightItems_optional& x);

    void
    LightItems (::std::unique_ptr< LightItems_type > p);

    // Precipitation
    //
    typedef ::oo_2_0::Precipitation Precipitation_type;
    typedef ::xsd::cxx::tree::optional< Precipitation_type > Precipitation_optional;
    typedef ::xsd::cxx::tree::traits< Precipitation_type, char > Precipitation_traits;

    const Precipitation_optional&
    Precipitation () const;

    Precipitation_optional&
    Precipitation ();

    void
    Precipitation (const Precipitation_type& x);

    void
    Precipitation (const Precipitation_optional& x);

    void
    Precipitation (::std::unique_ptr< Precipitation_type > p);

    // VisibilityItems
    //
    typedef ::msdl_1::VisibilityItemsType VisibilityItems_type;
    typedef ::xsd::cxx::tree::optional< VisibilityItems_type > VisibilityItems_optional;
    typedef ::xsd::cxx::tree::traits< VisibilityItems_type, char > VisibilityItems_traits;

    const VisibilityItems_optional&
    VisibilityItems () const;

    VisibilityItems_optional&
    VisibilityItems ();

    void
    VisibilityItems (const VisibilityItems_type& x);

    void
    VisibilityItems (const VisibilityItems_optional& x);

    void
    VisibilityItems (::std::unique_ptr< VisibilityItems_type > p);

    // WindItems
    //
    typedef ::msdl_1::WindItemsType WindItems_type;
    typedef ::xsd::cxx::tree::optional< WindItems_type > WindItems_optional;
    typedef ::xsd::cxx::tree::traits< WindItems_type, char > WindItems_traits;

    const WindItems_optional&
    WindItems () const;

    WindItems_optional&
    WindItems ();

    void
    WindItems (const WindItems_type& x);

    void
    WindItems (const WindItems_optional& x);

    void
    WindItems (::std::unique_ptr< WindItems_type > p);

    // Constructors.
    //
    ScenarioWeatherType ();

    ScenarioWeatherType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ScenarioWeatherType (const ScenarioWeatherType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual ScenarioWeatherType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ScenarioWeatherType&
    operator= (const ScenarioWeatherType& x);

    virtual 
    ~ScenarioWeatherType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Atmosphere_optional Atmosphere_;
    CloudCoverItems_optional CloudCoverItems_;
    Icing_optional Icing_;
    LightItems_optional LightItems_;
    Precipitation_optional Precipitation_;
    VisibilityItems_optional VisibilityItems_;
    WindItems_optional WindItems_;
  };

  class StatusType: public ::xml_schema::type
  {
    public:
    // MOPPLevel
    //
    typedef ::msdl_1::enumMOPPLevelType MOPPLevel_type;
    typedef ::xsd::cxx::tree::optional< MOPPLevel_type > MOPPLevel_optional;
    typedef ::xsd::cxx::tree::traits< MOPPLevel_type, char > MOPPLevel_traits;

    const MOPPLevel_optional&
    MOPPLevel () const;

    MOPPLevel_optional&
    MOPPLevel ();

    void
    MOPPLevel (const MOPPLevel_type& x);

    void
    MOPPLevel (const MOPPLevel_optional& x);

    void
    MOPPLevel (::std::unique_ptr< MOPPLevel_type > p);

    // WeaponControlStatus
    //
    typedef ::msdl_1::enumWeaponControlStatusType WeaponControlStatus_type;
    typedef ::xsd::cxx::tree::optional< WeaponControlStatus_type > WeaponControlStatus_optional;
    typedef ::xsd::cxx::tree::traits< WeaponControlStatus_type, char > WeaponControlStatus_traits;

    const WeaponControlStatus_optional&
    WeaponControlStatus () const;

    WeaponControlStatus_optional&
    WeaponControlStatus ();

    void
    WeaponControlStatus (const WeaponControlStatus_type& x);

    void
    WeaponControlStatus (const WeaponControlStatus_optional& x);

    void
    WeaponControlStatus (::std::unique_ptr< WeaponControlStatus_type > p);

    // Constructors.
    //
    StatusType ();

    StatusType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    StatusType (const StatusType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual StatusType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    StatusType&
    operator= (const StatusType& x);

    virtual 
    ~StatusType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    MOPPLevel_optional MOPPLevel_;
    WeaponControlStatus_optional WeaponControlStatus_;
  };

  class SupportRelationsType: public ::xml_schema::type
  {
    public:
    // SupportRelation
    //
    typedef ::msdl_1::SupportRelationType SupportRelation_type;
    typedef ::xsd::cxx::tree::sequence< SupportRelation_type > SupportRelation_sequence;
    typedef SupportRelation_sequence::iterator SupportRelation_iterator;
    typedef SupportRelation_sequence::const_iterator SupportRelation_const_iterator;
    typedef ::xsd::cxx::tree::traits< SupportRelation_type, char > SupportRelation_traits;

    const SupportRelation_sequence&
    SupportRelation () const;

    SupportRelation_sequence&
    SupportRelation ();

    void
    SupportRelation (const SupportRelation_sequence& s);

    // Constructors.
    //
    SupportRelationsType ();

    SupportRelationsType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    SupportRelationsType (const SupportRelationsType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual SupportRelationsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SupportRelationsType&
    operator= (const SupportRelationsType& x);

    virtual 
    ~SupportRelationsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SupportRelation_sequence SupportRelation_;
  };

  class SupportRelationType: public ::xml_schema::type
  {
    public:
    // SupportedUnitHandle
    //
    typedef ::msdl_1::patternUUIDRef32 SupportedUnitHandle_type;
    typedef ::xsd::cxx::tree::traits< SupportedUnitHandle_type, char > SupportedUnitHandle_traits;

    const SupportedUnitHandle_type&
    SupportedUnitHandle () const;

    SupportedUnitHandle_type&
    SupportedUnitHandle ();

    void
    SupportedUnitHandle (const SupportedUnitHandle_type& x);

    void
    SupportedUnitHandle (::std::unique_ptr< SupportedUnitHandle_type > p);

    // PriorityToSupport
    //
    typedef ::msdl_1::integerPriorityToSupport1 PriorityToSupport_type;
    typedef ::xsd::cxx::tree::optional< PriorityToSupport_type > PriorityToSupport_optional;
    typedef ::xsd::cxx::tree::traits< PriorityToSupport_type, char > PriorityToSupport_traits;

    const PriorityToSupport_optional&
    PriorityToSupport () const;

    PriorityToSupport_optional&
    PriorityToSupport ();

    void
    PriorityToSupport (const PriorityToSupport_type& x);

    void
    PriorityToSupport (const PriorityToSupport_optional& x);

    void
    PriorityToSupport (::std::unique_ptr< PriorityToSupport_type > p);

    // SupportType
    //
    typedef ::msdl_1::enumSupportRelationType SupportType_type;
    typedef ::xsd::cxx::tree::traits< SupportType_type, char > SupportType_traits;

    const SupportType_type&
    SupportType () const;

    SupportType_type&
    SupportType ();

    void
    SupportType (const SupportType_type& x);

    void
    SupportType (::std::unique_ptr< SupportType_type > p);

    // SupportRoleType
    //
    typedef ::msdl_1::enumSupportRoleType SupportRoleType_type;
    typedef ::xsd::cxx::tree::optional< SupportRoleType_type > SupportRoleType_optional;
    typedef ::xsd::cxx::tree::traits< SupportRoleType_type, char > SupportRoleType_traits;

    const SupportRoleType_optional&
    SupportRoleType () const;

    SupportRoleType_optional&
    SupportRoleType ();

    void
    SupportRoleType (const SupportRoleType_type& x);

    void
    SupportRoleType (const SupportRoleType_optional& x);

    void
    SupportRoleType (::std::unique_ptr< SupportRoleType_type > p);

    // Constructors.
    //
    SupportRelationType (const SupportedUnitHandle_type&,
                         const SupportType_type&);

    SupportRelationType (::std::unique_ptr< SupportedUnitHandle_type >,
                         ::std::unique_ptr< SupportType_type >);

    SupportRelationType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    SupportRelationType (const SupportRelationType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual SupportRelationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SupportRelationType&
    operator= (const SupportRelationType& x);

    virtual 
    ~SupportRelationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< SupportedUnitHandle_type > SupportedUnitHandle_;
    PriorityToSupport_optional PriorityToSupport_;
    ::xsd::cxx::tree::one< SupportType_type > SupportType_;
    SupportRoleType_optional SupportRoleType_;
  };

  class SymbolClassModifiersType: public ::xml_schema::type
  {
    public:
    // PointSymbolModifiers
    //
    typedef ::msdl_1::PointSymbolModifiersType PointSymbolModifiers_type;
    typedef ::xsd::cxx::tree::optional< PointSymbolModifiers_type > PointSymbolModifiers_optional;
    typedef ::xsd::cxx::tree::traits< PointSymbolModifiers_type, char > PointSymbolModifiers_traits;

    const PointSymbolModifiers_optional&
    PointSymbolModifiers () const;

    PointSymbolModifiers_optional&
    PointSymbolModifiers ();

    void
    PointSymbolModifiers (const PointSymbolModifiers_type& x);

    void
    PointSymbolModifiers (const PointSymbolModifiers_optional& x);

    void
    PointSymbolModifiers (::std::unique_ptr< PointSymbolModifiers_type > p);

    // LineSymbolModifiers
    //
    typedef ::msdl_1::LineSymbolModifiersType LineSymbolModifiers_type;
    typedef ::xsd::cxx::tree::optional< LineSymbolModifiers_type > LineSymbolModifiers_optional;
    typedef ::xsd::cxx::tree::traits< LineSymbolModifiers_type, char > LineSymbolModifiers_traits;

    const LineSymbolModifiers_optional&
    LineSymbolModifiers () const;

    LineSymbolModifiers_optional&
    LineSymbolModifiers ();

    void
    LineSymbolModifiers (const LineSymbolModifiers_type& x);

    void
    LineSymbolModifiers (const LineSymbolModifiers_optional& x);

    void
    LineSymbolModifiers (::std::unique_ptr< LineSymbolModifiers_type > p);

    // AreaSymbolModifiers
    //
    typedef ::msdl_1::AreaSymbolModifiersType AreaSymbolModifiers_type;
    typedef ::xsd::cxx::tree::optional< AreaSymbolModifiers_type > AreaSymbolModifiers_optional;
    typedef ::xsd::cxx::tree::traits< AreaSymbolModifiers_type, char > AreaSymbolModifiers_traits;

    const AreaSymbolModifiers_optional&
    AreaSymbolModifiers () const;

    AreaSymbolModifiers_optional&
    AreaSymbolModifiers ();

    void
    AreaSymbolModifiers (const AreaSymbolModifiers_type& x);

    void
    AreaSymbolModifiers (const AreaSymbolModifiers_optional& x);

    void
    AreaSymbolModifiers (::std::unique_ptr< AreaSymbolModifiers_type > p);

    // BoundarySymbolModifiers
    //
    typedef ::msdl_1::BoundarySymbolModifiersType BoundarySymbolModifiers_type;
    typedef ::xsd::cxx::tree::optional< BoundarySymbolModifiers_type > BoundarySymbolModifiers_optional;
    typedef ::xsd::cxx::tree::traits< BoundarySymbolModifiers_type, char > BoundarySymbolModifiers_traits;

    const BoundarySymbolModifiers_optional&
    BoundarySymbolModifiers () const;

    BoundarySymbolModifiers_optional&
    BoundarySymbolModifiers ();

    void
    BoundarySymbolModifiers (const BoundarySymbolModifiers_type& x);

    void
    BoundarySymbolModifiers (const BoundarySymbolModifiers_optional& x);

    void
    BoundarySymbolModifiers (::std::unique_ptr< BoundarySymbolModifiers_type > p);

    // NBCEventSymbolModifiers
    //
    typedef ::msdl_1::NBCEventSymbolModifiersType NBCEventSymbolModifiers_type;
    typedef ::xsd::cxx::tree::optional< NBCEventSymbolModifiers_type > NBCEventSymbolModifiers_optional;
    typedef ::xsd::cxx::tree::traits< NBCEventSymbolModifiers_type, char > NBCEventSymbolModifiers_traits;

    const NBCEventSymbolModifiers_optional&
    NBCEventSymbolModifiers () const;

    NBCEventSymbolModifiers_optional&
    NBCEventSymbolModifiers ();

    void
    NBCEventSymbolModifiers (const NBCEventSymbolModifiers_type& x);

    void
    NBCEventSymbolModifiers (const NBCEventSymbolModifiers_optional& x);

    void
    NBCEventSymbolModifiers (::std::unique_ptr< NBCEventSymbolModifiers_type > p);

    // TaskSymbolModifiers
    //
    typedef ::msdl_1::TaskSymbolModifiersType TaskSymbolModifiers_type;
    typedef ::xsd::cxx::tree::optional< TaskSymbolModifiers_type > TaskSymbolModifiers_optional;
    typedef ::xsd::cxx::tree::traits< TaskSymbolModifiers_type, char > TaskSymbolModifiers_traits;

    const TaskSymbolModifiers_optional&
    TaskSymbolModifiers () const;

    TaskSymbolModifiers_optional&
    TaskSymbolModifiers ();

    void
    TaskSymbolModifiers (const TaskSymbolModifiers_type& x);

    void
    TaskSymbolModifiers (const TaskSymbolModifiers_optional& x);

    void
    TaskSymbolModifiers (::std::unique_ptr< TaskSymbolModifiers_type > p);

    // Constructors.
    //
    SymbolClassModifiersType ();

    SymbolClassModifiersType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    SymbolClassModifiersType (const SymbolClassModifiersType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual SymbolClassModifiersType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SymbolClassModifiersType&
    operator= (const SymbolClassModifiersType& x);

    virtual 
    ~SymbolClassModifiersType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    PointSymbolModifiers_optional PointSymbolModifiers_;
    LineSymbolModifiers_optional LineSymbolModifiers_;
    AreaSymbolModifiers_optional AreaSymbolModifiers_;
    BoundarySymbolModifiers_optional BoundarySymbolModifiers_;
    NBCEventSymbolModifiers_optional NBCEventSymbolModifiers_;
    TaskSymbolModifiers_optional TaskSymbolModifiers_;
  };

  class SymbologyDataStandardType: public ::xml_schema::type
  {
    public:
    // StandardName
    //
    typedef ::msdl_1::enumSymbologyStandardType StandardName_type;
    typedef ::xsd::cxx::tree::traits< StandardName_type, char > StandardName_traits;

    const StandardName_type&
    StandardName () const;

    StandardName_type&
    StandardName ();

    void
    StandardName (const StandardName_type& x);

    void
    StandardName (::std::unique_ptr< StandardName_type > p);

    // MajorVersion
    //
    typedef ::msdl_1::textIdentifier64 MajorVersion_type;
    typedef ::xsd::cxx::tree::traits< MajorVersion_type, char > MajorVersion_traits;

    const MajorVersion_type&
    MajorVersion () const;

    MajorVersion_type&
    MajorVersion ();

    void
    MajorVersion (const MajorVersion_type& x);

    void
    MajorVersion (::std::unique_ptr< MajorVersion_type > p);

    // MinorVersion
    //
    typedef ::msdl_1::textIdentifier64 MinorVersion_type;
    typedef ::xsd::cxx::tree::traits< MinorVersion_type, char > MinorVersion_traits;

    const MinorVersion_type&
    MinorVersion () const;

    MinorVersion_type&
    MinorVersion ();

    void
    MinorVersion (const MinorVersion_type& x);

    void
    MinorVersion (::std::unique_ptr< MinorVersion_type > p);

    // Constructors.
    //
    SymbologyDataStandardType (const StandardName_type&,
                               const MajorVersion_type&,
                               const MinorVersion_type&);

    SymbologyDataStandardType (::std::unique_ptr< StandardName_type >,
                               ::std::unique_ptr< MajorVersion_type >,
                               ::std::unique_ptr< MinorVersion_type >);

    SymbologyDataStandardType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    SymbologyDataStandardType (const SymbologyDataStandardType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual SymbologyDataStandardType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SymbologyDataStandardType&
    operator= (const SymbologyDataStandardType& x);

    virtual 
    ~SymbologyDataStandardType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< StandardName_type > StandardName_;
    ::xsd::cxx::tree::one< MajorVersion_type > MajorVersion_;
    ::xsd::cxx::tree::one< MinorVersion_type > MinorVersion_;
  };

  class TacticalGraphicsType: public ::xml_schema::type
  {
    public:
    // TacticalGraphic
    //
    typedef ::msdl_1::TacticalGraphicType TacticalGraphic_type;
    typedef ::xsd::cxx::tree::sequence< TacticalGraphic_type > TacticalGraphic_sequence;
    typedef TacticalGraphic_sequence::iterator TacticalGraphic_iterator;
    typedef TacticalGraphic_sequence::const_iterator TacticalGraphic_const_iterator;
    typedef ::xsd::cxx::tree::traits< TacticalGraphic_type, char > TacticalGraphic_traits;

    const TacticalGraphic_sequence&
    TacticalGraphic () const;

    TacticalGraphic_sequence&
    TacticalGraphic ();

    void
    TacticalGraphic (const TacticalGraphic_sequence& s);

    // Constructors.
    //
    TacticalGraphicsType ();

    TacticalGraphicsType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    TacticalGraphicsType (const TacticalGraphicsType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual TacticalGraphicsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TacticalGraphicsType&
    operator= (const TacticalGraphicsType& x);

    virtual 
    ~TacticalGraphicsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    TacticalGraphic_sequence TacticalGraphic_;
  };

  class TacticalGraphicType: public ::xml_schema::type
  {
    public:
    // ObjectHandle
    //
    typedef ::msdl_1::patternUUID32 ObjectHandle_type;
    typedef ::xsd::cxx::tree::traits< ObjectHandle_type, char > ObjectHandle_traits;

    const ObjectHandle_type&
    ObjectHandle () const;

    ObjectHandle_type&
    ObjectHandle ();

    void
    ObjectHandle (const ObjectHandle_type& x);

    void
    ObjectHandle (::std::unique_ptr< ObjectHandle_type > p);

    // SymbolIdentifier
    //
    typedef ::msdl_1::patternTacticalGraphicSymbolID15 SymbolIdentifier_type;
    typedef ::xsd::cxx::tree::traits< SymbolIdentifier_type, char > SymbolIdentifier_traits;

    const SymbolIdentifier_type&
    SymbolIdentifier () const;

    SymbolIdentifier_type&
    SymbolIdentifier ();

    void
    SymbolIdentifier (const SymbolIdentifier_type& x);

    void
    SymbolIdentifier (::std::unique_ptr< SymbolIdentifier_type > p);

    // Affiliation
    //
    typedef ::msdl_1::enumBaseAffiliation Affiliation_type;
    typedef ::xsd::cxx::tree::traits< Affiliation_type, char > Affiliation_traits;

    const Affiliation_type&
    Affiliation () const;

    Affiliation_type&
    Affiliation ();

    void
    Affiliation (const Affiliation_type& x);

    void
    Affiliation (::std::unique_ptr< Affiliation_type > p);

    // Owner
    //
    typedef ::msdl_1::OwnerType Owner_type;
    typedef ::xsd::cxx::tree::traits< Owner_type, char > Owner_traits;

    const Owner_type&
    Owner () const;

    Owner_type&
    Owner ();

    void
    Owner (const Owner_type& x);

    void
    Owner (::std::unique_ptr< Owner_type > p);

    // AnchorPoints
    //
    typedef ::msdl_1::AnchorPointsType AnchorPoints_type;
    typedef ::xsd::cxx::tree::traits< AnchorPoints_type, char > AnchorPoints_traits;

    const AnchorPoints_type&
    AnchorPoints () const;

    AnchorPoints_type&
    AnchorPoints ();

    void
    AnchorPoints (const AnchorPoints_type& x);

    void
    AnchorPoints (::std::unique_ptr< AnchorPoints_type > p);

    // AssociatedOverlays
    //
    typedef ::msdl_1::AssociatedOverlaysType AssociatedOverlays_type;
    typedef ::xsd::cxx::tree::optional< AssociatedOverlays_type > AssociatedOverlays_optional;
    typedef ::xsd::cxx::tree::traits< AssociatedOverlays_type, char > AssociatedOverlays_traits;

    const AssociatedOverlays_optional&
    AssociatedOverlays () const;

    AssociatedOverlays_optional&
    AssociatedOverlays ();

    void
    AssociatedOverlays (const AssociatedOverlays_type& x);

    void
    AssociatedOverlays (const AssociatedOverlays_optional& x);

    void
    AssociatedOverlays (::std::unique_ptr< AssociatedOverlays_type > p);

    // SymbolClassData
    //
    typedef ::msdl_1::SymbolClassModifiersType SymbolClassData_type;
    typedef ::xsd::cxx::tree::optional< SymbolClassData_type > SymbolClassData_optional;
    typedef ::xsd::cxx::tree::traits< SymbolClassData_type, char > SymbolClassData_traits;

    const SymbolClassData_optional&
    SymbolClassData () const;

    SymbolClassData_optional&
    SymbolClassData ();

    void
    SymbolClassData (const SymbolClassData_type& x);

    void
    SymbolClassData (const SymbolClassData_optional& x);

    void
    SymbolClassData (::std::unique_ptr< SymbolClassData_type > p);

    // SymbolClassChoice
    //
    typedef ::msdl_1::enumSymbolClassType SymbolClassChoice_type;
    typedef ::xsd::cxx::tree::traits< SymbolClassChoice_type, char > SymbolClassChoice_traits;

    const SymbolClassChoice_type&
    SymbolClassChoice () const;

    SymbolClassChoice_type&
    SymbolClassChoice ();

    void
    SymbolClassChoice (const SymbolClassChoice_type& x);

    void
    SymbolClassChoice (::std::unique_ptr< SymbolClassChoice_type > p);

    // Constructors.
    //
    TacticalGraphicType (const ObjectHandle_type&,
                         const SymbolIdentifier_type&,
                         const Affiliation_type&,
                         const Owner_type&,
                         const AnchorPoints_type&,
                         const SymbolClassChoice_type&);

    TacticalGraphicType (const ObjectHandle_type&,
                         const SymbolIdentifier_type&,
                         const Affiliation_type&,
                         ::std::unique_ptr< Owner_type >,
                         ::std::unique_ptr< AnchorPoints_type >,
                         const SymbolClassChoice_type&);

    TacticalGraphicType (::std::unique_ptr< ObjectHandle_type >,
                         ::std::unique_ptr< SymbolIdentifier_type >,
                         ::std::unique_ptr< Affiliation_type >,
                         ::std::unique_ptr< Owner_type >,
                         ::std::unique_ptr< AnchorPoints_type >,
                         ::std::unique_ptr< SymbolClassChoice_type >);

    TacticalGraphicType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    TacticalGraphicType (const TacticalGraphicType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual TacticalGraphicType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TacticalGraphicType&
    operator= (const TacticalGraphicType& x);

    virtual 
    ~TacticalGraphicType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ObjectHandle_type > ObjectHandle_;
    ::xsd::cxx::tree::one< SymbolIdentifier_type > SymbolIdentifier_;
    ::xsd::cxx::tree::one< Affiliation_type > Affiliation_;
    ::xsd::cxx::tree::one< Owner_type > Owner_;
    ::xsd::cxx::tree::one< AnchorPoints_type > AnchorPoints_;
    AssociatedOverlays_optional AssociatedOverlays_;
    SymbolClassData_optional SymbolClassData_;
    ::xsd::cxx::tree::one< SymbolClassChoice_type > SymbolClassChoice_;
  };

  class TaskSymbolModifiersType: public ::xml_schema::type
  {
    public:
    // UniqueDesignation
    //
    typedef ::msdl_1::text21 UniqueDesignation_type;
    typedef ::xsd::cxx::tree::optional< UniqueDesignation_type > UniqueDesignation_optional;
    typedef ::xsd::cxx::tree::traits< UniqueDesignation_type, char > UniqueDesignation_traits;

    const UniqueDesignation_optional&
    UniqueDesignation () const;

    UniqueDesignation_optional&
    UniqueDesignation ();

    void
    UniqueDesignation (const UniqueDesignation_type& x);

    void
    UniqueDesignation (const UniqueDesignation_optional& x);

    void
    UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > p);

    // DateTimeGroup
    //
    typedef ::msdl_1::patternTimeDTGRelative20 DateTimeGroup_type;
    typedef ::xsd::cxx::tree::optional< DateTimeGroup_type > DateTimeGroup_optional;
    typedef ::xsd::cxx::tree::traits< DateTimeGroup_type, char > DateTimeGroup_traits;

    const DateTimeGroup_optional&
    DateTimeGroup () const;

    DateTimeGroup_optional&
    DateTimeGroup ();

    void
    DateTimeGroup (const DateTimeGroup_type& x);

    void
    DateTimeGroup (const DateTimeGroup_optional& x);

    void
    DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > p);

    // Constructors.
    //
    TaskSymbolModifiersType ();

    TaskSymbolModifiersType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    TaskSymbolModifiersType (const TaskSymbolModifiersType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual TaskSymbolModifiersType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TaskSymbolModifiersType&
    operator= (const TaskSymbolModifiersType& x);

    virtual 
    ~TaskSymbolModifiersType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    UniqueDesignation_optional UniqueDesignation_;
    DateTimeGroup_optional DateTimeGroup_;
  };

  class UnitDispositionType: public ::xml_schema::type
  {
    public:
    // Location
    //
    typedef ::msdl_1::CoordinatesType Location_type;
    typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
    typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

    const Location_optional&
    Location () const;

    Location_optional&
    Location ();

    void
    Location (const Location_type& x);

    void
    Location (const Location_optional& x);

    void
    Location (::std::unique_ptr< Location_type > p);

    // DirectionOfMovement
    //
    typedef ::msdl_1::floatCompassDegrees3_3 DirectionOfMovement_type;
    typedef ::xsd::cxx::tree::optional< DirectionOfMovement_type > DirectionOfMovement_optional;
    typedef ::xsd::cxx::tree::traits< DirectionOfMovement_type, char > DirectionOfMovement_traits;

    const DirectionOfMovement_optional&
    DirectionOfMovement () const;

    DirectionOfMovement_optional&
    DirectionOfMovement ();

    void
    DirectionOfMovement (const DirectionOfMovement_type& x);

    void
    DirectionOfMovement (const DirectionOfMovement_optional& x);

    void
    DirectionOfMovement (::std::unique_ptr< DirectionOfMovement_type > p);

    // Speed
    //
    typedef ::msdl_1::floatSpeed6_2 Speed_type;
    typedef ::xsd::cxx::tree::optional< Speed_type > Speed_optional;
    typedef ::xsd::cxx::tree::traits< Speed_type, char > Speed_traits;

    const Speed_optional&
    Speed () const;

    Speed_optional&
    Speed ();

    void
    Speed (const Speed_type& x);

    void
    Speed (const Speed_optional& x);

    void
    Speed (::std::unique_ptr< Speed_type > p);

    // FormationPosition
    //
    typedef ::msdl_1::FormationPositionType FormationPosition_type;
    typedef ::xsd::cxx::tree::optional< FormationPosition_type > FormationPosition_optional;
    typedef ::xsd::cxx::tree::traits< FormationPosition_type, char > FormationPosition_traits;

    const FormationPosition_optional&
    FormationPosition () const;

    FormationPosition_optional&
    FormationPosition ();

    void
    FormationPosition (const FormationPosition_type& x);

    void
    FormationPosition (const FormationPosition_optional& x);

    void
    FormationPosition (::std::unique_ptr< FormationPosition_type > p);

    // OwnFormation
    //
    typedef ::msdl_1::OwnFormationType OwnFormation_type;
    typedef ::xsd::cxx::tree::optional< OwnFormation_type > OwnFormation_optional;
    typedef ::xsd::cxx::tree::traits< OwnFormation_type, char > OwnFormation_traits;

    const OwnFormation_optional&
    OwnFormation () const;

    OwnFormation_optional&
    OwnFormation ();

    void
    OwnFormation (const OwnFormation_type& x);

    void
    OwnFormation (const OwnFormation_optional& x);

    void
    OwnFormation (::std::unique_ptr< OwnFormation_type > p);

    // Constructors.
    //
    UnitDispositionType ();

    UnitDispositionType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    UnitDispositionType (const UnitDispositionType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual UnitDispositionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UnitDispositionType&
    operator= (const UnitDispositionType& x);

    virtual 
    ~UnitDispositionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Location_optional Location_;
    DirectionOfMovement_optional DirectionOfMovement_;
    Speed_optional Speed_;
    FormationPosition_optional FormationPosition_;
    OwnFormation_optional OwnFormation_;
  };

  class UnitModelType: public ::xml_schema::type
  {
    public:
    // Resolution
    //
    typedef ::msdl_1::enumModelResolutionType Resolution_type;
    typedef ::xsd::cxx::tree::optional< Resolution_type > Resolution_optional;
    typedef ::xsd::cxx::tree::traits< Resolution_type, char > Resolution_traits;

    const Resolution_optional&
    Resolution () const;

    Resolution_optional&
    Resolution ();

    void
    Resolution (const Resolution_type& x);

    void
    Resolution (const Resolution_optional& x);

    void
    Resolution (::std::unique_ptr< Resolution_type > p);

    // AggregateBased
    //
    typedef ::msdl_1::boolean AggregateBased_type;
    typedef ::xsd::cxx::tree::optional< AggregateBased_type > AggregateBased_optional;
    typedef ::xsd::cxx::tree::traits< AggregateBased_type, char > AggregateBased_traits;

    const AggregateBased_optional&
    AggregateBased () const;

    AggregateBased_optional&
    AggregateBased ();

    void
    AggregateBased (const AggregateBased_type& x);

    void
    AggregateBased (const AggregateBased_optional& x);

    void
    AggregateBased (::std::unique_ptr< AggregateBased_type > p);

    // Constructors.
    //
    UnitModelType ();

    UnitModelType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    UnitModelType (const UnitModelType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual UnitModelType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UnitModelType&
    operator= (const UnitModelType& x);

    virtual 
    ~UnitModelType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Resolution_optional Resolution_;
    AggregateBased_optional AggregateBased_;
  };

  class UnitRelationsType: public ::xml_schema::type
  {
    public:
    // ForceRelation
    //
    typedef ::msdl_1::ForceRelationType ForceRelation_type;
    typedef ::xsd::cxx::tree::traits< ForceRelation_type, char > ForceRelation_traits;

    const ForceRelation_type&
    ForceRelation () const;

    ForceRelation_type&
    ForceRelation ();

    void
    ForceRelation (const ForceRelation_type& x);

    void
    ForceRelation (::std::unique_ptr< ForceRelation_type > p);

    // SupportRelations
    //
    typedef ::msdl_1::SupportRelationsType SupportRelations_type;
    typedef ::xsd::cxx::tree::optional< SupportRelations_type > SupportRelations_optional;
    typedef ::xsd::cxx::tree::traits< SupportRelations_type, char > SupportRelations_traits;

    const SupportRelations_optional&
    SupportRelations () const;

    SupportRelations_optional&
    SupportRelations ();

    void
    SupportRelations (const SupportRelations_type& x);

    void
    SupportRelations (const SupportRelations_optional& x);

    void
    SupportRelations (::std::unique_ptr< SupportRelations_type > p);

    // OrganicRelation
    //
    typedef ::msdl_1::OrganicRelationType OrganicRelation_type;
    typedef ::xsd::cxx::tree::optional< OrganicRelation_type > OrganicRelation_optional;
    typedef ::xsd::cxx::tree::traits< OrganicRelation_type, char > OrganicRelation_traits;

    const OrganicRelation_optional&
    OrganicRelation () const;

    OrganicRelation_optional&
    OrganicRelation ();

    void
    OrganicRelation (const OrganicRelation_type& x);

    void
    OrganicRelation (const OrganicRelation_optional& x);

    void
    OrganicRelation (::std::unique_ptr< OrganicRelation_type > p);

    // Constructors.
    //
    UnitRelationsType (const ForceRelation_type&);

    UnitRelationsType (::std::unique_ptr< ForceRelation_type >);

    UnitRelationsType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    UnitRelationsType (const UnitRelationsType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual UnitRelationsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UnitRelationsType&
    operator= (const UnitRelationsType& x);

    virtual 
    ~UnitRelationsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ForceRelation_type > ForceRelation_;
    SupportRelations_optional SupportRelations_;
    OrganicRelation_optional OrganicRelation_;
  };

  class UnitsType: public ::xml_schema::type
  {
    public:
    // Unit
    //
    typedef ::msdl_1::UnitType Unit_type;
    typedef ::xsd::cxx::tree::sequence< Unit_type > Unit_sequence;
    typedef Unit_sequence::iterator Unit_iterator;
    typedef Unit_sequence::const_iterator Unit_const_iterator;
    typedef ::xsd::cxx::tree::traits< Unit_type, char > Unit_traits;

    const Unit_sequence&
    Unit () const;

    Unit_sequence&
    Unit ();

    void
    Unit (const Unit_sequence& s);

    // Constructors.
    //
    UnitsType ();

    UnitsType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    UnitsType (const UnitsType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual UnitsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UnitsType&
    operator= (const UnitsType& x);

    virtual 
    ~UnitsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Unit_sequence Unit_;
  };

  class UnitSymbolModifiersType: public ::xml_schema::type
  {
    public:
    // Echelon
    //
    typedef ::msdl_1::enumEchelon Echelon_type;
    typedef ::xsd::cxx::tree::optional< Echelon_type > Echelon_optional;
    typedef ::xsd::cxx::tree::traits< Echelon_type, char > Echelon_traits;

    const Echelon_optional&
    Echelon () const;

    Echelon_optional&
    Echelon ();

    void
    Echelon (const Echelon_type& x);

    void
    Echelon (const Echelon_optional& x);

    void
    Echelon (::std::unique_ptr< Echelon_type > p);

    // ReinforcedReduced
    //
    typedef ::msdl_1::enumReinforcedReducedType ReinforcedReduced_type;
    typedef ::xsd::cxx::tree::optional< ReinforcedReduced_type > ReinforcedReduced_optional;
    typedef ::xsd::cxx::tree::traits< ReinforcedReduced_type, char > ReinforcedReduced_traits;

    const ReinforcedReduced_optional&
    ReinforcedReduced () const;

    ReinforcedReduced_optional&
    ReinforcedReduced ();

    void
    ReinforcedReduced (const ReinforcedReduced_type& x);

    void
    ReinforcedReduced (const ReinforcedReduced_optional& x);

    void
    ReinforcedReduced (::std::unique_ptr< ReinforcedReduced_type > p);

    // StaffComments
    //
    typedef ::msdl_1::text20 StaffComments_type;
    typedef ::xsd::cxx::tree::optional< StaffComments_type > StaffComments_optional;
    typedef ::xsd::cxx::tree::traits< StaffComments_type, char > StaffComments_traits;

    const StaffComments_optional&
    StaffComments () const;

    StaffComments_optional&
    StaffComments ();

    void
    StaffComments (const StaffComments_type& x);

    void
    StaffComments (const StaffComments_optional& x);

    void
    StaffComments (::std::unique_ptr< StaffComments_type > p);

    // AdditionalInfo
    //
    typedef ::msdl_1::text20 AdditionalInfo_type;
    typedef ::xsd::cxx::tree::optional< AdditionalInfo_type > AdditionalInfo_optional;
    typedef ::xsd::cxx::tree::traits< AdditionalInfo_type, char > AdditionalInfo_traits;

    const AdditionalInfo_optional&
    AdditionalInfo () const;

    AdditionalInfo_optional&
    AdditionalInfo ();

    void
    AdditionalInfo (const AdditionalInfo_type& x);

    void
    AdditionalInfo (const AdditionalInfo_optional& x);

    void
    AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > p);

    // CombatEffectiveness
    //
    typedef ::msdl_1::enumCombatEffectivenessType CombatEffectiveness_type;
    typedef ::xsd::cxx::tree::optional< CombatEffectiveness_type > CombatEffectiveness_optional;
    typedef ::xsd::cxx::tree::traits< CombatEffectiveness_type, char > CombatEffectiveness_traits;

    const CombatEffectiveness_optional&
    CombatEffectiveness () const;

    CombatEffectiveness_optional&
    CombatEffectiveness ();

    void
    CombatEffectiveness (const CombatEffectiveness_type& x);

    void
    CombatEffectiveness (const CombatEffectiveness_optional& x);

    void
    CombatEffectiveness (::std::unique_ptr< CombatEffectiveness_type > p);

    // HigherFormation
    //
    typedef ::msdl_1::text21 HigherFormation_type;
    typedef ::xsd::cxx::tree::optional< HigherFormation_type > HigherFormation_optional;
    typedef ::xsd::cxx::tree::traits< HigherFormation_type, char > HigherFormation_traits;

    const HigherFormation_optional&
    HigherFormation () const;

    HigherFormation_optional&
    HigherFormation ();

    void
    HigherFormation (const HigherFormation_type& x);

    void
    HigherFormation (const HigherFormation_optional& x);

    void
    HigherFormation (::std::unique_ptr< HigherFormation_type > p);

    // IFF
    //
    typedef ::msdl_1::textIFF5 IFF_type;
    typedef ::xsd::cxx::tree::optional< IFF_type > IFF_optional;
    typedef ::xsd::cxx::tree::traits< IFF_type, char > IFF_traits;

    const IFF_optional&
    IFF () const;

    IFF_optional&
    IFF ();

    void
    IFF (const IFF_type& x);

    void
    IFF (const IFF_optional& x);

    void
    IFF (::std::unique_ptr< IFF_type > p);

    // UniqueDesignation
    //
    typedef ::msdl_1::text21 UniqueDesignation_type;
    typedef ::xsd::cxx::tree::traits< UniqueDesignation_type, char > UniqueDesignation_traits;

    const UniqueDesignation_type&
    UniqueDesignation () const;

    UniqueDesignation_type&
    UniqueDesignation ();

    void
    UniqueDesignation (const UniqueDesignation_type& x);

    void
    UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > p);

    // SpecialC2HQ
    //
    typedef ::msdl_1::textSpecialC2HQ9 SpecialC2HQ_type;
    typedef ::xsd::cxx::tree::optional< SpecialC2HQ_type > SpecialC2HQ_optional;
    typedef ::xsd::cxx::tree::traits< SpecialC2HQ_type, char > SpecialC2HQ_traits;

    const SpecialC2HQ_optional&
    SpecialC2HQ () const;

    SpecialC2HQ_optional&
    SpecialC2HQ ();

    void
    SpecialC2HQ (const SpecialC2HQ_type& x);

    void
    SpecialC2HQ (const SpecialC2HQ_optional& x);

    void
    SpecialC2HQ (::std::unique_ptr< SpecialC2HQ_type > p);

    // Constructors.
    //
    UnitSymbolModifiersType (const UniqueDesignation_type&);

    UnitSymbolModifiersType (::std::unique_ptr< UniqueDesignation_type >);

    UnitSymbolModifiersType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    UnitSymbolModifiersType (const UnitSymbolModifiersType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual UnitSymbolModifiersType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UnitSymbolModifiersType&
    operator= (const UnitSymbolModifiersType& x);

    virtual 
    ~UnitSymbolModifiersType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Echelon_optional Echelon_;
    ReinforcedReduced_optional ReinforcedReduced_;
    StaffComments_optional StaffComments_;
    AdditionalInfo_optional AdditionalInfo_;
    CombatEffectiveness_optional CombatEffectiveness_;
    HigherFormation_optional HigherFormation_;
    IFF_optional IFF_;
    ::xsd::cxx::tree::one< UniqueDesignation_type > UniqueDesignation_;
    SpecialC2HQ_optional SpecialC2HQ_;
  };

  class UnitType: public ::xml_schema::type
  {
    public:
    // ObjectHandle
    //
    typedef ::msdl_1::patternUUID32 ObjectHandle_type;
    typedef ::xsd::cxx::tree::traits< ObjectHandle_type, char > ObjectHandle_traits;

    const ObjectHandle_type&
    ObjectHandle () const;

    ObjectHandle_type&
    ObjectHandle ();

    void
    ObjectHandle (const ObjectHandle_type& x);

    void
    ObjectHandle (::std::unique_ptr< ObjectHandle_type > p);

    // SymbolIdentifier
    //
    typedef ::msdl_1::patternForceSymbolID15 SymbolIdentifier_type;
    typedef ::xsd::cxx::tree::traits< SymbolIdentifier_type, char > SymbolIdentifier_traits;

    const SymbolIdentifier_type&
    SymbolIdentifier () const;

    SymbolIdentifier_type&
    SymbolIdentifier ();

    void
    SymbolIdentifier (const SymbolIdentifier_type& x);

    void
    SymbolIdentifier (::std::unique_ptr< SymbolIdentifier_type > p);

    // Name
    //
    typedef ::msdl_1::textName255 Name_type;
    typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
    typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

    const Name_optional&
    Name () const;

    Name_optional&
    Name ();

    void
    Name (const Name_type& x);

    void
    Name (const Name_optional& x);

    void
    Name (::std::unique_ptr< Name_type > p);

    // UnitSymbolModifiers
    //
    typedef ::msdl_1::UnitSymbolModifiersType UnitSymbolModifiers_type;
    typedef ::xsd::cxx::tree::optional< UnitSymbolModifiers_type > UnitSymbolModifiers_optional;
    typedef ::xsd::cxx::tree::traits< UnitSymbolModifiers_type, char > UnitSymbolModifiers_traits;

    const UnitSymbolModifiers_optional&
    UnitSymbolModifiers () const;

    UnitSymbolModifiers_optional&
    UnitSymbolModifiers ();

    void
    UnitSymbolModifiers (const UnitSymbolModifiers_type& x);

    void
    UnitSymbolModifiers (const UnitSymbolModifiers_optional& x);

    void
    UnitSymbolModifiers (::std::unique_ptr< UnitSymbolModifiers_type > p);

    // CommunicationNetInstances
    //
    typedef ::msdl_1::CommunicationNetInstancesType CommunicationNetInstances_type;
    typedef ::xsd::cxx::tree::optional< CommunicationNetInstances_type > CommunicationNetInstances_optional;
    typedef ::xsd::cxx::tree::traits< CommunicationNetInstances_type, char > CommunicationNetInstances_traits;

    const CommunicationNetInstances_optional&
    CommunicationNetInstances () const;

    CommunicationNetInstances_optional&
    CommunicationNetInstances ();

    void
    CommunicationNetInstances (const CommunicationNetInstances_type& x);

    void
    CommunicationNetInstances (const CommunicationNetInstances_optional& x);

    void
    CommunicationNetInstances (::std::unique_ptr< CommunicationNetInstances_type > p);

    // Status
    //
    typedef ::msdl_1::StatusType Status_type;
    typedef ::xsd::cxx::tree::optional< Status_type > Status_optional;
    typedef ::xsd::cxx::tree::traits< Status_type, char > Status_traits;

    const Status_optional&
    Status () const;

    Status_optional&
    Status ();

    void
    Status (const Status_type& x);

    void
    Status (const Status_optional& x);

    void
    Status (::std::unique_ptr< Status_type > p);

    // Disposition
    //
    typedef ::msdl_1::UnitDispositionType Disposition_type;
    typedef ::xsd::cxx::tree::optional< Disposition_type > Disposition_optional;
    typedef ::xsd::cxx::tree::traits< Disposition_type, char > Disposition_traits;

    const Disposition_optional&
    Disposition () const;

    Disposition_optional&
    Disposition ();

    void
    Disposition (const Disposition_type& x);

    void
    Disposition (const Disposition_optional& x);

    void
    Disposition (::std::unique_ptr< Disposition_type > p);

    // Relations
    //
    typedef ::msdl_1::UnitRelationsType Relations_type;
    typedef ::xsd::cxx::tree::traits< Relations_type, char > Relations_traits;

    const Relations_type&
    Relations () const;

    Relations_type&
    Relations ();

    void
    Relations (const Relations_type& x);

    void
    Relations (::std::unique_ptr< Relations_type > p);

    // Model
    //
    typedef ::msdl_1::UnitModelType Model_type;
    typedef ::xsd::cxx::tree::optional< Model_type > Model_optional;
    typedef ::xsd::cxx::tree::traits< Model_type, char > Model_traits;

    const Model_optional&
    Model () const;

    Model_optional&
    Model ();

    void
    Model (const Model_type& x);

    void
    Model (const Model_optional& x);

    void
    Model (::std::unique_ptr< Model_type > p);

    // Constructors.
    //
    UnitType (const ObjectHandle_type&,
              const SymbolIdentifier_type&,
              const Relations_type&);

    UnitType (const ObjectHandle_type&,
              const SymbolIdentifier_type&,
              ::std::unique_ptr< Relations_type >);

    UnitType (::std::unique_ptr< ObjectHandle_type >,
              ::std::unique_ptr< SymbolIdentifier_type >,
              ::std::unique_ptr< Relations_type >);

    UnitType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    UnitType (const UnitType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual UnitType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UnitType&
    operator= (const UnitType& x);

    virtual 
    ~UnitType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ObjectHandle_type > ObjectHandle_;
    ::xsd::cxx::tree::one< SymbolIdentifier_type > SymbolIdentifier_;
    Name_optional Name_;
    UnitSymbolModifiers_optional UnitSymbolModifiers_;
    CommunicationNetInstances_optional CommunicationNetInstances_;
    Status_optional Status_;
    Disposition_optional Disposition_;
    ::xsd::cxx::tree::one< Relations_type > Relations_;
    Model_optional Model_;
  };

  class UTMType: public ::xml_schema::type
  {
    public:
    // UTMGridZone
    //
    typedef ::msdl_1::patternUTMGridZone3 UTMGridZone_type;
    typedef ::xsd::cxx::tree::traits< UTMGridZone_type, char > UTMGridZone_traits;

    const UTMGridZone_type&
    UTMGridZone () const;

    UTMGridZone_type&
    UTMGridZone ();

    void
    UTMGridZone (const UTMGridZone_type& x);

    void
    UTMGridZone (::std::unique_ptr< UTMGridZone_type > p);

    // UTMEasting
    //
    typedef ::msdl_1::floatUTMEasting9_2 UTMEasting_type;
    typedef ::xsd::cxx::tree::traits< UTMEasting_type, char > UTMEasting_traits;

    const UTMEasting_type&
    UTMEasting () const;

    UTMEasting_type&
    UTMEasting ();

    void
    UTMEasting (const UTMEasting_type& x);

    void
    UTMEasting (::std::unique_ptr< UTMEasting_type > p);

    // UTMNorthing
    //
    typedef ::msdl_1::floatUTMNorthing9_2 UTMNorthing_type;
    typedef ::xsd::cxx::tree::traits< UTMNorthing_type, char > UTMNorthing_traits;

    const UTMNorthing_type&
    UTMNorthing () const;

    UTMNorthing_type&
    UTMNorthing ();

    void
    UTMNorthing (const UTMNorthing_type& x);

    void
    UTMNorthing (::std::unique_ptr< UTMNorthing_type > p);

    // ElevationAGL
    //
    typedef ::msdl_1::floatElevationAGL6_2 ElevationAGL_type;
    typedef ::xsd::cxx::tree::optional< ElevationAGL_type > ElevationAGL_optional;
    typedef ::xsd::cxx::tree::traits< ElevationAGL_type, char > ElevationAGL_traits;

    const ElevationAGL_optional&
    ElevationAGL () const;

    ElevationAGL_optional&
    ElevationAGL ();

    void
    ElevationAGL (const ElevationAGL_type& x);

    void
    ElevationAGL (const ElevationAGL_optional& x);

    void
    ElevationAGL (::std::unique_ptr< ElevationAGL_type > p);

    // Constructors.
    //
    UTMType (const UTMGridZone_type&,
             const UTMEasting_type&,
             const UTMNorthing_type&);

    UTMType (::std::unique_ptr< UTMGridZone_type >,
             ::std::unique_ptr< UTMEasting_type >,
             ::std::unique_ptr< UTMNorthing_type >);

    UTMType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    UTMType (const UTMType& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual UTMType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UTMType&
    operator= (const UTMType& x);

    virtual 
    ~UTMType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< UTMGridZone_type > UTMGridZone_;
    ::xsd::cxx::tree::one< UTMEasting_type > UTMEasting_;
    ::xsd::cxx::tree::one< UTMNorthing_type > UTMNorthing_;
    ElevationAGL_optional ElevationAGL_;
  };

  class VisibilityItemsType: public ::xml_schema::type
  {
    public:
    // Visibility
    //
    typedef ::oo_2_0::Visibility Visibility_type;
    typedef ::xsd::cxx::tree::sequence< Visibility_type > Visibility_sequence;
    typedef Visibility_sequence::iterator Visibility_iterator;
    typedef Visibility_sequence::const_iterator Visibility_const_iterator;
    typedef ::xsd::cxx::tree::traits< Visibility_type, char > Visibility_traits;

    const Visibility_sequence&
    Visibility () const;

    Visibility_sequence&
    Visibility ();

    void
    Visibility (const Visibility_sequence& s);

    // Constructors.
    //
    VisibilityItemsType ();

    VisibilityItemsType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    VisibilityItemsType (const VisibilityItemsType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual VisibilityItemsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    VisibilityItemsType&
    operator= (const VisibilityItemsType& x);

    virtual 
    ~VisibilityItemsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Visibility_sequence Visibility_;
  };

  class WindItemsType: public ::xml_schema::type
  {
    public:
    // Wind
    //
    typedef ::oo_2_0::Wind Wind_type;
    typedef ::xsd::cxx::tree::sequence< Wind_type > Wind_sequence;
    typedef Wind_sequence::iterator Wind_iterator;
    typedef Wind_sequence::const_iterator Wind_const_iterator;
    typedef ::xsd::cxx::tree::traits< Wind_type, char > Wind_traits;

    const Wind_sequence&
    Wind () const;

    Wind_sequence&
    Wind ();

    void
    Wind (const Wind_sequence& s);

    // Constructors.
    //
    WindItemsType ();

    WindItemsType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    WindItemsType (const WindItemsType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual WindItemsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    WindItemsType&
    operator= (const WindItemsType& x);

    virtual 
    ~WindItemsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Wind_sequence Wind_;
  };
}

#include <iosfwd>

namespace msdl_1
{
  ::std::ostream&
  operator<< (::std::ostream&, const AnchorPointType&);

  ::std::ostream&
  operator<< (::std::ostream&, const AnchorPointsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const AnchorType&);

  ::std::ostream&
  operator<< (::std::ostream&, const AreaSymbolModifiersType&);

  ::std::ostream&
  operator<< (::std::ostream&, const AssociatedOverlaysType&);

  ::std::ostream&
  operator<< (::std::ostream&, const AssociationsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const AssociationType&);

  ::std::ostream&
  operator<< (::std::ostream&, const BoundarySymbolModifiersType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CloudCoverItemsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CommandRelationType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CommunicationNetInstancesType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CommunicationNetInstanceType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CommunicationNetReferencesType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CommunicationNetReferenceType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CoordinateDataStandardType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CoordinatesType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CoordinatePointType&);

  ::std::ostream&
  operator<< (::std::ostream&, const EnvironmentType&);

  ::std::ostream&
  operator<< (::std::ostream&, const EquipmentDispositionType&);

  ::std::ostream&
  operator<< (::std::ostream&, const EquipmentItemType&);

  ::std::ostream&
  operator<< (::std::ostream&, const EquipmentModelType&);

  ::std::ostream&
  operator<< (::std::ostream&, const EquipmentRelationsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const EquipmentSymbolModifiersType&);

  ::std::ostream&
  operator<< (::std::ostream&, const EquipmentType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ForceRelationDataType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ForceRelationType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ForceSidesType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ForceSideType&);

  ::std::ostream&
  operator<< (::std::ostream&, const FormationDataType&);

  ::std::ostream&
  operator<< (::std::ostream&, const FormationPositionType&);

  ::std::ostream&
  operator<< (::std::ostream&, const GCCType&);

  ::std::ostream&
  operator<< (::std::ostream&, const GDCType&);

  ::std::ostream&
  operator<< (::std::ostream&, const InstallationsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const InstallationSymbolModifiersType&);

  ::std::ostream&
  operator<< (::std::ostream&, const InstallationType&);

  ::std::ostream&
  operator<< (::std::ostream&, const LightItemsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const LineSymbolModifiersType&);

  ::std::ostream&
  operator<< (::std::ostream&, const METOCDispositionType&);

  ::std::ostream&
  operator<< (::std::ostream&, const METOCGraphicType&);

  ::std::ostream&
  operator<< (::std::ostream&, const METOCType&);

  ::std::ostream&
  operator<< (::std::ostream&, const MilitaryScenarioType&);

  ::std::ostream&
  operator<< (::std::ostream&, const MGRSType&);

  ::std::ostream&
  operator<< (::std::ostream&, const MOOTWDispositionType&);

  ::std::ostream&
  operator<< (::std::ostream&, const MOOTWGraphicsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const MOOTWGraphicType&);

  ::std::ostream&
  operator<< (::std::ostream&, const MOOTWSymbolModifiersType&);

  ::std::ostream&
  operator<< (::std::ostream&, const NBCEventSymbolModifiersType&);

  ::std::ostream&
  operator<< (::std::ostream&, const OptionsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganicRelationDataType&);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganicRelationType&);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganizationDetailType&);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganizationsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const OverlayHandlesType&);

  ::std::ostream&
  operator<< (::std::ostream&, const OverlaysType&);

  ::std::ostream&
  operator<< (::std::ostream&, const OverlayType&);

  ::std::ostream&
  operator<< (::std::ostream&, const OwnerType&);

  ::std::ostream&
  operator<< (::std::ostream&, const OwnerDataType&);

  ::std::ostream&
  operator<< (::std::ostream&, const OwnFormationType&);

  ::std::ostream&
  operator<< (::std::ostream&, const PointSymbolModifiersType&);

  ::std::ostream&
  operator<< (::std::ostream&, const RectangleAreaType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ScenarioDataStandardsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ScenarioWeatherType&);

  ::std::ostream&
  operator<< (::std::ostream&, const StatusType&);

  ::std::ostream&
  operator<< (::std::ostream&, const SupportRelationsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const SupportRelationType&);

  ::std::ostream&
  operator<< (::std::ostream&, const SymbolClassModifiersType&);

  ::std::ostream&
  operator<< (::std::ostream&, const SymbologyDataStandardType&);

  ::std::ostream&
  operator<< (::std::ostream&, const TacticalGraphicsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const TacticalGraphicType&);

  ::std::ostream&
  operator<< (::std::ostream&, const TaskSymbolModifiersType&);

  ::std::ostream&
  operator<< (::std::ostream&, const UnitDispositionType&);

  ::std::ostream&
  operator<< (::std::ostream&, const UnitModelType&);

  ::std::ostream&
  operator<< (::std::ostream&, const UnitRelationsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const UnitsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const UnitSymbolModifiersType&);

  ::std::ostream&
  operator<< (::std::ostream&, const UnitType&);

  ::std::ostream&
  operator<< (::std::ostream&, const UTMType&);

  ::std::ostream&
  operator<< (::std::ostream&, const VisibilityItemsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const WindItemsType&);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace msdl_1
{
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace msdl_1
{
  void
  operator<< (::xercesc::DOMElement&, const AnchorPointType&);

  void
  operator<< (::xercesc::DOMElement&, const AnchorPointsType&);

  void
  operator<< (::xercesc::DOMElement&, const AnchorType&);

  void
  operator<< (::xercesc::DOMElement&, const AreaSymbolModifiersType&);

  void
  operator<< (::xercesc::DOMElement&, const AssociatedOverlaysType&);

  void
  operator<< (::xercesc::DOMElement&, const AssociationsType&);

  void
  operator<< (::xercesc::DOMElement&, const AssociationType&);

  void
  operator<< (::xercesc::DOMElement&, const BoundarySymbolModifiersType&);

  void
  operator<< (::xercesc::DOMElement&, const CloudCoverItemsType&);

  void
  operator<< (::xercesc::DOMElement&, const CommandRelationType&);

  void
  operator<< (::xercesc::DOMElement&, const CommunicationNetInstancesType&);

  void
  operator<< (::xercesc::DOMElement&, const CommunicationNetInstanceType&);

  void
  operator<< (::xercesc::DOMElement&, const CommunicationNetReferencesType&);

  void
  operator<< (::xercesc::DOMElement&, const CommunicationNetReferenceType&);

  void
  operator<< (::xercesc::DOMElement&, const CoordinateDataStandardType&);

  void
  operator<< (::xercesc::DOMElement&, const CoordinatesType&);

  void
  operator<< (::xercesc::DOMElement&, const CoordinatePointType&);

  void
  operator<< (::xercesc::DOMElement&, const EnvironmentType&);

  void
  operator<< (::xercesc::DOMElement&, const EquipmentDispositionType&);

  void
  operator<< (::xercesc::DOMElement&, const EquipmentItemType&);

  void
  operator<< (::xercesc::DOMElement&, const EquipmentModelType&);

  void
  operator<< (::xercesc::DOMElement&, const EquipmentRelationsType&);

  void
  operator<< (::xercesc::DOMElement&, const EquipmentSymbolModifiersType&);

  void
  operator<< (::xercesc::DOMElement&, const EquipmentType&);

  void
  operator<< (::xercesc::DOMElement&, const ForceRelationDataType&);

  void
  operator<< (::xercesc::DOMElement&, const ForceRelationType&);

  void
  operator<< (::xercesc::DOMElement&, const ForceSidesType&);

  void
  operator<< (::xercesc::DOMElement&, const ForceSideType&);

  void
  operator<< (::xercesc::DOMElement&, const FormationDataType&);

  void
  operator<< (::xercesc::DOMElement&, const FormationPositionType&);

  void
  operator<< (::xercesc::DOMElement&, const GCCType&);

  void
  operator<< (::xercesc::DOMElement&, const GDCType&);

  void
  operator<< (::xercesc::DOMElement&, const InstallationsType&);

  void
  operator<< (::xercesc::DOMElement&, const InstallationSymbolModifiersType&);

  void
  operator<< (::xercesc::DOMElement&, const InstallationType&);

  void
  operator<< (::xercesc::DOMElement&, const LightItemsType&);

  void
  operator<< (::xercesc::DOMElement&, const LineSymbolModifiersType&);

  void
  operator<< (::xercesc::DOMElement&, const METOCDispositionType&);

  void
  operator<< (::xercesc::DOMElement&, const METOCGraphicType&);

  void
  operator<< (::xercesc::DOMElement&, const METOCType&);

  void
  operator<< (::xercesc::DOMElement&, const MilitaryScenarioType&);

  void
  operator<< (::xercesc::DOMElement&, const MGRSType&);

  void
  operator<< (::xercesc::DOMElement&, const MOOTWDispositionType&);

  void
  operator<< (::xercesc::DOMElement&, const MOOTWGraphicsType&);

  void
  operator<< (::xercesc::DOMElement&, const MOOTWGraphicType&);

  void
  operator<< (::xercesc::DOMElement&, const MOOTWSymbolModifiersType&);

  void
  operator<< (::xercesc::DOMElement&, const NBCEventSymbolModifiersType&);

  void
  operator<< (::xercesc::DOMElement&, const OptionsType&);

  void
  operator<< (::xercesc::DOMElement&, const OrganicRelationDataType&);

  void
  operator<< (::xercesc::DOMElement&, const OrganicRelationType&);

  void
  operator<< (::xercesc::DOMElement&, const OrganizationDetailType&);

  void
  operator<< (::xercesc::DOMElement&, const OrganizationsType&);

  void
  operator<< (::xercesc::DOMElement&, const OverlayHandlesType&);

  void
  operator<< (::xercesc::DOMElement&, const OverlaysType&);

  void
  operator<< (::xercesc::DOMElement&, const OverlayType&);

  void
  operator<< (::xercesc::DOMElement&, const OwnerType&);

  void
  operator<< (::xercesc::DOMElement&, const OwnerDataType&);

  void
  operator<< (::xercesc::DOMElement&, const OwnFormationType&);

  void
  operator<< (::xercesc::DOMElement&, const PointSymbolModifiersType&);

  void
  operator<< (::xercesc::DOMElement&, const RectangleAreaType&);

  void
  operator<< (::xercesc::DOMElement&, const ScenarioDataStandardsType&);

  void
  operator<< (::xercesc::DOMElement&, const ScenarioWeatherType&);

  void
  operator<< (::xercesc::DOMElement&, const StatusType&);

  void
  operator<< (::xercesc::DOMElement&, const SupportRelationsType&);

  void
  operator<< (::xercesc::DOMElement&, const SupportRelationType&);

  void
  operator<< (::xercesc::DOMElement&, const SymbolClassModifiersType&);

  void
  operator<< (::xercesc::DOMElement&, const SymbologyDataStandardType&);

  void
  operator<< (::xercesc::DOMElement&, const TacticalGraphicsType&);

  void
  operator<< (::xercesc::DOMElement&, const TacticalGraphicType&);

  void
  operator<< (::xercesc::DOMElement&, const TaskSymbolModifiersType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitDispositionType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitModelType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitRelationsType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitsType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitSymbolModifiersType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitType&);

  void
  operator<< (::xercesc::DOMElement&, const UTMType&);

  void
  operator<< (::xercesc::DOMElement&, const VisibilityItemsType&);

  void
  operator<< (::xercesc::DOMElement&, const WindItemsType&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // MSDL_COMPLEX_TYPES_1_0_0_HXX
