// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "MsdlComplexTypes_1.0.0.hxx"

namespace msdl_1
{
  // AnchorPointType
  // 

  const AnchorPointType::AnchorChoice_type& AnchorPointType::
  AnchorChoice () const
  {
    return this->AnchorChoice_.get ();
  }

  AnchorPointType::AnchorChoice_type& AnchorPointType::
  AnchorChoice ()
  {
    return this->AnchorChoice_.get ();
  }

  void AnchorPointType::
  AnchorChoice (const AnchorChoice_type& x)
  {
    this->AnchorChoice_.set (x);
  }

  void AnchorPointType::
  AnchorChoice (::std::unique_ptr< AnchorChoice_type > x)
  {
    this->AnchorChoice_.set (std::move (x));
  }

  const AnchorPointType::Anchor_type& AnchorPointType::
  Anchor () const
  {
    return this->Anchor_.get ();
  }

  AnchorPointType::Anchor_type& AnchorPointType::
  Anchor ()
  {
    return this->Anchor_.get ();
  }

  void AnchorPointType::
  Anchor (const Anchor_type& x)
  {
    this->Anchor_.set (x);
  }

  void AnchorPointType::
  Anchor (::std::unique_ptr< Anchor_type > x)
  {
    this->Anchor_.set (std::move (x));
  }


  // AnchorPointsType
  // 

  const AnchorPointsType::AnchorPoint_sequence& AnchorPointsType::
  AnchorPoint () const
  {
    return this->AnchorPoint_;
  }

  AnchorPointsType::AnchorPoint_sequence& AnchorPointsType::
  AnchorPoint ()
  {
    return this->AnchorPoint_;
  }

  void AnchorPointsType::
  AnchorPoint (const AnchorPoint_sequence& s)
  {
    this->AnchorPoint_ = s;
  }


  // AnchorType
  // 

  const AnchorType::Location_optional& AnchorType::
  Location () const
  {
    return this->Location_;
  }

  AnchorType::Location_optional& AnchorType::
  Location ()
  {
    return this->Location_;
  }

  void AnchorType::
  Location (const Location_type& x)
  {
    this->Location_.set (x);
  }

  void AnchorType::
  Location (const Location_optional& x)
  {
    this->Location_ = x;
  }

  void AnchorType::
  Location (::std::unique_ptr< Location_type > x)
  {
    this->Location_.set (std::move (x));
  }

  const AnchorType::PointSymbolHandle_optional& AnchorType::
  PointSymbolHandle () const
  {
    return this->PointSymbolHandle_;
  }

  AnchorType::PointSymbolHandle_optional& AnchorType::
  PointSymbolHandle ()
  {
    return this->PointSymbolHandle_;
  }

  void AnchorType::
  PointSymbolHandle (const PointSymbolHandle_type& x)
  {
    this->PointSymbolHandle_.set (x);
  }

  void AnchorType::
  PointSymbolHandle (const PointSymbolHandle_optional& x)
  {
    this->PointSymbolHandle_ = x;
  }

  void AnchorType::
  PointSymbolHandle (::std::unique_ptr< PointSymbolHandle_type > x)
  {
    this->PointSymbolHandle_.set (std::move (x));
  }


  // AreaSymbolModifiersType
  // 

  const AreaSymbolModifiersType::Echelon_optional& AreaSymbolModifiersType::
  Echelon () const
  {
    return this->Echelon_;
  }

  AreaSymbolModifiersType::Echelon_optional& AreaSymbolModifiersType::
  Echelon ()
  {
    return this->Echelon_;
  }

  void AreaSymbolModifiersType::
  Echelon (const Echelon_type& x)
  {
    this->Echelon_.set (x);
  }

  void AreaSymbolModifiersType::
  Echelon (const Echelon_optional& x)
  {
    this->Echelon_ = x;
  }

  void AreaSymbolModifiersType::
  Echelon (::std::unique_ptr< Echelon_type > x)
  {
    this->Echelon_.set (std::move (x));
  }

  const AreaSymbolModifiersType::AdditionalInfo_optional& AreaSymbolModifiersType::
  AdditionalInfo () const
  {
    return this->AdditionalInfo_;
  }

  AreaSymbolModifiersType::AdditionalInfo_optional& AreaSymbolModifiersType::
  AdditionalInfo ()
  {
    return this->AdditionalInfo_;
  }

  void AreaSymbolModifiersType::
  AdditionalInfo (const AdditionalInfo_type& x)
  {
    this->AdditionalInfo_.set (x);
  }

  void AreaSymbolModifiersType::
  AdditionalInfo (const AdditionalInfo_optional& x)
  {
    this->AdditionalInfo_ = x;
  }

  void AreaSymbolModifiersType::
  AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > x)
  {
    this->AdditionalInfo_.set (std::move (x));
  }

  const AreaSymbolModifiersType::AdditionalInfo1_optional& AreaSymbolModifiersType::
  AdditionalInfo1 () const
  {
    return this->AdditionalInfo1_;
  }

  AreaSymbolModifiersType::AdditionalInfo1_optional& AreaSymbolModifiersType::
  AdditionalInfo1 ()
  {
    return this->AdditionalInfo1_;
  }

  void AreaSymbolModifiersType::
  AdditionalInfo1 (const AdditionalInfo1_type& x)
  {
    this->AdditionalInfo1_.set (x);
  }

  void AreaSymbolModifiersType::
  AdditionalInfo1 (const AdditionalInfo1_optional& x)
  {
    this->AdditionalInfo1_ = x;
  }

  void AreaSymbolModifiersType::
  AdditionalInfo1 (::std::unique_ptr< AdditionalInfo1_type > x)
  {
    this->AdditionalInfo1_.set (std::move (x));
  }

  const AreaSymbolModifiersType::AdditionalInfo2_optional& AreaSymbolModifiersType::
  AdditionalInfo2 () const
  {
    return this->AdditionalInfo2_;
  }

  AreaSymbolModifiersType::AdditionalInfo2_optional& AreaSymbolModifiersType::
  AdditionalInfo2 ()
  {
    return this->AdditionalInfo2_;
  }

  void AreaSymbolModifiersType::
  AdditionalInfo2 (const AdditionalInfo2_type& x)
  {
    this->AdditionalInfo2_.set (x);
  }

  void AreaSymbolModifiersType::
  AdditionalInfo2 (const AdditionalInfo2_optional& x)
  {
    this->AdditionalInfo2_ = x;
  }

  void AreaSymbolModifiersType::
  AdditionalInfo2 (::std::unique_ptr< AdditionalInfo2_type > x)
  {
    this->AdditionalInfo2_.set (std::move (x));
  }

  const AreaSymbolModifiersType::UniqueDesignation_optional& AreaSymbolModifiersType::
  UniqueDesignation () const
  {
    return this->UniqueDesignation_;
  }

  AreaSymbolModifiersType::UniqueDesignation_optional& AreaSymbolModifiersType::
  UniqueDesignation ()
  {
    return this->UniqueDesignation_;
  }

  void AreaSymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_type& x)
  {
    this->UniqueDesignation_.set (x);
  }

  void AreaSymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_optional& x)
  {
    this->UniqueDesignation_ = x;
  }

  void AreaSymbolModifiersType::
  UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > x)
  {
    this->UniqueDesignation_.set (std::move (x));
  }

  const AreaSymbolModifiersType::DateTimeGroup_optional& AreaSymbolModifiersType::
  DateTimeGroup () const
  {
    return this->DateTimeGroup_;
  }

  AreaSymbolModifiersType::DateTimeGroup_optional& AreaSymbolModifiersType::
  DateTimeGroup ()
  {
    return this->DateTimeGroup_;
  }

  void AreaSymbolModifiersType::
  DateTimeGroup (const DateTimeGroup_type& x)
  {
    this->DateTimeGroup_.set (x);
  }

  void AreaSymbolModifiersType::
  DateTimeGroup (const DateTimeGroup_optional& x)
  {
    this->DateTimeGroup_ = x;
  }

  void AreaSymbolModifiersType::
  DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > x)
  {
    this->DateTimeGroup_.set (std::move (x));
  }

  const AreaSymbolModifiersType::DateTimeGroup1_optional& AreaSymbolModifiersType::
  DateTimeGroup1 () const
  {
    return this->DateTimeGroup1_;
  }

  AreaSymbolModifiersType::DateTimeGroup1_optional& AreaSymbolModifiersType::
  DateTimeGroup1 ()
  {
    return this->DateTimeGroup1_;
  }

  void AreaSymbolModifiersType::
  DateTimeGroup1 (const DateTimeGroup1_type& x)
  {
    this->DateTimeGroup1_.set (x);
  }

  void AreaSymbolModifiersType::
  DateTimeGroup1 (const DateTimeGroup1_optional& x)
  {
    this->DateTimeGroup1_ = x;
  }

  void AreaSymbolModifiersType::
  DateTimeGroup1 (::std::unique_ptr< DateTimeGroup1_type > x)
  {
    this->DateTimeGroup1_.set (std::move (x));
  }


  // AssociatedOverlaysType
  // 

  const AssociatedOverlaysType::OverlayHandles_type& AssociatedOverlaysType::
  OverlayHandles () const
  {
    return this->OverlayHandles_.get ();
  }

  AssociatedOverlaysType::OverlayHandles_type& AssociatedOverlaysType::
  OverlayHandles ()
  {
    return this->OverlayHandles_.get ();
  }

  void AssociatedOverlaysType::
  OverlayHandles (const OverlayHandles_type& x)
  {
    this->OverlayHandles_.set (x);
  }

  void AssociatedOverlaysType::
  OverlayHandles (::std::unique_ptr< OverlayHandles_type > x)
  {
    this->OverlayHandles_.set (std::move (x));
  }

  const AssociatedOverlaysType::SourceOverlayType_optional& AssociatedOverlaysType::
  SourceOverlayType () const
  {
    return this->SourceOverlayType_;
  }

  AssociatedOverlaysType::SourceOverlayType_optional& AssociatedOverlaysType::
  SourceOverlayType ()
  {
    return this->SourceOverlayType_;
  }

  void AssociatedOverlaysType::
  SourceOverlayType (const SourceOverlayType_type& x)
  {
    this->SourceOverlayType_.set (x);
  }

  void AssociatedOverlaysType::
  SourceOverlayType (const SourceOverlayType_optional& x)
  {
    this->SourceOverlayType_ = x;
  }

  void AssociatedOverlaysType::
  SourceOverlayType (::std::unique_ptr< SourceOverlayType_type > x)
  {
    this->SourceOverlayType_.set (std::move (x));
  }


  // AssociationsType
  // 

  const AssociationsType::Association_sequence& AssociationsType::
  Association () const
  {
    return this->Association_;
  }

  AssociationsType::Association_sequence& AssociationsType::
  Association ()
  {
    return this->Association_;
  }

  void AssociationsType::
  Association (const Association_sequence& s)
  {
    this->Association_ = s;
  }


  // AssociationType
  // 

  const AssociationType::AffiliateHandle_type& AssociationType::
  AffiliateHandle () const
  {
    return this->AffiliateHandle_.get ();
  }

  AssociationType::AffiliateHandle_type& AssociationType::
  AffiliateHandle ()
  {
    return this->AffiliateHandle_.get ();
  }

  void AssociationType::
  AffiliateHandle (const AffiliateHandle_type& x)
  {
    this->AffiliateHandle_.set (x);
  }

  void AssociationType::
  AffiliateHandle (::std::unique_ptr< AffiliateHandle_type > x)
  {
    this->AffiliateHandle_.set (std::move (x));
  }

  const AssociationType::Relationship_type& AssociationType::
  Relationship () const
  {
    return this->Relationship_.get ();
  }

  AssociationType::Relationship_type& AssociationType::
  Relationship ()
  {
    return this->Relationship_.get ();
  }

  void AssociationType::
  Relationship (const Relationship_type& x)
  {
    this->Relationship_.set (x);
  }

  void AssociationType::
  Relationship (::std::unique_ptr< Relationship_type > x)
  {
    this->Relationship_.set (std::move (x));
  }


  // BoundarySymbolModifiersType
  // 

  const BoundarySymbolModifiersType::Echelon_optional& BoundarySymbolModifiersType::
  Echelon () const
  {
    return this->Echelon_;
  }

  BoundarySymbolModifiersType::Echelon_optional& BoundarySymbolModifiersType::
  Echelon ()
  {
    return this->Echelon_;
  }

  void BoundarySymbolModifiersType::
  Echelon (const Echelon_type& x)
  {
    this->Echelon_.set (x);
  }

  void BoundarySymbolModifiersType::
  Echelon (const Echelon_optional& x)
  {
    this->Echelon_ = x;
  }

  void BoundarySymbolModifiersType::
  Echelon (::std::unique_ptr< Echelon_type > x)
  {
    this->Echelon_.set (std::move (x));
  }

  const BoundarySymbolModifiersType::UniqueDesignation_optional& BoundarySymbolModifiersType::
  UniqueDesignation () const
  {
    return this->UniqueDesignation_;
  }

  BoundarySymbolModifiersType::UniqueDesignation_optional& BoundarySymbolModifiersType::
  UniqueDesignation ()
  {
    return this->UniqueDesignation_;
  }

  void BoundarySymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_type& x)
  {
    this->UniqueDesignation_.set (x);
  }

  void BoundarySymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_optional& x)
  {
    this->UniqueDesignation_ = x;
  }

  void BoundarySymbolModifiersType::
  UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > x)
  {
    this->UniqueDesignation_.set (std::move (x));
  }

  const BoundarySymbolModifiersType::UniqueDesignation1_optional& BoundarySymbolModifiersType::
  UniqueDesignation1 () const
  {
    return this->UniqueDesignation1_;
  }

  BoundarySymbolModifiersType::UniqueDesignation1_optional& BoundarySymbolModifiersType::
  UniqueDesignation1 ()
  {
    return this->UniqueDesignation1_;
  }

  void BoundarySymbolModifiersType::
  UniqueDesignation1 (const UniqueDesignation1_type& x)
  {
    this->UniqueDesignation1_.set (x);
  }

  void BoundarySymbolModifiersType::
  UniqueDesignation1 (const UniqueDesignation1_optional& x)
  {
    this->UniqueDesignation1_ = x;
  }

  void BoundarySymbolModifiersType::
  UniqueDesignation1 (::std::unique_ptr< UniqueDesignation1_type > x)
  {
    this->UniqueDesignation1_.set (std::move (x));
  }


  // CloudCoverItemsType
  // 

  const CloudCoverItemsType::CloudCover_sequence& CloudCoverItemsType::
  CloudCover () const
  {
    return this->CloudCover_;
  }

  CloudCoverItemsType::CloudCover_sequence& CloudCoverItemsType::
  CloudCover ()
  {
    return this->CloudCover_;
  }

  void CloudCoverItemsType::
  CloudCover (const CloudCover_sequence& s)
  {
    this->CloudCover_ = s;
  }


  // CommandRelationType
  // 

  const CommandRelationType::CommandingSuperiorHandle_type& CommandRelationType::
  CommandingSuperiorHandle () const
  {
    return this->CommandingSuperiorHandle_.get ();
  }

  CommandRelationType::CommandingSuperiorHandle_type& CommandRelationType::
  CommandingSuperiorHandle ()
  {
    return this->CommandingSuperiorHandle_.get ();
  }

  void CommandRelationType::
  CommandingSuperiorHandle (const CommandingSuperiorHandle_type& x)
  {
    this->CommandingSuperiorHandle_.set (x);
  }

  void CommandRelationType::
  CommandingSuperiorHandle (::std::unique_ptr< CommandingSuperiorHandle_type > x)
  {
    this->CommandingSuperiorHandle_.set (std::move (x));
  }

  const CommandRelationType::CommandRelationshipType_type& CommandRelationType::
  CommandRelationshipType () const
  {
    return this->CommandRelationshipType_.get ();
  }

  CommandRelationType::CommandRelationshipType_type& CommandRelationType::
  CommandRelationshipType ()
  {
    return this->CommandRelationshipType_.get ();
  }

  void CommandRelationType::
  CommandRelationshipType (const CommandRelationshipType_type& x)
  {
    this->CommandRelationshipType_.set (x);
  }

  void CommandRelationType::
  CommandRelationshipType (::std::unique_ptr< CommandRelationshipType_type > x)
  {
    this->CommandRelationshipType_.set (std::move (x));
  }


  // CommunicationNetInstancesType
  // 

  const CommunicationNetInstancesType::CommunicationNetInstance_sequence& CommunicationNetInstancesType::
  CommunicationNetInstance () const
  {
    return this->CommunicationNetInstance_;
  }

  CommunicationNetInstancesType::CommunicationNetInstance_sequence& CommunicationNetInstancesType::
  CommunicationNetInstance ()
  {
    return this->CommunicationNetInstance_;
  }

  void CommunicationNetInstancesType::
  CommunicationNetInstance (const CommunicationNetInstance_sequence& s)
  {
    this->CommunicationNetInstance_ = s;
  }


  // CommunicationNetInstanceType
  // 

  const CommunicationNetInstanceType::CommunicationNetType_optional& CommunicationNetInstanceType::
  CommunicationNetType () const
  {
    return this->CommunicationNetType_;
  }

  CommunicationNetInstanceType::CommunicationNetType_optional& CommunicationNetInstanceType::
  CommunicationNetType ()
  {
    return this->CommunicationNetType_;
  }

  void CommunicationNetInstanceType::
  CommunicationNetType (const CommunicationNetType_type& x)
  {
    this->CommunicationNetType_.set (x);
  }

  void CommunicationNetInstanceType::
  CommunicationNetType (const CommunicationNetType_optional& x)
  {
    this->CommunicationNetType_ = x;
  }

  void CommunicationNetInstanceType::
  CommunicationNetType (::std::unique_ptr< CommunicationNetType_type > x)
  {
    this->CommunicationNetType_.set (std::move (x));
  }

  const CommunicationNetInstanceType::CommunicationNetId_type& CommunicationNetInstanceType::
  CommunicationNetId () const
  {
    return this->CommunicationNetId_.get ();
  }

  CommunicationNetInstanceType::CommunicationNetId_type& CommunicationNetInstanceType::
  CommunicationNetId ()
  {
    return this->CommunicationNetId_.get ();
  }

  void CommunicationNetInstanceType::
  CommunicationNetId (const CommunicationNetId_type& x)
  {
    this->CommunicationNetId_.set (x);
  }

  void CommunicationNetInstanceType::
  CommunicationNetId (::std::unique_ptr< CommunicationNetId_type > x)
  {
    this->CommunicationNetId_.set (std::move (x));
  }

  const CommunicationNetInstanceType::CommunicationService_type& CommunicationNetInstanceType::
  CommunicationService () const
  {
    return this->CommunicationService_.get ();
  }

  CommunicationNetInstanceType::CommunicationService_type& CommunicationNetInstanceType::
  CommunicationService ()
  {
    return this->CommunicationService_.get ();
  }

  void CommunicationNetInstanceType::
  CommunicationService (const CommunicationService_type& x)
  {
    this->CommunicationService_.set (x);
  }

  void CommunicationNetInstanceType::
  CommunicationService (::std::unique_ptr< CommunicationService_type > x)
  {
    this->CommunicationService_.set (std::move (x));
  }


  // CommunicationNetReferencesType
  // 

  const CommunicationNetReferencesType::CommunicationNetReference_sequence& CommunicationNetReferencesType::
  CommunicationNetReference () const
  {
    return this->CommunicationNetReference_;
  }

  CommunicationNetReferencesType::CommunicationNetReference_sequence& CommunicationNetReferencesType::
  CommunicationNetReference ()
  {
    return this->CommunicationNetReference_;
  }

  void CommunicationNetReferencesType::
  CommunicationNetReference (const CommunicationNetReference_sequence& s)
  {
    this->CommunicationNetReference_ = s;
  }


  // CommunicationNetReferenceType
  // 

  const CommunicationNetReferenceType::CommunicationNetId_type& CommunicationNetReferenceType::
  CommunicationNetId () const
  {
    return this->CommunicationNetId_.get ();
  }

  CommunicationNetReferenceType::CommunicationNetId_type& CommunicationNetReferenceType::
  CommunicationNetId ()
  {
    return this->CommunicationNetId_.get ();
  }

  void CommunicationNetReferenceType::
  CommunicationNetId (const CommunicationNetId_type& x)
  {
    this->CommunicationNetId_.set (x);
  }

  void CommunicationNetReferenceType::
  CommunicationNetId (::std::unique_ptr< CommunicationNetId_type > x)
  {
    this->CommunicationNetId_.set (std::move (x));
  }

  const CommunicationNetReferenceType::UnitOwnerHandle_type& CommunicationNetReferenceType::
  UnitOwnerHandle () const
  {
    return this->UnitOwnerHandle_.get ();
  }

  CommunicationNetReferenceType::UnitOwnerHandle_type& CommunicationNetReferenceType::
  UnitOwnerHandle ()
  {
    return this->UnitOwnerHandle_.get ();
  }

  void CommunicationNetReferenceType::
  UnitOwnerHandle (const UnitOwnerHandle_type& x)
  {
    this->UnitOwnerHandle_.set (x);
  }

  void CommunicationNetReferenceType::
  UnitOwnerHandle (::std::unique_ptr< UnitOwnerHandle_type > x)
  {
    this->UnitOwnerHandle_.set (std::move (x));
  }


  // CoordinateDataStandardType
  // 

  const CoordinateDataStandardType::CoordinateSystemType_type& CoordinateDataStandardType::
  CoordinateSystemType () const
  {
    return this->CoordinateSystemType_.get ();
  }

  CoordinateDataStandardType::CoordinateSystemType_type& CoordinateDataStandardType::
  CoordinateSystemType ()
  {
    return this->CoordinateSystemType_.get ();
  }

  void CoordinateDataStandardType::
  CoordinateSystemType (const CoordinateSystemType_type& x)
  {
    this->CoordinateSystemType_.set (x);
  }

  void CoordinateDataStandardType::
  CoordinateSystemType (::std::unique_ptr< CoordinateSystemType_type > x)
  {
    this->CoordinateSystemType_.set (std::move (x));
  }

  const CoordinateDataStandardType::CoordinateSystemDatum_type& CoordinateDataStandardType::
  CoordinateSystemDatum () const
  {
    return this->CoordinateSystemDatum_.get ();
  }

  CoordinateDataStandardType::CoordinateSystemDatum_type& CoordinateDataStandardType::
  CoordinateSystemDatum ()
  {
    return this->CoordinateSystemDatum_.get ();
  }

  void CoordinateDataStandardType::
  CoordinateSystemDatum (const CoordinateSystemDatum_type& x)
  {
    this->CoordinateSystemDatum_.set (x);
  }

  void CoordinateDataStandardType::
  CoordinateSystemDatum (::std::unique_ptr< CoordinateSystemDatum_type > x)
  {
    this->CoordinateSystemDatum_.set (std::move (x));
  }


  // CoordinatesType
  // 

  const CoordinatesType::CoordinateChoice_type& CoordinatesType::
  CoordinateChoice () const
  {
    return this->CoordinateChoice_.get ();
  }

  CoordinatesType::CoordinateChoice_type& CoordinatesType::
  CoordinateChoice ()
  {
    return this->CoordinateChoice_.get ();
  }

  void CoordinatesType::
  CoordinateChoice (const CoordinateChoice_type& x)
  {
    this->CoordinateChoice_.set (x);
  }

  void CoordinatesType::
  CoordinateChoice (::std::unique_ptr< CoordinateChoice_type > x)
  {
    this->CoordinateChoice_.set (std::move (x));
  }

  const CoordinatesType::CoordinateData_type& CoordinatesType::
  CoordinateData () const
  {
    return this->CoordinateData_.get ();
  }

  CoordinatesType::CoordinateData_type& CoordinatesType::
  CoordinateData ()
  {
    return this->CoordinateData_.get ();
  }

  void CoordinatesType::
  CoordinateData (const CoordinateData_type& x)
  {
    this->CoordinateData_.set (x);
  }

  void CoordinatesType::
  CoordinateData (::std::unique_ptr< CoordinateData_type > x)
  {
    this->CoordinateData_.set (std::move (x));
  }


  // CoordinatePointType
  // 

  const CoordinatePointType::MGRS_optional& CoordinatePointType::
  MGRS () const
  {
    return this->MGRS_;
  }

  CoordinatePointType::MGRS_optional& CoordinatePointType::
  MGRS ()
  {
    return this->MGRS_;
  }

  void CoordinatePointType::
  MGRS (const MGRS_type& x)
  {
    this->MGRS_.set (x);
  }

  void CoordinatePointType::
  MGRS (const MGRS_optional& x)
  {
    this->MGRS_ = x;
  }

  void CoordinatePointType::
  MGRS (::std::unique_ptr< MGRS_type > x)
  {
    this->MGRS_.set (std::move (x));
  }

  const CoordinatePointType::UTM_optional& CoordinatePointType::
  UTM () const
  {
    return this->UTM_;
  }

  CoordinatePointType::UTM_optional& CoordinatePointType::
  UTM ()
  {
    return this->UTM_;
  }

  void CoordinatePointType::
  UTM (const UTM_type& x)
  {
    this->UTM_.set (x);
  }

  void CoordinatePointType::
  UTM (const UTM_optional& x)
  {
    this->UTM_ = x;
  }

  void CoordinatePointType::
  UTM (::std::unique_ptr< UTM_type > x)
  {
    this->UTM_.set (std::move (x));
  }

  const CoordinatePointType::GDC_optional& CoordinatePointType::
  GDC () const
  {
    return this->GDC_;
  }

  CoordinatePointType::GDC_optional& CoordinatePointType::
  GDC ()
  {
    return this->GDC_;
  }

  void CoordinatePointType::
  GDC (const GDC_type& x)
  {
    this->GDC_.set (x);
  }

  void CoordinatePointType::
  GDC (const GDC_optional& x)
  {
    this->GDC_ = x;
  }

  void CoordinatePointType::
  GDC (::std::unique_ptr< GDC_type > x)
  {
    this->GDC_.set (std::move (x));
  }

  const CoordinatePointType::GCC_optional& CoordinatePointType::
  GCC () const
  {
    return this->GCC_;
  }

  CoordinatePointType::GCC_optional& CoordinatePointType::
  GCC ()
  {
    return this->GCC_;
  }

  void CoordinatePointType::
  GCC (const GCC_type& x)
  {
    this->GCC_.set (x);
  }

  void CoordinatePointType::
  GCC (const GCC_optional& x)
  {
    this->GCC_ = x;
  }

  void CoordinatePointType::
  GCC (::std::unique_ptr< GCC_type > x)
  {
    this->GCC_.set (std::move (x));
  }


  // EnvironmentType
  // 

  const EnvironmentType::ScenarioTime_optional& EnvironmentType::
  ScenarioTime () const
  {
    return this->ScenarioTime_;
  }

  EnvironmentType::ScenarioTime_optional& EnvironmentType::
  ScenarioTime ()
  {
    return this->ScenarioTime_;
  }

  void EnvironmentType::
  ScenarioTime (const ScenarioTime_type& x)
  {
    this->ScenarioTime_.set (x);
  }

  void EnvironmentType::
  ScenarioTime (const ScenarioTime_optional& x)
  {
    this->ScenarioTime_ = x;
  }

  void EnvironmentType::
  ScenarioTime (::std::unique_ptr< ScenarioTime_type > x)
  {
    this->ScenarioTime_.set (std::move (x));
  }

  const EnvironmentType::AreaOfInterest_optional& EnvironmentType::
  AreaOfInterest () const
  {
    return this->AreaOfInterest_;
  }

  EnvironmentType::AreaOfInterest_optional& EnvironmentType::
  AreaOfInterest ()
  {
    return this->AreaOfInterest_;
  }

  void EnvironmentType::
  AreaOfInterest (const AreaOfInterest_type& x)
  {
    this->AreaOfInterest_.set (x);
  }

  void EnvironmentType::
  AreaOfInterest (const AreaOfInterest_optional& x)
  {
    this->AreaOfInterest_ = x;
  }

  void EnvironmentType::
  AreaOfInterest (::std::unique_ptr< AreaOfInterest_type > x)
  {
    this->AreaOfInterest_.set (std::move (x));
  }

  const EnvironmentType::ScenarioWeather_optional& EnvironmentType::
  ScenarioWeather () const
  {
    return this->ScenarioWeather_;
  }

  EnvironmentType::ScenarioWeather_optional& EnvironmentType::
  ScenarioWeather ()
  {
    return this->ScenarioWeather_;
  }

  void EnvironmentType::
  ScenarioWeather (const ScenarioWeather_type& x)
  {
    this->ScenarioWeather_.set (x);
  }

  void EnvironmentType::
  ScenarioWeather (const ScenarioWeather_optional& x)
  {
    this->ScenarioWeather_ = x;
  }

  void EnvironmentType::
  ScenarioWeather (::std::unique_ptr< ScenarioWeather_type > x)
  {
    this->ScenarioWeather_.set (std::move (x));
  }

  const EnvironmentType::METOC_optional& EnvironmentType::
  METOC () const
  {
    return this->METOC_;
  }

  EnvironmentType::METOC_optional& EnvironmentType::
  METOC ()
  {
    return this->METOC_;
  }

  void EnvironmentType::
  METOC (const METOC_type& x)
  {
    this->METOC_.set (x);
  }

  void EnvironmentType::
  METOC (const METOC_optional& x)
  {
    this->METOC_ = x;
  }

  void EnvironmentType::
  METOC (::std::unique_ptr< METOC_type > x)
  {
    this->METOC_.set (std::move (x));
  }


  // EquipmentDispositionType
  // 

  const EquipmentDispositionType::Location_type& EquipmentDispositionType::
  Location () const
  {
    return this->Location_.get ();
  }

  EquipmentDispositionType::Location_type& EquipmentDispositionType::
  Location ()
  {
    return this->Location_.get ();
  }

  void EquipmentDispositionType::
  Location (const Location_type& x)
  {
    this->Location_.set (x);
  }

  void EquipmentDispositionType::
  Location (::std::unique_ptr< Location_type > x)
  {
    this->Location_.set (std::move (x));
  }

  const EquipmentDispositionType::DirectionOfMovement_optional& EquipmentDispositionType::
  DirectionOfMovement () const
  {
    return this->DirectionOfMovement_;
  }

  EquipmentDispositionType::DirectionOfMovement_optional& EquipmentDispositionType::
  DirectionOfMovement ()
  {
    return this->DirectionOfMovement_;
  }

  void EquipmentDispositionType::
  DirectionOfMovement (const DirectionOfMovement_type& x)
  {
    this->DirectionOfMovement_.set (x);
  }

  void EquipmentDispositionType::
  DirectionOfMovement (const DirectionOfMovement_optional& x)
  {
    this->DirectionOfMovement_ = x;
  }

  void EquipmentDispositionType::
  DirectionOfMovement (::std::unique_ptr< DirectionOfMovement_type > x)
  {
    this->DirectionOfMovement_.set (std::move (x));
  }

  const EquipmentDispositionType::Speed_optional& EquipmentDispositionType::
  Speed () const
  {
    return this->Speed_;
  }

  EquipmentDispositionType::Speed_optional& EquipmentDispositionType::
  Speed ()
  {
    return this->Speed_;
  }

  void EquipmentDispositionType::
  Speed (const Speed_type& x)
  {
    this->Speed_.set (x);
  }

  void EquipmentDispositionType::
  Speed (const Speed_optional& x)
  {
    this->Speed_ = x;
  }

  void EquipmentDispositionType::
  Speed (::std::unique_ptr< Speed_type > x)
  {
    this->Speed_.set (std::move (x));
  }

  const EquipmentDispositionType::FormationPosition_optional& EquipmentDispositionType::
  FormationPosition () const
  {
    return this->FormationPosition_;
  }

  EquipmentDispositionType::FormationPosition_optional& EquipmentDispositionType::
  FormationPosition ()
  {
    return this->FormationPosition_;
  }

  void EquipmentDispositionType::
  FormationPosition (const FormationPosition_type& x)
  {
    this->FormationPosition_.set (x);
  }

  void EquipmentDispositionType::
  FormationPosition (const FormationPosition_optional& x)
  {
    this->FormationPosition_ = x;
  }

  void EquipmentDispositionType::
  FormationPosition (::std::unique_ptr< FormationPosition_type > x)
  {
    this->FormationPosition_.set (std::move (x));
  }


  // EquipmentItemType
  // 

  const EquipmentItemType::ObjectHandle_type& EquipmentItemType::
  ObjectHandle () const
  {
    return this->ObjectHandle_.get ();
  }

  EquipmentItemType::ObjectHandle_type& EquipmentItemType::
  ObjectHandle ()
  {
    return this->ObjectHandle_.get ();
  }

  void EquipmentItemType::
  ObjectHandle (const ObjectHandle_type& x)
  {
    this->ObjectHandle_.set (x);
  }

  void EquipmentItemType::
  ObjectHandle (::std::unique_ptr< ObjectHandle_type > x)
  {
    this->ObjectHandle_.set (std::move (x));
  }

  const EquipmentItemType::SymbolIdentifier_type& EquipmentItemType::
  SymbolIdentifier () const
  {
    return this->SymbolIdentifier_.get ();
  }

  EquipmentItemType::SymbolIdentifier_type& EquipmentItemType::
  SymbolIdentifier ()
  {
    return this->SymbolIdentifier_.get ();
  }

  void EquipmentItemType::
  SymbolIdentifier (const SymbolIdentifier_type& x)
  {
    this->SymbolIdentifier_.set (x);
  }

  void EquipmentItemType::
  SymbolIdentifier (::std::unique_ptr< SymbolIdentifier_type > x)
  {
    this->SymbolIdentifier_.set (std::move (x));
  }

  const EquipmentItemType::Name_optional& EquipmentItemType::
  Name () const
  {
    return this->Name_;
  }

  EquipmentItemType::Name_optional& EquipmentItemType::
  Name ()
  {
    return this->Name_;
  }

  void EquipmentItemType::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void EquipmentItemType::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void EquipmentItemType::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const EquipmentItemType::EquipmentSymbolModifiers_optional& EquipmentItemType::
  EquipmentSymbolModifiers () const
  {
    return this->EquipmentSymbolModifiers_;
  }

  EquipmentItemType::EquipmentSymbolModifiers_optional& EquipmentItemType::
  EquipmentSymbolModifiers ()
  {
    return this->EquipmentSymbolModifiers_;
  }

  void EquipmentItemType::
  EquipmentSymbolModifiers (const EquipmentSymbolModifiers_type& x)
  {
    this->EquipmentSymbolModifiers_.set (x);
  }

  void EquipmentItemType::
  EquipmentSymbolModifiers (const EquipmentSymbolModifiers_optional& x)
  {
    this->EquipmentSymbolModifiers_ = x;
  }

  void EquipmentItemType::
  EquipmentSymbolModifiers (::std::unique_ptr< EquipmentSymbolModifiers_type > x)
  {
    this->EquipmentSymbolModifiers_.set (std::move (x));
  }

  const EquipmentItemType::CommunicationNetReferences_optional& EquipmentItemType::
  CommunicationNetReferences () const
  {
    return this->CommunicationNetReferences_;
  }

  EquipmentItemType::CommunicationNetReferences_optional& EquipmentItemType::
  CommunicationNetReferences ()
  {
    return this->CommunicationNetReferences_;
  }

  void EquipmentItemType::
  CommunicationNetReferences (const CommunicationNetReferences_type& x)
  {
    this->CommunicationNetReferences_.set (x);
  }

  void EquipmentItemType::
  CommunicationNetReferences (const CommunicationNetReferences_optional& x)
  {
    this->CommunicationNetReferences_ = x;
  }

  void EquipmentItemType::
  CommunicationNetReferences (::std::unique_ptr< CommunicationNetReferences_type > x)
  {
    this->CommunicationNetReferences_.set (std::move (x));
  }

  const EquipmentItemType::Disposition_type& EquipmentItemType::
  Disposition () const
  {
    return this->Disposition_.get ();
  }

  EquipmentItemType::Disposition_type& EquipmentItemType::
  Disposition ()
  {
    return this->Disposition_.get ();
  }

  void EquipmentItemType::
  Disposition (const Disposition_type& x)
  {
    this->Disposition_.set (x);
  }

  void EquipmentItemType::
  Disposition (::std::unique_ptr< Disposition_type > x)
  {
    this->Disposition_.set (std::move (x));
  }

  const EquipmentItemType::Relations_type& EquipmentItemType::
  Relations () const
  {
    return this->Relations_.get ();
  }

  EquipmentItemType::Relations_type& EquipmentItemType::
  Relations ()
  {
    return this->Relations_.get ();
  }

  void EquipmentItemType::
  Relations (const Relations_type& x)
  {
    this->Relations_.set (x);
  }

  void EquipmentItemType::
  Relations (::std::unique_ptr< Relations_type > x)
  {
    this->Relations_.set (std::move (x));
  }

  const EquipmentItemType::Model_optional& EquipmentItemType::
  Model () const
  {
    return this->Model_;
  }

  EquipmentItemType::Model_optional& EquipmentItemType::
  Model ()
  {
    return this->Model_;
  }

  void EquipmentItemType::
  Model (const Model_type& x)
  {
    this->Model_.set (x);
  }

  void EquipmentItemType::
  Model (const Model_optional& x)
  {
    this->Model_ = x;
  }

  void EquipmentItemType::
  Model (::std::unique_ptr< Model_type > x)
  {
    this->Model_.set (std::move (x));
  }


  // EquipmentModelType
  // 

  const EquipmentModelType::Resolution_type& EquipmentModelType::
  Resolution () const
  {
    return this->Resolution_.get ();
  }

  EquipmentModelType::Resolution_type& EquipmentModelType::
  Resolution ()
  {
    return this->Resolution_.get ();
  }

  void EquipmentModelType::
  Resolution (const Resolution_type& x)
  {
    this->Resolution_.set (x);
  }

  void EquipmentModelType::
  Resolution (::std::unique_ptr< Resolution_type > x)
  {
    this->Resolution_.set (std::move (x));
  }


  // EquipmentRelationsType
  // 

  const EquipmentRelationsType::OrganicSuperiorHandle_optional& EquipmentRelationsType::
  OrganicSuperiorHandle () const
  {
    return this->OrganicSuperiorHandle_;
  }

  EquipmentRelationsType::OrganicSuperiorHandle_optional& EquipmentRelationsType::
  OrganicSuperiorHandle ()
  {
    return this->OrganicSuperiorHandle_;
  }

  void EquipmentRelationsType::
  OrganicSuperiorHandle (const OrganicSuperiorHandle_type& x)
  {
    this->OrganicSuperiorHandle_.set (x);
  }

  void EquipmentRelationsType::
  OrganicSuperiorHandle (const OrganicSuperiorHandle_optional& x)
  {
    this->OrganicSuperiorHandle_ = x;
  }

  void EquipmentRelationsType::
  OrganicSuperiorHandle (::std::unique_ptr< OrganicSuperiorHandle_type > x)
  {
    this->OrganicSuperiorHandle_.set (std::move (x));
  }

  const EquipmentRelationsType::HoldingOrganization_type& EquipmentRelationsType::
  HoldingOrganization () const
  {
    return this->HoldingOrganization_.get ();
  }

  EquipmentRelationsType::HoldingOrganization_type& EquipmentRelationsType::
  HoldingOrganization ()
  {
    return this->HoldingOrganization_.get ();
  }

  void EquipmentRelationsType::
  HoldingOrganization (const HoldingOrganization_type& x)
  {
    this->HoldingOrganization_.set (x);
  }

  void EquipmentRelationsType::
  HoldingOrganization (::std::unique_ptr< HoldingOrganization_type > x)
  {
    this->HoldingOrganization_.set (std::move (x));
  }


  // EquipmentSymbolModifiersType
  // 

  const EquipmentSymbolModifiersType::Quantity_optional& EquipmentSymbolModifiersType::
  Quantity () const
  {
    return this->Quantity_;
  }

  EquipmentSymbolModifiersType::Quantity_optional& EquipmentSymbolModifiersType::
  Quantity ()
  {
    return this->Quantity_;
  }

  void EquipmentSymbolModifiersType::
  Quantity (const Quantity_type& x)
  {
    this->Quantity_.set (x);
  }

  void EquipmentSymbolModifiersType::
  Quantity (const Quantity_optional& x)
  {
    this->Quantity_ = x;
  }

  void EquipmentSymbolModifiersType::
  Quantity (::std::unique_ptr< Quantity_type > x)
  {
    this->Quantity_.set (std::move (x));
  }

  const EquipmentSymbolModifiersType::StaffComments_optional& EquipmentSymbolModifiersType::
  StaffComments () const
  {
    return this->StaffComments_;
  }

  EquipmentSymbolModifiersType::StaffComments_optional& EquipmentSymbolModifiersType::
  StaffComments ()
  {
    return this->StaffComments_;
  }

  void EquipmentSymbolModifiersType::
  StaffComments (const StaffComments_type& x)
  {
    this->StaffComments_.set (x);
  }

  void EquipmentSymbolModifiersType::
  StaffComments (const StaffComments_optional& x)
  {
    this->StaffComments_ = x;
  }

  void EquipmentSymbolModifiersType::
  StaffComments (::std::unique_ptr< StaffComments_type > x)
  {
    this->StaffComments_.set (std::move (x));
  }

  const EquipmentSymbolModifiersType::AdditionalInfo_optional& EquipmentSymbolModifiersType::
  AdditionalInfo () const
  {
    return this->AdditionalInfo_;
  }

  EquipmentSymbolModifiersType::AdditionalInfo_optional& EquipmentSymbolModifiersType::
  AdditionalInfo ()
  {
    return this->AdditionalInfo_;
  }

  void EquipmentSymbolModifiersType::
  AdditionalInfo (const AdditionalInfo_type& x)
  {
    this->AdditionalInfo_.set (x);
  }

  void EquipmentSymbolModifiersType::
  AdditionalInfo (const AdditionalInfo_optional& x)
  {
    this->AdditionalInfo_ = x;
  }

  void EquipmentSymbolModifiersType::
  AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > x)
  {
    this->AdditionalInfo_.set (std::move (x));
  }

  const EquipmentSymbolModifiersType::CombatEffectiveness_optional& EquipmentSymbolModifiersType::
  CombatEffectiveness () const
  {
    return this->CombatEffectiveness_;
  }

  EquipmentSymbolModifiersType::CombatEffectiveness_optional& EquipmentSymbolModifiersType::
  CombatEffectiveness ()
  {
    return this->CombatEffectiveness_;
  }

  void EquipmentSymbolModifiersType::
  CombatEffectiveness (const CombatEffectiveness_type& x)
  {
    this->CombatEffectiveness_.set (x);
  }

  void EquipmentSymbolModifiersType::
  CombatEffectiveness (const CombatEffectiveness_optional& x)
  {
    this->CombatEffectiveness_ = x;
  }

  void EquipmentSymbolModifiersType::
  CombatEffectiveness (::std::unique_ptr< CombatEffectiveness_type > x)
  {
    this->CombatEffectiveness_.set (std::move (x));
  }

  const EquipmentSymbolModifiersType::IFF_optional& EquipmentSymbolModifiersType::
  IFF () const
  {
    return this->IFF_;
  }

  EquipmentSymbolModifiersType::IFF_optional& EquipmentSymbolModifiersType::
  IFF ()
  {
    return this->IFF_;
  }

  void EquipmentSymbolModifiersType::
  IFF (const IFF_type& x)
  {
    this->IFF_.set (x);
  }

  void EquipmentSymbolModifiersType::
  IFF (const IFF_optional& x)
  {
    this->IFF_ = x;
  }

  void EquipmentSymbolModifiersType::
  IFF (::std::unique_ptr< IFF_type > x)
  {
    this->IFF_.set (std::move (x));
  }

  const EquipmentSymbolModifiersType::UniqueDesignation_type& EquipmentSymbolModifiersType::
  UniqueDesignation () const
  {
    return this->UniqueDesignation_.get ();
  }

  EquipmentSymbolModifiersType::UniqueDesignation_type& EquipmentSymbolModifiersType::
  UniqueDesignation ()
  {
    return this->UniqueDesignation_.get ();
  }

  void EquipmentSymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_type& x)
  {
    this->UniqueDesignation_.set (x);
  }

  void EquipmentSymbolModifiersType::
  UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > x)
  {
    this->UniqueDesignation_.set (std::move (x));
  }

  const EquipmentSymbolModifiersType::EquipmentType_optional& EquipmentSymbolModifiersType::
  EquipmentType () const
  {
    return this->EquipmentType_;
  }

  EquipmentSymbolModifiersType::EquipmentType_optional& EquipmentSymbolModifiersType::
  EquipmentType ()
  {
    return this->EquipmentType_;
  }

  void EquipmentSymbolModifiersType::
  EquipmentType (const EquipmentType_type& x)
  {
    this->EquipmentType_.set (x);
  }

  void EquipmentSymbolModifiersType::
  EquipmentType (const EquipmentType_optional& x)
  {
    this->EquipmentType_ = x;
  }

  void EquipmentSymbolModifiersType::
  EquipmentType (::std::unique_ptr< EquipmentType_type > x)
  {
    this->EquipmentType_.set (std::move (x));
  }

  const EquipmentSymbolModifiersType::TowedSonarArray_optional& EquipmentSymbolModifiersType::
  TowedSonarArray () const
  {
    return this->TowedSonarArray_;
  }

  EquipmentSymbolModifiersType::TowedSonarArray_optional& EquipmentSymbolModifiersType::
  TowedSonarArray ()
  {
    return this->TowedSonarArray_;
  }

  void EquipmentSymbolModifiersType::
  TowedSonarArray (const TowedSonarArray_type& x)
  {
    this->TowedSonarArray_.set (x);
  }

  void EquipmentSymbolModifiersType::
  TowedSonarArray (const TowedSonarArray_optional& x)
  {
    this->TowedSonarArray_ = x;
  }

  void EquipmentSymbolModifiersType::
  TowedSonarArray (::std::unique_ptr< TowedSonarArray_type > x)
  {
    this->TowedSonarArray_.set (std::move (x));
  }


  // EquipmentType
  // 

  const EquipmentType::EquipmentItem_sequence& EquipmentType::
  EquipmentItem () const
  {
    return this->EquipmentItem_;
  }

  EquipmentType::EquipmentItem_sequence& EquipmentType::
  EquipmentItem ()
  {
    return this->EquipmentItem_;
  }

  void EquipmentType::
  EquipmentItem (const EquipmentItem_sequence& s)
  {
    this->EquipmentItem_ = s;
  }


  // ForceRelationDataType
  // 

  const ForceRelationDataType::CommandRelation_optional& ForceRelationDataType::
  CommandRelation () const
  {
    return this->CommandRelation_;
  }

  ForceRelationDataType::CommandRelation_optional& ForceRelationDataType::
  CommandRelation ()
  {
    return this->CommandRelation_;
  }

  void ForceRelationDataType::
  CommandRelation (const CommandRelation_type& x)
  {
    this->CommandRelation_.set (x);
  }

  void ForceRelationDataType::
  CommandRelation (const CommandRelation_optional& x)
  {
    this->CommandRelation_ = x;
  }

  void ForceRelationDataType::
  CommandRelation (::std::unique_ptr< CommandRelation_type > x)
  {
    this->CommandRelation_.set (std::move (x));
  }

  const ForceRelationDataType::ForceSideHandle_optional& ForceRelationDataType::
  ForceSideHandle () const
  {
    return this->ForceSideHandle_;
  }

  ForceRelationDataType::ForceSideHandle_optional& ForceRelationDataType::
  ForceSideHandle ()
  {
    return this->ForceSideHandle_;
  }

  void ForceRelationDataType::
  ForceSideHandle (const ForceSideHandle_type& x)
  {
    this->ForceSideHandle_.set (x);
  }

  void ForceRelationDataType::
  ForceSideHandle (const ForceSideHandle_optional& x)
  {
    this->ForceSideHandle_ = x;
  }

  void ForceRelationDataType::
  ForceSideHandle (::std::unique_ptr< ForceSideHandle_type > x)
  {
    this->ForceSideHandle_.set (std::move (x));
  }


  // ForceRelationType
  // 

  const ForceRelationType::ForceRelationChoice_type& ForceRelationType::
  ForceRelationChoice () const
  {
    return this->ForceRelationChoice_.get ();
  }

  ForceRelationType::ForceRelationChoice_type& ForceRelationType::
  ForceRelationChoice ()
  {
    return this->ForceRelationChoice_.get ();
  }

  void ForceRelationType::
  ForceRelationChoice (const ForceRelationChoice_type& x)
  {
    this->ForceRelationChoice_.set (x);
  }

  void ForceRelationType::
  ForceRelationChoice (::std::unique_ptr< ForceRelationChoice_type > x)
  {
    this->ForceRelationChoice_.set (std::move (x));
  }

  const ForceRelationType::ForceRelationData_type& ForceRelationType::
  ForceRelationData () const
  {
    return this->ForceRelationData_.get ();
  }

  ForceRelationType::ForceRelationData_type& ForceRelationType::
  ForceRelationData ()
  {
    return this->ForceRelationData_.get ();
  }

  void ForceRelationType::
  ForceRelationData (const ForceRelationData_type& x)
  {
    this->ForceRelationData_.set (x);
  }

  void ForceRelationType::
  ForceRelationData (::std::unique_ptr< ForceRelationData_type > x)
  {
    this->ForceRelationData_.set (std::move (x));
  }


  // ForceSidesType
  // 

  const ForceSidesType::ForceSide_sequence& ForceSidesType::
  ForceSide () const
  {
    return this->ForceSide_;
  }

  ForceSidesType::ForceSide_sequence& ForceSidesType::
  ForceSide ()
  {
    return this->ForceSide_;
  }

  void ForceSidesType::
  ForceSide (const ForceSide_sequence& s)
  {
    this->ForceSide_ = s;
  }


  // ForceSideType
  // 

  const ForceSideType::ObjectHandle_type& ForceSideType::
  ObjectHandle () const
  {
    return this->ObjectHandle_.get ();
  }

  ForceSideType::ObjectHandle_type& ForceSideType::
  ObjectHandle ()
  {
    return this->ObjectHandle_.get ();
  }

  void ForceSideType::
  ObjectHandle (const ObjectHandle_type& x)
  {
    this->ObjectHandle_.set (x);
  }

  void ForceSideType::
  ObjectHandle (::std::unique_ptr< ObjectHandle_type > x)
  {
    this->ObjectHandle_.set (std::move (x));
  }

  const ForceSideType::ForceSideName_type& ForceSideType::
  ForceSideName () const
  {
    return this->ForceSideName_.get ();
  }

  ForceSideType::ForceSideName_type& ForceSideType::
  ForceSideName ()
  {
    return this->ForceSideName_.get ();
  }

  void ForceSideType::
  ForceSideName (const ForceSideName_type& x)
  {
    this->ForceSideName_.set (x);
  }

  void ForceSideType::
  ForceSideName (::std::unique_ptr< ForceSideName_type > x)
  {
    this->ForceSideName_.set (std::move (x));
  }

  const ForceSideType::AllegianceHandle_optional& ForceSideType::
  AllegianceHandle () const
  {
    return this->AllegianceHandle_;
  }

  ForceSideType::AllegianceHandle_optional& ForceSideType::
  AllegianceHandle ()
  {
    return this->AllegianceHandle_;
  }

  void ForceSideType::
  AllegianceHandle (const AllegianceHandle_type& x)
  {
    this->AllegianceHandle_.set (x);
  }

  void ForceSideType::
  AllegianceHandle (const AllegianceHandle_optional& x)
  {
    this->AllegianceHandle_ = x;
  }

  void ForceSideType::
  AllegianceHandle (::std::unique_ptr< AllegianceHandle_type > x)
  {
    this->AllegianceHandle_.set (std::move (x));
  }

  const ForceSideType::MilitaryService_optional& ForceSideType::
  MilitaryService () const
  {
    return this->MilitaryService_;
  }

  ForceSideType::MilitaryService_optional& ForceSideType::
  MilitaryService ()
  {
    return this->MilitaryService_;
  }

  void ForceSideType::
  MilitaryService (const MilitaryService_type& x)
  {
    this->MilitaryService_.set (x);
  }

  void ForceSideType::
  MilitaryService (const MilitaryService_optional& x)
  {
    this->MilitaryService_ = x;
  }

  void ForceSideType::
  MilitaryService (::std::unique_ptr< MilitaryService_type > x)
  {
    this->MilitaryService_.set (std::move (x));
  }

  const ForceSideType::CountryCode_optional& ForceSideType::
  CountryCode () const
  {
    return this->CountryCode_;
  }

  ForceSideType::CountryCode_optional& ForceSideType::
  CountryCode ()
  {
    return this->CountryCode_;
  }

  void ForceSideType::
  CountryCode (const CountryCode_type& x)
  {
    this->CountryCode_.set (x);
  }

  void ForceSideType::
  CountryCode (const CountryCode_optional& x)
  {
    this->CountryCode_ = x;
  }

  void ForceSideType::
  CountryCode (::std::unique_ptr< CountryCode_type > x)
  {
    this->CountryCode_.set (std::move (x));
  }

  const ForceSideType::Associations_optional& ForceSideType::
  Associations () const
  {
    return this->Associations_;
  }

  ForceSideType::Associations_optional& ForceSideType::
  Associations ()
  {
    return this->Associations_;
  }

  void ForceSideType::
  Associations (const Associations_type& x)
  {
    this->Associations_.set (x);
  }

  void ForceSideType::
  Associations (const Associations_optional& x)
  {
    this->Associations_ = x;
  }

  void ForceSideType::
  Associations (::std::unique_ptr< Associations_type > x)
  {
    this->Associations_.set (std::move (x));
  }


  // FormationDataType
  // 

  const FormationDataType::GroundFormationType_optional& FormationDataType::
  GroundFormationType () const
  {
    return this->GroundFormationType_;
  }

  FormationDataType::GroundFormationType_optional& FormationDataType::
  GroundFormationType ()
  {
    return this->GroundFormationType_;
  }

  void FormationDataType::
  GroundFormationType (const GroundFormationType_type& x)
  {
    this->GroundFormationType_.set (x);
  }

  void FormationDataType::
  GroundFormationType (const GroundFormationType_optional& x)
  {
    this->GroundFormationType_ = x;
  }

  void FormationDataType::
  GroundFormationType (::std::unique_ptr< GroundFormationType_type > x)
  {
    this->GroundFormationType_.set (std::move (x));
  }

  const FormationDataType::AirFormationType_optional& FormationDataType::
  AirFormationType () const
  {
    return this->AirFormationType_;
  }

  FormationDataType::AirFormationType_optional& FormationDataType::
  AirFormationType ()
  {
    return this->AirFormationType_;
  }

  void FormationDataType::
  AirFormationType (const AirFormationType_type& x)
  {
    this->AirFormationType_.set (x);
  }

  void FormationDataType::
  AirFormationType (const AirFormationType_optional& x)
  {
    this->AirFormationType_ = x;
  }

  void FormationDataType::
  AirFormationType (::std::unique_ptr< AirFormationType_type > x)
  {
    this->AirFormationType_.set (std::move (x));
  }

  const FormationDataType::SurfaceFomationType_optional& FormationDataType::
  SurfaceFomationType () const
  {
    return this->SurfaceFomationType_;
  }

  FormationDataType::SurfaceFomationType_optional& FormationDataType::
  SurfaceFomationType ()
  {
    return this->SurfaceFomationType_;
  }

  void FormationDataType::
  SurfaceFomationType (const SurfaceFomationType_type& x)
  {
    this->SurfaceFomationType_.set (x);
  }

  void FormationDataType::
  SurfaceFomationType (const SurfaceFomationType_optional& x)
  {
    this->SurfaceFomationType_ = x;
  }

  void FormationDataType::
  SurfaceFomationType (::std::unique_ptr< SurfaceFomationType_type > x)
  {
    this->SurfaceFomationType_.set (std::move (x));
  }

  const FormationDataType::SubsurfaceFormationType_optional& FormationDataType::
  SubsurfaceFormationType () const
  {
    return this->SubsurfaceFormationType_;
  }

  FormationDataType::SubsurfaceFormationType_optional& FormationDataType::
  SubsurfaceFormationType ()
  {
    return this->SubsurfaceFormationType_;
  }

  void FormationDataType::
  SubsurfaceFormationType (const SubsurfaceFormationType_type& x)
  {
    this->SubsurfaceFormationType_.set (x);
  }

  void FormationDataType::
  SubsurfaceFormationType (const SubsurfaceFormationType_optional& x)
  {
    this->SubsurfaceFormationType_ = x;
  }

  void FormationDataType::
  SubsurfaceFormationType (::std::unique_ptr< SubsurfaceFormationType_type > x)
  {
    this->SubsurfaceFormationType_.set (std::move (x));
  }


  // FormationPositionType
  // 

  const FormationPositionType::OutOfFormation_optional& FormationPositionType::
  OutOfFormation () const
  {
    return this->OutOfFormation_;
  }

  FormationPositionType::OutOfFormation_optional& FormationPositionType::
  OutOfFormation ()
  {
    return this->OutOfFormation_;
  }

  void FormationPositionType::
  OutOfFormation (const OutOfFormation_type& x)
  {
    this->OutOfFormation_.set (x);
  }

  void FormationPositionType::
  OutOfFormation (const OutOfFormation_optional& x)
  {
    this->OutOfFormation_ = x;
  }

  void FormationPositionType::
  OutOfFormation (::std::unique_ptr< OutOfFormation_type > x)
  {
    this->OutOfFormation_.set (std::move (x));
  }

  const FormationPositionType::FormationOrder_optional& FormationPositionType::
  FormationOrder () const
  {
    return this->FormationOrder_;
  }

  FormationPositionType::FormationOrder_optional& FormationPositionType::
  FormationOrder ()
  {
    return this->FormationOrder_;
  }

  void FormationPositionType::
  FormationOrder (const FormationOrder_type& x)
  {
    this->FormationOrder_.set (x);
  }

  void FormationPositionType::
  FormationOrder (const FormationOrder_optional& x)
  {
    this->FormationOrder_ = x;
  }

  void FormationPositionType::
  FormationOrder (::std::unique_ptr< FormationOrder_type > x)
  {
    this->FormationOrder_.set (std::move (x));
  }

  const FormationPositionType::SensorOrientation_optional& FormationPositionType::
  SensorOrientation () const
  {
    return this->SensorOrientation_;
  }

  FormationPositionType::SensorOrientation_optional& FormationPositionType::
  SensorOrientation ()
  {
    return this->SensorOrientation_;
  }

  void FormationPositionType::
  SensorOrientation (const SensorOrientation_type& x)
  {
    this->SensorOrientation_.set (x);
  }

  void FormationPositionType::
  SensorOrientation (const SensorOrientation_optional& x)
  {
    this->SensorOrientation_ = x;
  }

  void FormationPositionType::
  SensorOrientation (::std::unique_ptr< SensorOrientation_type > x)
  {
    this->SensorOrientation_.set (std::move (x));
  }


  // GCCType
  // 

  const GCCType::X_type& GCCType::
  X () const
  {
    return this->X_.get ();
  }

  GCCType::X_type& GCCType::
  X ()
  {
    return this->X_.get ();
  }

  void GCCType::
  X (const X_type& x)
  {
    this->X_.set (x);
  }

  void GCCType::
  X (::std::unique_ptr< X_type > x)
  {
    this->X_.set (std::move (x));
  }

  const GCCType::Y_type& GCCType::
  Y () const
  {
    return this->Y_.get ();
  }

  GCCType::Y_type& GCCType::
  Y ()
  {
    return this->Y_.get ();
  }

  void GCCType::
  Y (const Y_type& x)
  {
    this->Y_.set (x);
  }

  void GCCType::
  Y (::std::unique_ptr< Y_type > x)
  {
    this->Y_.set (std::move (x));
  }

  const GCCType::Z_type& GCCType::
  Z () const
  {
    return this->Z_.get ();
  }

  GCCType::Z_type& GCCType::
  Z ()
  {
    return this->Z_.get ();
  }

  void GCCType::
  Z (const Z_type& x)
  {
    this->Z_.set (x);
  }

  void GCCType::
  Z (::std::unique_ptr< Z_type > x)
  {
    this->Z_.set (std::move (x));
  }


  // GDCType
  // 

  const GDCType::Latitude_type& GDCType::
  Latitude () const
  {
    return this->Latitude_.get ();
  }

  GDCType::Latitude_type& GDCType::
  Latitude ()
  {
    return this->Latitude_.get ();
  }

  void GDCType::
  Latitude (const Latitude_type& x)
  {
    this->Latitude_.set (x);
  }

  void GDCType::
  Latitude (::std::unique_ptr< Latitude_type > x)
  {
    this->Latitude_.set (std::move (x));
  }

  const GDCType::Longitude_type& GDCType::
  Longitude () const
  {
    return this->Longitude_.get ();
  }

  GDCType::Longitude_type& GDCType::
  Longitude ()
  {
    return this->Longitude_.get ();
  }

  void GDCType::
  Longitude (const Longitude_type& x)
  {
    this->Longitude_.set (x);
  }

  void GDCType::
  Longitude (::std::unique_ptr< Longitude_type > x)
  {
    this->Longitude_.set (std::move (x));
  }

  const GDCType::ElevationAGL_type& GDCType::
  ElevationAGL () const
  {
    return this->ElevationAGL_.get ();
  }

  GDCType::ElevationAGL_type& GDCType::
  ElevationAGL ()
  {
    return this->ElevationAGL_.get ();
  }

  void GDCType::
  ElevationAGL (const ElevationAGL_type& x)
  {
    this->ElevationAGL_.set (x);
  }

  void GDCType::
  ElevationAGL (::std::unique_ptr< ElevationAGL_type > x)
  {
    this->ElevationAGL_.set (std::move (x));
  }


  // InstallationsType
  // 

  const InstallationsType::Installation_sequence& InstallationsType::
  Installation () const
  {
    return this->Installation_;
  }

  InstallationsType::Installation_sequence& InstallationsType::
  Installation ()
  {
    return this->Installation_;
  }

  void InstallationsType::
  Installation (const Installation_sequence& s)
  {
    this->Installation_ = s;
  }


  // InstallationSymbolModifiersType
  // 

  const InstallationSymbolModifiersType::FrameShapeModifier_optional& InstallationSymbolModifiersType::
  FrameShapeModifier () const
  {
    return this->FrameShapeModifier_;
  }

  InstallationSymbolModifiersType::FrameShapeModifier_optional& InstallationSymbolModifiersType::
  FrameShapeModifier ()
  {
    return this->FrameShapeModifier_;
  }

  void InstallationSymbolModifiersType::
  FrameShapeModifier (const FrameShapeModifier_type& x)
  {
    this->FrameShapeModifier_.set (x);
  }

  void InstallationSymbolModifiersType::
  FrameShapeModifier (const FrameShapeModifier_optional& x)
  {
    this->FrameShapeModifier_ = x;
  }

  void InstallationSymbolModifiersType::
  FrameShapeModifier (::std::unique_ptr< FrameShapeModifier_type > x)
  {
    this->FrameShapeModifier_.set (std::move (x));
  }

  const InstallationSymbolModifiersType::StaffComments_optional& InstallationSymbolModifiersType::
  StaffComments () const
  {
    return this->StaffComments_;
  }

  InstallationSymbolModifiersType::StaffComments_optional& InstallationSymbolModifiersType::
  StaffComments ()
  {
    return this->StaffComments_;
  }

  void InstallationSymbolModifiersType::
  StaffComments (const StaffComments_type& x)
  {
    this->StaffComments_.set (x);
  }

  void InstallationSymbolModifiersType::
  StaffComments (const StaffComments_optional& x)
  {
    this->StaffComments_ = x;
  }

  void InstallationSymbolModifiersType::
  StaffComments (::std::unique_ptr< StaffComments_type > x)
  {
    this->StaffComments_.set (std::move (x));
  }

  const InstallationSymbolModifiersType::AdditionalInfo_optional& InstallationSymbolModifiersType::
  AdditionalInfo () const
  {
    return this->AdditionalInfo_;
  }

  InstallationSymbolModifiersType::AdditionalInfo_optional& InstallationSymbolModifiersType::
  AdditionalInfo ()
  {
    return this->AdditionalInfo_;
  }

  void InstallationSymbolModifiersType::
  AdditionalInfo (const AdditionalInfo_type& x)
  {
    this->AdditionalInfo_.set (x);
  }

  void InstallationSymbolModifiersType::
  AdditionalInfo (const AdditionalInfo_optional& x)
  {
    this->AdditionalInfo_ = x;
  }

  void InstallationSymbolModifiersType::
  AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > x)
  {
    this->AdditionalInfo_.set (std::move (x));
  }

  const InstallationSymbolModifiersType::CombatEffectiveness_optional& InstallationSymbolModifiersType::
  CombatEffectiveness () const
  {
    return this->CombatEffectiveness_;
  }

  InstallationSymbolModifiersType::CombatEffectiveness_optional& InstallationSymbolModifiersType::
  CombatEffectiveness ()
  {
    return this->CombatEffectiveness_;
  }

  void InstallationSymbolModifiersType::
  CombatEffectiveness (const CombatEffectiveness_type& x)
  {
    this->CombatEffectiveness_.set (x);
  }

  void InstallationSymbolModifiersType::
  CombatEffectiveness (const CombatEffectiveness_optional& x)
  {
    this->CombatEffectiveness_ = x;
  }

  void InstallationSymbolModifiersType::
  CombatEffectiveness (::std::unique_ptr< CombatEffectiveness_type > x)
  {
    this->CombatEffectiveness_.set (std::move (x));
  }

  const InstallationSymbolModifiersType::IFF_optional& InstallationSymbolModifiersType::
  IFF () const
  {
    return this->IFF_;
  }

  InstallationSymbolModifiersType::IFF_optional& InstallationSymbolModifiersType::
  IFF ()
  {
    return this->IFF_;
  }

  void InstallationSymbolModifiersType::
  IFF (const IFF_type& x)
  {
    this->IFF_.set (x);
  }

  void InstallationSymbolModifiersType::
  IFF (const IFF_optional& x)
  {
    this->IFF_ = x;
  }

  void InstallationSymbolModifiersType::
  IFF (::std::unique_ptr< IFF_type > x)
  {
    this->IFF_.set (std::move (x));
  }

  const InstallationSymbolModifiersType::UniqueDesignation_type& InstallationSymbolModifiersType::
  UniqueDesignation () const
  {
    return this->UniqueDesignation_.get ();
  }

  InstallationSymbolModifiersType::UniqueDesignation_type& InstallationSymbolModifiersType::
  UniqueDesignation ()
  {
    return this->UniqueDesignation_.get ();
  }

  void InstallationSymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_type& x)
  {
    this->UniqueDesignation_.set (x);
  }

  void InstallationSymbolModifiersType::
  UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > x)
  {
    this->UniqueDesignation_.set (std::move (x));
  }

  const InstallationSymbolModifiersType::DateTimeGroup_optional& InstallationSymbolModifiersType::
  DateTimeGroup () const
  {
    return this->DateTimeGroup_;
  }

  InstallationSymbolModifiersType::DateTimeGroup_optional& InstallationSymbolModifiersType::
  DateTimeGroup ()
  {
    return this->DateTimeGroup_;
  }

  void InstallationSymbolModifiersType::
  DateTimeGroup (const DateTimeGroup_type& x)
  {
    this->DateTimeGroup_.set (x);
  }

  void InstallationSymbolModifiersType::
  DateTimeGroup (const DateTimeGroup_optional& x)
  {
    this->DateTimeGroup_ = x;
  }

  void InstallationSymbolModifiersType::
  DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > x)
  {
    this->DateTimeGroup_.set (std::move (x));
  }


  // InstallationType
  // 

  const InstallationType::ObjectHandle_type& InstallationType::
  ObjectHandle () const
  {
    return this->ObjectHandle_.get ();
  }

  InstallationType::ObjectHandle_type& InstallationType::
  ObjectHandle ()
  {
    return this->ObjectHandle_.get ();
  }

  void InstallationType::
  ObjectHandle (const ObjectHandle_type& x)
  {
    this->ObjectHandle_.set (x);
  }

  void InstallationType::
  ObjectHandle (::std::unique_ptr< ObjectHandle_type > x)
  {
    this->ObjectHandle_.set (std::move (x));
  }

  const InstallationType::SymbolIdentifier_type& InstallationType::
  SymbolIdentifier () const
  {
    return this->SymbolIdentifier_.get ();
  }

  InstallationType::SymbolIdentifier_type& InstallationType::
  SymbolIdentifier ()
  {
    return this->SymbolIdentifier_.get ();
  }

  void InstallationType::
  SymbolIdentifier (const SymbolIdentifier_type& x)
  {
    this->SymbolIdentifier_.set (x);
  }

  void InstallationType::
  SymbolIdentifier (::std::unique_ptr< SymbolIdentifier_type > x)
  {
    this->SymbolIdentifier_.set (std::move (x));
  }

  const InstallationType::Affiliation_type& InstallationType::
  Affiliation () const
  {
    return this->Affiliation_.get ();
  }

  InstallationType::Affiliation_type& InstallationType::
  Affiliation ()
  {
    return this->Affiliation_.get ();
  }

  void InstallationType::
  Affiliation (const Affiliation_type& x)
  {
    this->Affiliation_.set (x);
  }

  void InstallationType::
  Affiliation (::std::unique_ptr< Affiliation_type > x)
  {
    this->Affiliation_.set (std::move (x));
  }

  const InstallationType::Owner_type& InstallationType::
  Owner () const
  {
    return this->Owner_.get ();
  }

  InstallationType::Owner_type& InstallationType::
  Owner ()
  {
    return this->Owner_.get ();
  }

  void InstallationType::
  Owner (const Owner_type& x)
  {
    this->Owner_.set (x);
  }

  void InstallationType::
  Owner (::std::unique_ptr< Owner_type > x)
  {
    this->Owner_.set (std::move (x));
  }

  const InstallationType::Location_type& InstallationType::
  Location () const
  {
    return this->Location_.get ();
  }

  InstallationType::Location_type& InstallationType::
  Location ()
  {
    return this->Location_.get ();
  }

  void InstallationType::
  Location (const Location_type& x)
  {
    this->Location_.set (x);
  }

  void InstallationType::
  Location (::std::unique_ptr< Location_type > x)
  {
    this->Location_.set (std::move (x));
  }

  const InstallationType::Orientation_optional& InstallationType::
  Orientation () const
  {
    return this->Orientation_;
  }

  InstallationType::Orientation_optional& InstallationType::
  Orientation ()
  {
    return this->Orientation_;
  }

  void InstallationType::
  Orientation (const Orientation_type& x)
  {
    this->Orientation_.set (x);
  }

  void InstallationType::
  Orientation (const Orientation_optional& x)
  {
    this->Orientation_ = x;
  }

  void InstallationType::
  Orientation (::std::unique_ptr< Orientation_type > x)
  {
    this->Orientation_.set (std::move (x));
  }

  const InstallationType::Name_optional& InstallationType::
  Name () const
  {
    return this->Name_;
  }

  InstallationType::Name_optional& InstallationType::
  Name ()
  {
    return this->Name_;
  }

  void InstallationType::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void InstallationType::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void InstallationType::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const InstallationType::InstallationSymbolModifiers_optional& InstallationType::
  InstallationSymbolModifiers () const
  {
    return this->InstallationSymbolModifiers_;
  }

  InstallationType::InstallationSymbolModifiers_optional& InstallationType::
  InstallationSymbolModifiers ()
  {
    return this->InstallationSymbolModifiers_;
  }

  void InstallationType::
  InstallationSymbolModifiers (const InstallationSymbolModifiers_type& x)
  {
    this->InstallationSymbolModifiers_.set (x);
  }

  void InstallationType::
  InstallationSymbolModifiers (const InstallationSymbolModifiers_optional& x)
  {
    this->InstallationSymbolModifiers_ = x;
  }

  void InstallationType::
  InstallationSymbolModifiers (::std::unique_ptr< InstallationSymbolModifiers_type > x)
  {
    this->InstallationSymbolModifiers_.set (std::move (x));
  }

  const InstallationType::AssociatedOverlays_optional& InstallationType::
  AssociatedOverlays () const
  {
    return this->AssociatedOverlays_;
  }

  InstallationType::AssociatedOverlays_optional& InstallationType::
  AssociatedOverlays ()
  {
    return this->AssociatedOverlays_;
  }

  void InstallationType::
  AssociatedOverlays (const AssociatedOverlays_type& x)
  {
    this->AssociatedOverlays_.set (x);
  }

  void InstallationType::
  AssociatedOverlays (const AssociatedOverlays_optional& x)
  {
    this->AssociatedOverlays_ = x;
  }

  void InstallationType::
  AssociatedOverlays (::std::unique_ptr< AssociatedOverlays_type > x)
  {
    this->AssociatedOverlays_.set (std::move (x));
  }


  // LightItemsType
  // 

  const LightItemsType::Light_sequence& LightItemsType::
  Light () const
  {
    return this->Light_;
  }

  LightItemsType::Light_sequence& LightItemsType::
  Light ()
  {
    return this->Light_;
  }

  void LightItemsType::
  Light (const Light_sequence& s)
  {
    this->Light_ = s;
  }


  // LineSymbolModifiersType
  // 

  const LineSymbolModifiersType::UniqueDesignation_optional& LineSymbolModifiersType::
  UniqueDesignation () const
  {
    return this->UniqueDesignation_;
  }

  LineSymbolModifiersType::UniqueDesignation_optional& LineSymbolModifiersType::
  UniqueDesignation ()
  {
    return this->UniqueDesignation_;
  }

  void LineSymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_type& x)
  {
    this->UniqueDesignation_.set (x);
  }

  void LineSymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_optional& x)
  {
    this->UniqueDesignation_ = x;
  }

  void LineSymbolModifiersType::
  UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > x)
  {
    this->UniqueDesignation_.set (std::move (x));
  }

  const LineSymbolModifiersType::UniqueDesignation1_optional& LineSymbolModifiersType::
  UniqueDesignation1 () const
  {
    return this->UniqueDesignation1_;
  }

  LineSymbolModifiersType::UniqueDesignation1_optional& LineSymbolModifiersType::
  UniqueDesignation1 ()
  {
    return this->UniqueDesignation1_;
  }

  void LineSymbolModifiersType::
  UniqueDesignation1 (const UniqueDesignation1_type& x)
  {
    this->UniqueDesignation1_.set (x);
  }

  void LineSymbolModifiersType::
  UniqueDesignation1 (const UniqueDesignation1_optional& x)
  {
    this->UniqueDesignation1_ = x;
  }

  void LineSymbolModifiersType::
  UniqueDesignation1 (::std::unique_ptr< UniqueDesignation1_type > x)
  {
    this->UniqueDesignation1_.set (std::move (x));
  }

  const LineSymbolModifiersType::DateTimeGroup_optional& LineSymbolModifiersType::
  DateTimeGroup () const
  {
    return this->DateTimeGroup_;
  }

  LineSymbolModifiersType::DateTimeGroup_optional& LineSymbolModifiersType::
  DateTimeGroup ()
  {
    return this->DateTimeGroup_;
  }

  void LineSymbolModifiersType::
  DateTimeGroup (const DateTimeGroup_type& x)
  {
    this->DateTimeGroup_.set (x);
  }

  void LineSymbolModifiersType::
  DateTimeGroup (const DateTimeGroup_optional& x)
  {
    this->DateTimeGroup_ = x;
  }

  void LineSymbolModifiersType::
  DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > x)
  {
    this->DateTimeGroup_.set (std::move (x));
  }

  const LineSymbolModifiersType::DateTimeGroup1_optional& LineSymbolModifiersType::
  DateTimeGroup1 () const
  {
    return this->DateTimeGroup1_;
  }

  LineSymbolModifiersType::DateTimeGroup1_optional& LineSymbolModifiersType::
  DateTimeGroup1 ()
  {
    return this->DateTimeGroup1_;
  }

  void LineSymbolModifiersType::
  DateTimeGroup1 (const DateTimeGroup1_type& x)
  {
    this->DateTimeGroup1_.set (x);
  }

  void LineSymbolModifiersType::
  DateTimeGroup1 (const DateTimeGroup1_optional& x)
  {
    this->DateTimeGroup1_ = x;
  }

  void LineSymbolModifiersType::
  DateTimeGroup1 (::std::unique_ptr< DateTimeGroup1_type > x)
  {
    this->DateTimeGroup1_.set (std::move (x));
  }


  // METOCDispositionType
  // 

  const METOCDispositionType::AnchorPoints_type& METOCDispositionType::
  AnchorPoints () const
  {
    return this->AnchorPoints_.get ();
  }

  METOCDispositionType::AnchorPoints_type& METOCDispositionType::
  AnchorPoints ()
  {
    return this->AnchorPoints_.get ();
  }

  void METOCDispositionType::
  AnchorPoints (const AnchorPoints_type& x)
  {
    this->AnchorPoints_.set (x);
  }

  void METOCDispositionType::
  AnchorPoints (::std::unique_ptr< AnchorPoints_type > x)
  {
    this->AnchorPoints_.set (std::move (x));
  }

  const METOCDispositionType::DirectionOfMovement_optional& METOCDispositionType::
  DirectionOfMovement () const
  {
    return this->DirectionOfMovement_;
  }

  METOCDispositionType::DirectionOfMovement_optional& METOCDispositionType::
  DirectionOfMovement ()
  {
    return this->DirectionOfMovement_;
  }

  void METOCDispositionType::
  DirectionOfMovement (const DirectionOfMovement_type& x)
  {
    this->DirectionOfMovement_.set (x);
  }

  void METOCDispositionType::
  DirectionOfMovement (const DirectionOfMovement_optional& x)
  {
    this->DirectionOfMovement_ = x;
  }

  void METOCDispositionType::
  DirectionOfMovement (::std::unique_ptr< DirectionOfMovement_type > x)
  {
    this->DirectionOfMovement_.set (std::move (x));
  }

  const METOCDispositionType::Speed_optional& METOCDispositionType::
  Speed () const
  {
    return this->Speed_;
  }

  METOCDispositionType::Speed_optional& METOCDispositionType::
  Speed ()
  {
    return this->Speed_;
  }

  void METOCDispositionType::
  Speed (const Speed_type& x)
  {
    this->Speed_.set (x);
  }

  void METOCDispositionType::
  Speed (const Speed_optional& x)
  {
    this->Speed_ = x;
  }

  void METOCDispositionType::
  Speed (::std::unique_ptr< Speed_type > x)
  {
    this->Speed_.set (std::move (x));
  }


  // METOCGraphicType
  // 

  const METOCGraphicType::ObjectHandle_type& METOCGraphicType::
  ObjectHandle () const
  {
    return this->ObjectHandle_.get ();
  }

  METOCGraphicType::ObjectHandle_type& METOCGraphicType::
  ObjectHandle ()
  {
    return this->ObjectHandle_.get ();
  }

  void METOCGraphicType::
  ObjectHandle (const ObjectHandle_type& x)
  {
    this->ObjectHandle_.set (x);
  }

  void METOCGraphicType::
  ObjectHandle (::std::unique_ptr< ObjectHandle_type > x)
  {
    this->ObjectHandle_.set (std::move (x));
  }

  const METOCGraphicType::SymbolIdentifier_type& METOCGraphicType::
  SymbolIdentifier () const
  {
    return this->SymbolIdentifier_.get ();
  }

  METOCGraphicType::SymbolIdentifier_type& METOCGraphicType::
  SymbolIdentifier ()
  {
    return this->SymbolIdentifier_.get ();
  }

  void METOCGraphicType::
  SymbolIdentifier (const SymbolIdentifier_type& x)
  {
    this->SymbolIdentifier_.set (x);
  }

  void METOCGraphicType::
  SymbolIdentifier (::std::unique_ptr< SymbolIdentifier_type > x)
  {
    this->SymbolIdentifier_.set (std::move (x));
  }

  const METOCGraphicType::UniqueDesignation_type& METOCGraphicType::
  UniqueDesignation () const
  {
    return this->UniqueDesignation_.get ();
  }

  METOCGraphicType::UniqueDesignation_type& METOCGraphicType::
  UniqueDesignation ()
  {
    return this->UniqueDesignation_.get ();
  }

  void METOCGraphicType::
  UniqueDesignation (const UniqueDesignation_type& x)
  {
    this->UniqueDesignation_.set (x);
  }

  void METOCGraphicType::
  UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > x)
  {
    this->UniqueDesignation_.set (std::move (x));
  }

  const METOCGraphicType::DateTimeGroup_optional& METOCGraphicType::
  DateTimeGroup () const
  {
    return this->DateTimeGroup_;
  }

  METOCGraphicType::DateTimeGroup_optional& METOCGraphicType::
  DateTimeGroup ()
  {
    return this->DateTimeGroup_;
  }

  void METOCGraphicType::
  DateTimeGroup (const DateTimeGroup_type& x)
  {
    this->DateTimeGroup_.set (x);
  }

  void METOCGraphicType::
  DateTimeGroup (const DateTimeGroup_optional& x)
  {
    this->DateTimeGroup_ = x;
  }

  void METOCGraphicType::
  DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > x)
  {
    this->DateTimeGroup_.set (std::move (x));
  }

  const METOCGraphicType::DateTimeGroup1_optional& METOCGraphicType::
  DateTimeGroup1 () const
  {
    return this->DateTimeGroup1_;
  }

  METOCGraphicType::DateTimeGroup1_optional& METOCGraphicType::
  DateTimeGroup1 ()
  {
    return this->DateTimeGroup1_;
  }

  void METOCGraphicType::
  DateTimeGroup1 (const DateTimeGroup1_type& x)
  {
    this->DateTimeGroup1_.set (x);
  }

  void METOCGraphicType::
  DateTimeGroup1 (const DateTimeGroup1_optional& x)
  {
    this->DateTimeGroup1_ = x;
  }

  void METOCGraphicType::
  DateTimeGroup1 (::std::unique_ptr< DateTimeGroup1_type > x)
  {
    this->DateTimeGroup1_.set (std::move (x));
  }

  const METOCGraphicType::Quantity_optional& METOCGraphicType::
  Quantity () const
  {
    return this->Quantity_;
  }

  METOCGraphicType::Quantity_optional& METOCGraphicType::
  Quantity ()
  {
    return this->Quantity_;
  }

  void METOCGraphicType::
  Quantity (const Quantity_type& x)
  {
    this->Quantity_.set (x);
  }

  void METOCGraphicType::
  Quantity (const Quantity_optional& x)
  {
    this->Quantity_ = x;
  }

  void METOCGraphicType::
  Quantity (::std::unique_ptr< Quantity_type > x)
  {
    this->Quantity_.set (std::move (x));
  }

  const METOCGraphicType::AdditionalInfo_optional& METOCGraphicType::
  AdditionalInfo () const
  {
    return this->AdditionalInfo_;
  }

  METOCGraphicType::AdditionalInfo_optional& METOCGraphicType::
  AdditionalInfo ()
  {
    return this->AdditionalInfo_;
  }

  void METOCGraphicType::
  AdditionalInfo (const AdditionalInfo_type& x)
  {
    this->AdditionalInfo_.set (x);
  }

  void METOCGraphicType::
  AdditionalInfo (const AdditionalInfo_optional& x)
  {
    this->AdditionalInfo_ = x;
  }

  void METOCGraphicType::
  AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > x)
  {
    this->AdditionalInfo_.set (std::move (x));
  }

  const METOCGraphicType::Disposition_type& METOCGraphicType::
  Disposition () const
  {
    return this->Disposition_.get ();
  }

  METOCGraphicType::Disposition_type& METOCGraphicType::
  Disposition ()
  {
    return this->Disposition_.get ();
  }

  void METOCGraphicType::
  Disposition (const Disposition_type& x)
  {
    this->Disposition_.set (x);
  }

  void METOCGraphicType::
  Disposition (::std::unique_ptr< Disposition_type > x)
  {
    this->Disposition_.set (std::move (x));
  }


  // METOCType
  // 

  const METOCType::METOCGraphic_sequence& METOCType::
  METOCGraphic () const
  {
    return this->METOCGraphic_;
  }

  METOCType::METOCGraphic_sequence& METOCType::
  METOCGraphic ()
  {
    return this->METOCGraphic_;
  }

  void METOCType::
  METOCGraphic (const METOCGraphic_sequence& s)
  {
    this->METOCGraphic_ = s;
  }


  // MilitaryScenarioType
  // 

  const MilitaryScenarioType::ScenarioID_type& MilitaryScenarioType::
  ScenarioID () const
  {
    return this->ScenarioID_.get ();
  }

  MilitaryScenarioType::ScenarioID_type& MilitaryScenarioType::
  ScenarioID ()
  {
    return this->ScenarioID_.get ();
  }

  void MilitaryScenarioType::
  ScenarioID (const ScenarioID_type& x)
  {
    this->ScenarioID_.set (x);
  }

  void MilitaryScenarioType::
  ScenarioID (::std::unique_ptr< ScenarioID_type > x)
  {
    this->ScenarioID_.set (std::move (x));
  }

  const MilitaryScenarioType::Options_type& MilitaryScenarioType::
  Options () const
  {
    return this->Options_.get ();
  }

  MilitaryScenarioType::Options_type& MilitaryScenarioType::
  Options ()
  {
    return this->Options_.get ();
  }

  void MilitaryScenarioType::
  Options (const Options_type& x)
  {
    this->Options_.set (x);
  }

  void MilitaryScenarioType::
  Options (::std::unique_ptr< Options_type > x)
  {
    this->Options_.set (std::move (x));
  }

  const MilitaryScenarioType::Environment_optional& MilitaryScenarioType::
  Environment () const
  {
    return this->Environment_;
  }

  MilitaryScenarioType::Environment_optional& MilitaryScenarioType::
  Environment ()
  {
    return this->Environment_;
  }

  void MilitaryScenarioType::
  Environment (const Environment_type& x)
  {
    this->Environment_.set (x);
  }

  void MilitaryScenarioType::
  Environment (const Environment_optional& x)
  {
    this->Environment_ = x;
  }

  void MilitaryScenarioType::
  Environment (::std::unique_ptr< Environment_type > x)
  {
    this->Environment_.set (std::move (x));
  }

  const MilitaryScenarioType::ForceSides_type& MilitaryScenarioType::
  ForceSides () const
  {
    return this->ForceSides_.get ();
  }

  MilitaryScenarioType::ForceSides_type& MilitaryScenarioType::
  ForceSides ()
  {
    return this->ForceSides_.get ();
  }

  void MilitaryScenarioType::
  ForceSides (const ForceSides_type& x)
  {
    this->ForceSides_.set (x);
  }

  void MilitaryScenarioType::
  ForceSides (::std::unique_ptr< ForceSides_type > x)
  {
    this->ForceSides_.set (std::move (x));
  }

  const MilitaryScenarioType::Organizations_optional& MilitaryScenarioType::
  Organizations () const
  {
    return this->Organizations_;
  }

  MilitaryScenarioType::Organizations_optional& MilitaryScenarioType::
  Organizations ()
  {
    return this->Organizations_;
  }

  void MilitaryScenarioType::
  Organizations (const Organizations_type& x)
  {
    this->Organizations_.set (x);
  }

  void MilitaryScenarioType::
  Organizations (const Organizations_optional& x)
  {
    this->Organizations_ = x;
  }

  void MilitaryScenarioType::
  Organizations (::std::unique_ptr< Organizations_type > x)
  {
    this->Organizations_.set (std::move (x));
  }

  const MilitaryScenarioType::Overlays_optional& MilitaryScenarioType::
  Overlays () const
  {
    return this->Overlays_;
  }

  MilitaryScenarioType::Overlays_optional& MilitaryScenarioType::
  Overlays ()
  {
    return this->Overlays_;
  }

  void MilitaryScenarioType::
  Overlays (const Overlays_type& x)
  {
    this->Overlays_.set (x);
  }

  void MilitaryScenarioType::
  Overlays (const Overlays_optional& x)
  {
    this->Overlays_ = x;
  }

  void MilitaryScenarioType::
  Overlays (::std::unique_ptr< Overlays_type > x)
  {
    this->Overlays_.set (std::move (x));
  }

  const MilitaryScenarioType::Installations_optional& MilitaryScenarioType::
  Installations () const
  {
    return this->Installations_;
  }

  MilitaryScenarioType::Installations_optional& MilitaryScenarioType::
  Installations ()
  {
    return this->Installations_;
  }

  void MilitaryScenarioType::
  Installations (const Installations_type& x)
  {
    this->Installations_.set (x);
  }

  void MilitaryScenarioType::
  Installations (const Installations_optional& x)
  {
    this->Installations_ = x;
  }

  void MilitaryScenarioType::
  Installations (::std::unique_ptr< Installations_type > x)
  {
    this->Installations_.set (std::move (x));
  }

  const MilitaryScenarioType::TacticalGraphics_optional& MilitaryScenarioType::
  TacticalGraphics () const
  {
    return this->TacticalGraphics_;
  }

  MilitaryScenarioType::TacticalGraphics_optional& MilitaryScenarioType::
  TacticalGraphics ()
  {
    return this->TacticalGraphics_;
  }

  void MilitaryScenarioType::
  TacticalGraphics (const TacticalGraphics_type& x)
  {
    this->TacticalGraphics_.set (x);
  }

  void MilitaryScenarioType::
  TacticalGraphics (const TacticalGraphics_optional& x)
  {
    this->TacticalGraphics_ = x;
  }

  void MilitaryScenarioType::
  TacticalGraphics (::std::unique_ptr< TacticalGraphics_type > x)
  {
    this->TacticalGraphics_.set (std::move (x));
  }

  const MilitaryScenarioType::MOOTWGraphics_optional& MilitaryScenarioType::
  MOOTWGraphics () const
  {
    return this->MOOTWGraphics_;
  }

  MilitaryScenarioType::MOOTWGraphics_optional& MilitaryScenarioType::
  MOOTWGraphics ()
  {
    return this->MOOTWGraphics_;
  }

  void MilitaryScenarioType::
  MOOTWGraphics (const MOOTWGraphics_type& x)
  {
    this->MOOTWGraphics_.set (x);
  }

  void MilitaryScenarioType::
  MOOTWGraphics (const MOOTWGraphics_optional& x)
  {
    this->MOOTWGraphics_ = x;
  }

  void MilitaryScenarioType::
  MOOTWGraphics (::std::unique_ptr< MOOTWGraphics_type > x)
  {
    this->MOOTWGraphics_.set (std::move (x));
  }


  // MGRSType
  // 

  const MGRSType::MGRSGridZone_type& MGRSType::
  MGRSGridZone () const
  {
    return this->MGRSGridZone_.get ();
  }

  MGRSType::MGRSGridZone_type& MGRSType::
  MGRSGridZone ()
  {
    return this->MGRSGridZone_.get ();
  }

  void MGRSType::
  MGRSGridZone (const MGRSGridZone_type& x)
  {
    this->MGRSGridZone_.set (x);
  }

  void MGRSType::
  MGRSGridZone (::std::unique_ptr< MGRSGridZone_type > x)
  {
    this->MGRSGridZone_.set (std::move (x));
  }

  const MGRSType::MGRSGridSquare_type& MGRSType::
  MGRSGridSquare () const
  {
    return this->MGRSGridSquare_.get ();
  }

  MGRSType::MGRSGridSquare_type& MGRSType::
  MGRSGridSquare ()
  {
    return this->MGRSGridSquare_.get ();
  }

  void MGRSType::
  MGRSGridSquare (const MGRSGridSquare_type& x)
  {
    this->MGRSGridSquare_.set (x);
  }

  void MGRSType::
  MGRSGridSquare (::std::unique_ptr< MGRSGridSquare_type > x)
  {
    this->MGRSGridSquare_.set (std::move (x));
  }

  const MGRSType::MGRSPrecision_type& MGRSType::
  MGRSPrecision () const
  {
    return this->MGRSPrecision_.get ();
  }

  MGRSType::MGRSPrecision_type& MGRSType::
  MGRSPrecision ()
  {
    return this->MGRSPrecision_.get ();
  }

  void MGRSType::
  MGRSPrecision (const MGRSPrecision_type& x)
  {
    this->MGRSPrecision_.set (x);
  }

  void MGRSType::
  MGRSPrecision (::std::unique_ptr< MGRSPrecision_type > x)
  {
    this->MGRSPrecision_.set (std::move (x));
  }

  const MGRSType::MGRSEasting_type& MGRSType::
  MGRSEasting () const
  {
    return this->MGRSEasting_.get ();
  }

  MGRSType::MGRSEasting_type& MGRSType::
  MGRSEasting ()
  {
    return this->MGRSEasting_.get ();
  }

  void MGRSType::
  MGRSEasting (const MGRSEasting_type& x)
  {
    this->MGRSEasting_.set (x);
  }

  void MGRSType::
  MGRSEasting (::std::unique_ptr< MGRSEasting_type > x)
  {
    this->MGRSEasting_.set (std::move (x));
  }

  const MGRSType::MGRSNorthing_type& MGRSType::
  MGRSNorthing () const
  {
    return this->MGRSNorthing_.get ();
  }

  MGRSType::MGRSNorthing_type& MGRSType::
  MGRSNorthing ()
  {
    return this->MGRSNorthing_.get ();
  }

  void MGRSType::
  MGRSNorthing (const MGRSNorthing_type& x)
  {
    this->MGRSNorthing_.set (x);
  }

  void MGRSType::
  MGRSNorthing (::std::unique_ptr< MGRSNorthing_type > x)
  {
    this->MGRSNorthing_.set (std::move (x));
  }

  const MGRSType::ElevationAGL_optional& MGRSType::
  ElevationAGL () const
  {
    return this->ElevationAGL_;
  }

  MGRSType::ElevationAGL_optional& MGRSType::
  ElevationAGL ()
  {
    return this->ElevationAGL_;
  }

  void MGRSType::
  ElevationAGL (const ElevationAGL_type& x)
  {
    this->ElevationAGL_.set (x);
  }

  void MGRSType::
  ElevationAGL (const ElevationAGL_optional& x)
  {
    this->ElevationAGL_ = x;
  }

  void MGRSType::
  ElevationAGL (::std::unique_ptr< ElevationAGL_type > x)
  {
    this->ElevationAGL_.set (std::move (x));
  }


  // MOOTWDispositionType
  // 

  const MOOTWDispositionType::Location_type& MOOTWDispositionType::
  Location () const
  {
    return this->Location_.get ();
  }

  MOOTWDispositionType::Location_type& MOOTWDispositionType::
  Location ()
  {
    return this->Location_.get ();
  }

  void MOOTWDispositionType::
  Location (const Location_type& x)
  {
    this->Location_.set (x);
  }

  void MOOTWDispositionType::
  Location (::std::unique_ptr< Location_type > x)
  {
    this->Location_.set (std::move (x));
  }

  const MOOTWDispositionType::DirectionOfMovement_optional& MOOTWDispositionType::
  DirectionOfMovement () const
  {
    return this->DirectionOfMovement_;
  }

  MOOTWDispositionType::DirectionOfMovement_optional& MOOTWDispositionType::
  DirectionOfMovement ()
  {
    return this->DirectionOfMovement_;
  }

  void MOOTWDispositionType::
  DirectionOfMovement (const DirectionOfMovement_type& x)
  {
    this->DirectionOfMovement_.set (x);
  }

  void MOOTWDispositionType::
  DirectionOfMovement (const DirectionOfMovement_optional& x)
  {
    this->DirectionOfMovement_ = x;
  }

  void MOOTWDispositionType::
  DirectionOfMovement (::std::unique_ptr< DirectionOfMovement_type > x)
  {
    this->DirectionOfMovement_.set (std::move (x));
  }

  const MOOTWDispositionType::Speed_optional& MOOTWDispositionType::
  Speed () const
  {
    return this->Speed_;
  }

  MOOTWDispositionType::Speed_optional& MOOTWDispositionType::
  Speed ()
  {
    return this->Speed_;
  }

  void MOOTWDispositionType::
  Speed (const Speed_type& x)
  {
    this->Speed_.set (x);
  }

  void MOOTWDispositionType::
  Speed (const Speed_optional& x)
  {
    this->Speed_ = x;
  }

  void MOOTWDispositionType::
  Speed (::std::unique_ptr< Speed_type > x)
  {
    this->Speed_.set (std::move (x));
  }


  // MOOTWGraphicsType
  // 

  const MOOTWGraphicsType::MOOTWGraphic_sequence& MOOTWGraphicsType::
  MOOTWGraphic () const
  {
    return this->MOOTWGraphic_;
  }

  MOOTWGraphicsType::MOOTWGraphic_sequence& MOOTWGraphicsType::
  MOOTWGraphic ()
  {
    return this->MOOTWGraphic_;
  }

  void MOOTWGraphicsType::
  MOOTWGraphic (const MOOTWGraphic_sequence& s)
  {
    this->MOOTWGraphic_ = s;
  }


  // MOOTWGraphicType
  // 

  const MOOTWGraphicType::ObjectHandle_type& MOOTWGraphicType::
  ObjectHandle () const
  {
    return this->ObjectHandle_.get ();
  }

  MOOTWGraphicType::ObjectHandle_type& MOOTWGraphicType::
  ObjectHandle ()
  {
    return this->ObjectHandle_.get ();
  }

  void MOOTWGraphicType::
  ObjectHandle (const ObjectHandle_type& x)
  {
    this->ObjectHandle_.set (x);
  }

  void MOOTWGraphicType::
  ObjectHandle (::std::unique_ptr< ObjectHandle_type > x)
  {
    this->ObjectHandle_.set (std::move (x));
  }

  const MOOTWGraphicType::SymbolIdentifier_type& MOOTWGraphicType::
  SymbolIdentifier () const
  {
    return this->SymbolIdentifier_.get ();
  }

  MOOTWGraphicType::SymbolIdentifier_type& MOOTWGraphicType::
  SymbolIdentifier ()
  {
    return this->SymbolIdentifier_.get ();
  }

  void MOOTWGraphicType::
  SymbolIdentifier (const SymbolIdentifier_type& x)
  {
    this->SymbolIdentifier_.set (x);
  }

  void MOOTWGraphicType::
  SymbolIdentifier (::std::unique_ptr< SymbolIdentifier_type > x)
  {
    this->SymbolIdentifier_.set (std::move (x));
  }

  const MOOTWGraphicType::Affiliation_type& MOOTWGraphicType::
  Affiliation () const
  {
    return this->Affiliation_.get ();
  }

  MOOTWGraphicType::Affiliation_type& MOOTWGraphicType::
  Affiliation ()
  {
    return this->Affiliation_.get ();
  }

  void MOOTWGraphicType::
  Affiliation (const Affiliation_type& x)
  {
    this->Affiliation_.set (x);
  }

  void MOOTWGraphicType::
  Affiliation (::std::unique_ptr< Affiliation_type > x)
  {
    this->Affiliation_.set (std::move (x));
  }

  const MOOTWGraphicType::Owner_type& MOOTWGraphicType::
  Owner () const
  {
    return this->Owner_.get ();
  }

  MOOTWGraphicType::Owner_type& MOOTWGraphicType::
  Owner ()
  {
    return this->Owner_.get ();
  }

  void MOOTWGraphicType::
  Owner (const Owner_type& x)
  {
    this->Owner_.set (x);
  }

  void MOOTWGraphicType::
  Owner (::std::unique_ptr< Owner_type > x)
  {
    this->Owner_.set (std::move (x));
  }

  const MOOTWGraphicType::MOOTWSymbolModifiers_optional& MOOTWGraphicType::
  MOOTWSymbolModifiers () const
  {
    return this->MOOTWSymbolModifiers_;
  }

  MOOTWGraphicType::MOOTWSymbolModifiers_optional& MOOTWGraphicType::
  MOOTWSymbolModifiers ()
  {
    return this->MOOTWSymbolModifiers_;
  }

  void MOOTWGraphicType::
  MOOTWSymbolModifiers (const MOOTWSymbolModifiers_type& x)
  {
    this->MOOTWSymbolModifiers_.set (x);
  }

  void MOOTWGraphicType::
  MOOTWSymbolModifiers (const MOOTWSymbolModifiers_optional& x)
  {
    this->MOOTWSymbolModifiers_ = x;
  }

  void MOOTWGraphicType::
  MOOTWSymbolModifiers (::std::unique_ptr< MOOTWSymbolModifiers_type > x)
  {
    this->MOOTWSymbolModifiers_.set (std::move (x));
  }

  const MOOTWGraphicType::AssociatedOverlays_optional& MOOTWGraphicType::
  AssociatedOverlays () const
  {
    return this->AssociatedOverlays_;
  }

  MOOTWGraphicType::AssociatedOverlays_optional& MOOTWGraphicType::
  AssociatedOverlays ()
  {
    return this->AssociatedOverlays_;
  }

  void MOOTWGraphicType::
  AssociatedOverlays (const AssociatedOverlays_type& x)
  {
    this->AssociatedOverlays_.set (x);
  }

  void MOOTWGraphicType::
  AssociatedOverlays (const AssociatedOverlays_optional& x)
  {
    this->AssociatedOverlays_ = x;
  }

  void MOOTWGraphicType::
  AssociatedOverlays (::std::unique_ptr< AssociatedOverlays_type > x)
  {
    this->AssociatedOverlays_.set (std::move (x));
  }

  const MOOTWGraphicType::Disposition_type& MOOTWGraphicType::
  Disposition () const
  {
    return this->Disposition_.get ();
  }

  MOOTWGraphicType::Disposition_type& MOOTWGraphicType::
  Disposition ()
  {
    return this->Disposition_.get ();
  }

  void MOOTWGraphicType::
  Disposition (const Disposition_type& x)
  {
    this->Disposition_.set (x);
  }

  void MOOTWGraphicType::
  Disposition (::std::unique_ptr< Disposition_type > x)
  {
    this->Disposition_.set (std::move (x));
  }


  // MOOTWSymbolModifiersType
  // 

  const MOOTWSymbolModifiersType::Echelon_optional& MOOTWSymbolModifiersType::
  Echelon () const
  {
    return this->Echelon_;
  }

  MOOTWSymbolModifiersType::Echelon_optional& MOOTWSymbolModifiersType::
  Echelon ()
  {
    return this->Echelon_;
  }

  void MOOTWSymbolModifiersType::
  Echelon (const Echelon_type& x)
  {
    this->Echelon_.set (x);
  }

  void MOOTWSymbolModifiersType::
  Echelon (const Echelon_optional& x)
  {
    this->Echelon_ = x;
  }

  void MOOTWSymbolModifiersType::
  Echelon (::std::unique_ptr< Echelon_type > x)
  {
    this->Echelon_.set (std::move (x));
  }

  const MOOTWSymbolModifiersType::ReinforcedReduced_optional& MOOTWSymbolModifiersType::
  ReinforcedReduced () const
  {
    return this->ReinforcedReduced_;
  }

  MOOTWSymbolModifiersType::ReinforcedReduced_optional& MOOTWSymbolModifiersType::
  ReinforcedReduced ()
  {
    return this->ReinforcedReduced_;
  }

  void MOOTWSymbolModifiersType::
  ReinforcedReduced (const ReinforcedReduced_type& x)
  {
    this->ReinforcedReduced_.set (x);
  }

  void MOOTWSymbolModifiersType::
  ReinforcedReduced (const ReinforcedReduced_optional& x)
  {
    this->ReinforcedReduced_ = x;
  }

  void MOOTWSymbolModifiersType::
  ReinforcedReduced (::std::unique_ptr< ReinforcedReduced_type > x)
  {
    this->ReinforcedReduced_.set (std::move (x));
  }

  const MOOTWSymbolModifiersType::FrameShapeModifier_optional& MOOTWSymbolModifiersType::
  FrameShapeModifier () const
  {
    return this->FrameShapeModifier_;
  }

  MOOTWSymbolModifiersType::FrameShapeModifier_optional& MOOTWSymbolModifiersType::
  FrameShapeModifier ()
  {
    return this->FrameShapeModifier_;
  }

  void MOOTWSymbolModifiersType::
  FrameShapeModifier (const FrameShapeModifier_type& x)
  {
    this->FrameShapeModifier_.set (x);
  }

  void MOOTWSymbolModifiersType::
  FrameShapeModifier (const FrameShapeModifier_optional& x)
  {
    this->FrameShapeModifier_ = x;
  }

  void MOOTWSymbolModifiersType::
  FrameShapeModifier (::std::unique_ptr< FrameShapeModifier_type > x)
  {
    this->FrameShapeModifier_.set (std::move (x));
  }

  const MOOTWSymbolModifiersType::StaffComments_optional& MOOTWSymbolModifiersType::
  StaffComments () const
  {
    return this->StaffComments_;
  }

  MOOTWSymbolModifiersType::StaffComments_optional& MOOTWSymbolModifiersType::
  StaffComments ()
  {
    return this->StaffComments_;
  }

  void MOOTWSymbolModifiersType::
  StaffComments (const StaffComments_type& x)
  {
    this->StaffComments_.set (x);
  }

  void MOOTWSymbolModifiersType::
  StaffComments (const StaffComments_optional& x)
  {
    this->StaffComments_ = x;
  }

  void MOOTWSymbolModifiersType::
  StaffComments (::std::unique_ptr< StaffComments_type > x)
  {
    this->StaffComments_.set (std::move (x));
  }

  const MOOTWSymbolModifiersType::AdditionalInfo_optional& MOOTWSymbolModifiersType::
  AdditionalInfo () const
  {
    return this->AdditionalInfo_;
  }

  MOOTWSymbolModifiersType::AdditionalInfo_optional& MOOTWSymbolModifiersType::
  AdditionalInfo ()
  {
    return this->AdditionalInfo_;
  }

  void MOOTWSymbolModifiersType::
  AdditionalInfo (const AdditionalInfo_type& x)
  {
    this->AdditionalInfo_.set (x);
  }

  void MOOTWSymbolModifiersType::
  AdditionalInfo (const AdditionalInfo_optional& x)
  {
    this->AdditionalInfo_ = x;
  }

  void MOOTWSymbolModifiersType::
  AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > x)
  {
    this->AdditionalInfo_.set (std::move (x));
  }

  const MOOTWSymbolModifiersType::CombatEffectiveness_optional& MOOTWSymbolModifiersType::
  CombatEffectiveness () const
  {
    return this->CombatEffectiveness_;
  }

  MOOTWSymbolModifiersType::CombatEffectiveness_optional& MOOTWSymbolModifiersType::
  CombatEffectiveness ()
  {
    return this->CombatEffectiveness_;
  }

  void MOOTWSymbolModifiersType::
  CombatEffectiveness (const CombatEffectiveness_type& x)
  {
    this->CombatEffectiveness_.set (x);
  }

  void MOOTWSymbolModifiersType::
  CombatEffectiveness (const CombatEffectiveness_optional& x)
  {
    this->CombatEffectiveness_ = x;
  }

  void MOOTWSymbolModifiersType::
  CombatEffectiveness (::std::unique_ptr< CombatEffectiveness_type > x)
  {
    this->CombatEffectiveness_.set (std::move (x));
  }

  const MOOTWSymbolModifiersType::IFF_optional& MOOTWSymbolModifiersType::
  IFF () const
  {
    return this->IFF_;
  }

  MOOTWSymbolModifiersType::IFF_optional& MOOTWSymbolModifiersType::
  IFF ()
  {
    return this->IFF_;
  }

  void MOOTWSymbolModifiersType::
  IFF (const IFF_type& x)
  {
    this->IFF_.set (x);
  }

  void MOOTWSymbolModifiersType::
  IFF (const IFF_optional& x)
  {
    this->IFF_ = x;
  }

  void MOOTWSymbolModifiersType::
  IFF (::std::unique_ptr< IFF_type > x)
  {
    this->IFF_.set (std::move (x));
  }

  const MOOTWSymbolModifiersType::UniqueDesignation_type& MOOTWSymbolModifiersType::
  UniqueDesignation () const
  {
    return this->UniqueDesignation_.get ();
  }

  MOOTWSymbolModifiersType::UniqueDesignation_type& MOOTWSymbolModifiersType::
  UniqueDesignation ()
  {
    return this->UniqueDesignation_.get ();
  }

  void MOOTWSymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_type& x)
  {
    this->UniqueDesignation_.set (x);
  }

  void MOOTWSymbolModifiersType::
  UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > x)
  {
    this->UniqueDesignation_.set (std::move (x));
  }

  const MOOTWSymbolModifiersType::DateTimeGroup_optional& MOOTWSymbolModifiersType::
  DateTimeGroup () const
  {
    return this->DateTimeGroup_;
  }

  MOOTWSymbolModifiersType::DateTimeGroup_optional& MOOTWSymbolModifiersType::
  DateTimeGroup ()
  {
    return this->DateTimeGroup_;
  }

  void MOOTWSymbolModifiersType::
  DateTimeGroup (const DateTimeGroup_type& x)
  {
    this->DateTimeGroup_.set (x);
  }

  void MOOTWSymbolModifiersType::
  DateTimeGroup (const DateTimeGroup_optional& x)
  {
    this->DateTimeGroup_ = x;
  }

  void MOOTWSymbolModifiersType::
  DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > x)
  {
    this->DateTimeGroup_.set (std::move (x));
  }

  const MOOTWSymbolModifiersType::SpecialC2HQ_optional& MOOTWSymbolModifiersType::
  SpecialC2HQ () const
  {
    return this->SpecialC2HQ_;
  }

  MOOTWSymbolModifiersType::SpecialC2HQ_optional& MOOTWSymbolModifiersType::
  SpecialC2HQ ()
  {
    return this->SpecialC2HQ_;
  }

  void MOOTWSymbolModifiersType::
  SpecialC2HQ (const SpecialC2HQ_type& x)
  {
    this->SpecialC2HQ_.set (x);
  }

  void MOOTWSymbolModifiersType::
  SpecialC2HQ (const SpecialC2HQ_optional& x)
  {
    this->SpecialC2HQ_ = x;
  }

  void MOOTWSymbolModifiersType::
  SpecialC2HQ (::std::unique_ptr< SpecialC2HQ_type > x)
  {
    this->SpecialC2HQ_.set (std::move (x));
  }


  // NBCEventSymbolModifiersType
  // 

  const NBCEventSymbolModifiersType::Quantity_optional& NBCEventSymbolModifiersType::
  Quantity () const
  {
    return this->Quantity_;
  }

  NBCEventSymbolModifiersType::Quantity_optional& NBCEventSymbolModifiersType::
  Quantity ()
  {
    return this->Quantity_;
  }

  void NBCEventSymbolModifiersType::
  Quantity (const Quantity_type& x)
  {
    this->Quantity_.set (x);
  }

  void NBCEventSymbolModifiersType::
  Quantity (const Quantity_optional& x)
  {
    this->Quantity_ = x;
  }

  void NBCEventSymbolModifiersType::
  Quantity (::std::unique_ptr< Quantity_type > x)
  {
    this->Quantity_.set (std::move (x));
  }

  const NBCEventSymbolModifiersType::AdditionalInfo_optional& NBCEventSymbolModifiersType::
  AdditionalInfo () const
  {
    return this->AdditionalInfo_;
  }

  NBCEventSymbolModifiersType::AdditionalInfo_optional& NBCEventSymbolModifiersType::
  AdditionalInfo ()
  {
    return this->AdditionalInfo_;
  }

  void NBCEventSymbolModifiersType::
  AdditionalInfo (const AdditionalInfo_type& x)
  {
    this->AdditionalInfo_.set (x);
  }

  void NBCEventSymbolModifiersType::
  AdditionalInfo (const AdditionalInfo_optional& x)
  {
    this->AdditionalInfo_ = x;
  }

  void NBCEventSymbolModifiersType::
  AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > x)
  {
    this->AdditionalInfo_.set (std::move (x));
  }

  const NBCEventSymbolModifiersType::UniqueDesignation_optional& NBCEventSymbolModifiersType::
  UniqueDesignation () const
  {
    return this->UniqueDesignation_;
  }

  NBCEventSymbolModifiersType::UniqueDesignation_optional& NBCEventSymbolModifiersType::
  UniqueDesignation ()
  {
    return this->UniqueDesignation_;
  }

  void NBCEventSymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_type& x)
  {
    this->UniqueDesignation_.set (x);
  }

  void NBCEventSymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_optional& x)
  {
    this->UniqueDesignation_ = x;
  }

  void NBCEventSymbolModifiersType::
  UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > x)
  {
    this->UniqueDesignation_.set (std::move (x));
  }

  const NBCEventSymbolModifiersType::NBCType_optional& NBCEventSymbolModifiersType::
  NBCType () const
  {
    return this->NBCType_;
  }

  NBCEventSymbolModifiersType::NBCType_optional& NBCEventSymbolModifiersType::
  NBCType ()
  {
    return this->NBCType_;
  }

  void NBCEventSymbolModifiersType::
  NBCType (const NBCType_type& x)
  {
    this->NBCType_.set (x);
  }

  void NBCEventSymbolModifiersType::
  NBCType (const NBCType_optional& x)
  {
    this->NBCType_ = x;
  }

  void NBCEventSymbolModifiersType::
  NBCType (::std::unique_ptr< NBCType_type > x)
  {
    this->NBCType_.set (std::move (x));
  }

  const NBCEventSymbolModifiersType::DateTimeGroup_optional& NBCEventSymbolModifiersType::
  DateTimeGroup () const
  {
    return this->DateTimeGroup_;
  }

  NBCEventSymbolModifiersType::DateTimeGroup_optional& NBCEventSymbolModifiersType::
  DateTimeGroup ()
  {
    return this->DateTimeGroup_;
  }

  void NBCEventSymbolModifiersType::
  DateTimeGroup (const DateTimeGroup_type& x)
  {
    this->DateTimeGroup_.set (x);
  }

  void NBCEventSymbolModifiersType::
  DateTimeGroup (const DateTimeGroup_optional& x)
  {
    this->DateTimeGroup_ = x;
  }

  void NBCEventSymbolModifiersType::
  DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > x)
  {
    this->DateTimeGroup_.set (std::move (x));
  }

  const NBCEventSymbolModifiersType::Speed_type& NBCEventSymbolModifiersType::
  Speed () const
  {
    return this->Speed_.get ();
  }

  NBCEventSymbolModifiersType::Speed_type& NBCEventSymbolModifiersType::
  Speed ()
  {
    return this->Speed_.get ();
  }

  void NBCEventSymbolModifiersType::
  Speed (const Speed_type& x)
  {
    this->Speed_.set (x);
  }

  void NBCEventSymbolModifiersType::
  Speed (::std::unique_ptr< Speed_type > x)
  {
    this->Speed_.set (std::move (x));
  }

  const NBCEventSymbolModifiersType::DirectionOfMovement_type& NBCEventSymbolModifiersType::
  DirectionOfMovement () const
  {
    return this->DirectionOfMovement_.get ();
  }

  NBCEventSymbolModifiersType::DirectionOfMovement_type& NBCEventSymbolModifiersType::
  DirectionOfMovement ()
  {
    return this->DirectionOfMovement_.get ();
  }

  void NBCEventSymbolModifiersType::
  DirectionOfMovement (const DirectionOfMovement_type& x)
  {
    this->DirectionOfMovement_.set (x);
  }

  void NBCEventSymbolModifiersType::
  DirectionOfMovement (::std::unique_ptr< DirectionOfMovement_type > x)
  {
    this->DirectionOfMovement_.set (std::move (x));
  }


  // OptionsType
  // 

  const OptionsType::MSDLVersion_type& OptionsType::
  MSDLVersion () const
  {
    return this->MSDLVersion_.get ();
  }

  OptionsType::MSDLVersion_type& OptionsType::
  MSDLVersion ()
  {
    return this->MSDLVersion_.get ();
  }

  void OptionsType::
  MSDLVersion (const MSDLVersion_type& x)
  {
    this->MSDLVersion_.set (x);
  }

  void OptionsType::
  MSDLVersion (::std::unique_ptr< MSDLVersion_type > x)
  {
    this->MSDLVersion_.set (std::move (x));
  }

  const OptionsType::OrganizationDetail_optional& OptionsType::
  OrganizationDetail () const
  {
    return this->OrganizationDetail_;
  }

  OptionsType::OrganizationDetail_optional& OptionsType::
  OrganizationDetail ()
  {
    return this->OrganizationDetail_;
  }

  void OptionsType::
  OrganizationDetail (const OrganizationDetail_type& x)
  {
    this->OrganizationDetail_.set (x);
  }

  void OptionsType::
  OrganizationDetail (const OrganizationDetail_optional& x)
  {
    this->OrganizationDetail_ = x;
  }

  void OptionsType::
  OrganizationDetail (::std::unique_ptr< OrganizationDetail_type > x)
  {
    this->OrganizationDetail_.set (std::move (x));
  }

  const OptionsType::ScenarioDataStandards_optional& OptionsType::
  ScenarioDataStandards () const
  {
    return this->ScenarioDataStandards_;
  }

  OptionsType::ScenarioDataStandards_optional& OptionsType::
  ScenarioDataStandards ()
  {
    return this->ScenarioDataStandards_;
  }

  void OptionsType::
  ScenarioDataStandards (const ScenarioDataStandards_type& x)
  {
    this->ScenarioDataStandards_.set (x);
  }

  void OptionsType::
  ScenarioDataStandards (const ScenarioDataStandards_optional& x)
  {
    this->ScenarioDataStandards_ = x;
  }

  void OptionsType::
  ScenarioDataStandards (::std::unique_ptr< ScenarioDataStandards_type > x)
  {
    this->ScenarioDataStandards_.set (std::move (x));
  }


  // OrganicRelationDataType
  // 

  const OrganicRelationDataType::OrganicForceSideHandle_optional& OrganicRelationDataType::
  OrganicForceSideHandle () const
  {
    return this->OrganicForceSideHandle_;
  }

  OrganicRelationDataType::OrganicForceSideHandle_optional& OrganicRelationDataType::
  OrganicForceSideHandle ()
  {
    return this->OrganicForceSideHandle_;
  }

  void OrganicRelationDataType::
  OrganicForceSideHandle (const OrganicForceSideHandle_type& x)
  {
    this->OrganicForceSideHandle_.set (x);
  }

  void OrganicRelationDataType::
  OrganicForceSideHandle (const OrganicForceSideHandle_optional& x)
  {
    this->OrganicForceSideHandle_ = x;
  }

  void OrganicRelationDataType::
  OrganicForceSideHandle (::std::unique_ptr< OrganicForceSideHandle_type > x)
  {
    this->OrganicForceSideHandle_.set (std::move (x));
  }

  const OrganicRelationDataType::OrganicSuperiorHandle_optional& OrganicRelationDataType::
  OrganicSuperiorHandle () const
  {
    return this->OrganicSuperiorHandle_;
  }

  OrganicRelationDataType::OrganicSuperiorHandle_optional& OrganicRelationDataType::
  OrganicSuperiorHandle ()
  {
    return this->OrganicSuperiorHandle_;
  }

  void OrganicRelationDataType::
  OrganicSuperiorHandle (const OrganicSuperiorHandle_type& x)
  {
    this->OrganicSuperiorHandle_.set (x);
  }

  void OrganicRelationDataType::
  OrganicSuperiorHandle (const OrganicSuperiorHandle_optional& x)
  {
    this->OrganicSuperiorHandle_ = x;
  }

  void OrganicRelationDataType::
  OrganicSuperiorHandle (::std::unique_ptr< OrganicSuperiorHandle_type > x)
  {
    this->OrganicSuperiorHandle_.set (std::move (x));
  }


  // OrganicRelationType
  // 

  const OrganicRelationType::OrganicRelationData_type& OrganicRelationType::
  OrganicRelationData () const
  {
    return this->OrganicRelationData_.get ();
  }

  OrganicRelationType::OrganicRelationData_type& OrganicRelationType::
  OrganicRelationData ()
  {
    return this->OrganicRelationData_.get ();
  }

  void OrganicRelationType::
  OrganicRelationData (const OrganicRelationData_type& x)
  {
    this->OrganicRelationData_.set (x);
  }

  void OrganicRelationType::
  OrganicRelationData (::std::unique_ptr< OrganicRelationData_type > x)
  {
    this->OrganicRelationData_.set (std::move (x));
  }

  const OrganicRelationType::OrganicRelationChoice_type& OrganicRelationType::
  OrganicRelationChoice () const
  {
    return this->OrganicRelationChoice_.get ();
  }

  OrganicRelationType::OrganicRelationChoice_type& OrganicRelationType::
  OrganicRelationChoice ()
  {
    return this->OrganicRelationChoice_.get ();
  }

  void OrganicRelationType::
  OrganicRelationChoice (const OrganicRelationChoice_type& x)
  {
    this->OrganicRelationChoice_.set (x);
  }

  void OrganicRelationType::
  OrganicRelationChoice (::std::unique_ptr< OrganicRelationChoice_type > x)
  {
    this->OrganicRelationChoice_.set (std::move (x));
  }


  // OrganizationDetailType
  // 

  const OrganizationDetailType::AggregateBased_type& OrganizationDetailType::
  AggregateBased () const
  {
    return this->AggregateBased_.get ();
  }

  OrganizationDetailType::AggregateBased_type& OrganizationDetailType::
  AggregateBased ()
  {
    return this->AggregateBased_.get ();
  }

  void OrganizationDetailType::
  AggregateBased (const AggregateBased_type& x)
  {
    this->AggregateBased_.set (x);
  }

  void OrganizationDetailType::
  AggregateBased (::std::unique_ptr< AggregateBased_type > x)
  {
    this->AggregateBased_.set (std::move (x));
  }

  const OrganizationDetailType::AggregateEchelon_optional& OrganizationDetailType::
  AggregateEchelon () const
  {
    return this->AggregateEchelon_;
  }

  OrganizationDetailType::AggregateEchelon_optional& OrganizationDetailType::
  AggregateEchelon ()
  {
    return this->AggregateEchelon_;
  }

  void OrganizationDetailType::
  AggregateEchelon (const AggregateEchelon_type& x)
  {
    this->AggregateEchelon_.set (x);
  }

  void OrganizationDetailType::
  AggregateEchelon (const AggregateEchelon_optional& x)
  {
    this->AggregateEchelon_ = x;
  }

  void OrganizationDetailType::
  AggregateEchelon (::std::unique_ptr< AggregateEchelon_type > x)
  {
    this->AggregateEchelon_.set (std::move (x));
  }


  // OrganizationsType
  // 

  const OrganizationsType::Units_type& OrganizationsType::
  Units () const
  {
    return this->Units_.get ();
  }

  OrganizationsType::Units_type& OrganizationsType::
  Units ()
  {
    return this->Units_.get ();
  }

  void OrganizationsType::
  Units (const Units_type& x)
  {
    this->Units_.set (x);
  }

  void OrganizationsType::
  Units (::std::unique_ptr< Units_type > x)
  {
    this->Units_.set (std::move (x));
  }

  const OrganizationsType::Equipment_optional& OrganizationsType::
  Equipment () const
  {
    return this->Equipment_;
  }

  OrganizationsType::Equipment_optional& OrganizationsType::
  Equipment ()
  {
    return this->Equipment_;
  }

  void OrganizationsType::
  Equipment (const Equipment_type& x)
  {
    this->Equipment_.set (x);
  }

  void OrganizationsType::
  Equipment (const Equipment_optional& x)
  {
    this->Equipment_ = x;
  }

  void OrganizationsType::
  Equipment (::std::unique_ptr< Equipment_type > x)
  {
    this->Equipment_.set (std::move (x));
  }


  // OverlayHandlesType
  // 

  const OverlayHandlesType::OverlayHandle_sequence& OverlayHandlesType::
  OverlayHandle () const
  {
    return this->OverlayHandle_;
  }

  OverlayHandlesType::OverlayHandle_sequence& OverlayHandlesType::
  OverlayHandle ()
  {
    return this->OverlayHandle_;
  }

  void OverlayHandlesType::
  OverlayHandle (const OverlayHandle_sequence& s)
  {
    this->OverlayHandle_ = s;
  }


  // OverlaysType
  // 

  const OverlaysType::Overlay_sequence& OverlaysType::
  Overlay () const
  {
    return this->Overlay_;
  }

  OverlaysType::Overlay_sequence& OverlaysType::
  Overlay ()
  {
    return this->Overlay_;
  }

  void OverlaysType::
  Overlay (const Overlay_sequence& s)
  {
    this->Overlay_ = s;
  }


  // OverlayType
  // 

  const OverlayType::ObjectHandle_type& OverlayType::
  ObjectHandle () const
  {
    return this->ObjectHandle_.get ();
  }

  OverlayType::ObjectHandle_type& OverlayType::
  ObjectHandle ()
  {
    return this->ObjectHandle_.get ();
  }

  void OverlayType::
  ObjectHandle (const ObjectHandle_type& x)
  {
    this->ObjectHandle_.set (x);
  }

  void OverlayType::
  ObjectHandle (::std::unique_ptr< ObjectHandle_type > x)
  {
    this->ObjectHandle_.set (std::move (x));
  }

  const OverlayType::OverlayType1_type& OverlayType::
  OverlayType1 () const
  {
    return this->OverlayType1_.get ();
  }

  OverlayType::OverlayType1_type& OverlayType::
  OverlayType1 ()
  {
    return this->OverlayType1_.get ();
  }

  void OverlayType::
  OverlayType1 (const OverlayType1_type& x)
  {
    this->OverlayType1_.set (x);
  }

  void OverlayType::
  OverlayType1 (::std::unique_ptr< OverlayType1_type > x)
  {
    this->OverlayType1_.set (std::move (x));
  }

  const OverlayType::OverlayName_type& OverlayType::
  OverlayName () const
  {
    return this->OverlayName_.get ();
  }

  OverlayType::OverlayName_type& OverlayType::
  OverlayName ()
  {
    return this->OverlayName_.get ();
  }

  void OverlayType::
  OverlayName (const OverlayName_type& x)
  {
    this->OverlayName_.set (x);
  }

  void OverlayType::
  OverlayName (::std::unique_ptr< OverlayName_type > x)
  {
    this->OverlayName_.set (std::move (x));
  }


  // OwnerType
  // 

  const OwnerType::OwnerChoice_type& OwnerType::
  OwnerChoice () const
  {
    return this->OwnerChoice_.get ();
  }

  OwnerType::OwnerChoice_type& OwnerType::
  OwnerChoice ()
  {
    return this->OwnerChoice_.get ();
  }

  void OwnerType::
  OwnerChoice (const OwnerChoice_type& x)
  {
    this->OwnerChoice_.set (x);
  }

  void OwnerType::
  OwnerChoice (::std::unique_ptr< OwnerChoice_type > x)
  {
    this->OwnerChoice_.set (std::move (x));
  }

  const OwnerType::OwnerData_type& OwnerType::
  OwnerData () const
  {
    return this->OwnerData_.get ();
  }

  OwnerType::OwnerData_type& OwnerType::
  OwnerData ()
  {
    return this->OwnerData_.get ();
  }

  void OwnerType::
  OwnerData (const OwnerData_type& x)
  {
    this->OwnerData_.set (x);
  }

  void OwnerType::
  OwnerData (::std::unique_ptr< OwnerData_type > x)
  {
    this->OwnerData_.set (std::move (x));
  }


  // OwnerDataType
  // 

  const OwnerDataType::UnitOwnerHandle_optional& OwnerDataType::
  UnitOwnerHandle () const
  {
    return this->UnitOwnerHandle_;
  }

  OwnerDataType::UnitOwnerHandle_optional& OwnerDataType::
  UnitOwnerHandle ()
  {
    return this->UnitOwnerHandle_;
  }

  void OwnerDataType::
  UnitOwnerHandle (const UnitOwnerHandle_type& x)
  {
    this->UnitOwnerHandle_.set (x);
  }

  void OwnerDataType::
  UnitOwnerHandle (const UnitOwnerHandle_optional& x)
  {
    this->UnitOwnerHandle_ = x;
  }

  void OwnerDataType::
  UnitOwnerHandle (::std::unique_ptr< UnitOwnerHandle_type > x)
  {
    this->UnitOwnerHandle_.set (std::move (x));
  }

  const OwnerDataType::ForceOwnerHandle_optional& OwnerDataType::
  ForceOwnerHandle () const
  {
    return this->ForceOwnerHandle_;
  }

  OwnerDataType::ForceOwnerHandle_optional& OwnerDataType::
  ForceOwnerHandle ()
  {
    return this->ForceOwnerHandle_;
  }

  void OwnerDataType::
  ForceOwnerHandle (const ForceOwnerHandle_type& x)
  {
    this->ForceOwnerHandle_.set (x);
  }

  void OwnerDataType::
  ForceOwnerHandle (const ForceOwnerHandle_optional& x)
  {
    this->ForceOwnerHandle_ = x;
  }

  void OwnerDataType::
  ForceOwnerHandle (::std::unique_ptr< ForceOwnerHandle_type > x)
  {
    this->ForceOwnerHandle_.set (std::move (x));
  }


  // OwnFormationType
  // 

  const OwnFormationType::FormationLocationType_type& OwnFormationType::
  FormationLocationType () const
  {
    return this->FormationLocationType_.get ();
  }

  OwnFormationType::FormationLocationType_type& OwnFormationType::
  FormationLocationType ()
  {
    return this->FormationLocationType_.get ();
  }

  void OwnFormationType::
  FormationLocationType (const FormationLocationType_type& x)
  {
    this->FormationLocationType_.set (x);
  }

  void OwnFormationType::
  FormationLocationType (::std::unique_ptr< FormationLocationType_type > x)
  {
    this->FormationLocationType_.set (std::move (x));
  }

  const OwnFormationType::FormationSpacing_optional& OwnFormationType::
  FormationSpacing () const
  {
    return this->FormationSpacing_;
  }

  OwnFormationType::FormationSpacing_optional& OwnFormationType::
  FormationSpacing ()
  {
    return this->FormationSpacing_;
  }

  void OwnFormationType::
  FormationSpacing (const FormationSpacing_type& x)
  {
    this->FormationSpacing_.set (x);
  }

  void OwnFormationType::
  FormationSpacing (const FormationSpacing_optional& x)
  {
    this->FormationSpacing_ = x;
  }

  void OwnFormationType::
  FormationSpacing (::std::unique_ptr< FormationSpacing_type > x)
  {
    this->FormationSpacing_.set (std::move (x));
  }

  const OwnFormationType::FormationOrientation_optional& OwnFormationType::
  FormationOrientation () const
  {
    return this->FormationOrientation_;
  }

  OwnFormationType::FormationOrientation_optional& OwnFormationType::
  FormationOrientation ()
  {
    return this->FormationOrientation_;
  }

  void OwnFormationType::
  FormationOrientation (const FormationOrientation_type& x)
  {
    this->FormationOrientation_.set (x);
  }

  void OwnFormationType::
  FormationOrientation (const FormationOrientation_optional& x)
  {
    this->FormationOrientation_ = x;
  }

  void OwnFormationType::
  FormationOrientation (::std::unique_ptr< FormationOrientation_type > x)
  {
    this->FormationOrientation_.set (std::move (x));
  }

  const OwnFormationType::FormationChoice_type& OwnFormationType::
  FormationChoice () const
  {
    return this->FormationChoice_.get ();
  }

  OwnFormationType::FormationChoice_type& OwnFormationType::
  FormationChoice ()
  {
    return this->FormationChoice_.get ();
  }

  void OwnFormationType::
  FormationChoice (const FormationChoice_type& x)
  {
    this->FormationChoice_.set (x);
  }

  void OwnFormationType::
  FormationChoice (::std::unique_ptr< FormationChoice_type > x)
  {
    this->FormationChoice_.set (std::move (x));
  }

  const OwnFormationType::FormationData_type& OwnFormationType::
  FormationData () const
  {
    return this->FormationData_.get ();
  }

  OwnFormationType::FormationData_type& OwnFormationType::
  FormationData ()
  {
    return this->FormationData_.get ();
  }

  void OwnFormationType::
  FormationData (const FormationData_type& x)
  {
    this->FormationData_.set (x);
  }

  void OwnFormationType::
  FormationData (::std::unique_ptr< FormationData_type > x)
  {
    this->FormationData_.set (std::move (x));
  }


  // PointSymbolModifiersType
  // 

  const PointSymbolModifiersType::AdditionalInfo_optional& PointSymbolModifiersType::
  AdditionalInfo () const
  {
    return this->AdditionalInfo_;
  }

  PointSymbolModifiersType::AdditionalInfo_optional& PointSymbolModifiersType::
  AdditionalInfo ()
  {
    return this->AdditionalInfo_;
  }

  void PointSymbolModifiersType::
  AdditionalInfo (const AdditionalInfo_type& x)
  {
    this->AdditionalInfo_.set (x);
  }

  void PointSymbolModifiersType::
  AdditionalInfo (const AdditionalInfo_optional& x)
  {
    this->AdditionalInfo_ = x;
  }

  void PointSymbolModifiersType::
  AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > x)
  {
    this->AdditionalInfo_.set (std::move (x));
  }

  const PointSymbolModifiersType::AdditionalInfo1_optional& PointSymbolModifiersType::
  AdditionalInfo1 () const
  {
    return this->AdditionalInfo1_;
  }

  PointSymbolModifiersType::AdditionalInfo1_optional& PointSymbolModifiersType::
  AdditionalInfo1 ()
  {
    return this->AdditionalInfo1_;
  }

  void PointSymbolModifiersType::
  AdditionalInfo1 (const AdditionalInfo1_type& x)
  {
    this->AdditionalInfo1_.set (x);
  }

  void PointSymbolModifiersType::
  AdditionalInfo1 (const AdditionalInfo1_optional& x)
  {
    this->AdditionalInfo1_ = x;
  }

  void PointSymbolModifiersType::
  AdditionalInfo1 (::std::unique_ptr< AdditionalInfo1_type > x)
  {
    this->AdditionalInfo1_.set (std::move (x));
  }

  const PointSymbolModifiersType::UniqueDesignation_type& PointSymbolModifiersType::
  UniqueDesignation () const
  {
    return this->UniqueDesignation_.get ();
  }

  PointSymbolModifiersType::UniqueDesignation_type& PointSymbolModifiersType::
  UniqueDesignation ()
  {
    return this->UniqueDesignation_.get ();
  }

  void PointSymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_type& x)
  {
    this->UniqueDesignation_.set (x);
  }

  void PointSymbolModifiersType::
  UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > x)
  {
    this->UniqueDesignation_.set (std::move (x));
  }

  const PointSymbolModifiersType::DateTimeGroup_optional& PointSymbolModifiersType::
  DateTimeGroup () const
  {
    return this->DateTimeGroup_;
  }

  PointSymbolModifiersType::DateTimeGroup_optional& PointSymbolModifiersType::
  DateTimeGroup ()
  {
    return this->DateTimeGroup_;
  }

  void PointSymbolModifiersType::
  DateTimeGroup (const DateTimeGroup_type& x)
  {
    this->DateTimeGroup_.set (x);
  }

  void PointSymbolModifiersType::
  DateTimeGroup (const DateTimeGroup_optional& x)
  {
    this->DateTimeGroup_ = x;
  }

  void PointSymbolModifiersType::
  DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > x)
  {
    this->DateTimeGroup_.set (std::move (x));
  }

  const PointSymbolModifiersType::DateTimeGroup1_optional& PointSymbolModifiersType::
  DateTimeGroup1 () const
  {
    return this->DateTimeGroup1_;
  }

  PointSymbolModifiersType::DateTimeGroup1_optional& PointSymbolModifiersType::
  DateTimeGroup1 ()
  {
    return this->DateTimeGroup1_;
  }

  void PointSymbolModifiersType::
  DateTimeGroup1 (const DateTimeGroup1_type& x)
  {
    this->DateTimeGroup1_.set (x);
  }

  void PointSymbolModifiersType::
  DateTimeGroup1 (const DateTimeGroup1_optional& x)
  {
    this->DateTimeGroup1_ = x;
  }

  void PointSymbolModifiersType::
  DateTimeGroup1 (::std::unique_ptr< DateTimeGroup1_type > x)
  {
    this->DateTimeGroup1_.set (std::move (x));
  }

  const PointSymbolModifiersType::Orientation_optional& PointSymbolModifiersType::
  Orientation () const
  {
    return this->Orientation_;
  }

  PointSymbolModifiersType::Orientation_optional& PointSymbolModifiersType::
  Orientation ()
  {
    return this->Orientation_;
  }

  void PointSymbolModifiersType::
  Orientation (const Orientation_type& x)
  {
    this->Orientation_.set (x);
  }

  void PointSymbolModifiersType::
  Orientation (const Orientation_optional& x)
  {
    this->Orientation_ = x;
  }

  void PointSymbolModifiersType::
  Orientation (::std::unique_ptr< Orientation_type > x)
  {
    this->Orientation_.set (std::move (x));
  }


  // RectangleAreaType
  // 

  const RectangleAreaType::Name_optional& RectangleAreaType::
  Name () const
  {
    return this->Name_;
  }

  RectangleAreaType::Name_optional& RectangleAreaType::
  Name ()
  {
    return this->Name_;
  }

  void RectangleAreaType::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void RectangleAreaType::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void RectangleAreaType::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const RectangleAreaType::UpperRight_type& RectangleAreaType::
  UpperRight () const
  {
    return this->UpperRight_.get ();
  }

  RectangleAreaType::UpperRight_type& RectangleAreaType::
  UpperRight ()
  {
    return this->UpperRight_.get ();
  }

  void RectangleAreaType::
  UpperRight (const UpperRight_type& x)
  {
    this->UpperRight_.set (x);
  }

  void RectangleAreaType::
  UpperRight (::std::unique_ptr< UpperRight_type > x)
  {
    this->UpperRight_.set (std::move (x));
  }

  const RectangleAreaType::LowerLeft_type& RectangleAreaType::
  LowerLeft () const
  {
    return this->LowerLeft_.get ();
  }

  RectangleAreaType::LowerLeft_type& RectangleAreaType::
  LowerLeft ()
  {
    return this->LowerLeft_.get ();
  }

  void RectangleAreaType::
  LowerLeft (const LowerLeft_type& x)
  {
    this->LowerLeft_.set (x);
  }

  void RectangleAreaType::
  LowerLeft (::std::unique_ptr< LowerLeft_type > x)
  {
    this->LowerLeft_.set (std::move (x));
  }


  // ScenarioDataStandardsType
  // 

  const ScenarioDataStandardsType::SymbologyDataStandard_type& ScenarioDataStandardsType::
  SymbologyDataStandard () const
  {
    return this->SymbologyDataStandard_.get ();
  }

  ScenarioDataStandardsType::SymbologyDataStandard_type& ScenarioDataStandardsType::
  SymbologyDataStandard ()
  {
    return this->SymbologyDataStandard_.get ();
  }

  void ScenarioDataStandardsType::
  SymbologyDataStandard (const SymbologyDataStandard_type& x)
  {
    this->SymbologyDataStandard_.set (x);
  }

  void ScenarioDataStandardsType::
  SymbologyDataStandard (::std::unique_ptr< SymbologyDataStandard_type > x)
  {
    this->SymbologyDataStandard_.set (std::move (x));
  }

  const ScenarioDataStandardsType::CoordinateDataStandard_type& ScenarioDataStandardsType::
  CoordinateDataStandard () const
  {
    return this->CoordinateDataStandard_.get ();
  }

  ScenarioDataStandardsType::CoordinateDataStandard_type& ScenarioDataStandardsType::
  CoordinateDataStandard ()
  {
    return this->CoordinateDataStandard_.get ();
  }

  void ScenarioDataStandardsType::
  CoordinateDataStandard (const CoordinateDataStandard_type& x)
  {
    this->CoordinateDataStandard_.set (x);
  }

  void ScenarioDataStandardsType::
  CoordinateDataStandard (::std::unique_ptr< CoordinateDataStandard_type > x)
  {
    this->CoordinateDataStandard_.set (std::move (x));
  }


  // ScenarioWeatherType
  // 

  const ScenarioWeatherType::Atmosphere_optional& ScenarioWeatherType::
  Atmosphere () const
  {
    return this->Atmosphere_;
  }

  ScenarioWeatherType::Atmosphere_optional& ScenarioWeatherType::
  Atmosphere ()
  {
    return this->Atmosphere_;
  }

  void ScenarioWeatherType::
  Atmosphere (const Atmosphere_type& x)
  {
    this->Atmosphere_.set (x);
  }

  void ScenarioWeatherType::
  Atmosphere (const Atmosphere_optional& x)
  {
    this->Atmosphere_ = x;
  }

  void ScenarioWeatherType::
  Atmosphere (::std::unique_ptr< Atmosphere_type > x)
  {
    this->Atmosphere_.set (std::move (x));
  }

  const ScenarioWeatherType::CloudCoverItems_optional& ScenarioWeatherType::
  CloudCoverItems () const
  {
    return this->CloudCoverItems_;
  }

  ScenarioWeatherType::CloudCoverItems_optional& ScenarioWeatherType::
  CloudCoverItems ()
  {
    return this->CloudCoverItems_;
  }

  void ScenarioWeatherType::
  CloudCoverItems (const CloudCoverItems_type& x)
  {
    this->CloudCoverItems_.set (x);
  }

  void ScenarioWeatherType::
  CloudCoverItems (const CloudCoverItems_optional& x)
  {
    this->CloudCoverItems_ = x;
  }

  void ScenarioWeatherType::
  CloudCoverItems (::std::unique_ptr< CloudCoverItems_type > x)
  {
    this->CloudCoverItems_.set (std::move (x));
  }

  const ScenarioWeatherType::Icing_optional& ScenarioWeatherType::
  Icing () const
  {
    return this->Icing_;
  }

  ScenarioWeatherType::Icing_optional& ScenarioWeatherType::
  Icing ()
  {
    return this->Icing_;
  }

  void ScenarioWeatherType::
  Icing (const Icing_type& x)
  {
    this->Icing_.set (x);
  }

  void ScenarioWeatherType::
  Icing (const Icing_optional& x)
  {
    this->Icing_ = x;
  }

  void ScenarioWeatherType::
  Icing (::std::unique_ptr< Icing_type > x)
  {
    this->Icing_.set (std::move (x));
  }

  const ScenarioWeatherType::LightItems_optional& ScenarioWeatherType::
  LightItems () const
  {
    return this->LightItems_;
  }

  ScenarioWeatherType::LightItems_optional& ScenarioWeatherType::
  LightItems ()
  {
    return this->LightItems_;
  }

  void ScenarioWeatherType::
  LightItems (const LightItems_type& x)
  {
    this->LightItems_.set (x);
  }

  void ScenarioWeatherType::
  LightItems (const LightItems_optional& x)
  {
    this->LightItems_ = x;
  }

  void ScenarioWeatherType::
  LightItems (::std::unique_ptr< LightItems_type > x)
  {
    this->LightItems_.set (std::move (x));
  }

  const ScenarioWeatherType::Precipitation_optional& ScenarioWeatherType::
  Precipitation () const
  {
    return this->Precipitation_;
  }

  ScenarioWeatherType::Precipitation_optional& ScenarioWeatherType::
  Precipitation ()
  {
    return this->Precipitation_;
  }

  void ScenarioWeatherType::
  Precipitation (const Precipitation_type& x)
  {
    this->Precipitation_.set (x);
  }

  void ScenarioWeatherType::
  Precipitation (const Precipitation_optional& x)
  {
    this->Precipitation_ = x;
  }

  void ScenarioWeatherType::
  Precipitation (::std::unique_ptr< Precipitation_type > x)
  {
    this->Precipitation_.set (std::move (x));
  }

  const ScenarioWeatherType::VisibilityItems_optional& ScenarioWeatherType::
  VisibilityItems () const
  {
    return this->VisibilityItems_;
  }

  ScenarioWeatherType::VisibilityItems_optional& ScenarioWeatherType::
  VisibilityItems ()
  {
    return this->VisibilityItems_;
  }

  void ScenarioWeatherType::
  VisibilityItems (const VisibilityItems_type& x)
  {
    this->VisibilityItems_.set (x);
  }

  void ScenarioWeatherType::
  VisibilityItems (const VisibilityItems_optional& x)
  {
    this->VisibilityItems_ = x;
  }

  void ScenarioWeatherType::
  VisibilityItems (::std::unique_ptr< VisibilityItems_type > x)
  {
    this->VisibilityItems_.set (std::move (x));
  }

  const ScenarioWeatherType::WindItems_optional& ScenarioWeatherType::
  WindItems () const
  {
    return this->WindItems_;
  }

  ScenarioWeatherType::WindItems_optional& ScenarioWeatherType::
  WindItems ()
  {
    return this->WindItems_;
  }

  void ScenarioWeatherType::
  WindItems (const WindItems_type& x)
  {
    this->WindItems_.set (x);
  }

  void ScenarioWeatherType::
  WindItems (const WindItems_optional& x)
  {
    this->WindItems_ = x;
  }

  void ScenarioWeatherType::
  WindItems (::std::unique_ptr< WindItems_type > x)
  {
    this->WindItems_.set (std::move (x));
  }


  // StatusType
  // 

  const StatusType::MOPPLevel_optional& StatusType::
  MOPPLevel () const
  {
    return this->MOPPLevel_;
  }

  StatusType::MOPPLevel_optional& StatusType::
  MOPPLevel ()
  {
    return this->MOPPLevel_;
  }

  void StatusType::
  MOPPLevel (const MOPPLevel_type& x)
  {
    this->MOPPLevel_.set (x);
  }

  void StatusType::
  MOPPLevel (const MOPPLevel_optional& x)
  {
    this->MOPPLevel_ = x;
  }

  void StatusType::
  MOPPLevel (::std::unique_ptr< MOPPLevel_type > x)
  {
    this->MOPPLevel_.set (std::move (x));
  }

  const StatusType::WeaponControlStatus_optional& StatusType::
  WeaponControlStatus () const
  {
    return this->WeaponControlStatus_;
  }

  StatusType::WeaponControlStatus_optional& StatusType::
  WeaponControlStatus ()
  {
    return this->WeaponControlStatus_;
  }

  void StatusType::
  WeaponControlStatus (const WeaponControlStatus_type& x)
  {
    this->WeaponControlStatus_.set (x);
  }

  void StatusType::
  WeaponControlStatus (const WeaponControlStatus_optional& x)
  {
    this->WeaponControlStatus_ = x;
  }

  void StatusType::
  WeaponControlStatus (::std::unique_ptr< WeaponControlStatus_type > x)
  {
    this->WeaponControlStatus_.set (std::move (x));
  }


  // SupportRelationsType
  // 

  const SupportRelationsType::SupportRelation_sequence& SupportRelationsType::
  SupportRelation () const
  {
    return this->SupportRelation_;
  }

  SupportRelationsType::SupportRelation_sequence& SupportRelationsType::
  SupportRelation ()
  {
    return this->SupportRelation_;
  }

  void SupportRelationsType::
  SupportRelation (const SupportRelation_sequence& s)
  {
    this->SupportRelation_ = s;
  }


  // SupportRelationType
  // 

  const SupportRelationType::SupportedUnitHandle_type& SupportRelationType::
  SupportedUnitHandle () const
  {
    return this->SupportedUnitHandle_.get ();
  }

  SupportRelationType::SupportedUnitHandle_type& SupportRelationType::
  SupportedUnitHandle ()
  {
    return this->SupportedUnitHandle_.get ();
  }

  void SupportRelationType::
  SupportedUnitHandle (const SupportedUnitHandle_type& x)
  {
    this->SupportedUnitHandle_.set (x);
  }

  void SupportRelationType::
  SupportedUnitHandle (::std::unique_ptr< SupportedUnitHandle_type > x)
  {
    this->SupportedUnitHandle_.set (std::move (x));
  }

  const SupportRelationType::PriorityToSupport_optional& SupportRelationType::
  PriorityToSupport () const
  {
    return this->PriorityToSupport_;
  }

  SupportRelationType::PriorityToSupport_optional& SupportRelationType::
  PriorityToSupport ()
  {
    return this->PriorityToSupport_;
  }

  void SupportRelationType::
  PriorityToSupport (const PriorityToSupport_type& x)
  {
    this->PriorityToSupport_.set (x);
  }

  void SupportRelationType::
  PriorityToSupport (const PriorityToSupport_optional& x)
  {
    this->PriorityToSupport_ = x;
  }

  void SupportRelationType::
  PriorityToSupport (::std::unique_ptr< PriorityToSupport_type > x)
  {
    this->PriorityToSupport_.set (std::move (x));
  }

  const SupportRelationType::SupportType_type& SupportRelationType::
  SupportType () const
  {
    return this->SupportType_.get ();
  }

  SupportRelationType::SupportType_type& SupportRelationType::
  SupportType ()
  {
    return this->SupportType_.get ();
  }

  void SupportRelationType::
  SupportType (const SupportType_type& x)
  {
    this->SupportType_.set (x);
  }

  void SupportRelationType::
  SupportType (::std::unique_ptr< SupportType_type > x)
  {
    this->SupportType_.set (std::move (x));
  }

  const SupportRelationType::SupportRoleType_optional& SupportRelationType::
  SupportRoleType () const
  {
    return this->SupportRoleType_;
  }

  SupportRelationType::SupportRoleType_optional& SupportRelationType::
  SupportRoleType ()
  {
    return this->SupportRoleType_;
  }

  void SupportRelationType::
  SupportRoleType (const SupportRoleType_type& x)
  {
    this->SupportRoleType_.set (x);
  }

  void SupportRelationType::
  SupportRoleType (const SupportRoleType_optional& x)
  {
    this->SupportRoleType_ = x;
  }

  void SupportRelationType::
  SupportRoleType (::std::unique_ptr< SupportRoleType_type > x)
  {
    this->SupportRoleType_.set (std::move (x));
  }


  // SymbolClassModifiersType
  // 

  const SymbolClassModifiersType::PointSymbolModifiers_optional& SymbolClassModifiersType::
  PointSymbolModifiers () const
  {
    return this->PointSymbolModifiers_;
  }

  SymbolClassModifiersType::PointSymbolModifiers_optional& SymbolClassModifiersType::
  PointSymbolModifiers ()
  {
    return this->PointSymbolModifiers_;
  }

  void SymbolClassModifiersType::
  PointSymbolModifiers (const PointSymbolModifiers_type& x)
  {
    this->PointSymbolModifiers_.set (x);
  }

  void SymbolClassModifiersType::
  PointSymbolModifiers (const PointSymbolModifiers_optional& x)
  {
    this->PointSymbolModifiers_ = x;
  }

  void SymbolClassModifiersType::
  PointSymbolModifiers (::std::unique_ptr< PointSymbolModifiers_type > x)
  {
    this->PointSymbolModifiers_.set (std::move (x));
  }

  const SymbolClassModifiersType::LineSymbolModifiers_optional& SymbolClassModifiersType::
  LineSymbolModifiers () const
  {
    return this->LineSymbolModifiers_;
  }

  SymbolClassModifiersType::LineSymbolModifiers_optional& SymbolClassModifiersType::
  LineSymbolModifiers ()
  {
    return this->LineSymbolModifiers_;
  }

  void SymbolClassModifiersType::
  LineSymbolModifiers (const LineSymbolModifiers_type& x)
  {
    this->LineSymbolModifiers_.set (x);
  }

  void SymbolClassModifiersType::
  LineSymbolModifiers (const LineSymbolModifiers_optional& x)
  {
    this->LineSymbolModifiers_ = x;
  }

  void SymbolClassModifiersType::
  LineSymbolModifiers (::std::unique_ptr< LineSymbolModifiers_type > x)
  {
    this->LineSymbolModifiers_.set (std::move (x));
  }

  const SymbolClassModifiersType::AreaSymbolModifiers_optional& SymbolClassModifiersType::
  AreaSymbolModifiers () const
  {
    return this->AreaSymbolModifiers_;
  }

  SymbolClassModifiersType::AreaSymbolModifiers_optional& SymbolClassModifiersType::
  AreaSymbolModifiers ()
  {
    return this->AreaSymbolModifiers_;
  }

  void SymbolClassModifiersType::
  AreaSymbolModifiers (const AreaSymbolModifiers_type& x)
  {
    this->AreaSymbolModifiers_.set (x);
  }

  void SymbolClassModifiersType::
  AreaSymbolModifiers (const AreaSymbolModifiers_optional& x)
  {
    this->AreaSymbolModifiers_ = x;
  }

  void SymbolClassModifiersType::
  AreaSymbolModifiers (::std::unique_ptr< AreaSymbolModifiers_type > x)
  {
    this->AreaSymbolModifiers_.set (std::move (x));
  }

  const SymbolClassModifiersType::BoundarySymbolModifiers_optional& SymbolClassModifiersType::
  BoundarySymbolModifiers () const
  {
    return this->BoundarySymbolModifiers_;
  }

  SymbolClassModifiersType::BoundarySymbolModifiers_optional& SymbolClassModifiersType::
  BoundarySymbolModifiers ()
  {
    return this->BoundarySymbolModifiers_;
  }

  void SymbolClassModifiersType::
  BoundarySymbolModifiers (const BoundarySymbolModifiers_type& x)
  {
    this->BoundarySymbolModifiers_.set (x);
  }

  void SymbolClassModifiersType::
  BoundarySymbolModifiers (const BoundarySymbolModifiers_optional& x)
  {
    this->BoundarySymbolModifiers_ = x;
  }

  void SymbolClassModifiersType::
  BoundarySymbolModifiers (::std::unique_ptr< BoundarySymbolModifiers_type > x)
  {
    this->BoundarySymbolModifiers_.set (std::move (x));
  }

  const SymbolClassModifiersType::NBCEventSymbolModifiers_optional& SymbolClassModifiersType::
  NBCEventSymbolModifiers () const
  {
    return this->NBCEventSymbolModifiers_;
  }

  SymbolClassModifiersType::NBCEventSymbolModifiers_optional& SymbolClassModifiersType::
  NBCEventSymbolModifiers ()
  {
    return this->NBCEventSymbolModifiers_;
  }

  void SymbolClassModifiersType::
  NBCEventSymbolModifiers (const NBCEventSymbolModifiers_type& x)
  {
    this->NBCEventSymbolModifiers_.set (x);
  }

  void SymbolClassModifiersType::
  NBCEventSymbolModifiers (const NBCEventSymbolModifiers_optional& x)
  {
    this->NBCEventSymbolModifiers_ = x;
  }

  void SymbolClassModifiersType::
  NBCEventSymbolModifiers (::std::unique_ptr< NBCEventSymbolModifiers_type > x)
  {
    this->NBCEventSymbolModifiers_.set (std::move (x));
  }

  const SymbolClassModifiersType::TaskSymbolModifiers_optional& SymbolClassModifiersType::
  TaskSymbolModifiers () const
  {
    return this->TaskSymbolModifiers_;
  }

  SymbolClassModifiersType::TaskSymbolModifiers_optional& SymbolClassModifiersType::
  TaskSymbolModifiers ()
  {
    return this->TaskSymbolModifiers_;
  }

  void SymbolClassModifiersType::
  TaskSymbolModifiers (const TaskSymbolModifiers_type& x)
  {
    this->TaskSymbolModifiers_.set (x);
  }

  void SymbolClassModifiersType::
  TaskSymbolModifiers (const TaskSymbolModifiers_optional& x)
  {
    this->TaskSymbolModifiers_ = x;
  }

  void SymbolClassModifiersType::
  TaskSymbolModifiers (::std::unique_ptr< TaskSymbolModifiers_type > x)
  {
    this->TaskSymbolModifiers_.set (std::move (x));
  }


  // SymbologyDataStandardType
  // 

  const SymbologyDataStandardType::StandardName_type& SymbologyDataStandardType::
  StandardName () const
  {
    return this->StandardName_.get ();
  }

  SymbologyDataStandardType::StandardName_type& SymbologyDataStandardType::
  StandardName ()
  {
    return this->StandardName_.get ();
  }

  void SymbologyDataStandardType::
  StandardName (const StandardName_type& x)
  {
    this->StandardName_.set (x);
  }

  void SymbologyDataStandardType::
  StandardName (::std::unique_ptr< StandardName_type > x)
  {
    this->StandardName_.set (std::move (x));
  }

  const SymbologyDataStandardType::MajorVersion_type& SymbologyDataStandardType::
  MajorVersion () const
  {
    return this->MajorVersion_.get ();
  }

  SymbologyDataStandardType::MajorVersion_type& SymbologyDataStandardType::
  MajorVersion ()
  {
    return this->MajorVersion_.get ();
  }

  void SymbologyDataStandardType::
  MajorVersion (const MajorVersion_type& x)
  {
    this->MajorVersion_.set (x);
  }

  void SymbologyDataStandardType::
  MajorVersion (::std::unique_ptr< MajorVersion_type > x)
  {
    this->MajorVersion_.set (std::move (x));
  }

  const SymbologyDataStandardType::MinorVersion_type& SymbologyDataStandardType::
  MinorVersion () const
  {
    return this->MinorVersion_.get ();
  }

  SymbologyDataStandardType::MinorVersion_type& SymbologyDataStandardType::
  MinorVersion ()
  {
    return this->MinorVersion_.get ();
  }

  void SymbologyDataStandardType::
  MinorVersion (const MinorVersion_type& x)
  {
    this->MinorVersion_.set (x);
  }

  void SymbologyDataStandardType::
  MinorVersion (::std::unique_ptr< MinorVersion_type > x)
  {
    this->MinorVersion_.set (std::move (x));
  }


  // TacticalGraphicsType
  // 

  const TacticalGraphicsType::TacticalGraphic_sequence& TacticalGraphicsType::
  TacticalGraphic () const
  {
    return this->TacticalGraphic_;
  }

  TacticalGraphicsType::TacticalGraphic_sequence& TacticalGraphicsType::
  TacticalGraphic ()
  {
    return this->TacticalGraphic_;
  }

  void TacticalGraphicsType::
  TacticalGraphic (const TacticalGraphic_sequence& s)
  {
    this->TacticalGraphic_ = s;
  }


  // TacticalGraphicType
  // 

  const TacticalGraphicType::ObjectHandle_type& TacticalGraphicType::
  ObjectHandle () const
  {
    return this->ObjectHandle_.get ();
  }

  TacticalGraphicType::ObjectHandle_type& TacticalGraphicType::
  ObjectHandle ()
  {
    return this->ObjectHandle_.get ();
  }

  void TacticalGraphicType::
  ObjectHandle (const ObjectHandle_type& x)
  {
    this->ObjectHandle_.set (x);
  }

  void TacticalGraphicType::
  ObjectHandle (::std::unique_ptr< ObjectHandle_type > x)
  {
    this->ObjectHandle_.set (std::move (x));
  }

  const TacticalGraphicType::SymbolIdentifier_type& TacticalGraphicType::
  SymbolIdentifier () const
  {
    return this->SymbolIdentifier_.get ();
  }

  TacticalGraphicType::SymbolIdentifier_type& TacticalGraphicType::
  SymbolIdentifier ()
  {
    return this->SymbolIdentifier_.get ();
  }

  void TacticalGraphicType::
  SymbolIdentifier (const SymbolIdentifier_type& x)
  {
    this->SymbolIdentifier_.set (x);
  }

  void TacticalGraphicType::
  SymbolIdentifier (::std::unique_ptr< SymbolIdentifier_type > x)
  {
    this->SymbolIdentifier_.set (std::move (x));
  }

  const TacticalGraphicType::Affiliation_type& TacticalGraphicType::
  Affiliation () const
  {
    return this->Affiliation_.get ();
  }

  TacticalGraphicType::Affiliation_type& TacticalGraphicType::
  Affiliation ()
  {
    return this->Affiliation_.get ();
  }

  void TacticalGraphicType::
  Affiliation (const Affiliation_type& x)
  {
    this->Affiliation_.set (x);
  }

  void TacticalGraphicType::
  Affiliation (::std::unique_ptr< Affiliation_type > x)
  {
    this->Affiliation_.set (std::move (x));
  }

  const TacticalGraphicType::Owner_type& TacticalGraphicType::
  Owner () const
  {
    return this->Owner_.get ();
  }

  TacticalGraphicType::Owner_type& TacticalGraphicType::
  Owner ()
  {
    return this->Owner_.get ();
  }

  void TacticalGraphicType::
  Owner (const Owner_type& x)
  {
    this->Owner_.set (x);
  }

  void TacticalGraphicType::
  Owner (::std::unique_ptr< Owner_type > x)
  {
    this->Owner_.set (std::move (x));
  }

  const TacticalGraphicType::AnchorPoints_type& TacticalGraphicType::
  AnchorPoints () const
  {
    return this->AnchorPoints_.get ();
  }

  TacticalGraphicType::AnchorPoints_type& TacticalGraphicType::
  AnchorPoints ()
  {
    return this->AnchorPoints_.get ();
  }

  void TacticalGraphicType::
  AnchorPoints (const AnchorPoints_type& x)
  {
    this->AnchorPoints_.set (x);
  }

  void TacticalGraphicType::
  AnchorPoints (::std::unique_ptr< AnchorPoints_type > x)
  {
    this->AnchorPoints_.set (std::move (x));
  }

  const TacticalGraphicType::AssociatedOverlays_optional& TacticalGraphicType::
  AssociatedOverlays () const
  {
    return this->AssociatedOverlays_;
  }

  TacticalGraphicType::AssociatedOverlays_optional& TacticalGraphicType::
  AssociatedOverlays ()
  {
    return this->AssociatedOverlays_;
  }

  void TacticalGraphicType::
  AssociatedOverlays (const AssociatedOverlays_type& x)
  {
    this->AssociatedOverlays_.set (x);
  }

  void TacticalGraphicType::
  AssociatedOverlays (const AssociatedOverlays_optional& x)
  {
    this->AssociatedOverlays_ = x;
  }

  void TacticalGraphicType::
  AssociatedOverlays (::std::unique_ptr< AssociatedOverlays_type > x)
  {
    this->AssociatedOverlays_.set (std::move (x));
  }

  const TacticalGraphicType::SymbolClassData_optional& TacticalGraphicType::
  SymbolClassData () const
  {
    return this->SymbolClassData_;
  }

  TacticalGraphicType::SymbolClassData_optional& TacticalGraphicType::
  SymbolClassData ()
  {
    return this->SymbolClassData_;
  }

  void TacticalGraphicType::
  SymbolClassData (const SymbolClassData_type& x)
  {
    this->SymbolClassData_.set (x);
  }

  void TacticalGraphicType::
  SymbolClassData (const SymbolClassData_optional& x)
  {
    this->SymbolClassData_ = x;
  }

  void TacticalGraphicType::
  SymbolClassData (::std::unique_ptr< SymbolClassData_type > x)
  {
    this->SymbolClassData_.set (std::move (x));
  }

  const TacticalGraphicType::SymbolClassChoice_type& TacticalGraphicType::
  SymbolClassChoice () const
  {
    return this->SymbolClassChoice_.get ();
  }

  TacticalGraphicType::SymbolClassChoice_type& TacticalGraphicType::
  SymbolClassChoice ()
  {
    return this->SymbolClassChoice_.get ();
  }

  void TacticalGraphicType::
  SymbolClassChoice (const SymbolClassChoice_type& x)
  {
    this->SymbolClassChoice_.set (x);
  }

  void TacticalGraphicType::
  SymbolClassChoice (::std::unique_ptr< SymbolClassChoice_type > x)
  {
    this->SymbolClassChoice_.set (std::move (x));
  }


  // TaskSymbolModifiersType
  // 

  const TaskSymbolModifiersType::UniqueDesignation_optional& TaskSymbolModifiersType::
  UniqueDesignation () const
  {
    return this->UniqueDesignation_;
  }

  TaskSymbolModifiersType::UniqueDesignation_optional& TaskSymbolModifiersType::
  UniqueDesignation ()
  {
    return this->UniqueDesignation_;
  }

  void TaskSymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_type& x)
  {
    this->UniqueDesignation_.set (x);
  }

  void TaskSymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_optional& x)
  {
    this->UniqueDesignation_ = x;
  }

  void TaskSymbolModifiersType::
  UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > x)
  {
    this->UniqueDesignation_.set (std::move (x));
  }

  const TaskSymbolModifiersType::DateTimeGroup_optional& TaskSymbolModifiersType::
  DateTimeGroup () const
  {
    return this->DateTimeGroup_;
  }

  TaskSymbolModifiersType::DateTimeGroup_optional& TaskSymbolModifiersType::
  DateTimeGroup ()
  {
    return this->DateTimeGroup_;
  }

  void TaskSymbolModifiersType::
  DateTimeGroup (const DateTimeGroup_type& x)
  {
    this->DateTimeGroup_.set (x);
  }

  void TaskSymbolModifiersType::
  DateTimeGroup (const DateTimeGroup_optional& x)
  {
    this->DateTimeGroup_ = x;
  }

  void TaskSymbolModifiersType::
  DateTimeGroup (::std::unique_ptr< DateTimeGroup_type > x)
  {
    this->DateTimeGroup_.set (std::move (x));
  }


  // UnitDispositionType
  // 

  const UnitDispositionType::Location_optional& UnitDispositionType::
  Location () const
  {
    return this->Location_;
  }

  UnitDispositionType::Location_optional& UnitDispositionType::
  Location ()
  {
    return this->Location_;
  }

  void UnitDispositionType::
  Location (const Location_type& x)
  {
    this->Location_.set (x);
  }

  void UnitDispositionType::
  Location (const Location_optional& x)
  {
    this->Location_ = x;
  }

  void UnitDispositionType::
  Location (::std::unique_ptr< Location_type > x)
  {
    this->Location_.set (std::move (x));
  }

  const UnitDispositionType::DirectionOfMovement_optional& UnitDispositionType::
  DirectionOfMovement () const
  {
    return this->DirectionOfMovement_;
  }

  UnitDispositionType::DirectionOfMovement_optional& UnitDispositionType::
  DirectionOfMovement ()
  {
    return this->DirectionOfMovement_;
  }

  void UnitDispositionType::
  DirectionOfMovement (const DirectionOfMovement_type& x)
  {
    this->DirectionOfMovement_.set (x);
  }

  void UnitDispositionType::
  DirectionOfMovement (const DirectionOfMovement_optional& x)
  {
    this->DirectionOfMovement_ = x;
  }

  void UnitDispositionType::
  DirectionOfMovement (::std::unique_ptr< DirectionOfMovement_type > x)
  {
    this->DirectionOfMovement_.set (std::move (x));
  }

  const UnitDispositionType::Speed_optional& UnitDispositionType::
  Speed () const
  {
    return this->Speed_;
  }

  UnitDispositionType::Speed_optional& UnitDispositionType::
  Speed ()
  {
    return this->Speed_;
  }

  void UnitDispositionType::
  Speed (const Speed_type& x)
  {
    this->Speed_.set (x);
  }

  void UnitDispositionType::
  Speed (const Speed_optional& x)
  {
    this->Speed_ = x;
  }

  void UnitDispositionType::
  Speed (::std::unique_ptr< Speed_type > x)
  {
    this->Speed_.set (std::move (x));
  }

  const UnitDispositionType::FormationPosition_optional& UnitDispositionType::
  FormationPosition () const
  {
    return this->FormationPosition_;
  }

  UnitDispositionType::FormationPosition_optional& UnitDispositionType::
  FormationPosition ()
  {
    return this->FormationPosition_;
  }

  void UnitDispositionType::
  FormationPosition (const FormationPosition_type& x)
  {
    this->FormationPosition_.set (x);
  }

  void UnitDispositionType::
  FormationPosition (const FormationPosition_optional& x)
  {
    this->FormationPosition_ = x;
  }

  void UnitDispositionType::
  FormationPosition (::std::unique_ptr< FormationPosition_type > x)
  {
    this->FormationPosition_.set (std::move (x));
  }

  const UnitDispositionType::OwnFormation_optional& UnitDispositionType::
  OwnFormation () const
  {
    return this->OwnFormation_;
  }

  UnitDispositionType::OwnFormation_optional& UnitDispositionType::
  OwnFormation ()
  {
    return this->OwnFormation_;
  }

  void UnitDispositionType::
  OwnFormation (const OwnFormation_type& x)
  {
    this->OwnFormation_.set (x);
  }

  void UnitDispositionType::
  OwnFormation (const OwnFormation_optional& x)
  {
    this->OwnFormation_ = x;
  }

  void UnitDispositionType::
  OwnFormation (::std::unique_ptr< OwnFormation_type > x)
  {
    this->OwnFormation_.set (std::move (x));
  }


  // UnitModelType
  // 

  const UnitModelType::Resolution_optional& UnitModelType::
  Resolution () const
  {
    return this->Resolution_;
  }

  UnitModelType::Resolution_optional& UnitModelType::
  Resolution ()
  {
    return this->Resolution_;
  }

  void UnitModelType::
  Resolution (const Resolution_type& x)
  {
    this->Resolution_.set (x);
  }

  void UnitModelType::
  Resolution (const Resolution_optional& x)
  {
    this->Resolution_ = x;
  }

  void UnitModelType::
  Resolution (::std::unique_ptr< Resolution_type > x)
  {
    this->Resolution_.set (std::move (x));
  }

  const UnitModelType::AggregateBased_optional& UnitModelType::
  AggregateBased () const
  {
    return this->AggregateBased_;
  }

  UnitModelType::AggregateBased_optional& UnitModelType::
  AggregateBased ()
  {
    return this->AggregateBased_;
  }

  void UnitModelType::
  AggregateBased (const AggregateBased_type& x)
  {
    this->AggregateBased_.set (x);
  }

  void UnitModelType::
  AggregateBased (const AggregateBased_optional& x)
  {
    this->AggregateBased_ = x;
  }

  void UnitModelType::
  AggregateBased (::std::unique_ptr< AggregateBased_type > x)
  {
    this->AggregateBased_.set (std::move (x));
  }


  // UnitRelationsType
  // 

  const UnitRelationsType::ForceRelation_type& UnitRelationsType::
  ForceRelation () const
  {
    return this->ForceRelation_.get ();
  }

  UnitRelationsType::ForceRelation_type& UnitRelationsType::
  ForceRelation ()
  {
    return this->ForceRelation_.get ();
  }

  void UnitRelationsType::
  ForceRelation (const ForceRelation_type& x)
  {
    this->ForceRelation_.set (x);
  }

  void UnitRelationsType::
  ForceRelation (::std::unique_ptr< ForceRelation_type > x)
  {
    this->ForceRelation_.set (std::move (x));
  }

  const UnitRelationsType::SupportRelations_optional& UnitRelationsType::
  SupportRelations () const
  {
    return this->SupportRelations_;
  }

  UnitRelationsType::SupportRelations_optional& UnitRelationsType::
  SupportRelations ()
  {
    return this->SupportRelations_;
  }

  void UnitRelationsType::
  SupportRelations (const SupportRelations_type& x)
  {
    this->SupportRelations_.set (x);
  }

  void UnitRelationsType::
  SupportRelations (const SupportRelations_optional& x)
  {
    this->SupportRelations_ = x;
  }

  void UnitRelationsType::
  SupportRelations (::std::unique_ptr< SupportRelations_type > x)
  {
    this->SupportRelations_.set (std::move (x));
  }

  const UnitRelationsType::OrganicRelation_optional& UnitRelationsType::
  OrganicRelation () const
  {
    return this->OrganicRelation_;
  }

  UnitRelationsType::OrganicRelation_optional& UnitRelationsType::
  OrganicRelation ()
  {
    return this->OrganicRelation_;
  }

  void UnitRelationsType::
  OrganicRelation (const OrganicRelation_type& x)
  {
    this->OrganicRelation_.set (x);
  }

  void UnitRelationsType::
  OrganicRelation (const OrganicRelation_optional& x)
  {
    this->OrganicRelation_ = x;
  }

  void UnitRelationsType::
  OrganicRelation (::std::unique_ptr< OrganicRelation_type > x)
  {
    this->OrganicRelation_.set (std::move (x));
  }


  // UnitsType
  // 

  const UnitsType::Unit_sequence& UnitsType::
  Unit () const
  {
    return this->Unit_;
  }

  UnitsType::Unit_sequence& UnitsType::
  Unit ()
  {
    return this->Unit_;
  }

  void UnitsType::
  Unit (const Unit_sequence& s)
  {
    this->Unit_ = s;
  }


  // UnitSymbolModifiersType
  // 

  const UnitSymbolModifiersType::Echelon_optional& UnitSymbolModifiersType::
  Echelon () const
  {
    return this->Echelon_;
  }

  UnitSymbolModifiersType::Echelon_optional& UnitSymbolModifiersType::
  Echelon ()
  {
    return this->Echelon_;
  }

  void UnitSymbolModifiersType::
  Echelon (const Echelon_type& x)
  {
    this->Echelon_.set (x);
  }

  void UnitSymbolModifiersType::
  Echelon (const Echelon_optional& x)
  {
    this->Echelon_ = x;
  }

  void UnitSymbolModifiersType::
  Echelon (::std::unique_ptr< Echelon_type > x)
  {
    this->Echelon_.set (std::move (x));
  }

  const UnitSymbolModifiersType::ReinforcedReduced_optional& UnitSymbolModifiersType::
  ReinforcedReduced () const
  {
    return this->ReinforcedReduced_;
  }

  UnitSymbolModifiersType::ReinforcedReduced_optional& UnitSymbolModifiersType::
  ReinforcedReduced ()
  {
    return this->ReinforcedReduced_;
  }

  void UnitSymbolModifiersType::
  ReinforcedReduced (const ReinforcedReduced_type& x)
  {
    this->ReinforcedReduced_.set (x);
  }

  void UnitSymbolModifiersType::
  ReinforcedReduced (const ReinforcedReduced_optional& x)
  {
    this->ReinforcedReduced_ = x;
  }

  void UnitSymbolModifiersType::
  ReinforcedReduced (::std::unique_ptr< ReinforcedReduced_type > x)
  {
    this->ReinforcedReduced_.set (std::move (x));
  }

  const UnitSymbolModifiersType::StaffComments_optional& UnitSymbolModifiersType::
  StaffComments () const
  {
    return this->StaffComments_;
  }

  UnitSymbolModifiersType::StaffComments_optional& UnitSymbolModifiersType::
  StaffComments ()
  {
    return this->StaffComments_;
  }

  void UnitSymbolModifiersType::
  StaffComments (const StaffComments_type& x)
  {
    this->StaffComments_.set (x);
  }

  void UnitSymbolModifiersType::
  StaffComments (const StaffComments_optional& x)
  {
    this->StaffComments_ = x;
  }

  void UnitSymbolModifiersType::
  StaffComments (::std::unique_ptr< StaffComments_type > x)
  {
    this->StaffComments_.set (std::move (x));
  }

  const UnitSymbolModifiersType::AdditionalInfo_optional& UnitSymbolModifiersType::
  AdditionalInfo () const
  {
    return this->AdditionalInfo_;
  }

  UnitSymbolModifiersType::AdditionalInfo_optional& UnitSymbolModifiersType::
  AdditionalInfo ()
  {
    return this->AdditionalInfo_;
  }

  void UnitSymbolModifiersType::
  AdditionalInfo (const AdditionalInfo_type& x)
  {
    this->AdditionalInfo_.set (x);
  }

  void UnitSymbolModifiersType::
  AdditionalInfo (const AdditionalInfo_optional& x)
  {
    this->AdditionalInfo_ = x;
  }

  void UnitSymbolModifiersType::
  AdditionalInfo (::std::unique_ptr< AdditionalInfo_type > x)
  {
    this->AdditionalInfo_.set (std::move (x));
  }

  const UnitSymbolModifiersType::CombatEffectiveness_optional& UnitSymbolModifiersType::
  CombatEffectiveness () const
  {
    return this->CombatEffectiveness_;
  }

  UnitSymbolModifiersType::CombatEffectiveness_optional& UnitSymbolModifiersType::
  CombatEffectiveness ()
  {
    return this->CombatEffectiveness_;
  }

  void UnitSymbolModifiersType::
  CombatEffectiveness (const CombatEffectiveness_type& x)
  {
    this->CombatEffectiveness_.set (x);
  }

  void UnitSymbolModifiersType::
  CombatEffectiveness (const CombatEffectiveness_optional& x)
  {
    this->CombatEffectiveness_ = x;
  }

  void UnitSymbolModifiersType::
  CombatEffectiveness (::std::unique_ptr< CombatEffectiveness_type > x)
  {
    this->CombatEffectiveness_.set (std::move (x));
  }

  const UnitSymbolModifiersType::HigherFormation_optional& UnitSymbolModifiersType::
  HigherFormation () const
  {
    return this->HigherFormation_;
  }

  UnitSymbolModifiersType::HigherFormation_optional& UnitSymbolModifiersType::
  HigherFormation ()
  {
    return this->HigherFormation_;
  }

  void UnitSymbolModifiersType::
  HigherFormation (const HigherFormation_type& x)
  {
    this->HigherFormation_.set (x);
  }

  void UnitSymbolModifiersType::
  HigherFormation (const HigherFormation_optional& x)
  {
    this->HigherFormation_ = x;
  }

  void UnitSymbolModifiersType::
  HigherFormation (::std::unique_ptr< HigherFormation_type > x)
  {
    this->HigherFormation_.set (std::move (x));
  }

  const UnitSymbolModifiersType::IFF_optional& UnitSymbolModifiersType::
  IFF () const
  {
    return this->IFF_;
  }

  UnitSymbolModifiersType::IFF_optional& UnitSymbolModifiersType::
  IFF ()
  {
    return this->IFF_;
  }

  void UnitSymbolModifiersType::
  IFF (const IFF_type& x)
  {
    this->IFF_.set (x);
  }

  void UnitSymbolModifiersType::
  IFF (const IFF_optional& x)
  {
    this->IFF_ = x;
  }

  void UnitSymbolModifiersType::
  IFF (::std::unique_ptr< IFF_type > x)
  {
    this->IFF_.set (std::move (x));
  }

  const UnitSymbolModifiersType::UniqueDesignation_type& UnitSymbolModifiersType::
  UniqueDesignation () const
  {
    return this->UniqueDesignation_.get ();
  }

  UnitSymbolModifiersType::UniqueDesignation_type& UnitSymbolModifiersType::
  UniqueDesignation ()
  {
    return this->UniqueDesignation_.get ();
  }

  void UnitSymbolModifiersType::
  UniqueDesignation (const UniqueDesignation_type& x)
  {
    this->UniqueDesignation_.set (x);
  }

  void UnitSymbolModifiersType::
  UniqueDesignation (::std::unique_ptr< UniqueDesignation_type > x)
  {
    this->UniqueDesignation_.set (std::move (x));
  }

  const UnitSymbolModifiersType::SpecialC2HQ_optional& UnitSymbolModifiersType::
  SpecialC2HQ () const
  {
    return this->SpecialC2HQ_;
  }

  UnitSymbolModifiersType::SpecialC2HQ_optional& UnitSymbolModifiersType::
  SpecialC2HQ ()
  {
    return this->SpecialC2HQ_;
  }

  void UnitSymbolModifiersType::
  SpecialC2HQ (const SpecialC2HQ_type& x)
  {
    this->SpecialC2HQ_.set (x);
  }

  void UnitSymbolModifiersType::
  SpecialC2HQ (const SpecialC2HQ_optional& x)
  {
    this->SpecialC2HQ_ = x;
  }

  void UnitSymbolModifiersType::
  SpecialC2HQ (::std::unique_ptr< SpecialC2HQ_type > x)
  {
    this->SpecialC2HQ_.set (std::move (x));
  }


  // UnitType
  // 

  const UnitType::ObjectHandle_type& UnitType::
  ObjectHandle () const
  {
    return this->ObjectHandle_.get ();
  }

  UnitType::ObjectHandle_type& UnitType::
  ObjectHandle ()
  {
    return this->ObjectHandle_.get ();
  }

  void UnitType::
  ObjectHandle (const ObjectHandle_type& x)
  {
    this->ObjectHandle_.set (x);
  }

  void UnitType::
  ObjectHandle (::std::unique_ptr< ObjectHandle_type > x)
  {
    this->ObjectHandle_.set (std::move (x));
  }

  const UnitType::SymbolIdentifier_type& UnitType::
  SymbolIdentifier () const
  {
    return this->SymbolIdentifier_.get ();
  }

  UnitType::SymbolIdentifier_type& UnitType::
  SymbolIdentifier ()
  {
    return this->SymbolIdentifier_.get ();
  }

  void UnitType::
  SymbolIdentifier (const SymbolIdentifier_type& x)
  {
    this->SymbolIdentifier_.set (x);
  }

  void UnitType::
  SymbolIdentifier (::std::unique_ptr< SymbolIdentifier_type > x)
  {
    this->SymbolIdentifier_.set (std::move (x));
  }

  const UnitType::Name_optional& UnitType::
  Name () const
  {
    return this->Name_;
  }

  UnitType::Name_optional& UnitType::
  Name ()
  {
    return this->Name_;
  }

  void UnitType::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void UnitType::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void UnitType::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const UnitType::UnitSymbolModifiers_optional& UnitType::
  UnitSymbolModifiers () const
  {
    return this->UnitSymbolModifiers_;
  }

  UnitType::UnitSymbolModifiers_optional& UnitType::
  UnitSymbolModifiers ()
  {
    return this->UnitSymbolModifiers_;
  }

  void UnitType::
  UnitSymbolModifiers (const UnitSymbolModifiers_type& x)
  {
    this->UnitSymbolModifiers_.set (x);
  }

  void UnitType::
  UnitSymbolModifiers (const UnitSymbolModifiers_optional& x)
  {
    this->UnitSymbolModifiers_ = x;
  }

  void UnitType::
  UnitSymbolModifiers (::std::unique_ptr< UnitSymbolModifiers_type > x)
  {
    this->UnitSymbolModifiers_.set (std::move (x));
  }

  const UnitType::CommunicationNetInstances_optional& UnitType::
  CommunicationNetInstances () const
  {
    return this->CommunicationNetInstances_;
  }

  UnitType::CommunicationNetInstances_optional& UnitType::
  CommunicationNetInstances ()
  {
    return this->CommunicationNetInstances_;
  }

  void UnitType::
  CommunicationNetInstances (const CommunicationNetInstances_type& x)
  {
    this->CommunicationNetInstances_.set (x);
  }

  void UnitType::
  CommunicationNetInstances (const CommunicationNetInstances_optional& x)
  {
    this->CommunicationNetInstances_ = x;
  }

  void UnitType::
  CommunicationNetInstances (::std::unique_ptr< CommunicationNetInstances_type > x)
  {
    this->CommunicationNetInstances_.set (std::move (x));
  }

  const UnitType::Status_optional& UnitType::
  Status () const
  {
    return this->Status_;
  }

  UnitType::Status_optional& UnitType::
  Status ()
  {
    return this->Status_;
  }

  void UnitType::
  Status (const Status_type& x)
  {
    this->Status_.set (x);
  }

  void UnitType::
  Status (const Status_optional& x)
  {
    this->Status_ = x;
  }

  void UnitType::
  Status (::std::unique_ptr< Status_type > x)
  {
    this->Status_.set (std::move (x));
  }

  const UnitType::Disposition_optional& UnitType::
  Disposition () const
  {
    return this->Disposition_;
  }

  UnitType::Disposition_optional& UnitType::
  Disposition ()
  {
    return this->Disposition_;
  }

  void UnitType::
  Disposition (const Disposition_type& x)
  {
    this->Disposition_.set (x);
  }

  void UnitType::
  Disposition (const Disposition_optional& x)
  {
    this->Disposition_ = x;
  }

  void UnitType::
  Disposition (::std::unique_ptr< Disposition_type > x)
  {
    this->Disposition_.set (std::move (x));
  }

  const UnitType::Relations_type& UnitType::
  Relations () const
  {
    return this->Relations_.get ();
  }

  UnitType::Relations_type& UnitType::
  Relations ()
  {
    return this->Relations_.get ();
  }

  void UnitType::
  Relations (const Relations_type& x)
  {
    this->Relations_.set (x);
  }

  void UnitType::
  Relations (::std::unique_ptr< Relations_type > x)
  {
    this->Relations_.set (std::move (x));
  }

  const UnitType::Model_optional& UnitType::
  Model () const
  {
    return this->Model_;
  }

  UnitType::Model_optional& UnitType::
  Model ()
  {
    return this->Model_;
  }

  void UnitType::
  Model (const Model_type& x)
  {
    this->Model_.set (x);
  }

  void UnitType::
  Model (const Model_optional& x)
  {
    this->Model_ = x;
  }

  void UnitType::
  Model (::std::unique_ptr< Model_type > x)
  {
    this->Model_.set (std::move (x));
  }


  // UTMType
  // 

  const UTMType::UTMGridZone_type& UTMType::
  UTMGridZone () const
  {
    return this->UTMGridZone_.get ();
  }

  UTMType::UTMGridZone_type& UTMType::
  UTMGridZone ()
  {
    return this->UTMGridZone_.get ();
  }

  void UTMType::
  UTMGridZone (const UTMGridZone_type& x)
  {
    this->UTMGridZone_.set (x);
  }

  void UTMType::
  UTMGridZone (::std::unique_ptr< UTMGridZone_type > x)
  {
    this->UTMGridZone_.set (std::move (x));
  }

  const UTMType::UTMEasting_type& UTMType::
  UTMEasting () const
  {
    return this->UTMEasting_.get ();
  }

  UTMType::UTMEasting_type& UTMType::
  UTMEasting ()
  {
    return this->UTMEasting_.get ();
  }

  void UTMType::
  UTMEasting (const UTMEasting_type& x)
  {
    this->UTMEasting_.set (x);
  }

  void UTMType::
  UTMEasting (::std::unique_ptr< UTMEasting_type > x)
  {
    this->UTMEasting_.set (std::move (x));
  }

  const UTMType::UTMNorthing_type& UTMType::
  UTMNorthing () const
  {
    return this->UTMNorthing_.get ();
  }

  UTMType::UTMNorthing_type& UTMType::
  UTMNorthing ()
  {
    return this->UTMNorthing_.get ();
  }

  void UTMType::
  UTMNorthing (const UTMNorthing_type& x)
  {
    this->UTMNorthing_.set (x);
  }

  void UTMType::
  UTMNorthing (::std::unique_ptr< UTMNorthing_type > x)
  {
    this->UTMNorthing_.set (std::move (x));
  }

  const UTMType::ElevationAGL_optional& UTMType::
  ElevationAGL () const
  {
    return this->ElevationAGL_;
  }

  UTMType::ElevationAGL_optional& UTMType::
  ElevationAGL ()
  {
    return this->ElevationAGL_;
  }

  void UTMType::
  ElevationAGL (const ElevationAGL_type& x)
  {
    this->ElevationAGL_.set (x);
  }

  void UTMType::
  ElevationAGL (const ElevationAGL_optional& x)
  {
    this->ElevationAGL_ = x;
  }

  void UTMType::
  ElevationAGL (::std::unique_ptr< ElevationAGL_type > x)
  {
    this->ElevationAGL_.set (std::move (x));
  }


  // VisibilityItemsType
  // 

  const VisibilityItemsType::Visibility_sequence& VisibilityItemsType::
  Visibility () const
  {
    return this->Visibility_;
  }

  VisibilityItemsType::Visibility_sequence& VisibilityItemsType::
  Visibility ()
  {
    return this->Visibility_;
  }

  void VisibilityItemsType::
  Visibility (const Visibility_sequence& s)
  {
    this->Visibility_ = s;
  }


  // WindItemsType
  // 

  const WindItemsType::Wind_sequence& WindItemsType::
  Wind () const
  {
    return this->Wind_;
  }

  WindItemsType::Wind_sequence& WindItemsType::
  Wind ()
  {
    return this->Wind_;
  }

  void WindItemsType::
  Wind (const Wind_sequence& s)
  {
    this->Wind_ = s;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

#include <xsd/cxx/tree/comparison-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;

  static
  const ::xsd::cxx::tree::comparison_plate< 0, char >
  comparison_plate_init;
}

namespace msdl_1
{
  // AnchorPointType
  //

  AnchorPointType::
  AnchorPointType (const AnchorChoice_type& AnchorChoice,
                   const Anchor_type& Anchor)
  : ::xml_schema::type (),
    AnchorChoice_ (AnchorChoice, this),
    Anchor_ (Anchor, this)
  {
  }

  AnchorPointType::
  AnchorPointType (const AnchorChoice_type& AnchorChoice,
                   ::std::unique_ptr< Anchor_type > Anchor)
  : ::xml_schema::type (),
    AnchorChoice_ (AnchorChoice, this),
    Anchor_ (std::move (Anchor), this)
  {
  }

  AnchorPointType::
  AnchorPointType (::std::unique_ptr< AnchorChoice_type > AnchorChoice,
                   ::std::unique_ptr< Anchor_type > Anchor)
  : ::xml_schema::type (),
    AnchorChoice_ (std::move (AnchorChoice), this),
    Anchor_ (std::move (Anchor), this)
  {
  }

  AnchorPointType::
  AnchorPointType (const AnchorPointType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AnchorChoice_ (x.AnchorChoice_, f, this),
    Anchor_ (x.Anchor_, f, this)
  {
  }

  AnchorPointType::
  AnchorPointType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AnchorChoice_ (this),
    Anchor_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AnchorPointType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AnchorChoice
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AnchorChoice",
            "",
            &::xsd::cxx::tree::factory_impl< AnchorChoice_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!AnchorChoice_.present ())
          {
            ::std::unique_ptr< AnchorChoice_type > r (
              dynamic_cast< AnchorChoice_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AnchorChoice_.set (::std::move (r));
            continue;
          }
        }
      }

      // Anchor
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Anchor",
            "",
            &::xsd::cxx::tree::factory_impl< Anchor_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Anchor_.present ())
          {
            ::std::unique_ptr< Anchor_type > r (
              dynamic_cast< Anchor_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Anchor_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!AnchorChoice_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AnchorChoice",
        "");
    }

    if (!Anchor_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Anchor",
        "");
    }
  }

  AnchorPointType* AnchorPointType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AnchorPointType (*this, f, c);
  }

  AnchorPointType& AnchorPointType::
  operator= (const AnchorPointType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AnchorChoice_ = x.AnchorChoice_;
      this->Anchor_ = x.Anchor_;
    }

    return *this;
  }

  AnchorPointType::
  ~AnchorPointType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AnchorPointType >
  _xsd_AnchorPointType_type_factory_init (
    "AnchorPointType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, AnchorPointType >
  _xsd_AnchorPointType_comparison_init;

  bool
  operator== (const AnchorPointType& x, const AnchorPointType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.AnchorChoice (), y.AnchorChoice ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Anchor (), y.Anchor ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const AnchorPointType& x, const AnchorPointType& y)
  {
    return !(x == y);
  }

  // AnchorPointsType
  //

  AnchorPointsType::
  AnchorPointsType ()
  : ::xml_schema::type (),
    AnchorPoint_ (this)
  {
  }

  AnchorPointsType::
  AnchorPointsType (const AnchorPointsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AnchorPoint_ (x.AnchorPoint_, f, this)
  {
  }

  AnchorPointsType::
  AnchorPointsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AnchorPoint_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AnchorPointsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AnchorPoint
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AnchorPoint",
            "",
            &::xsd::cxx::tree::factory_impl< AnchorPoint_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< AnchorPoint_type > r (
            dynamic_cast< AnchorPoint_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AnchorPoint_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  AnchorPointsType* AnchorPointsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AnchorPointsType (*this, f, c);
  }

  AnchorPointsType& AnchorPointsType::
  operator= (const AnchorPointsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AnchorPoint_ = x.AnchorPoint_;
    }

    return *this;
  }

  AnchorPointsType::
  ~AnchorPointsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AnchorPointsType >
  _xsd_AnchorPointsType_type_factory_init (
    "AnchorPointsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, AnchorPointsType >
  _xsd_AnchorPointsType_comparison_init;

  bool
  operator== (const AnchorPointsType& x, const AnchorPointsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      AnchorPointsType::AnchorPoint_sequence a (x.AnchorPoint ()), b (y.AnchorPoint ());

      if (a.size () != b.size ())
        return false;

      for (AnchorPointsType::AnchorPoint_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const AnchorPointsType& x, const AnchorPointsType& y)
  {
    return !(x == y);
  }

  // AnchorType
  //

  AnchorType::
  AnchorType ()
  : ::xml_schema::type (),
    Location_ (this),
    PointSymbolHandle_ (this)
  {
  }

  AnchorType::
  AnchorType (const AnchorType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Location_ (x.Location_, f, this),
    PointSymbolHandle_ (x.PointSymbolHandle_, f, this)
  {
  }

  AnchorType::
  AnchorType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Location_ (this),
    PointSymbolHandle_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AnchorType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Location
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Location",
            "",
            &::xsd::cxx::tree::factory_impl< Location_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Location_)
          {
            ::std::unique_ptr< Location_type > r (
              dynamic_cast< Location_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Location_.set (::std::move (r));
            continue;
          }
        }
      }

      // PointSymbolHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PointSymbolHandle",
            "",
            &::xsd::cxx::tree::factory_impl< PointSymbolHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->PointSymbolHandle_)
          {
            ::std::unique_ptr< PointSymbolHandle_type > r (
              dynamic_cast< PointSymbolHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->PointSymbolHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  AnchorType* AnchorType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AnchorType (*this, f, c);
  }

  AnchorType& AnchorType::
  operator= (const AnchorType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Location_ = x.Location_;
      this->PointSymbolHandle_ = x.PointSymbolHandle_;
    }

    return *this;
  }

  AnchorType::
  ~AnchorType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AnchorType >
  _xsd_AnchorType_type_factory_init (
    "AnchorType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, AnchorType >
  _xsd_AnchorType_comparison_init;

  bool
  operator== (const AnchorType& x, const AnchorType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      AnchorType::Location_optional a (x.Location ()), b (y.Location ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      AnchorType::PointSymbolHandle_optional a (x.PointSymbolHandle ()), b (y.PointSymbolHandle ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const AnchorType& x, const AnchorType& y)
  {
    return !(x == y);
  }

  // AreaSymbolModifiersType
  //

  AreaSymbolModifiersType::
  AreaSymbolModifiersType ()
  : ::xml_schema::type (),
    Echelon_ (this),
    AdditionalInfo_ (this),
    AdditionalInfo1_ (this),
    AdditionalInfo2_ (this),
    UniqueDesignation_ (this),
    DateTimeGroup_ (this),
    DateTimeGroup1_ (this)
  {
  }

  AreaSymbolModifiersType::
  AreaSymbolModifiersType (const AreaSymbolModifiersType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Echelon_ (x.Echelon_, f, this),
    AdditionalInfo_ (x.AdditionalInfo_, f, this),
    AdditionalInfo1_ (x.AdditionalInfo1_, f, this),
    AdditionalInfo2_ (x.AdditionalInfo2_, f, this),
    UniqueDesignation_ (x.UniqueDesignation_, f, this),
    DateTimeGroup_ (x.DateTimeGroup_, f, this),
    DateTimeGroup1_ (x.DateTimeGroup1_, f, this)
  {
  }

  AreaSymbolModifiersType::
  AreaSymbolModifiersType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Echelon_ (this),
    AdditionalInfo_ (this),
    AdditionalInfo1_ (this),
    AdditionalInfo2_ (this),
    UniqueDesignation_ (this),
    DateTimeGroup_ (this),
    DateTimeGroup1_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AreaSymbolModifiersType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Echelon
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Echelon",
            "",
            &::xsd::cxx::tree::factory_impl< Echelon_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Echelon_)
          {
            ::std::unique_ptr< Echelon_type > r (
              dynamic_cast< Echelon_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Echelon_.set (::std::move (r));
            continue;
          }
        }
      }

      // AdditionalInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AdditionalInfo",
            "",
            &::xsd::cxx::tree::factory_impl< AdditionalInfo_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AdditionalInfo_)
          {
            ::std::unique_ptr< AdditionalInfo_type > r (
              dynamic_cast< AdditionalInfo_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AdditionalInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      // AdditionalInfo1
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AdditionalInfo1",
            "",
            &::xsd::cxx::tree::factory_impl< AdditionalInfo1_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AdditionalInfo1_)
          {
            ::std::unique_ptr< AdditionalInfo1_type > r (
              dynamic_cast< AdditionalInfo1_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AdditionalInfo1_.set (::std::move (r));
            continue;
          }
        }
      }

      // AdditionalInfo2
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AdditionalInfo2",
            "",
            &::xsd::cxx::tree::factory_impl< AdditionalInfo2_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AdditionalInfo2_)
          {
            ::std::unique_ptr< AdditionalInfo2_type > r (
              dynamic_cast< AdditionalInfo2_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AdditionalInfo2_.set (::std::move (r));
            continue;
          }
        }
      }

      // UniqueDesignation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UniqueDesignation",
            "",
            &::xsd::cxx::tree::factory_impl< UniqueDesignation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->UniqueDesignation_)
          {
            ::std::unique_ptr< UniqueDesignation_type > r (
              dynamic_cast< UniqueDesignation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UniqueDesignation_.set (::std::move (r));
            continue;
          }
        }
      }

      // DateTimeGroup
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DateTimeGroup",
            "",
            &::xsd::cxx::tree::factory_impl< DateTimeGroup_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DateTimeGroup_)
          {
            ::std::unique_ptr< DateTimeGroup_type > r (
              dynamic_cast< DateTimeGroup_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DateTimeGroup_.set (::std::move (r));
            continue;
          }
        }
      }

      // DateTimeGroup1
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DateTimeGroup1",
            "",
            &::xsd::cxx::tree::factory_impl< DateTimeGroup1_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DateTimeGroup1_)
          {
            ::std::unique_ptr< DateTimeGroup1_type > r (
              dynamic_cast< DateTimeGroup1_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DateTimeGroup1_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  AreaSymbolModifiersType* AreaSymbolModifiersType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AreaSymbolModifiersType (*this, f, c);
  }

  AreaSymbolModifiersType& AreaSymbolModifiersType::
  operator= (const AreaSymbolModifiersType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Echelon_ = x.Echelon_;
      this->AdditionalInfo_ = x.AdditionalInfo_;
      this->AdditionalInfo1_ = x.AdditionalInfo1_;
      this->AdditionalInfo2_ = x.AdditionalInfo2_;
      this->UniqueDesignation_ = x.UniqueDesignation_;
      this->DateTimeGroup_ = x.DateTimeGroup_;
      this->DateTimeGroup1_ = x.DateTimeGroup1_;
    }

    return *this;
  }

  AreaSymbolModifiersType::
  ~AreaSymbolModifiersType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AreaSymbolModifiersType >
  _xsd_AreaSymbolModifiersType_type_factory_init (
    "AreaSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, AreaSymbolModifiersType >
  _xsd_AreaSymbolModifiersType_comparison_init;

  bool
  operator== (const AreaSymbolModifiersType& x, const AreaSymbolModifiersType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      AreaSymbolModifiersType::Echelon_optional a (x.Echelon ()), b (y.Echelon ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      AreaSymbolModifiersType::AdditionalInfo_optional a (x.AdditionalInfo ()), b (y.AdditionalInfo ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      AreaSymbolModifiersType::AdditionalInfo1_optional a (x.AdditionalInfo1 ()), b (y.AdditionalInfo1 ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      AreaSymbolModifiersType::AdditionalInfo2_optional a (x.AdditionalInfo2 ()), b (y.AdditionalInfo2 ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      AreaSymbolModifiersType::UniqueDesignation_optional a (x.UniqueDesignation ()), b (y.UniqueDesignation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      AreaSymbolModifiersType::DateTimeGroup_optional a (x.DateTimeGroup ()), b (y.DateTimeGroup ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      AreaSymbolModifiersType::DateTimeGroup1_optional a (x.DateTimeGroup1 ()), b (y.DateTimeGroup1 ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const AreaSymbolModifiersType& x, const AreaSymbolModifiersType& y)
  {
    return !(x == y);
  }

  // AssociatedOverlaysType
  //

  AssociatedOverlaysType::
  AssociatedOverlaysType (const OverlayHandles_type& OverlayHandles)
  : ::xml_schema::type (),
    OverlayHandles_ (OverlayHandles, this),
    SourceOverlayType_ (this)
  {
  }

  AssociatedOverlaysType::
  AssociatedOverlaysType (::std::unique_ptr< OverlayHandles_type > OverlayHandles)
  : ::xml_schema::type (),
    OverlayHandles_ (std::move (OverlayHandles), this),
    SourceOverlayType_ (this)
  {
  }

  AssociatedOverlaysType::
  AssociatedOverlaysType (const AssociatedOverlaysType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    OverlayHandles_ (x.OverlayHandles_, f, this),
    SourceOverlayType_ (x.SourceOverlayType_, f, this)
  {
  }

  AssociatedOverlaysType::
  AssociatedOverlaysType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    OverlayHandles_ (this),
    SourceOverlayType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AssociatedOverlaysType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OverlayHandles
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OverlayHandles",
            "",
            &::xsd::cxx::tree::factory_impl< OverlayHandles_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!OverlayHandles_.present ())
          {
            ::std::unique_ptr< OverlayHandles_type > r (
              dynamic_cast< OverlayHandles_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OverlayHandles_.set (::std::move (r));
            continue;
          }
        }
      }

      // SourceOverlayType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SourceOverlayType",
            "",
            &::xsd::cxx::tree::factory_impl< SourceOverlayType_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SourceOverlayType_)
          {
            ::std::unique_ptr< SourceOverlayType_type > r (
              dynamic_cast< SourceOverlayType_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SourceOverlayType_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!OverlayHandles_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "OverlayHandles",
        "");
    }
  }

  AssociatedOverlaysType* AssociatedOverlaysType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AssociatedOverlaysType (*this, f, c);
  }

  AssociatedOverlaysType& AssociatedOverlaysType::
  operator= (const AssociatedOverlaysType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->OverlayHandles_ = x.OverlayHandles_;
      this->SourceOverlayType_ = x.SourceOverlayType_;
    }

    return *this;
  }

  AssociatedOverlaysType::
  ~AssociatedOverlaysType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AssociatedOverlaysType >
  _xsd_AssociatedOverlaysType_type_factory_init (
    "AssociatedOverlaysType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, AssociatedOverlaysType >
  _xsd_AssociatedOverlaysType_comparison_init;

  bool
  operator== (const AssociatedOverlaysType& x, const AssociatedOverlaysType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.OverlayHandles (), y.OverlayHandles ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      AssociatedOverlaysType::SourceOverlayType_optional a (x.SourceOverlayType ()), b (y.SourceOverlayType ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const AssociatedOverlaysType& x, const AssociatedOverlaysType& y)
  {
    return !(x == y);
  }

  // AssociationsType
  //

  AssociationsType::
  AssociationsType ()
  : ::xml_schema::type (),
    Association_ (this)
  {
  }

  AssociationsType::
  AssociationsType (const AssociationsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Association_ (x.Association_, f, this)
  {
  }

  AssociationsType::
  AssociationsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Association_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AssociationsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Association
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Association",
            "",
            &::xsd::cxx::tree::factory_impl< Association_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< Association_type > r (
            dynamic_cast< Association_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Association_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  AssociationsType* AssociationsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AssociationsType (*this, f, c);
  }

  AssociationsType& AssociationsType::
  operator= (const AssociationsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Association_ = x.Association_;
    }

    return *this;
  }

  AssociationsType::
  ~AssociationsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AssociationsType >
  _xsd_AssociationsType_type_factory_init (
    "AssociationsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, AssociationsType >
  _xsd_AssociationsType_comparison_init;

  bool
  operator== (const AssociationsType& x, const AssociationsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      AssociationsType::Association_sequence a (x.Association ()), b (y.Association ());

      if (a.size () != b.size ())
        return false;

      for (AssociationsType::Association_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const AssociationsType& x, const AssociationsType& y)
  {
    return !(x == y);
  }

  // AssociationType
  //

  AssociationType::
  AssociationType (const AffiliateHandle_type& AffiliateHandle,
                   const Relationship_type& Relationship)
  : ::xml_schema::type (),
    AffiliateHandle_ (AffiliateHandle, this),
    Relationship_ (Relationship, this)
  {
  }

  AssociationType::
  AssociationType (::std::unique_ptr< AffiliateHandle_type > AffiliateHandle,
                   ::std::unique_ptr< Relationship_type > Relationship)
  : ::xml_schema::type (),
    AffiliateHandle_ (std::move (AffiliateHandle), this),
    Relationship_ (std::move (Relationship), this)
  {
  }

  AssociationType::
  AssociationType (const AssociationType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AffiliateHandle_ (x.AffiliateHandle_, f, this),
    Relationship_ (x.Relationship_, f, this)
  {
  }

  AssociationType::
  AssociationType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AffiliateHandle_ (this),
    Relationship_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AssociationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AffiliateHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AffiliateHandle",
            "",
            &::xsd::cxx::tree::factory_impl< AffiliateHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!AffiliateHandle_.present ())
          {
            ::std::unique_ptr< AffiliateHandle_type > r (
              dynamic_cast< AffiliateHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AffiliateHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // Relationship
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Relationship",
            "",
            &::xsd::cxx::tree::factory_impl< Relationship_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Relationship_.present ())
          {
            ::std::unique_ptr< Relationship_type > r (
              dynamic_cast< Relationship_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Relationship_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!AffiliateHandle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AffiliateHandle",
        "");
    }

    if (!Relationship_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Relationship",
        "");
    }
  }

  AssociationType* AssociationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AssociationType (*this, f, c);
  }

  AssociationType& AssociationType::
  operator= (const AssociationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AffiliateHandle_ = x.AffiliateHandle_;
      this->Relationship_ = x.Relationship_;
    }

    return *this;
  }

  AssociationType::
  ~AssociationType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AssociationType >
  _xsd_AssociationType_type_factory_init (
    "AssociationType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, AssociationType >
  _xsd_AssociationType_comparison_init;

  bool
  operator== (const AssociationType& x, const AssociationType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.AffiliateHandle (), y.AffiliateHandle ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Relationship (), y.Relationship ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const AssociationType& x, const AssociationType& y)
  {
    return !(x == y);
  }

  // BoundarySymbolModifiersType
  //

  BoundarySymbolModifiersType::
  BoundarySymbolModifiersType ()
  : ::xml_schema::type (),
    Echelon_ (this),
    UniqueDesignation_ (this),
    UniqueDesignation1_ (this)
  {
  }

  BoundarySymbolModifiersType::
  BoundarySymbolModifiersType (const BoundarySymbolModifiersType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Echelon_ (x.Echelon_, f, this),
    UniqueDesignation_ (x.UniqueDesignation_, f, this),
    UniqueDesignation1_ (x.UniqueDesignation1_, f, this)
  {
  }

  BoundarySymbolModifiersType::
  BoundarySymbolModifiersType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Echelon_ (this),
    UniqueDesignation_ (this),
    UniqueDesignation1_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void BoundarySymbolModifiersType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Echelon
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Echelon",
            "",
            &::xsd::cxx::tree::factory_impl< Echelon_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Echelon_)
          {
            ::std::unique_ptr< Echelon_type > r (
              dynamic_cast< Echelon_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Echelon_.set (::std::move (r));
            continue;
          }
        }
      }

      // UniqueDesignation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UniqueDesignation",
            "",
            &::xsd::cxx::tree::factory_impl< UniqueDesignation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->UniqueDesignation_)
          {
            ::std::unique_ptr< UniqueDesignation_type > r (
              dynamic_cast< UniqueDesignation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UniqueDesignation_.set (::std::move (r));
            continue;
          }
        }
      }

      // UniqueDesignation1
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UniqueDesignation1",
            "",
            &::xsd::cxx::tree::factory_impl< UniqueDesignation1_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->UniqueDesignation1_)
          {
            ::std::unique_ptr< UniqueDesignation1_type > r (
              dynamic_cast< UniqueDesignation1_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UniqueDesignation1_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  BoundarySymbolModifiersType* BoundarySymbolModifiersType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BoundarySymbolModifiersType (*this, f, c);
  }

  BoundarySymbolModifiersType& BoundarySymbolModifiersType::
  operator= (const BoundarySymbolModifiersType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Echelon_ = x.Echelon_;
      this->UniqueDesignation_ = x.UniqueDesignation_;
      this->UniqueDesignation1_ = x.UniqueDesignation1_;
    }

    return *this;
  }

  BoundarySymbolModifiersType::
  ~BoundarySymbolModifiersType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, BoundarySymbolModifiersType >
  _xsd_BoundarySymbolModifiersType_type_factory_init (
    "BoundarySymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, BoundarySymbolModifiersType >
  _xsd_BoundarySymbolModifiersType_comparison_init;

  bool
  operator== (const BoundarySymbolModifiersType& x, const BoundarySymbolModifiersType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      BoundarySymbolModifiersType::Echelon_optional a (x.Echelon ()), b (y.Echelon ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      BoundarySymbolModifiersType::UniqueDesignation_optional a (x.UniqueDesignation ()), b (y.UniqueDesignation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      BoundarySymbolModifiersType::UniqueDesignation1_optional a (x.UniqueDesignation1 ()), b (y.UniqueDesignation1 ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const BoundarySymbolModifiersType& x, const BoundarySymbolModifiersType& y)
  {
    return !(x == y);
  }

  // CloudCoverItemsType
  //

  CloudCoverItemsType::
  CloudCoverItemsType ()
  : ::xml_schema::type (),
    CloudCover_ (this)
  {
  }

  CloudCoverItemsType::
  CloudCoverItemsType (const CloudCoverItemsType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CloudCover_ (x.CloudCover_, f, this)
  {
  }

  CloudCoverItemsType::
  CloudCoverItemsType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CloudCover_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CloudCoverItemsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CloudCover
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CloudCover",
            "",
            &::xsd::cxx::tree::factory_impl< CloudCover_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< CloudCover_type > r (
            dynamic_cast< CloudCover_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->CloudCover_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  CloudCoverItemsType* CloudCoverItemsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CloudCoverItemsType (*this, f, c);
  }

  CloudCoverItemsType& CloudCoverItemsType::
  operator= (const CloudCoverItemsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CloudCover_ = x.CloudCover_;
    }

    return *this;
  }

  CloudCoverItemsType::
  ~CloudCoverItemsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CloudCoverItemsType >
  _xsd_CloudCoverItemsType_type_factory_init (
    "CloudCoverItemsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, CloudCoverItemsType >
  _xsd_CloudCoverItemsType_comparison_init;

  bool
  operator== (const CloudCoverItemsType& x, const CloudCoverItemsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      CloudCoverItemsType::CloudCover_sequence a (x.CloudCover ()), b (y.CloudCover ());

      if (a.size () != b.size ())
        return false;

      for (CloudCoverItemsType::CloudCover_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const CloudCoverItemsType& x, const CloudCoverItemsType& y)
  {
    return !(x == y);
  }

  // CommandRelationType
  //

  CommandRelationType::
  CommandRelationType (const CommandingSuperiorHandle_type& CommandingSuperiorHandle,
                       const CommandRelationshipType_type& CommandRelationshipType)
  : ::xml_schema::type (),
    CommandingSuperiorHandle_ (CommandingSuperiorHandle, this),
    CommandRelationshipType_ (CommandRelationshipType, this)
  {
  }

  CommandRelationType::
  CommandRelationType (::std::unique_ptr< CommandingSuperiorHandle_type > CommandingSuperiorHandle,
                       ::std::unique_ptr< CommandRelationshipType_type > CommandRelationshipType)
  : ::xml_schema::type (),
    CommandingSuperiorHandle_ (std::move (CommandingSuperiorHandle), this),
    CommandRelationshipType_ (std::move (CommandRelationshipType), this)
  {
  }

  CommandRelationType::
  CommandRelationType (const CommandRelationType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CommandingSuperiorHandle_ (x.CommandingSuperiorHandle_, f, this),
    CommandRelationshipType_ (x.CommandRelationshipType_, f, this)
  {
  }

  CommandRelationType::
  CommandRelationType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CommandingSuperiorHandle_ (this),
    CommandRelationshipType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CommandRelationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CommandingSuperiorHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CommandingSuperiorHandle",
            "",
            &::xsd::cxx::tree::factory_impl< CommandingSuperiorHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!CommandingSuperiorHandle_.present ())
          {
            ::std::unique_ptr< CommandingSuperiorHandle_type > r (
              dynamic_cast< CommandingSuperiorHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CommandingSuperiorHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // CommandRelationshipType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CommandRelationshipType",
            "",
            &::xsd::cxx::tree::factory_impl< CommandRelationshipType_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!CommandRelationshipType_.present ())
          {
            ::std::unique_ptr< CommandRelationshipType_type > r (
              dynamic_cast< CommandRelationshipType_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CommandRelationshipType_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!CommandingSuperiorHandle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CommandingSuperiorHandle",
        "");
    }

    if (!CommandRelationshipType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CommandRelationshipType",
        "");
    }
  }

  CommandRelationType* CommandRelationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CommandRelationType (*this, f, c);
  }

  CommandRelationType& CommandRelationType::
  operator= (const CommandRelationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CommandingSuperiorHandle_ = x.CommandingSuperiorHandle_;
      this->CommandRelationshipType_ = x.CommandRelationshipType_;
    }

    return *this;
  }

  CommandRelationType::
  ~CommandRelationType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CommandRelationType >
  _xsd_CommandRelationType_type_factory_init (
    "CommandRelationType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, CommandRelationType >
  _xsd_CommandRelationType_comparison_init;

  bool
  operator== (const CommandRelationType& x, const CommandRelationType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.CommandingSuperiorHandle (), y.CommandingSuperiorHandle ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.CommandRelationshipType (), y.CommandRelationshipType ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const CommandRelationType& x, const CommandRelationType& y)
  {
    return !(x == y);
  }

  // CommunicationNetInstancesType
  //

  CommunicationNetInstancesType::
  CommunicationNetInstancesType ()
  : ::xml_schema::type (),
    CommunicationNetInstance_ (this)
  {
  }

  CommunicationNetInstancesType::
  CommunicationNetInstancesType (const CommunicationNetInstancesType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CommunicationNetInstance_ (x.CommunicationNetInstance_, f, this)
  {
  }

  CommunicationNetInstancesType::
  CommunicationNetInstancesType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CommunicationNetInstance_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CommunicationNetInstancesType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CommunicationNetInstance
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CommunicationNetInstance",
            "",
            &::xsd::cxx::tree::factory_impl< CommunicationNetInstance_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< CommunicationNetInstance_type > r (
            dynamic_cast< CommunicationNetInstance_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->CommunicationNetInstance_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  CommunicationNetInstancesType* CommunicationNetInstancesType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CommunicationNetInstancesType (*this, f, c);
  }

  CommunicationNetInstancesType& CommunicationNetInstancesType::
  operator= (const CommunicationNetInstancesType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CommunicationNetInstance_ = x.CommunicationNetInstance_;
    }

    return *this;
  }

  CommunicationNetInstancesType::
  ~CommunicationNetInstancesType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CommunicationNetInstancesType >
  _xsd_CommunicationNetInstancesType_type_factory_init (
    "CommunicationNetInstancesType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, CommunicationNetInstancesType >
  _xsd_CommunicationNetInstancesType_comparison_init;

  bool
  operator== (const CommunicationNetInstancesType& x, const CommunicationNetInstancesType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      CommunicationNetInstancesType::CommunicationNetInstance_sequence a (x.CommunicationNetInstance ()), b (y.CommunicationNetInstance ());

      if (a.size () != b.size ())
        return false;

      for (CommunicationNetInstancesType::CommunicationNetInstance_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const CommunicationNetInstancesType& x, const CommunicationNetInstancesType& y)
  {
    return !(x == y);
  }

  // CommunicationNetInstanceType
  //

  CommunicationNetInstanceType::
  CommunicationNetInstanceType (const CommunicationNetId_type& CommunicationNetId,
                                const CommunicationService_type& CommunicationService)
  : ::xml_schema::type (),
    CommunicationNetType_ (this),
    CommunicationNetId_ (CommunicationNetId, this),
    CommunicationService_ (CommunicationService, this)
  {
  }

  CommunicationNetInstanceType::
  CommunicationNetInstanceType (::std::unique_ptr< CommunicationNetId_type > CommunicationNetId,
                                ::std::unique_ptr< CommunicationService_type > CommunicationService)
  : ::xml_schema::type (),
    CommunicationNetType_ (this),
    CommunicationNetId_ (std::move (CommunicationNetId), this),
    CommunicationService_ (std::move (CommunicationService), this)
  {
  }

  CommunicationNetInstanceType::
  CommunicationNetInstanceType (const CommunicationNetInstanceType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CommunicationNetType_ (x.CommunicationNetType_, f, this),
    CommunicationNetId_ (x.CommunicationNetId_, f, this),
    CommunicationService_ (x.CommunicationService_, f, this)
  {
  }

  CommunicationNetInstanceType::
  CommunicationNetInstanceType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CommunicationNetType_ (this),
    CommunicationNetId_ (this),
    CommunicationService_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CommunicationNetInstanceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CommunicationNetType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CommunicationNetType",
            "",
            &::xsd::cxx::tree::factory_impl< CommunicationNetType_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CommunicationNetType_)
          {
            ::std::unique_ptr< CommunicationNetType_type > r (
              dynamic_cast< CommunicationNetType_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CommunicationNetType_.set (::std::move (r));
            continue;
          }
        }
      }

      // CommunicationNetId
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CommunicationNetId",
            "",
            &::xsd::cxx::tree::factory_impl< CommunicationNetId_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!CommunicationNetId_.present ())
          {
            ::std::unique_ptr< CommunicationNetId_type > r (
              dynamic_cast< CommunicationNetId_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CommunicationNetId_.set (::std::move (r));
            continue;
          }
        }
      }

      // CommunicationService
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CommunicationService",
            "",
            &::xsd::cxx::tree::factory_impl< CommunicationService_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!CommunicationService_.present ())
          {
            ::std::unique_ptr< CommunicationService_type > r (
              dynamic_cast< CommunicationService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CommunicationService_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!CommunicationNetId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CommunicationNetId",
        "");
    }

    if (!CommunicationService_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CommunicationService",
        "");
    }
  }

  CommunicationNetInstanceType* CommunicationNetInstanceType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CommunicationNetInstanceType (*this, f, c);
  }

  CommunicationNetInstanceType& CommunicationNetInstanceType::
  operator= (const CommunicationNetInstanceType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CommunicationNetType_ = x.CommunicationNetType_;
      this->CommunicationNetId_ = x.CommunicationNetId_;
      this->CommunicationService_ = x.CommunicationService_;
    }

    return *this;
  }

  CommunicationNetInstanceType::
  ~CommunicationNetInstanceType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CommunicationNetInstanceType >
  _xsd_CommunicationNetInstanceType_type_factory_init (
    "CommunicationNetInstanceType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, CommunicationNetInstanceType >
  _xsd_CommunicationNetInstanceType_comparison_init;

  bool
  operator== (const CommunicationNetInstanceType& x, const CommunicationNetInstanceType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      CommunicationNetInstanceType::CommunicationNetType_optional a (x.CommunicationNetType ()), b (y.CommunicationNetType ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.CommunicationNetId (), y.CommunicationNetId ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.CommunicationService (), y.CommunicationService ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const CommunicationNetInstanceType& x, const CommunicationNetInstanceType& y)
  {
    return !(x == y);
  }

  // CommunicationNetReferencesType
  //

  CommunicationNetReferencesType::
  CommunicationNetReferencesType ()
  : ::xml_schema::type (),
    CommunicationNetReference_ (this)
  {
  }

  CommunicationNetReferencesType::
  CommunicationNetReferencesType (const CommunicationNetReferencesType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CommunicationNetReference_ (x.CommunicationNetReference_, f, this)
  {
  }

  CommunicationNetReferencesType::
  CommunicationNetReferencesType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CommunicationNetReference_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CommunicationNetReferencesType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CommunicationNetReference
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CommunicationNetReference",
            "",
            &::xsd::cxx::tree::factory_impl< CommunicationNetReference_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< CommunicationNetReference_type > r (
            dynamic_cast< CommunicationNetReference_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->CommunicationNetReference_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  CommunicationNetReferencesType* CommunicationNetReferencesType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CommunicationNetReferencesType (*this, f, c);
  }

  CommunicationNetReferencesType& CommunicationNetReferencesType::
  operator= (const CommunicationNetReferencesType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CommunicationNetReference_ = x.CommunicationNetReference_;
    }

    return *this;
  }

  CommunicationNetReferencesType::
  ~CommunicationNetReferencesType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CommunicationNetReferencesType >
  _xsd_CommunicationNetReferencesType_type_factory_init (
    "CommunicationNetReferencesType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, CommunicationNetReferencesType >
  _xsd_CommunicationNetReferencesType_comparison_init;

  bool
  operator== (const CommunicationNetReferencesType& x, const CommunicationNetReferencesType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      CommunicationNetReferencesType::CommunicationNetReference_sequence a (x.CommunicationNetReference ()), b (y.CommunicationNetReference ());

      if (a.size () != b.size ())
        return false;

      for (CommunicationNetReferencesType::CommunicationNetReference_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const CommunicationNetReferencesType& x, const CommunicationNetReferencesType& y)
  {
    return !(x == y);
  }

  // CommunicationNetReferenceType
  //

  CommunicationNetReferenceType::
  CommunicationNetReferenceType (const CommunicationNetId_type& CommunicationNetId,
                                 const UnitOwnerHandle_type& UnitOwnerHandle)
  : ::xml_schema::type (),
    CommunicationNetId_ (CommunicationNetId, this),
    UnitOwnerHandle_ (UnitOwnerHandle, this)
  {
  }

  CommunicationNetReferenceType::
  CommunicationNetReferenceType (::std::unique_ptr< CommunicationNetId_type > CommunicationNetId,
                                 ::std::unique_ptr< UnitOwnerHandle_type > UnitOwnerHandle)
  : ::xml_schema::type (),
    CommunicationNetId_ (std::move (CommunicationNetId), this),
    UnitOwnerHandle_ (std::move (UnitOwnerHandle), this)
  {
  }

  CommunicationNetReferenceType::
  CommunicationNetReferenceType (const CommunicationNetReferenceType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CommunicationNetId_ (x.CommunicationNetId_, f, this),
    UnitOwnerHandle_ (x.UnitOwnerHandle_, f, this)
  {
  }

  CommunicationNetReferenceType::
  CommunicationNetReferenceType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CommunicationNetId_ (this),
    UnitOwnerHandle_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CommunicationNetReferenceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CommunicationNetId
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CommunicationNetId",
            "",
            &::xsd::cxx::tree::factory_impl< CommunicationNetId_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!CommunicationNetId_.present ())
          {
            ::std::unique_ptr< CommunicationNetId_type > r (
              dynamic_cast< CommunicationNetId_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CommunicationNetId_.set (::std::move (r));
            continue;
          }
        }
      }

      // UnitOwnerHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UnitOwnerHandle",
            "",
            &::xsd::cxx::tree::factory_impl< UnitOwnerHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!UnitOwnerHandle_.present ())
          {
            ::std::unique_ptr< UnitOwnerHandle_type > r (
              dynamic_cast< UnitOwnerHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UnitOwnerHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!CommunicationNetId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CommunicationNetId",
        "");
    }

    if (!UnitOwnerHandle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "UnitOwnerHandle",
        "");
    }
  }

  CommunicationNetReferenceType* CommunicationNetReferenceType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CommunicationNetReferenceType (*this, f, c);
  }

  CommunicationNetReferenceType& CommunicationNetReferenceType::
  operator= (const CommunicationNetReferenceType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CommunicationNetId_ = x.CommunicationNetId_;
      this->UnitOwnerHandle_ = x.UnitOwnerHandle_;
    }

    return *this;
  }

  CommunicationNetReferenceType::
  ~CommunicationNetReferenceType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CommunicationNetReferenceType >
  _xsd_CommunicationNetReferenceType_type_factory_init (
    "CommunicationNetReferenceType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, CommunicationNetReferenceType >
  _xsd_CommunicationNetReferenceType_comparison_init;

  bool
  operator== (const CommunicationNetReferenceType& x, const CommunicationNetReferenceType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.CommunicationNetId (), y.CommunicationNetId ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.UnitOwnerHandle (), y.UnitOwnerHandle ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const CommunicationNetReferenceType& x, const CommunicationNetReferenceType& y)
  {
    return !(x == y);
  }

  // CoordinateDataStandardType
  //

  CoordinateDataStandardType::
  CoordinateDataStandardType (const CoordinateSystemType_type& CoordinateSystemType,
                              const CoordinateSystemDatum_type& CoordinateSystemDatum)
  : ::xml_schema::type (),
    CoordinateSystemType_ (CoordinateSystemType, this),
    CoordinateSystemDatum_ (CoordinateSystemDatum, this)
  {
  }

  CoordinateDataStandardType::
  CoordinateDataStandardType (::std::unique_ptr< CoordinateSystemType_type > CoordinateSystemType,
                              ::std::unique_ptr< CoordinateSystemDatum_type > CoordinateSystemDatum)
  : ::xml_schema::type (),
    CoordinateSystemType_ (std::move (CoordinateSystemType), this),
    CoordinateSystemDatum_ (std::move (CoordinateSystemDatum), this)
  {
  }

  CoordinateDataStandardType::
  CoordinateDataStandardType (const CoordinateDataStandardType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CoordinateSystemType_ (x.CoordinateSystemType_, f, this),
    CoordinateSystemDatum_ (x.CoordinateSystemDatum_, f, this)
  {
  }

  CoordinateDataStandardType::
  CoordinateDataStandardType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CoordinateSystemType_ (this),
    CoordinateSystemDatum_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CoordinateDataStandardType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CoordinateSystemType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CoordinateSystemType",
            "",
            &::xsd::cxx::tree::factory_impl< CoordinateSystemType_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!CoordinateSystemType_.present ())
          {
            ::std::unique_ptr< CoordinateSystemType_type > r (
              dynamic_cast< CoordinateSystemType_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CoordinateSystemType_.set (::std::move (r));
            continue;
          }
        }
      }

      // CoordinateSystemDatum
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CoordinateSystemDatum",
            "",
            &::xsd::cxx::tree::factory_impl< CoordinateSystemDatum_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!CoordinateSystemDatum_.present ())
          {
            ::std::unique_ptr< CoordinateSystemDatum_type > r (
              dynamic_cast< CoordinateSystemDatum_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CoordinateSystemDatum_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!CoordinateSystemType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CoordinateSystemType",
        "");
    }

    if (!CoordinateSystemDatum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CoordinateSystemDatum",
        "");
    }
  }

  CoordinateDataStandardType* CoordinateDataStandardType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CoordinateDataStandardType (*this, f, c);
  }

  CoordinateDataStandardType& CoordinateDataStandardType::
  operator= (const CoordinateDataStandardType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CoordinateSystemType_ = x.CoordinateSystemType_;
      this->CoordinateSystemDatum_ = x.CoordinateSystemDatum_;
    }

    return *this;
  }

  CoordinateDataStandardType::
  ~CoordinateDataStandardType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CoordinateDataStandardType >
  _xsd_CoordinateDataStandardType_type_factory_init (
    "CoordinateDataStandardType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, CoordinateDataStandardType >
  _xsd_CoordinateDataStandardType_comparison_init;

  bool
  operator== (const CoordinateDataStandardType& x, const CoordinateDataStandardType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.CoordinateSystemType (), y.CoordinateSystemType ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.CoordinateSystemDatum (), y.CoordinateSystemDatum ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const CoordinateDataStandardType& x, const CoordinateDataStandardType& y)
  {
    return !(x == y);
  }

  // CoordinatesType
  //

  CoordinatesType::
  CoordinatesType (const CoordinateChoice_type& CoordinateChoice,
                   const CoordinateData_type& CoordinateData)
  : ::xml_schema::type (),
    CoordinateChoice_ (CoordinateChoice, this),
    CoordinateData_ (CoordinateData, this)
  {
  }

  CoordinatesType::
  CoordinatesType (const CoordinateChoice_type& CoordinateChoice,
                   ::std::unique_ptr< CoordinateData_type > CoordinateData)
  : ::xml_schema::type (),
    CoordinateChoice_ (CoordinateChoice, this),
    CoordinateData_ (std::move (CoordinateData), this)
  {
  }

  CoordinatesType::
  CoordinatesType (::std::unique_ptr< CoordinateChoice_type > CoordinateChoice,
                   ::std::unique_ptr< CoordinateData_type > CoordinateData)
  : ::xml_schema::type (),
    CoordinateChoice_ (std::move (CoordinateChoice), this),
    CoordinateData_ (std::move (CoordinateData), this)
  {
  }

  CoordinatesType::
  CoordinatesType (const CoordinatesType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CoordinateChoice_ (x.CoordinateChoice_, f, this),
    CoordinateData_ (x.CoordinateData_, f, this)
  {
  }

  CoordinatesType::
  CoordinatesType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CoordinateChoice_ (this),
    CoordinateData_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CoordinatesType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CoordinateChoice
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CoordinateChoice",
            "",
            &::xsd::cxx::tree::factory_impl< CoordinateChoice_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!CoordinateChoice_.present ())
          {
            ::std::unique_ptr< CoordinateChoice_type > r (
              dynamic_cast< CoordinateChoice_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CoordinateChoice_.set (::std::move (r));
            continue;
          }
        }
      }

      // CoordinateData
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CoordinateData",
            "",
            &::xsd::cxx::tree::factory_impl< CoordinateData_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!CoordinateData_.present ())
          {
            ::std::unique_ptr< CoordinateData_type > r (
              dynamic_cast< CoordinateData_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CoordinateData_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!CoordinateChoice_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CoordinateChoice",
        "");
    }

    if (!CoordinateData_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CoordinateData",
        "");
    }
  }

  CoordinatesType* CoordinatesType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CoordinatesType (*this, f, c);
  }

  CoordinatesType& CoordinatesType::
  operator= (const CoordinatesType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CoordinateChoice_ = x.CoordinateChoice_;
      this->CoordinateData_ = x.CoordinateData_;
    }

    return *this;
  }

  CoordinatesType::
  ~CoordinatesType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CoordinatesType >
  _xsd_CoordinatesType_type_factory_init (
    "CoordinatesType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, CoordinatesType >
  _xsd_CoordinatesType_comparison_init;

  bool
  operator== (const CoordinatesType& x, const CoordinatesType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.CoordinateChoice (), y.CoordinateChoice ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.CoordinateData (), y.CoordinateData ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const CoordinatesType& x, const CoordinatesType& y)
  {
    return !(x == y);
  }

  // CoordinatePointType
  //

  CoordinatePointType::
  CoordinatePointType ()
  : ::xml_schema::type (),
    MGRS_ (this),
    UTM_ (this),
    GDC_ (this),
    GCC_ (this)
  {
  }

  CoordinatePointType::
  CoordinatePointType (const CoordinatePointType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    MGRS_ (x.MGRS_, f, this),
    UTM_ (x.UTM_, f, this),
    GDC_ (x.GDC_, f, this),
    GCC_ (x.GCC_, f, this)
  {
  }

  CoordinatePointType::
  CoordinatePointType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    MGRS_ (this),
    UTM_ (this),
    GDC_ (this),
    GCC_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CoordinatePointType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MGRS
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MGRS",
            "",
            &::xsd::cxx::tree::factory_impl< MGRS_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MGRS_)
          {
            ::std::unique_ptr< MGRS_type > r (
              dynamic_cast< MGRS_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MGRS_.set (::std::move (r));
            continue;
          }
        }
      }

      // UTM
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UTM",
            "",
            &::xsd::cxx::tree::factory_impl< UTM_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->UTM_)
          {
            ::std::unique_ptr< UTM_type > r (
              dynamic_cast< UTM_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UTM_.set (::std::move (r));
            continue;
          }
        }
      }

      // GDC
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "GDC",
            "",
            &::xsd::cxx::tree::factory_impl< GDC_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->GDC_)
          {
            ::std::unique_ptr< GDC_type > r (
              dynamic_cast< GDC_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->GDC_.set (::std::move (r));
            continue;
          }
        }
      }

      // GCC
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "GCC",
            "",
            &::xsd::cxx::tree::factory_impl< GCC_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->GCC_)
          {
            ::std::unique_ptr< GCC_type > r (
              dynamic_cast< GCC_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->GCC_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  CoordinatePointType* CoordinatePointType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CoordinatePointType (*this, f, c);
  }

  CoordinatePointType& CoordinatePointType::
  operator= (const CoordinatePointType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->MGRS_ = x.MGRS_;
      this->UTM_ = x.UTM_;
      this->GDC_ = x.GDC_;
      this->GCC_ = x.GCC_;
    }

    return *this;
  }

  CoordinatePointType::
  ~CoordinatePointType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CoordinatePointType >
  _xsd_CoordinatePointType_type_factory_init (
    "CoordinatePointType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, CoordinatePointType >
  _xsd_CoordinatePointType_comparison_init;

  bool
  operator== (const CoordinatePointType& x, const CoordinatePointType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      CoordinatePointType::MGRS_optional a (x.MGRS ()), b (y.MGRS ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      CoordinatePointType::UTM_optional a (x.UTM ()), b (y.UTM ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      CoordinatePointType::GDC_optional a (x.GDC ()), b (y.GDC ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      CoordinatePointType::GCC_optional a (x.GCC ()), b (y.GCC ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const CoordinatePointType& x, const CoordinatePointType& y)
  {
    return !(x == y);
  }

  // EnvironmentType
  //

  EnvironmentType::
  EnvironmentType ()
  : ::xml_schema::type (),
    ScenarioTime_ (this),
    AreaOfInterest_ (this),
    ScenarioWeather_ (this),
    METOC_ (this)
  {
  }

  EnvironmentType::
  EnvironmentType (const EnvironmentType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ScenarioTime_ (x.ScenarioTime_, f, this),
    AreaOfInterest_ (x.AreaOfInterest_, f, this),
    ScenarioWeather_ (x.ScenarioWeather_, f, this),
    METOC_ (x.METOC_, f, this)
  {
  }

  EnvironmentType::
  EnvironmentType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ScenarioTime_ (this),
    AreaOfInterest_ (this),
    ScenarioWeather_ (this),
    METOC_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void EnvironmentType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ScenarioTime
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ScenarioTime",
            "",
            &::xsd::cxx::tree::factory_impl< ScenarioTime_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ScenarioTime_)
          {
            ::std::unique_ptr< ScenarioTime_type > r (
              dynamic_cast< ScenarioTime_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ScenarioTime_.set (::std::move (r));
            continue;
          }
        }
      }

      // AreaOfInterest
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AreaOfInterest",
            "",
            &::xsd::cxx::tree::factory_impl< AreaOfInterest_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AreaOfInterest_)
          {
            ::std::unique_ptr< AreaOfInterest_type > r (
              dynamic_cast< AreaOfInterest_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AreaOfInterest_.set (::std::move (r));
            continue;
          }
        }
      }

      // ScenarioWeather
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ScenarioWeather",
            "",
            &::xsd::cxx::tree::factory_impl< ScenarioWeather_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ScenarioWeather_)
          {
            ::std::unique_ptr< ScenarioWeather_type > r (
              dynamic_cast< ScenarioWeather_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ScenarioWeather_.set (::std::move (r));
            continue;
          }
        }
      }

      // METOC
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "METOC",
            "",
            &::xsd::cxx::tree::factory_impl< METOC_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->METOC_)
          {
            ::std::unique_ptr< METOC_type > r (
              dynamic_cast< METOC_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->METOC_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  EnvironmentType* EnvironmentType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EnvironmentType (*this, f, c);
  }

  EnvironmentType& EnvironmentType::
  operator= (const EnvironmentType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ScenarioTime_ = x.ScenarioTime_;
      this->AreaOfInterest_ = x.AreaOfInterest_;
      this->ScenarioWeather_ = x.ScenarioWeather_;
      this->METOC_ = x.METOC_;
    }

    return *this;
  }

  EnvironmentType::
  ~EnvironmentType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnvironmentType >
  _xsd_EnvironmentType_type_factory_init (
    "EnvironmentType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, EnvironmentType >
  _xsd_EnvironmentType_comparison_init;

  bool
  operator== (const EnvironmentType& x, const EnvironmentType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EnvironmentType::ScenarioTime_optional a (x.ScenarioTime ()), b (y.ScenarioTime ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EnvironmentType::AreaOfInterest_optional a (x.AreaOfInterest ()), b (y.AreaOfInterest ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EnvironmentType::ScenarioWeather_optional a (x.ScenarioWeather ()), b (y.ScenarioWeather ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EnvironmentType::METOC_optional a (x.METOC ()), b (y.METOC ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const EnvironmentType& x, const EnvironmentType& y)
  {
    return !(x == y);
  }

  // EquipmentDispositionType
  //

  EquipmentDispositionType::
  EquipmentDispositionType (const Location_type& Location)
  : ::xml_schema::type (),
    Location_ (Location, this),
    DirectionOfMovement_ (this),
    Speed_ (this),
    FormationPosition_ (this)
  {
  }

  EquipmentDispositionType::
  EquipmentDispositionType (::std::unique_ptr< Location_type > Location)
  : ::xml_schema::type (),
    Location_ (std::move (Location), this),
    DirectionOfMovement_ (this),
    Speed_ (this),
    FormationPosition_ (this)
  {
  }

  EquipmentDispositionType::
  EquipmentDispositionType (const EquipmentDispositionType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Location_ (x.Location_, f, this),
    DirectionOfMovement_ (x.DirectionOfMovement_, f, this),
    Speed_ (x.Speed_, f, this),
    FormationPosition_ (x.FormationPosition_, f, this)
  {
  }

  EquipmentDispositionType::
  EquipmentDispositionType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Location_ (this),
    DirectionOfMovement_ (this),
    Speed_ (this),
    FormationPosition_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void EquipmentDispositionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Location
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Location",
            "",
            &::xsd::cxx::tree::factory_impl< Location_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Location_.present ())
          {
            ::std::unique_ptr< Location_type > r (
              dynamic_cast< Location_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Location_.set (::std::move (r));
            continue;
          }
        }
      }

      // DirectionOfMovement
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DirectionOfMovement",
            "",
            &::xsd::cxx::tree::factory_impl< DirectionOfMovement_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DirectionOfMovement_)
          {
            ::std::unique_ptr< DirectionOfMovement_type > r (
              dynamic_cast< DirectionOfMovement_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DirectionOfMovement_.set (::std::move (r));
            continue;
          }
        }
      }

      // Speed
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Speed",
            "",
            &::xsd::cxx::tree::factory_impl< Speed_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Speed_)
          {
            ::std::unique_ptr< Speed_type > r (
              dynamic_cast< Speed_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Speed_.set (::std::move (r));
            continue;
          }
        }
      }

      // FormationPosition
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "FormationPosition",
            "",
            &::xsd::cxx::tree::factory_impl< FormationPosition_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->FormationPosition_)
          {
            ::std::unique_ptr< FormationPosition_type > r (
              dynamic_cast< FormationPosition_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FormationPosition_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Location_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Location",
        "");
    }
  }

  EquipmentDispositionType* EquipmentDispositionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EquipmentDispositionType (*this, f, c);
  }

  EquipmentDispositionType& EquipmentDispositionType::
  operator= (const EquipmentDispositionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Location_ = x.Location_;
      this->DirectionOfMovement_ = x.DirectionOfMovement_;
      this->Speed_ = x.Speed_;
      this->FormationPosition_ = x.FormationPosition_;
    }

    return *this;
  }

  EquipmentDispositionType::
  ~EquipmentDispositionType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EquipmentDispositionType >
  _xsd_EquipmentDispositionType_type_factory_init (
    "EquipmentDispositionType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, EquipmentDispositionType >
  _xsd_EquipmentDispositionType_comparison_init;

  bool
  operator== (const EquipmentDispositionType& x, const EquipmentDispositionType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Location (), y.Location ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentDispositionType::DirectionOfMovement_optional a (x.DirectionOfMovement ()), b (y.DirectionOfMovement ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentDispositionType::Speed_optional a (x.Speed ()), b (y.Speed ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentDispositionType::FormationPosition_optional a (x.FormationPosition ()), b (y.FormationPosition ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const EquipmentDispositionType& x, const EquipmentDispositionType& y)
  {
    return !(x == y);
  }

  // EquipmentItemType
  //

  EquipmentItemType::
  EquipmentItemType (const ObjectHandle_type& ObjectHandle,
                     const SymbolIdentifier_type& SymbolIdentifier,
                     const Disposition_type& Disposition,
                     const Relations_type& Relations)
  : ::xml_schema::type (),
    ObjectHandle_ (ObjectHandle, this),
    SymbolIdentifier_ (SymbolIdentifier, this),
    Name_ (this),
    EquipmentSymbolModifiers_ (this),
    CommunicationNetReferences_ (this),
    Disposition_ (Disposition, this),
    Relations_ (Relations, this),
    Model_ (this)
  {
  }

  EquipmentItemType::
  EquipmentItemType (const ObjectHandle_type& ObjectHandle,
                     const SymbolIdentifier_type& SymbolIdentifier,
                     ::std::unique_ptr< Disposition_type > Disposition,
                     ::std::unique_ptr< Relations_type > Relations)
  : ::xml_schema::type (),
    ObjectHandle_ (ObjectHandle, this),
    SymbolIdentifier_ (SymbolIdentifier, this),
    Name_ (this),
    EquipmentSymbolModifiers_ (this),
    CommunicationNetReferences_ (this),
    Disposition_ (std::move (Disposition), this),
    Relations_ (std::move (Relations), this),
    Model_ (this)
  {
  }

  EquipmentItemType::
  EquipmentItemType (::std::unique_ptr< ObjectHandle_type > ObjectHandle,
                     ::std::unique_ptr< SymbolIdentifier_type > SymbolIdentifier,
                     ::std::unique_ptr< Disposition_type > Disposition,
                     ::std::unique_ptr< Relations_type > Relations)
  : ::xml_schema::type (),
    ObjectHandle_ (std::move (ObjectHandle), this),
    SymbolIdentifier_ (std::move (SymbolIdentifier), this),
    Name_ (this),
    EquipmentSymbolModifiers_ (this),
    CommunicationNetReferences_ (this),
    Disposition_ (std::move (Disposition), this),
    Relations_ (std::move (Relations), this),
    Model_ (this)
  {
  }

  EquipmentItemType::
  EquipmentItemType (const EquipmentItemType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ObjectHandle_ (x.ObjectHandle_, f, this),
    SymbolIdentifier_ (x.SymbolIdentifier_, f, this),
    Name_ (x.Name_, f, this),
    EquipmentSymbolModifiers_ (x.EquipmentSymbolModifiers_, f, this),
    CommunicationNetReferences_ (x.CommunicationNetReferences_, f, this),
    Disposition_ (x.Disposition_, f, this),
    Relations_ (x.Relations_, f, this),
    Model_ (x.Model_, f, this)
  {
  }

  EquipmentItemType::
  EquipmentItemType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ObjectHandle_ (this),
    SymbolIdentifier_ (this),
    Name_ (this),
    EquipmentSymbolModifiers_ (this),
    CommunicationNetReferences_ (this),
    Disposition_ (this),
    Relations_ (this),
    Model_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void EquipmentItemType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ObjectHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ObjectHandle",
            "",
            &::xsd::cxx::tree::factory_impl< ObjectHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ObjectHandle_.present ())
          {
            ::std::unique_ptr< ObjectHandle_type > r (
              dynamic_cast< ObjectHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ObjectHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // SymbolIdentifier
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SymbolIdentifier",
            "",
            &::xsd::cxx::tree::factory_impl< SymbolIdentifier_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!SymbolIdentifier_.present ())
          {
            ::std::unique_ptr< SymbolIdentifier_type > r (
              dynamic_cast< SymbolIdentifier_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SymbolIdentifier_.set (::std::move (r));
            continue;
          }
        }
      }

      // Name
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Name",
            "",
            &::xsd::cxx::tree::factory_impl< Name_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Name_)
          {
            ::std::unique_ptr< Name_type > r (
              dynamic_cast< Name_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Name_.set (::std::move (r));
            continue;
          }
        }
      }

      // EquipmentSymbolModifiers
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "EquipmentSymbolModifiers",
            "",
            &::xsd::cxx::tree::factory_impl< EquipmentSymbolModifiers_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->EquipmentSymbolModifiers_)
          {
            ::std::unique_ptr< EquipmentSymbolModifiers_type > r (
              dynamic_cast< EquipmentSymbolModifiers_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->EquipmentSymbolModifiers_.set (::std::move (r));
            continue;
          }
        }
      }

      // CommunicationNetReferences
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CommunicationNetReferences",
            "",
            &::xsd::cxx::tree::factory_impl< CommunicationNetReferences_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CommunicationNetReferences_)
          {
            ::std::unique_ptr< CommunicationNetReferences_type > r (
              dynamic_cast< CommunicationNetReferences_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CommunicationNetReferences_.set (::std::move (r));
            continue;
          }
        }
      }

      // Disposition
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Disposition",
            "",
            &::xsd::cxx::tree::factory_impl< Disposition_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Disposition_.present ())
          {
            ::std::unique_ptr< Disposition_type > r (
              dynamic_cast< Disposition_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Disposition_.set (::std::move (r));
            continue;
          }
        }
      }

      // Relations
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Relations",
            "",
            &::xsd::cxx::tree::factory_impl< Relations_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Relations_.present ())
          {
            ::std::unique_ptr< Relations_type > r (
              dynamic_cast< Relations_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Relations_.set (::std::move (r));
            continue;
          }
        }
      }

      // Model
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Model",
            "",
            &::xsd::cxx::tree::factory_impl< Model_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Model_)
          {
            ::std::unique_ptr< Model_type > r (
              dynamic_cast< Model_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Model_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ObjectHandle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ObjectHandle",
        "");
    }

    if (!SymbolIdentifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SymbolIdentifier",
        "");
    }

    if (!Disposition_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Disposition",
        "");
    }

    if (!Relations_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Relations",
        "");
    }
  }

  EquipmentItemType* EquipmentItemType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EquipmentItemType (*this, f, c);
  }

  EquipmentItemType& EquipmentItemType::
  operator= (const EquipmentItemType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ObjectHandle_ = x.ObjectHandle_;
      this->SymbolIdentifier_ = x.SymbolIdentifier_;
      this->Name_ = x.Name_;
      this->EquipmentSymbolModifiers_ = x.EquipmentSymbolModifiers_;
      this->CommunicationNetReferences_ = x.CommunicationNetReferences_;
      this->Disposition_ = x.Disposition_;
      this->Relations_ = x.Relations_;
      this->Model_ = x.Model_;
    }

    return *this;
  }

  EquipmentItemType::
  ~EquipmentItemType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EquipmentItemType >
  _xsd_EquipmentItemType_type_factory_init (
    "EquipmentItemType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, EquipmentItemType >
  _xsd_EquipmentItemType_comparison_init;

  bool
  operator== (const EquipmentItemType& x, const EquipmentItemType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ObjectHandle (), y.ObjectHandle ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.SymbolIdentifier (), y.SymbolIdentifier ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentItemType::Name_optional a (x.Name ()), b (y.Name ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentItemType::EquipmentSymbolModifiers_optional a (x.EquipmentSymbolModifiers ()), b (y.EquipmentSymbolModifiers ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentItemType::CommunicationNetReferences_optional a (x.CommunicationNetReferences ()), b (y.CommunicationNetReferences ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Disposition (), y.Disposition ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Relations (), y.Relations ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentItemType::Model_optional a (x.Model ()), b (y.Model ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const EquipmentItemType& x, const EquipmentItemType& y)
  {
    return !(x == y);
  }

  // EquipmentModelType
  //

  EquipmentModelType::
  EquipmentModelType (const Resolution_type& Resolution)
  : ::xml_schema::type (),
    Resolution_ (Resolution, this)
  {
  }

  EquipmentModelType::
  EquipmentModelType (::std::unique_ptr< Resolution_type > Resolution)
  : ::xml_schema::type (),
    Resolution_ (std::move (Resolution), this)
  {
  }

  EquipmentModelType::
  EquipmentModelType (const EquipmentModelType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Resolution_ (x.Resolution_, f, this)
  {
  }

  EquipmentModelType::
  EquipmentModelType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Resolution_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void EquipmentModelType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Resolution
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Resolution",
            "",
            &::xsd::cxx::tree::factory_impl< Resolution_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Resolution_.present ())
          {
            ::std::unique_ptr< Resolution_type > r (
              dynamic_cast< Resolution_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Resolution_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Resolution_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Resolution",
        "");
    }
  }

  EquipmentModelType* EquipmentModelType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EquipmentModelType (*this, f, c);
  }

  EquipmentModelType& EquipmentModelType::
  operator= (const EquipmentModelType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Resolution_ = x.Resolution_;
    }

    return *this;
  }

  EquipmentModelType::
  ~EquipmentModelType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EquipmentModelType >
  _xsd_EquipmentModelType_type_factory_init (
    "EquipmentModelType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, EquipmentModelType >
  _xsd_EquipmentModelType_comparison_init;

  bool
  operator== (const EquipmentModelType& x, const EquipmentModelType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Resolution (), y.Resolution ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const EquipmentModelType& x, const EquipmentModelType& y)
  {
    return !(x == y);
  }

  // EquipmentRelationsType
  //

  EquipmentRelationsType::
  EquipmentRelationsType (const HoldingOrganization_type& HoldingOrganization)
  : ::xml_schema::type (),
    OrganicSuperiorHandle_ (this),
    HoldingOrganization_ (HoldingOrganization, this)
  {
  }

  EquipmentRelationsType::
  EquipmentRelationsType (::std::unique_ptr< HoldingOrganization_type > HoldingOrganization)
  : ::xml_schema::type (),
    OrganicSuperiorHandle_ (this),
    HoldingOrganization_ (std::move (HoldingOrganization), this)
  {
  }

  EquipmentRelationsType::
  EquipmentRelationsType (const EquipmentRelationsType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    OrganicSuperiorHandle_ (x.OrganicSuperiorHandle_, f, this),
    HoldingOrganization_ (x.HoldingOrganization_, f, this)
  {
  }

  EquipmentRelationsType::
  EquipmentRelationsType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    OrganicSuperiorHandle_ (this),
    HoldingOrganization_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void EquipmentRelationsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OrganicSuperiorHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OrganicSuperiorHandle",
            "",
            &::xsd::cxx::tree::factory_impl< OrganicSuperiorHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->OrganicSuperiorHandle_)
          {
            ::std::unique_ptr< OrganicSuperiorHandle_type > r (
              dynamic_cast< OrganicSuperiorHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OrganicSuperiorHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // HoldingOrganization
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HoldingOrganization",
            "",
            &::xsd::cxx::tree::factory_impl< HoldingOrganization_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!HoldingOrganization_.present ())
          {
            ::std::unique_ptr< HoldingOrganization_type > r (
              dynamic_cast< HoldingOrganization_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->HoldingOrganization_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!HoldingOrganization_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HoldingOrganization",
        "");
    }
  }

  EquipmentRelationsType* EquipmentRelationsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EquipmentRelationsType (*this, f, c);
  }

  EquipmentRelationsType& EquipmentRelationsType::
  operator= (const EquipmentRelationsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->OrganicSuperiorHandle_ = x.OrganicSuperiorHandle_;
      this->HoldingOrganization_ = x.HoldingOrganization_;
    }

    return *this;
  }

  EquipmentRelationsType::
  ~EquipmentRelationsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EquipmentRelationsType >
  _xsd_EquipmentRelationsType_type_factory_init (
    "EquipmentRelationsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, EquipmentRelationsType >
  _xsd_EquipmentRelationsType_comparison_init;

  bool
  operator== (const EquipmentRelationsType& x, const EquipmentRelationsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentRelationsType::OrganicSuperiorHandle_optional a (x.OrganicSuperiorHandle ()), b (y.OrganicSuperiorHandle ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.HoldingOrganization (), y.HoldingOrganization ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const EquipmentRelationsType& x, const EquipmentRelationsType& y)
  {
    return !(x == y);
  }

  // EquipmentSymbolModifiersType
  //

  EquipmentSymbolModifiersType::
  EquipmentSymbolModifiersType (const UniqueDesignation_type& UniqueDesignation)
  : ::xml_schema::type (),
    Quantity_ (this),
    StaffComments_ (this),
    AdditionalInfo_ (this),
    CombatEffectiveness_ (this),
    IFF_ (this),
    UniqueDesignation_ (UniqueDesignation, this),
    EquipmentType_ (this),
    TowedSonarArray_ (this)
  {
  }

  EquipmentSymbolModifiersType::
  EquipmentSymbolModifiersType (::std::unique_ptr< UniqueDesignation_type > UniqueDesignation)
  : ::xml_schema::type (),
    Quantity_ (this),
    StaffComments_ (this),
    AdditionalInfo_ (this),
    CombatEffectiveness_ (this),
    IFF_ (this),
    UniqueDesignation_ (std::move (UniqueDesignation), this),
    EquipmentType_ (this),
    TowedSonarArray_ (this)
  {
  }

  EquipmentSymbolModifiersType::
  EquipmentSymbolModifiersType (const EquipmentSymbolModifiersType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Quantity_ (x.Quantity_, f, this),
    StaffComments_ (x.StaffComments_, f, this),
    AdditionalInfo_ (x.AdditionalInfo_, f, this),
    CombatEffectiveness_ (x.CombatEffectiveness_, f, this),
    IFF_ (x.IFF_, f, this),
    UniqueDesignation_ (x.UniqueDesignation_, f, this),
    EquipmentType_ (x.EquipmentType_, f, this),
    TowedSonarArray_ (x.TowedSonarArray_, f, this)
  {
  }

  EquipmentSymbolModifiersType::
  EquipmentSymbolModifiersType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Quantity_ (this),
    StaffComments_ (this),
    AdditionalInfo_ (this),
    CombatEffectiveness_ (this),
    IFF_ (this),
    UniqueDesignation_ (this),
    EquipmentType_ (this),
    TowedSonarArray_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void EquipmentSymbolModifiersType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Quantity
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Quantity",
            "",
            &::xsd::cxx::tree::factory_impl< Quantity_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Quantity_)
          {
            ::std::unique_ptr< Quantity_type > r (
              dynamic_cast< Quantity_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Quantity_.set (::std::move (r));
            continue;
          }
        }
      }

      // StaffComments
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "StaffComments",
            "",
            &::xsd::cxx::tree::factory_impl< StaffComments_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->StaffComments_)
          {
            ::std::unique_ptr< StaffComments_type > r (
              dynamic_cast< StaffComments_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->StaffComments_.set (::std::move (r));
            continue;
          }
        }
      }

      // AdditionalInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AdditionalInfo",
            "",
            &::xsd::cxx::tree::factory_impl< AdditionalInfo_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AdditionalInfo_)
          {
            ::std::unique_ptr< AdditionalInfo_type > r (
              dynamic_cast< AdditionalInfo_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AdditionalInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      // CombatEffectiveness
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CombatEffectiveness",
            "",
            &::xsd::cxx::tree::factory_impl< CombatEffectiveness_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CombatEffectiveness_)
          {
            ::std::unique_ptr< CombatEffectiveness_type > r (
              dynamic_cast< CombatEffectiveness_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CombatEffectiveness_.set (::std::move (r));
            continue;
          }
        }
      }

      // IFF
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "IFF",
            "",
            &::xsd::cxx::tree::factory_impl< IFF_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->IFF_)
          {
            ::std::unique_ptr< IFF_type > r (
              dynamic_cast< IFF_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->IFF_.set (::std::move (r));
            continue;
          }
        }
      }

      // UniqueDesignation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UniqueDesignation",
            "",
            &::xsd::cxx::tree::factory_impl< UniqueDesignation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!UniqueDesignation_.present ())
          {
            ::std::unique_ptr< UniqueDesignation_type > r (
              dynamic_cast< UniqueDesignation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UniqueDesignation_.set (::std::move (r));
            continue;
          }
        }
      }

      // EquipmentType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "EquipmentType",
            "",
            &::xsd::cxx::tree::factory_impl< EquipmentType_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->EquipmentType_)
          {
            ::std::unique_ptr< EquipmentType_type > r (
              dynamic_cast< EquipmentType_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->EquipmentType_.set (::std::move (r));
            continue;
          }
        }
      }

      // TowedSonarArray
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TowedSonarArray",
            "",
            &::xsd::cxx::tree::factory_impl< TowedSonarArray_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->TowedSonarArray_)
          {
            ::std::unique_ptr< TowedSonarArray_type > r (
              dynamic_cast< TowedSonarArray_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->TowedSonarArray_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!UniqueDesignation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "UniqueDesignation",
        "");
    }
  }

  EquipmentSymbolModifiersType* EquipmentSymbolModifiersType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EquipmentSymbolModifiersType (*this, f, c);
  }

  EquipmentSymbolModifiersType& EquipmentSymbolModifiersType::
  operator= (const EquipmentSymbolModifiersType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Quantity_ = x.Quantity_;
      this->StaffComments_ = x.StaffComments_;
      this->AdditionalInfo_ = x.AdditionalInfo_;
      this->CombatEffectiveness_ = x.CombatEffectiveness_;
      this->IFF_ = x.IFF_;
      this->UniqueDesignation_ = x.UniqueDesignation_;
      this->EquipmentType_ = x.EquipmentType_;
      this->TowedSonarArray_ = x.TowedSonarArray_;
    }

    return *this;
  }

  EquipmentSymbolModifiersType::
  ~EquipmentSymbolModifiersType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EquipmentSymbolModifiersType >
  _xsd_EquipmentSymbolModifiersType_type_factory_init (
    "EquipmentSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, EquipmentSymbolModifiersType >
  _xsd_EquipmentSymbolModifiersType_comparison_init;

  bool
  operator== (const EquipmentSymbolModifiersType& x, const EquipmentSymbolModifiersType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentSymbolModifiersType::Quantity_optional a (x.Quantity ()), b (y.Quantity ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentSymbolModifiersType::StaffComments_optional a (x.StaffComments ()), b (y.StaffComments ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentSymbolModifiersType::AdditionalInfo_optional a (x.AdditionalInfo ()), b (y.AdditionalInfo ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentSymbolModifiersType::CombatEffectiveness_optional a (x.CombatEffectiveness ()), b (y.CombatEffectiveness ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentSymbolModifiersType::IFF_optional a (x.IFF ()), b (y.IFF ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.UniqueDesignation (), y.UniqueDesignation ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentSymbolModifiersType::EquipmentType_optional a (x.EquipmentType ()), b (y.EquipmentType ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentSymbolModifiersType::TowedSonarArray_optional a (x.TowedSonarArray ()), b (y.TowedSonarArray ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const EquipmentSymbolModifiersType& x, const EquipmentSymbolModifiersType& y)
  {
    return !(x == y);
  }

  // EquipmentType
  //

  EquipmentType::
  EquipmentType ()
  : ::xml_schema::type (),
    EquipmentItem_ (this)
  {
  }

  EquipmentType::
  EquipmentType (const EquipmentType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    EquipmentItem_ (x.EquipmentItem_, f, this)
  {
  }

  EquipmentType::
  EquipmentType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    EquipmentItem_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void EquipmentType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EquipmentItem
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "EquipmentItem",
            "",
            &::xsd::cxx::tree::factory_impl< EquipmentItem_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< EquipmentItem_type > r (
            dynamic_cast< EquipmentItem_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->EquipmentItem_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  EquipmentType* EquipmentType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EquipmentType (*this, f, c);
  }

  EquipmentType& EquipmentType::
  operator= (const EquipmentType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->EquipmentItem_ = x.EquipmentItem_;
    }

    return *this;
  }

  EquipmentType::
  ~EquipmentType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EquipmentType >
  _xsd_EquipmentType_type_factory_init (
    "EquipmentType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, EquipmentType >
  _xsd_EquipmentType_comparison_init;

  bool
  operator== (const EquipmentType& x, const EquipmentType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      EquipmentType::EquipmentItem_sequence a (x.EquipmentItem ()), b (y.EquipmentItem ());

      if (a.size () != b.size ())
        return false;

      for (EquipmentType::EquipmentItem_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const EquipmentType& x, const EquipmentType& y)
  {
    return !(x == y);
  }

  // ForceRelationDataType
  //

  ForceRelationDataType::
  ForceRelationDataType ()
  : ::xml_schema::type (),
    CommandRelation_ (this),
    ForceSideHandle_ (this)
  {
  }

  ForceRelationDataType::
  ForceRelationDataType (const ForceRelationDataType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CommandRelation_ (x.CommandRelation_, f, this),
    ForceSideHandle_ (x.ForceSideHandle_, f, this)
  {
  }

  ForceRelationDataType::
  ForceRelationDataType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CommandRelation_ (this),
    ForceSideHandle_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ForceRelationDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CommandRelation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CommandRelation",
            "",
            &::xsd::cxx::tree::factory_impl< CommandRelation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CommandRelation_)
          {
            ::std::unique_ptr< CommandRelation_type > r (
              dynamic_cast< CommandRelation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CommandRelation_.set (::std::move (r));
            continue;
          }
        }
      }

      // ForceSideHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ForceSideHandle",
            "",
            &::xsd::cxx::tree::factory_impl< ForceSideHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ForceSideHandle_)
          {
            ::std::unique_ptr< ForceSideHandle_type > r (
              dynamic_cast< ForceSideHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ForceSideHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  ForceRelationDataType* ForceRelationDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ForceRelationDataType (*this, f, c);
  }

  ForceRelationDataType& ForceRelationDataType::
  operator= (const ForceRelationDataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CommandRelation_ = x.CommandRelation_;
      this->ForceSideHandle_ = x.ForceSideHandle_;
    }

    return *this;
  }

  ForceRelationDataType::
  ~ForceRelationDataType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ForceRelationDataType >
  _xsd_ForceRelationDataType_type_factory_init (
    "ForceRelationDataType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, ForceRelationDataType >
  _xsd_ForceRelationDataType_comparison_init;

  bool
  operator== (const ForceRelationDataType& x, const ForceRelationDataType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      ForceRelationDataType::CommandRelation_optional a (x.CommandRelation ()), b (y.CommandRelation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      ForceRelationDataType::ForceSideHandle_optional a (x.ForceSideHandle ()), b (y.ForceSideHandle ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const ForceRelationDataType& x, const ForceRelationDataType& y)
  {
    return !(x == y);
  }

  // ForceRelationType
  //

  ForceRelationType::
  ForceRelationType (const ForceRelationChoice_type& ForceRelationChoice,
                     const ForceRelationData_type& ForceRelationData)
  : ::xml_schema::type (),
    ForceRelationChoice_ (ForceRelationChoice, this),
    ForceRelationData_ (ForceRelationData, this)
  {
  }

  ForceRelationType::
  ForceRelationType (const ForceRelationChoice_type& ForceRelationChoice,
                     ::std::unique_ptr< ForceRelationData_type > ForceRelationData)
  : ::xml_schema::type (),
    ForceRelationChoice_ (ForceRelationChoice, this),
    ForceRelationData_ (std::move (ForceRelationData), this)
  {
  }

  ForceRelationType::
  ForceRelationType (::std::unique_ptr< ForceRelationChoice_type > ForceRelationChoice,
                     ::std::unique_ptr< ForceRelationData_type > ForceRelationData)
  : ::xml_schema::type (),
    ForceRelationChoice_ (std::move (ForceRelationChoice), this),
    ForceRelationData_ (std::move (ForceRelationData), this)
  {
  }

  ForceRelationType::
  ForceRelationType (const ForceRelationType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ForceRelationChoice_ (x.ForceRelationChoice_, f, this),
    ForceRelationData_ (x.ForceRelationData_, f, this)
  {
  }

  ForceRelationType::
  ForceRelationType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ForceRelationChoice_ (this),
    ForceRelationData_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ForceRelationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ForceRelationChoice
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ForceRelationChoice",
            "",
            &::xsd::cxx::tree::factory_impl< ForceRelationChoice_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ForceRelationChoice_.present ())
          {
            ::std::unique_ptr< ForceRelationChoice_type > r (
              dynamic_cast< ForceRelationChoice_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ForceRelationChoice_.set (::std::move (r));
            continue;
          }
        }
      }

      // ForceRelationData
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ForceRelationData",
            "",
            &::xsd::cxx::tree::factory_impl< ForceRelationData_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ForceRelationData_.present ())
          {
            ::std::unique_ptr< ForceRelationData_type > r (
              dynamic_cast< ForceRelationData_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ForceRelationData_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ForceRelationChoice_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ForceRelationChoice",
        "");
    }

    if (!ForceRelationData_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ForceRelationData",
        "");
    }
  }

  ForceRelationType* ForceRelationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ForceRelationType (*this, f, c);
  }

  ForceRelationType& ForceRelationType::
  operator= (const ForceRelationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ForceRelationChoice_ = x.ForceRelationChoice_;
      this->ForceRelationData_ = x.ForceRelationData_;
    }

    return *this;
  }

  ForceRelationType::
  ~ForceRelationType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ForceRelationType >
  _xsd_ForceRelationType_type_factory_init (
    "ForceRelationType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, ForceRelationType >
  _xsd_ForceRelationType_comparison_init;

  bool
  operator== (const ForceRelationType& x, const ForceRelationType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ForceRelationChoice (), y.ForceRelationChoice ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ForceRelationData (), y.ForceRelationData ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const ForceRelationType& x, const ForceRelationType& y)
  {
    return !(x == y);
  }

  // ForceSidesType
  //

  ForceSidesType::
  ForceSidesType ()
  : ::xml_schema::type (),
    ForceSide_ (this)
  {
  }

  ForceSidesType::
  ForceSidesType (const ForceSidesType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ForceSide_ (x.ForceSide_, f, this)
  {
  }

  ForceSidesType::
  ForceSidesType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ForceSide_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ForceSidesType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ForceSide
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ForceSide",
            "",
            &::xsd::cxx::tree::factory_impl< ForceSide_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ForceSide_type > r (
            dynamic_cast< ForceSide_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ForceSide_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ForceSidesType* ForceSidesType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ForceSidesType (*this, f, c);
  }

  ForceSidesType& ForceSidesType::
  operator= (const ForceSidesType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ForceSide_ = x.ForceSide_;
    }

    return *this;
  }

  ForceSidesType::
  ~ForceSidesType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ForceSidesType >
  _xsd_ForceSidesType_type_factory_init (
    "ForceSidesType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, ForceSidesType >
  _xsd_ForceSidesType_comparison_init;

  bool
  operator== (const ForceSidesType& x, const ForceSidesType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      ForceSidesType::ForceSide_sequence a (x.ForceSide ()), b (y.ForceSide ());

      if (a.size () != b.size ())
        return false;

      for (ForceSidesType::ForceSide_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const ForceSidesType& x, const ForceSidesType& y)
  {
    return !(x == y);
  }

  // ForceSideType
  //

  ForceSideType::
  ForceSideType (const ObjectHandle_type& ObjectHandle,
                 const ForceSideName_type& ForceSideName)
  : ::xml_schema::type (),
    ObjectHandle_ (ObjectHandle, this),
    ForceSideName_ (ForceSideName, this),
    AllegianceHandle_ (this),
    MilitaryService_ (this),
    CountryCode_ (this),
    Associations_ (this)
  {
  }

  ForceSideType::
  ForceSideType (::std::unique_ptr< ObjectHandle_type > ObjectHandle,
                 ::std::unique_ptr< ForceSideName_type > ForceSideName)
  : ::xml_schema::type (),
    ObjectHandle_ (std::move (ObjectHandle), this),
    ForceSideName_ (std::move (ForceSideName), this),
    AllegianceHandle_ (this),
    MilitaryService_ (this),
    CountryCode_ (this),
    Associations_ (this)
  {
  }

  ForceSideType::
  ForceSideType (const ForceSideType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ObjectHandle_ (x.ObjectHandle_, f, this),
    ForceSideName_ (x.ForceSideName_, f, this),
    AllegianceHandle_ (x.AllegianceHandle_, f, this),
    MilitaryService_ (x.MilitaryService_, f, this),
    CountryCode_ (x.CountryCode_, f, this),
    Associations_ (x.Associations_, f, this)
  {
  }

  ForceSideType::
  ForceSideType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ObjectHandle_ (this),
    ForceSideName_ (this),
    AllegianceHandle_ (this),
    MilitaryService_ (this),
    CountryCode_ (this),
    Associations_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ForceSideType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ObjectHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ObjectHandle",
            "",
            &::xsd::cxx::tree::factory_impl< ObjectHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ObjectHandle_.present ())
          {
            ::std::unique_ptr< ObjectHandle_type > r (
              dynamic_cast< ObjectHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ObjectHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // ForceSideName
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ForceSideName",
            "",
            &::xsd::cxx::tree::factory_impl< ForceSideName_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ForceSideName_.present ())
          {
            ::std::unique_ptr< ForceSideName_type > r (
              dynamic_cast< ForceSideName_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ForceSideName_.set (::std::move (r));
            continue;
          }
        }
      }

      // AllegianceHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AllegianceHandle",
            "",
            &::xsd::cxx::tree::factory_impl< AllegianceHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AllegianceHandle_)
          {
            ::std::unique_ptr< AllegianceHandle_type > r (
              dynamic_cast< AllegianceHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AllegianceHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // MilitaryService
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MilitaryService",
            "",
            &::xsd::cxx::tree::factory_impl< MilitaryService_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MilitaryService_)
          {
            ::std::unique_ptr< MilitaryService_type > r (
              dynamic_cast< MilitaryService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MilitaryService_.set (::std::move (r));
            continue;
          }
        }
      }

      // CountryCode
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CountryCode",
            "",
            &::xsd::cxx::tree::factory_impl< CountryCode_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CountryCode_)
          {
            ::std::unique_ptr< CountryCode_type > r (
              dynamic_cast< CountryCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CountryCode_.set (::std::move (r));
            continue;
          }
        }
      }

      // Associations
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Associations",
            "",
            &::xsd::cxx::tree::factory_impl< Associations_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Associations_)
          {
            ::std::unique_ptr< Associations_type > r (
              dynamic_cast< Associations_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Associations_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ObjectHandle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ObjectHandle",
        "");
    }

    if (!ForceSideName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ForceSideName",
        "");
    }
  }

  ForceSideType* ForceSideType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ForceSideType (*this, f, c);
  }

  ForceSideType& ForceSideType::
  operator= (const ForceSideType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ObjectHandle_ = x.ObjectHandle_;
      this->ForceSideName_ = x.ForceSideName_;
      this->AllegianceHandle_ = x.AllegianceHandle_;
      this->MilitaryService_ = x.MilitaryService_;
      this->CountryCode_ = x.CountryCode_;
      this->Associations_ = x.Associations_;
    }

    return *this;
  }

  ForceSideType::
  ~ForceSideType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ForceSideType >
  _xsd_ForceSideType_type_factory_init (
    "ForceSideType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, ForceSideType >
  _xsd_ForceSideType_comparison_init;

  bool
  operator== (const ForceSideType& x, const ForceSideType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ObjectHandle (), y.ObjectHandle ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ForceSideName (), y.ForceSideName ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      ForceSideType::AllegianceHandle_optional a (x.AllegianceHandle ()), b (y.AllegianceHandle ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      ForceSideType::MilitaryService_optional a (x.MilitaryService ()), b (y.MilitaryService ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      ForceSideType::CountryCode_optional a (x.CountryCode ()), b (y.CountryCode ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      ForceSideType::Associations_optional a (x.Associations ()), b (y.Associations ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const ForceSideType& x, const ForceSideType& y)
  {
    return !(x == y);
  }

  // FormationDataType
  //

  FormationDataType::
  FormationDataType ()
  : ::xml_schema::type (),
    GroundFormationType_ (this),
    AirFormationType_ (this),
    SurfaceFomationType_ (this),
    SubsurfaceFormationType_ (this)
  {
  }

  FormationDataType::
  FormationDataType (const FormationDataType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    GroundFormationType_ (x.GroundFormationType_, f, this),
    AirFormationType_ (x.AirFormationType_, f, this),
    SurfaceFomationType_ (x.SurfaceFomationType_, f, this),
    SubsurfaceFormationType_ (x.SubsurfaceFormationType_, f, this)
  {
  }

  FormationDataType::
  FormationDataType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    GroundFormationType_ (this),
    AirFormationType_ (this),
    SurfaceFomationType_ (this),
    SubsurfaceFormationType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FormationDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // GroundFormationType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "GroundFormationType",
            "",
            &::xsd::cxx::tree::factory_impl< GroundFormationType_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->GroundFormationType_)
          {
            ::std::unique_ptr< GroundFormationType_type > r (
              dynamic_cast< GroundFormationType_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->GroundFormationType_.set (::std::move (r));
            continue;
          }
        }
      }

      // AirFormationType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AirFormationType",
            "",
            &::xsd::cxx::tree::factory_impl< AirFormationType_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AirFormationType_)
          {
            ::std::unique_ptr< AirFormationType_type > r (
              dynamic_cast< AirFormationType_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AirFormationType_.set (::std::move (r));
            continue;
          }
        }
      }

      // SurfaceFomationType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SurfaceFomationType",
            "",
            &::xsd::cxx::tree::factory_impl< SurfaceFomationType_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SurfaceFomationType_)
          {
            ::std::unique_ptr< SurfaceFomationType_type > r (
              dynamic_cast< SurfaceFomationType_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SurfaceFomationType_.set (::std::move (r));
            continue;
          }
        }
      }

      // SubsurfaceFormationType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SubsurfaceFormationType",
            "",
            &::xsd::cxx::tree::factory_impl< SubsurfaceFormationType_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SubsurfaceFormationType_)
          {
            ::std::unique_ptr< SubsurfaceFormationType_type > r (
              dynamic_cast< SubsurfaceFormationType_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SubsurfaceFormationType_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  FormationDataType* FormationDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FormationDataType (*this, f, c);
  }

  FormationDataType& FormationDataType::
  operator= (const FormationDataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->GroundFormationType_ = x.GroundFormationType_;
      this->AirFormationType_ = x.AirFormationType_;
      this->SurfaceFomationType_ = x.SurfaceFomationType_;
      this->SubsurfaceFormationType_ = x.SubsurfaceFormationType_;
    }

    return *this;
  }

  FormationDataType::
  ~FormationDataType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, FormationDataType >
  _xsd_FormationDataType_type_factory_init (
    "FormationDataType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, FormationDataType >
  _xsd_FormationDataType_comparison_init;

  bool
  operator== (const FormationDataType& x, const FormationDataType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      FormationDataType::GroundFormationType_optional a (x.GroundFormationType ()), b (y.GroundFormationType ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      FormationDataType::AirFormationType_optional a (x.AirFormationType ()), b (y.AirFormationType ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      FormationDataType::SurfaceFomationType_optional a (x.SurfaceFomationType ()), b (y.SurfaceFomationType ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      FormationDataType::SubsurfaceFormationType_optional a (x.SubsurfaceFormationType ()), b (y.SubsurfaceFormationType ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const FormationDataType& x, const FormationDataType& y)
  {
    return !(x == y);
  }

  // FormationPositionType
  //

  FormationPositionType::
  FormationPositionType ()
  : ::xml_schema::type (),
    OutOfFormation_ (this),
    FormationOrder_ (this),
    SensorOrientation_ (this)
  {
  }

  FormationPositionType::
  FormationPositionType (const FormationPositionType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    OutOfFormation_ (x.OutOfFormation_, f, this),
    FormationOrder_ (x.FormationOrder_, f, this),
    SensorOrientation_ (x.SensorOrientation_, f, this)
  {
  }

  FormationPositionType::
  FormationPositionType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    OutOfFormation_ (this),
    FormationOrder_ (this),
    SensorOrientation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FormationPositionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OutOfFormation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OutOfFormation",
            "",
            &::xsd::cxx::tree::factory_impl< OutOfFormation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->OutOfFormation_)
          {
            ::std::unique_ptr< OutOfFormation_type > r (
              dynamic_cast< OutOfFormation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OutOfFormation_.set (::std::move (r));
            continue;
          }
        }
      }

      // FormationOrder
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "FormationOrder",
            "",
            &::xsd::cxx::tree::factory_impl< FormationOrder_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->FormationOrder_)
          {
            ::std::unique_ptr< FormationOrder_type > r (
              dynamic_cast< FormationOrder_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FormationOrder_.set (::std::move (r));
            continue;
          }
        }
      }

      // SensorOrientation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SensorOrientation",
            "",
            &::xsd::cxx::tree::factory_impl< SensorOrientation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SensorOrientation_)
          {
            ::std::unique_ptr< SensorOrientation_type > r (
              dynamic_cast< SensorOrientation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SensorOrientation_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  FormationPositionType* FormationPositionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FormationPositionType (*this, f, c);
  }

  FormationPositionType& FormationPositionType::
  operator= (const FormationPositionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->OutOfFormation_ = x.OutOfFormation_;
      this->FormationOrder_ = x.FormationOrder_;
      this->SensorOrientation_ = x.SensorOrientation_;
    }

    return *this;
  }

  FormationPositionType::
  ~FormationPositionType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, FormationPositionType >
  _xsd_FormationPositionType_type_factory_init (
    "FormationPositionType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, FormationPositionType >
  _xsd_FormationPositionType_comparison_init;

  bool
  operator== (const FormationPositionType& x, const FormationPositionType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      FormationPositionType::OutOfFormation_optional a (x.OutOfFormation ()), b (y.OutOfFormation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      FormationPositionType::FormationOrder_optional a (x.FormationOrder ()), b (y.FormationOrder ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      FormationPositionType::SensorOrientation_optional a (x.SensorOrientation ()), b (y.SensorOrientation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const FormationPositionType& x, const FormationPositionType& y)
  {
    return !(x == y);
  }

  // GCCType
  //

  GCCType::
  GCCType (const X_type& X,
           const Y_type& Y,
           const Z_type& Z)
  : ::xml_schema::type (),
    X_ (X, this),
    Y_ (Y, this),
    Z_ (Z, this)
  {
  }

  GCCType::
  GCCType (::std::unique_ptr< X_type > X,
           ::std::unique_ptr< Y_type > Y,
           ::std::unique_ptr< Z_type > Z)
  : ::xml_schema::type (),
    X_ (std::move (X), this),
    Y_ (std::move (Y), this),
    Z_ (std::move (Z), this)
  {
  }

  GCCType::
  GCCType (const GCCType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    X_ (x.X_, f, this),
    Y_ (x.Y_, f, this),
    Z_ (x.Z_, f, this)
  {
  }

  GCCType::
  GCCType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    X_ (this),
    Y_ (this),
    Z_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GCCType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // X
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "X",
            "",
            &::xsd::cxx::tree::factory_impl< X_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!X_.present ())
          {
            ::std::unique_ptr< X_type > r (
              dynamic_cast< X_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->X_.set (::std::move (r));
            continue;
          }
        }
      }

      // Y
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Y",
            "",
            &::xsd::cxx::tree::factory_impl< Y_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Y_.present ())
          {
            ::std::unique_ptr< Y_type > r (
              dynamic_cast< Y_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Y_.set (::std::move (r));
            continue;
          }
        }
      }

      // Z
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Z",
            "",
            &::xsd::cxx::tree::factory_impl< Z_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Z_.present ())
          {
            ::std::unique_ptr< Z_type > r (
              dynamic_cast< Z_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Z_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!X_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "X",
        "");
    }

    if (!Y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Y",
        "");
    }

    if (!Z_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Z",
        "");
    }
  }

  GCCType* GCCType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GCCType (*this, f, c);
  }

  GCCType& GCCType::
  operator= (const GCCType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->X_ = x.X_;
      this->Y_ = x.Y_;
      this->Z_ = x.Z_;
    }

    return *this;
  }

  GCCType::
  ~GCCType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, GCCType >
  _xsd_GCCType_type_factory_init (
    "GCCType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, GCCType >
  _xsd_GCCType_comparison_init;

  bool
  operator== (const GCCType& x, const GCCType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.X (), y.X ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Y (), y.Y ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Z (), y.Z ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const GCCType& x, const GCCType& y)
  {
    return !(x == y);
  }

  // GDCType
  //

  GDCType::
  GDCType (const Latitude_type& Latitude,
           const Longitude_type& Longitude,
           const ElevationAGL_type& ElevationAGL)
  : ::xml_schema::type (),
    Latitude_ (Latitude, this),
    Longitude_ (Longitude, this),
    ElevationAGL_ (ElevationAGL, this)
  {
  }

  GDCType::
  GDCType (::std::unique_ptr< Latitude_type > Latitude,
           ::std::unique_ptr< Longitude_type > Longitude,
           ::std::unique_ptr< ElevationAGL_type > ElevationAGL)
  : ::xml_schema::type (),
    Latitude_ (std::move (Latitude), this),
    Longitude_ (std::move (Longitude), this),
    ElevationAGL_ (std::move (ElevationAGL), this)
  {
  }

  GDCType::
  GDCType (const GDCType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Latitude_ (x.Latitude_, f, this),
    Longitude_ (x.Longitude_, f, this),
    ElevationAGL_ (x.ElevationAGL_, f, this)
  {
  }

  GDCType::
  GDCType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Latitude_ (this),
    Longitude_ (this),
    ElevationAGL_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GDCType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Latitude
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Latitude",
            "",
            &::xsd::cxx::tree::factory_impl< Latitude_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Latitude_.present ())
          {
            ::std::unique_ptr< Latitude_type > r (
              dynamic_cast< Latitude_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Latitude_.set (::std::move (r));
            continue;
          }
        }
      }

      // Longitude
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Longitude",
            "",
            &::xsd::cxx::tree::factory_impl< Longitude_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Longitude_.present ())
          {
            ::std::unique_ptr< Longitude_type > r (
              dynamic_cast< Longitude_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Longitude_.set (::std::move (r));
            continue;
          }
        }
      }

      // ElevationAGL
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ElevationAGL",
            "",
            &::xsd::cxx::tree::factory_impl< ElevationAGL_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ElevationAGL_.present ())
          {
            ::std::unique_ptr< ElevationAGL_type > r (
              dynamic_cast< ElevationAGL_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ElevationAGL_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Latitude_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Latitude",
        "");
    }

    if (!Longitude_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Longitude",
        "");
    }

    if (!ElevationAGL_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ElevationAGL",
        "");
    }
  }

  GDCType* GDCType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GDCType (*this, f, c);
  }

  GDCType& GDCType::
  operator= (const GDCType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Latitude_ = x.Latitude_;
      this->Longitude_ = x.Longitude_;
      this->ElevationAGL_ = x.ElevationAGL_;
    }

    return *this;
  }

  GDCType::
  ~GDCType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, GDCType >
  _xsd_GDCType_type_factory_init (
    "GDCType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, GDCType >
  _xsd_GDCType_comparison_init;

  bool
  operator== (const GDCType& x, const GDCType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Latitude (), y.Latitude ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Longitude (), y.Longitude ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ElevationAGL (), y.ElevationAGL ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const GDCType& x, const GDCType& y)
  {
    return !(x == y);
  }

  // InstallationsType
  //

  InstallationsType::
  InstallationsType ()
  : ::xml_schema::type (),
    Installation_ (this)
  {
  }

  InstallationsType::
  InstallationsType (const InstallationsType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Installation_ (x.Installation_, f, this)
  {
  }

  InstallationsType::
  InstallationsType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Installation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InstallationsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Installation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Installation",
            "",
            &::xsd::cxx::tree::factory_impl< Installation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< Installation_type > r (
            dynamic_cast< Installation_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Installation_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  InstallationsType* InstallationsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstallationsType (*this, f, c);
  }

  InstallationsType& InstallationsType::
  operator= (const InstallationsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Installation_ = x.Installation_;
    }

    return *this;
  }

  InstallationsType::
  ~InstallationsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, InstallationsType >
  _xsd_InstallationsType_type_factory_init (
    "InstallationsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, InstallationsType >
  _xsd_InstallationsType_comparison_init;

  bool
  operator== (const InstallationsType& x, const InstallationsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      InstallationsType::Installation_sequence a (x.Installation ()), b (y.Installation ());

      if (a.size () != b.size ())
        return false;

      for (InstallationsType::Installation_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const InstallationsType& x, const InstallationsType& y)
  {
    return !(x == y);
  }

  // InstallationSymbolModifiersType
  //

  InstallationSymbolModifiersType::
  InstallationSymbolModifiersType (const UniqueDesignation_type& UniqueDesignation)
  : ::xml_schema::type (),
    FrameShapeModifier_ (this),
    StaffComments_ (this),
    AdditionalInfo_ (this),
    CombatEffectiveness_ (this),
    IFF_ (this),
    UniqueDesignation_ (UniqueDesignation, this),
    DateTimeGroup_ (this)
  {
  }

  InstallationSymbolModifiersType::
  InstallationSymbolModifiersType (::std::unique_ptr< UniqueDesignation_type > UniqueDesignation)
  : ::xml_schema::type (),
    FrameShapeModifier_ (this),
    StaffComments_ (this),
    AdditionalInfo_ (this),
    CombatEffectiveness_ (this),
    IFF_ (this),
    UniqueDesignation_ (std::move (UniqueDesignation), this),
    DateTimeGroup_ (this)
  {
  }

  InstallationSymbolModifiersType::
  InstallationSymbolModifiersType (const InstallationSymbolModifiersType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    FrameShapeModifier_ (x.FrameShapeModifier_, f, this),
    StaffComments_ (x.StaffComments_, f, this),
    AdditionalInfo_ (x.AdditionalInfo_, f, this),
    CombatEffectiveness_ (x.CombatEffectiveness_, f, this),
    IFF_ (x.IFF_, f, this),
    UniqueDesignation_ (x.UniqueDesignation_, f, this),
    DateTimeGroup_ (x.DateTimeGroup_, f, this)
  {
  }

  InstallationSymbolModifiersType::
  InstallationSymbolModifiersType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    FrameShapeModifier_ (this),
    StaffComments_ (this),
    AdditionalInfo_ (this),
    CombatEffectiveness_ (this),
    IFF_ (this),
    UniqueDesignation_ (this),
    DateTimeGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InstallationSymbolModifiersType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FrameShapeModifier
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "FrameShapeModifier",
            "",
            &::xsd::cxx::tree::factory_impl< FrameShapeModifier_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->FrameShapeModifier_)
          {
            ::std::unique_ptr< FrameShapeModifier_type > r (
              dynamic_cast< FrameShapeModifier_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FrameShapeModifier_.set (::std::move (r));
            continue;
          }
        }
      }

      // StaffComments
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "StaffComments",
            "",
            &::xsd::cxx::tree::factory_impl< StaffComments_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->StaffComments_)
          {
            ::std::unique_ptr< StaffComments_type > r (
              dynamic_cast< StaffComments_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->StaffComments_.set (::std::move (r));
            continue;
          }
        }
      }

      // AdditionalInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AdditionalInfo",
            "",
            &::xsd::cxx::tree::factory_impl< AdditionalInfo_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AdditionalInfo_)
          {
            ::std::unique_ptr< AdditionalInfo_type > r (
              dynamic_cast< AdditionalInfo_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AdditionalInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      // CombatEffectiveness
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CombatEffectiveness",
            "",
            &::xsd::cxx::tree::factory_impl< CombatEffectiveness_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CombatEffectiveness_)
          {
            ::std::unique_ptr< CombatEffectiveness_type > r (
              dynamic_cast< CombatEffectiveness_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CombatEffectiveness_.set (::std::move (r));
            continue;
          }
        }
      }

      // IFF
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "IFF",
            "",
            &::xsd::cxx::tree::factory_impl< IFF_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->IFF_)
          {
            ::std::unique_ptr< IFF_type > r (
              dynamic_cast< IFF_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->IFF_.set (::std::move (r));
            continue;
          }
        }
      }

      // UniqueDesignation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UniqueDesignation",
            "",
            &::xsd::cxx::tree::factory_impl< UniqueDesignation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!UniqueDesignation_.present ())
          {
            ::std::unique_ptr< UniqueDesignation_type > r (
              dynamic_cast< UniqueDesignation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UniqueDesignation_.set (::std::move (r));
            continue;
          }
        }
      }

      // DateTimeGroup
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DateTimeGroup",
            "",
            &::xsd::cxx::tree::factory_impl< DateTimeGroup_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DateTimeGroup_)
          {
            ::std::unique_ptr< DateTimeGroup_type > r (
              dynamic_cast< DateTimeGroup_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DateTimeGroup_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!UniqueDesignation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "UniqueDesignation",
        "");
    }
  }

  InstallationSymbolModifiersType* InstallationSymbolModifiersType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstallationSymbolModifiersType (*this, f, c);
  }

  InstallationSymbolModifiersType& InstallationSymbolModifiersType::
  operator= (const InstallationSymbolModifiersType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->FrameShapeModifier_ = x.FrameShapeModifier_;
      this->StaffComments_ = x.StaffComments_;
      this->AdditionalInfo_ = x.AdditionalInfo_;
      this->CombatEffectiveness_ = x.CombatEffectiveness_;
      this->IFF_ = x.IFF_;
      this->UniqueDesignation_ = x.UniqueDesignation_;
      this->DateTimeGroup_ = x.DateTimeGroup_;
    }

    return *this;
  }

  InstallationSymbolModifiersType::
  ~InstallationSymbolModifiersType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, InstallationSymbolModifiersType >
  _xsd_InstallationSymbolModifiersType_type_factory_init (
    "InstallationSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, InstallationSymbolModifiersType >
  _xsd_InstallationSymbolModifiersType_comparison_init;

  bool
  operator== (const InstallationSymbolModifiersType& x, const InstallationSymbolModifiersType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      InstallationSymbolModifiersType::FrameShapeModifier_optional a (x.FrameShapeModifier ()), b (y.FrameShapeModifier ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      InstallationSymbolModifiersType::StaffComments_optional a (x.StaffComments ()), b (y.StaffComments ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      InstallationSymbolModifiersType::AdditionalInfo_optional a (x.AdditionalInfo ()), b (y.AdditionalInfo ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      InstallationSymbolModifiersType::CombatEffectiveness_optional a (x.CombatEffectiveness ()), b (y.CombatEffectiveness ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      InstallationSymbolModifiersType::IFF_optional a (x.IFF ()), b (y.IFF ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.UniqueDesignation (), y.UniqueDesignation ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      InstallationSymbolModifiersType::DateTimeGroup_optional a (x.DateTimeGroup ()), b (y.DateTimeGroup ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const InstallationSymbolModifiersType& x, const InstallationSymbolModifiersType& y)
  {
    return !(x == y);
  }

  // InstallationType
  //

  InstallationType::
  InstallationType (const ObjectHandle_type& ObjectHandle,
                    const SymbolIdentifier_type& SymbolIdentifier,
                    const Affiliation_type& Affiliation,
                    const Owner_type& Owner,
                    const Location_type& Location)
  : ::xml_schema::type (),
    ObjectHandle_ (ObjectHandle, this),
    SymbolIdentifier_ (SymbolIdentifier, this),
    Affiliation_ (Affiliation, this),
    Owner_ (Owner, this),
    Location_ (Location, this),
    Orientation_ (this),
    Name_ (this),
    InstallationSymbolModifiers_ (this),
    AssociatedOverlays_ (this)
  {
  }

  InstallationType::
  InstallationType (const ObjectHandle_type& ObjectHandle,
                    const SymbolIdentifier_type& SymbolIdentifier,
                    const Affiliation_type& Affiliation,
                    ::std::unique_ptr< Owner_type > Owner,
                    ::std::unique_ptr< Location_type > Location)
  : ::xml_schema::type (),
    ObjectHandle_ (ObjectHandle, this),
    SymbolIdentifier_ (SymbolIdentifier, this),
    Affiliation_ (Affiliation, this),
    Owner_ (std::move (Owner), this),
    Location_ (std::move (Location), this),
    Orientation_ (this),
    Name_ (this),
    InstallationSymbolModifiers_ (this),
    AssociatedOverlays_ (this)
  {
  }

  InstallationType::
  InstallationType (::std::unique_ptr< ObjectHandle_type > ObjectHandle,
                    ::std::unique_ptr< SymbolIdentifier_type > SymbolIdentifier,
                    ::std::unique_ptr< Affiliation_type > Affiliation,
                    ::std::unique_ptr< Owner_type > Owner,
                    ::std::unique_ptr< Location_type > Location)
  : ::xml_schema::type (),
    ObjectHandle_ (std::move (ObjectHandle), this),
    SymbolIdentifier_ (std::move (SymbolIdentifier), this),
    Affiliation_ (std::move (Affiliation), this),
    Owner_ (std::move (Owner), this),
    Location_ (std::move (Location), this),
    Orientation_ (this),
    Name_ (this),
    InstallationSymbolModifiers_ (this),
    AssociatedOverlays_ (this)
  {
  }

  InstallationType::
  InstallationType (const InstallationType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ObjectHandle_ (x.ObjectHandle_, f, this),
    SymbolIdentifier_ (x.SymbolIdentifier_, f, this),
    Affiliation_ (x.Affiliation_, f, this),
    Owner_ (x.Owner_, f, this),
    Location_ (x.Location_, f, this),
    Orientation_ (x.Orientation_, f, this),
    Name_ (x.Name_, f, this),
    InstallationSymbolModifiers_ (x.InstallationSymbolModifiers_, f, this),
    AssociatedOverlays_ (x.AssociatedOverlays_, f, this)
  {
  }

  InstallationType::
  InstallationType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ObjectHandle_ (this),
    SymbolIdentifier_ (this),
    Affiliation_ (this),
    Owner_ (this),
    Location_ (this),
    Orientation_ (this),
    Name_ (this),
    InstallationSymbolModifiers_ (this),
    AssociatedOverlays_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InstallationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ObjectHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ObjectHandle",
            "",
            &::xsd::cxx::tree::factory_impl< ObjectHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ObjectHandle_.present ())
          {
            ::std::unique_ptr< ObjectHandle_type > r (
              dynamic_cast< ObjectHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ObjectHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // SymbolIdentifier
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SymbolIdentifier",
            "",
            &::xsd::cxx::tree::factory_impl< SymbolIdentifier_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!SymbolIdentifier_.present ())
          {
            ::std::unique_ptr< SymbolIdentifier_type > r (
              dynamic_cast< SymbolIdentifier_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SymbolIdentifier_.set (::std::move (r));
            continue;
          }
        }
      }

      // Affiliation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Affiliation",
            "",
            &::xsd::cxx::tree::factory_impl< Affiliation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Affiliation_.present ())
          {
            ::std::unique_ptr< Affiliation_type > r (
              dynamic_cast< Affiliation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Affiliation_.set (::std::move (r));
            continue;
          }
        }
      }

      // Owner
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Owner",
            "",
            &::xsd::cxx::tree::factory_impl< Owner_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Owner_.present ())
          {
            ::std::unique_ptr< Owner_type > r (
              dynamic_cast< Owner_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Owner_.set (::std::move (r));
            continue;
          }
        }
      }

      // Location
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Location",
            "",
            &::xsd::cxx::tree::factory_impl< Location_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Location_.present ())
          {
            ::std::unique_ptr< Location_type > r (
              dynamic_cast< Location_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Location_.set (::std::move (r));
            continue;
          }
        }
      }

      // Orientation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Orientation",
            "",
            &::xsd::cxx::tree::factory_impl< Orientation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Orientation_)
          {
            ::std::unique_ptr< Orientation_type > r (
              dynamic_cast< Orientation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Orientation_.set (::std::move (r));
            continue;
          }
        }
      }

      // Name
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Name",
            "",
            &::xsd::cxx::tree::factory_impl< Name_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Name_)
          {
            ::std::unique_ptr< Name_type > r (
              dynamic_cast< Name_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Name_.set (::std::move (r));
            continue;
          }
        }
      }

      // InstallationSymbolModifiers
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "InstallationSymbolModifiers",
            "",
            &::xsd::cxx::tree::factory_impl< InstallationSymbolModifiers_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->InstallationSymbolModifiers_)
          {
            ::std::unique_ptr< InstallationSymbolModifiers_type > r (
              dynamic_cast< InstallationSymbolModifiers_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->InstallationSymbolModifiers_.set (::std::move (r));
            continue;
          }
        }
      }

      // AssociatedOverlays
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AssociatedOverlays",
            "",
            &::xsd::cxx::tree::factory_impl< AssociatedOverlays_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AssociatedOverlays_)
          {
            ::std::unique_ptr< AssociatedOverlays_type > r (
              dynamic_cast< AssociatedOverlays_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AssociatedOverlays_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ObjectHandle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ObjectHandle",
        "");
    }

    if (!SymbolIdentifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SymbolIdentifier",
        "");
    }

    if (!Affiliation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Affiliation",
        "");
    }

    if (!Owner_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Owner",
        "");
    }

    if (!Location_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Location",
        "");
    }
  }

  InstallationType* InstallationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstallationType (*this, f, c);
  }

  InstallationType& InstallationType::
  operator= (const InstallationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ObjectHandle_ = x.ObjectHandle_;
      this->SymbolIdentifier_ = x.SymbolIdentifier_;
      this->Affiliation_ = x.Affiliation_;
      this->Owner_ = x.Owner_;
      this->Location_ = x.Location_;
      this->Orientation_ = x.Orientation_;
      this->Name_ = x.Name_;
      this->InstallationSymbolModifiers_ = x.InstallationSymbolModifiers_;
      this->AssociatedOverlays_ = x.AssociatedOverlays_;
    }

    return *this;
  }

  InstallationType::
  ~InstallationType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, InstallationType >
  _xsd_InstallationType_type_factory_init (
    "InstallationType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, InstallationType >
  _xsd_InstallationType_comparison_init;

  bool
  operator== (const InstallationType& x, const InstallationType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ObjectHandle (), y.ObjectHandle ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.SymbolIdentifier (), y.SymbolIdentifier ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Affiliation (), y.Affiliation ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Owner (), y.Owner ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Location (), y.Location ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      InstallationType::Orientation_optional a (x.Orientation ()), b (y.Orientation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      InstallationType::Name_optional a (x.Name ()), b (y.Name ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      InstallationType::InstallationSymbolModifiers_optional a (x.InstallationSymbolModifiers ()), b (y.InstallationSymbolModifiers ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      InstallationType::AssociatedOverlays_optional a (x.AssociatedOverlays ()), b (y.AssociatedOverlays ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const InstallationType& x, const InstallationType& y)
  {
    return !(x == y);
  }

  // LightItemsType
  //

  LightItemsType::
  LightItemsType ()
  : ::xml_schema::type (),
    Light_ (this)
  {
  }

  LightItemsType::
  LightItemsType (const LightItemsType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Light_ (x.Light_, f, this)
  {
  }

  LightItemsType::
  LightItemsType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Light_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LightItemsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Light
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Light",
            "",
            &::xsd::cxx::tree::factory_impl< Light_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< Light_type > r (
            dynamic_cast< Light_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Light_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  LightItemsType* LightItemsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LightItemsType (*this, f, c);
  }

  LightItemsType& LightItemsType::
  operator= (const LightItemsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Light_ = x.Light_;
    }

    return *this;
  }

  LightItemsType::
  ~LightItemsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LightItemsType >
  _xsd_LightItemsType_type_factory_init (
    "LightItemsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, LightItemsType >
  _xsd_LightItemsType_comparison_init;

  bool
  operator== (const LightItemsType& x, const LightItemsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      LightItemsType::Light_sequence a (x.Light ()), b (y.Light ());

      if (a.size () != b.size ())
        return false;

      for (LightItemsType::Light_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const LightItemsType& x, const LightItemsType& y)
  {
    return !(x == y);
  }

  // LineSymbolModifiersType
  //

  LineSymbolModifiersType::
  LineSymbolModifiersType ()
  : ::xml_schema::type (),
    UniqueDesignation_ (this),
    UniqueDesignation1_ (this),
    DateTimeGroup_ (this),
    DateTimeGroup1_ (this)
  {
  }

  LineSymbolModifiersType::
  LineSymbolModifiersType (const LineSymbolModifiersType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    UniqueDesignation_ (x.UniqueDesignation_, f, this),
    UniqueDesignation1_ (x.UniqueDesignation1_, f, this),
    DateTimeGroup_ (x.DateTimeGroup_, f, this),
    DateTimeGroup1_ (x.DateTimeGroup1_, f, this)
  {
  }

  LineSymbolModifiersType::
  LineSymbolModifiersType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    UniqueDesignation_ (this),
    UniqueDesignation1_ (this),
    DateTimeGroup_ (this),
    DateTimeGroup1_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LineSymbolModifiersType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // UniqueDesignation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UniqueDesignation",
            "",
            &::xsd::cxx::tree::factory_impl< UniqueDesignation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->UniqueDesignation_)
          {
            ::std::unique_ptr< UniqueDesignation_type > r (
              dynamic_cast< UniqueDesignation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UniqueDesignation_.set (::std::move (r));
            continue;
          }
        }
      }

      // UniqueDesignation1
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UniqueDesignation1",
            "",
            &::xsd::cxx::tree::factory_impl< UniqueDesignation1_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->UniqueDesignation1_)
          {
            ::std::unique_ptr< UniqueDesignation1_type > r (
              dynamic_cast< UniqueDesignation1_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UniqueDesignation1_.set (::std::move (r));
            continue;
          }
        }
      }

      // DateTimeGroup
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DateTimeGroup",
            "",
            &::xsd::cxx::tree::factory_impl< DateTimeGroup_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DateTimeGroup_)
          {
            ::std::unique_ptr< DateTimeGroup_type > r (
              dynamic_cast< DateTimeGroup_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DateTimeGroup_.set (::std::move (r));
            continue;
          }
        }
      }

      // DateTimeGroup1
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DateTimeGroup1",
            "",
            &::xsd::cxx::tree::factory_impl< DateTimeGroup1_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DateTimeGroup1_)
          {
            ::std::unique_ptr< DateTimeGroup1_type > r (
              dynamic_cast< DateTimeGroup1_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DateTimeGroup1_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  LineSymbolModifiersType* LineSymbolModifiersType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LineSymbolModifiersType (*this, f, c);
  }

  LineSymbolModifiersType& LineSymbolModifiersType::
  operator= (const LineSymbolModifiersType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->UniqueDesignation_ = x.UniqueDesignation_;
      this->UniqueDesignation1_ = x.UniqueDesignation1_;
      this->DateTimeGroup_ = x.DateTimeGroup_;
      this->DateTimeGroup1_ = x.DateTimeGroup1_;
    }

    return *this;
  }

  LineSymbolModifiersType::
  ~LineSymbolModifiersType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LineSymbolModifiersType >
  _xsd_LineSymbolModifiersType_type_factory_init (
    "LineSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, LineSymbolModifiersType >
  _xsd_LineSymbolModifiersType_comparison_init;

  bool
  operator== (const LineSymbolModifiersType& x, const LineSymbolModifiersType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      LineSymbolModifiersType::UniqueDesignation_optional a (x.UniqueDesignation ()), b (y.UniqueDesignation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      LineSymbolModifiersType::UniqueDesignation1_optional a (x.UniqueDesignation1 ()), b (y.UniqueDesignation1 ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      LineSymbolModifiersType::DateTimeGroup_optional a (x.DateTimeGroup ()), b (y.DateTimeGroup ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      LineSymbolModifiersType::DateTimeGroup1_optional a (x.DateTimeGroup1 ()), b (y.DateTimeGroup1 ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const LineSymbolModifiersType& x, const LineSymbolModifiersType& y)
  {
    return !(x == y);
  }

  // METOCDispositionType
  //

  METOCDispositionType::
  METOCDispositionType (const AnchorPoints_type& AnchorPoints)
  : ::xml_schema::type (),
    AnchorPoints_ (AnchorPoints, this),
    DirectionOfMovement_ (this),
    Speed_ (this)
  {
  }

  METOCDispositionType::
  METOCDispositionType (::std::unique_ptr< AnchorPoints_type > AnchorPoints)
  : ::xml_schema::type (),
    AnchorPoints_ (std::move (AnchorPoints), this),
    DirectionOfMovement_ (this),
    Speed_ (this)
  {
  }

  METOCDispositionType::
  METOCDispositionType (const METOCDispositionType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AnchorPoints_ (x.AnchorPoints_, f, this),
    DirectionOfMovement_ (x.DirectionOfMovement_, f, this),
    Speed_ (x.Speed_, f, this)
  {
  }

  METOCDispositionType::
  METOCDispositionType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AnchorPoints_ (this),
    DirectionOfMovement_ (this),
    Speed_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void METOCDispositionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AnchorPoints
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AnchorPoints",
            "",
            &::xsd::cxx::tree::factory_impl< AnchorPoints_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!AnchorPoints_.present ())
          {
            ::std::unique_ptr< AnchorPoints_type > r (
              dynamic_cast< AnchorPoints_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AnchorPoints_.set (::std::move (r));
            continue;
          }
        }
      }

      // DirectionOfMovement
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DirectionOfMovement",
            "",
            &::xsd::cxx::tree::factory_impl< DirectionOfMovement_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DirectionOfMovement_)
          {
            ::std::unique_ptr< DirectionOfMovement_type > r (
              dynamic_cast< DirectionOfMovement_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DirectionOfMovement_.set (::std::move (r));
            continue;
          }
        }
      }

      // Speed
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Speed",
            "",
            &::xsd::cxx::tree::factory_impl< Speed_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Speed_)
          {
            ::std::unique_ptr< Speed_type > r (
              dynamic_cast< Speed_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Speed_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!AnchorPoints_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AnchorPoints",
        "");
    }
  }

  METOCDispositionType* METOCDispositionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class METOCDispositionType (*this, f, c);
  }

  METOCDispositionType& METOCDispositionType::
  operator= (const METOCDispositionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AnchorPoints_ = x.AnchorPoints_;
      this->DirectionOfMovement_ = x.DirectionOfMovement_;
      this->Speed_ = x.Speed_;
    }

    return *this;
  }

  METOCDispositionType::
  ~METOCDispositionType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, METOCDispositionType >
  _xsd_METOCDispositionType_type_factory_init (
    "METOCDispositionType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, METOCDispositionType >
  _xsd_METOCDispositionType_comparison_init;

  bool
  operator== (const METOCDispositionType& x, const METOCDispositionType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.AnchorPoints (), y.AnchorPoints ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      METOCDispositionType::DirectionOfMovement_optional a (x.DirectionOfMovement ()), b (y.DirectionOfMovement ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      METOCDispositionType::Speed_optional a (x.Speed ()), b (y.Speed ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const METOCDispositionType& x, const METOCDispositionType& y)
  {
    return !(x == y);
  }

  // METOCGraphicType
  //

  METOCGraphicType::
  METOCGraphicType (const ObjectHandle_type& ObjectHandle,
                    const SymbolIdentifier_type& SymbolIdentifier,
                    const UniqueDesignation_type& UniqueDesignation,
                    const Disposition_type& Disposition)
  : ::xml_schema::type (),
    ObjectHandle_ (ObjectHandle, this),
    SymbolIdentifier_ (SymbolIdentifier, this),
    UniqueDesignation_ (UniqueDesignation, this),
    DateTimeGroup_ (this),
    DateTimeGroup1_ (this),
    Quantity_ (this),
    AdditionalInfo_ (this),
    Disposition_ (Disposition, this)
  {
  }

  METOCGraphicType::
  METOCGraphicType (const ObjectHandle_type& ObjectHandle,
                    const SymbolIdentifier_type& SymbolIdentifier,
                    const UniqueDesignation_type& UniqueDesignation,
                    ::std::unique_ptr< Disposition_type > Disposition)
  : ::xml_schema::type (),
    ObjectHandle_ (ObjectHandle, this),
    SymbolIdentifier_ (SymbolIdentifier, this),
    UniqueDesignation_ (UniqueDesignation, this),
    DateTimeGroup_ (this),
    DateTimeGroup1_ (this),
    Quantity_ (this),
    AdditionalInfo_ (this),
    Disposition_ (std::move (Disposition), this)
  {
  }

  METOCGraphicType::
  METOCGraphicType (::std::unique_ptr< ObjectHandle_type > ObjectHandle,
                    ::std::unique_ptr< SymbolIdentifier_type > SymbolIdentifier,
                    ::std::unique_ptr< UniqueDesignation_type > UniqueDesignation,
                    ::std::unique_ptr< Disposition_type > Disposition)
  : ::xml_schema::type (),
    ObjectHandle_ (std::move (ObjectHandle), this),
    SymbolIdentifier_ (std::move (SymbolIdentifier), this),
    UniqueDesignation_ (std::move (UniqueDesignation), this),
    DateTimeGroup_ (this),
    DateTimeGroup1_ (this),
    Quantity_ (this),
    AdditionalInfo_ (this),
    Disposition_ (std::move (Disposition), this)
  {
  }

  METOCGraphicType::
  METOCGraphicType (const METOCGraphicType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ObjectHandle_ (x.ObjectHandle_, f, this),
    SymbolIdentifier_ (x.SymbolIdentifier_, f, this),
    UniqueDesignation_ (x.UniqueDesignation_, f, this),
    DateTimeGroup_ (x.DateTimeGroup_, f, this),
    DateTimeGroup1_ (x.DateTimeGroup1_, f, this),
    Quantity_ (x.Quantity_, f, this),
    AdditionalInfo_ (x.AdditionalInfo_, f, this),
    Disposition_ (x.Disposition_, f, this)
  {
  }

  METOCGraphicType::
  METOCGraphicType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ObjectHandle_ (this),
    SymbolIdentifier_ (this),
    UniqueDesignation_ (this),
    DateTimeGroup_ (this),
    DateTimeGroup1_ (this),
    Quantity_ (this),
    AdditionalInfo_ (this),
    Disposition_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void METOCGraphicType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ObjectHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ObjectHandle",
            "",
            &::xsd::cxx::tree::factory_impl< ObjectHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ObjectHandle_.present ())
          {
            ::std::unique_ptr< ObjectHandle_type > r (
              dynamic_cast< ObjectHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ObjectHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // SymbolIdentifier
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SymbolIdentifier",
            "",
            &::xsd::cxx::tree::factory_impl< SymbolIdentifier_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!SymbolIdentifier_.present ())
          {
            ::std::unique_ptr< SymbolIdentifier_type > r (
              dynamic_cast< SymbolIdentifier_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SymbolIdentifier_.set (::std::move (r));
            continue;
          }
        }
      }

      // UniqueDesignation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UniqueDesignation",
            "",
            &::xsd::cxx::tree::factory_impl< UniqueDesignation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!UniqueDesignation_.present ())
          {
            ::std::unique_ptr< UniqueDesignation_type > r (
              dynamic_cast< UniqueDesignation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UniqueDesignation_.set (::std::move (r));
            continue;
          }
        }
      }

      // DateTimeGroup
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DateTimeGroup",
            "",
            &::xsd::cxx::tree::factory_impl< DateTimeGroup_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DateTimeGroup_)
          {
            ::std::unique_ptr< DateTimeGroup_type > r (
              dynamic_cast< DateTimeGroup_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DateTimeGroup_.set (::std::move (r));
            continue;
          }
        }
      }

      // DateTimeGroup1
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DateTimeGroup1",
            "",
            &::xsd::cxx::tree::factory_impl< DateTimeGroup1_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DateTimeGroup1_)
          {
            ::std::unique_ptr< DateTimeGroup1_type > r (
              dynamic_cast< DateTimeGroup1_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DateTimeGroup1_.set (::std::move (r));
            continue;
          }
        }
      }

      // Quantity
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Quantity",
            "",
            &::xsd::cxx::tree::factory_impl< Quantity_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Quantity_)
          {
            ::std::unique_ptr< Quantity_type > r (
              dynamic_cast< Quantity_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Quantity_.set (::std::move (r));
            continue;
          }
        }
      }

      // AdditionalInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AdditionalInfo",
            "",
            &::xsd::cxx::tree::factory_impl< AdditionalInfo_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AdditionalInfo_)
          {
            ::std::unique_ptr< AdditionalInfo_type > r (
              dynamic_cast< AdditionalInfo_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AdditionalInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      // Disposition
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Disposition",
            "",
            &::xsd::cxx::tree::factory_impl< Disposition_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Disposition_.present ())
          {
            ::std::unique_ptr< Disposition_type > r (
              dynamic_cast< Disposition_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Disposition_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ObjectHandle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ObjectHandle",
        "");
    }

    if (!SymbolIdentifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SymbolIdentifier",
        "");
    }

    if (!UniqueDesignation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "UniqueDesignation",
        "");
    }

    if (!Disposition_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Disposition",
        "");
    }
  }

  METOCGraphicType* METOCGraphicType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class METOCGraphicType (*this, f, c);
  }

  METOCGraphicType& METOCGraphicType::
  operator= (const METOCGraphicType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ObjectHandle_ = x.ObjectHandle_;
      this->SymbolIdentifier_ = x.SymbolIdentifier_;
      this->UniqueDesignation_ = x.UniqueDesignation_;
      this->DateTimeGroup_ = x.DateTimeGroup_;
      this->DateTimeGroup1_ = x.DateTimeGroup1_;
      this->Quantity_ = x.Quantity_;
      this->AdditionalInfo_ = x.AdditionalInfo_;
      this->Disposition_ = x.Disposition_;
    }

    return *this;
  }

  METOCGraphicType::
  ~METOCGraphicType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, METOCGraphicType >
  _xsd_METOCGraphicType_type_factory_init (
    "METOCGraphicType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, METOCGraphicType >
  _xsd_METOCGraphicType_comparison_init;

  bool
  operator== (const METOCGraphicType& x, const METOCGraphicType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ObjectHandle (), y.ObjectHandle ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.SymbolIdentifier (), y.SymbolIdentifier ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.UniqueDesignation (), y.UniqueDesignation ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      METOCGraphicType::DateTimeGroup_optional a (x.DateTimeGroup ()), b (y.DateTimeGroup ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      METOCGraphicType::DateTimeGroup1_optional a (x.DateTimeGroup1 ()), b (y.DateTimeGroup1 ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      METOCGraphicType::Quantity_optional a (x.Quantity ()), b (y.Quantity ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      METOCGraphicType::AdditionalInfo_optional a (x.AdditionalInfo ()), b (y.AdditionalInfo ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Disposition (), y.Disposition ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const METOCGraphicType& x, const METOCGraphicType& y)
  {
    return !(x == y);
  }

  // METOCType
  //

  METOCType::
  METOCType ()
  : ::xml_schema::type (),
    METOCGraphic_ (this)
  {
  }

  METOCType::
  METOCType (const METOCType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    METOCGraphic_ (x.METOCGraphic_, f, this)
  {
  }

  METOCType::
  METOCType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    METOCGraphic_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void METOCType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // METOCGraphic
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "METOCGraphic",
            "",
            &::xsd::cxx::tree::factory_impl< METOCGraphic_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< METOCGraphic_type > r (
            dynamic_cast< METOCGraphic_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->METOCGraphic_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  METOCType* METOCType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class METOCType (*this, f, c);
  }

  METOCType& METOCType::
  operator= (const METOCType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->METOCGraphic_ = x.METOCGraphic_;
    }

    return *this;
  }

  METOCType::
  ~METOCType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, METOCType >
  _xsd_METOCType_type_factory_init (
    "METOCType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, METOCType >
  _xsd_METOCType_comparison_init;

  bool
  operator== (const METOCType& x, const METOCType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      METOCType::METOCGraphic_sequence a (x.METOCGraphic ()), b (y.METOCGraphic ());

      if (a.size () != b.size ())
        return false;

      for (METOCType::METOCGraphic_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const METOCType& x, const METOCType& y)
  {
    return !(x == y);
  }

  // MilitaryScenarioType
  //

  MilitaryScenarioType::
  MilitaryScenarioType (const ScenarioID_type& ScenarioID,
                        const Options_type& Options,
                        const ForceSides_type& ForceSides)
  : ::xml_schema::type (),
    ScenarioID_ (ScenarioID, this),
    Options_ (Options, this),
    Environment_ (this),
    ForceSides_ (ForceSides, this),
    Organizations_ (this),
    Overlays_ (this),
    Installations_ (this),
    TacticalGraphics_ (this),
    MOOTWGraphics_ (this)
  {
  }

  MilitaryScenarioType::
  MilitaryScenarioType (::std::unique_ptr< ScenarioID_type > ScenarioID,
                        ::std::unique_ptr< Options_type > Options,
                        ::std::unique_ptr< ForceSides_type > ForceSides)
  : ::xml_schema::type (),
    ScenarioID_ (std::move (ScenarioID), this),
    Options_ (std::move (Options), this),
    Environment_ (this),
    ForceSides_ (std::move (ForceSides), this),
    Organizations_ (this),
    Overlays_ (this),
    Installations_ (this),
    TacticalGraphics_ (this),
    MOOTWGraphics_ (this)
  {
  }

  MilitaryScenarioType::
  MilitaryScenarioType (const MilitaryScenarioType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ScenarioID_ (x.ScenarioID_, f, this),
    Options_ (x.Options_, f, this),
    Environment_ (x.Environment_, f, this),
    ForceSides_ (x.ForceSides_, f, this),
    Organizations_ (x.Organizations_, f, this),
    Overlays_ (x.Overlays_, f, this),
    Installations_ (x.Installations_, f, this),
    TacticalGraphics_ (x.TacticalGraphics_, f, this),
    MOOTWGraphics_ (x.MOOTWGraphics_, f, this)
  {
  }

  MilitaryScenarioType::
  MilitaryScenarioType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ScenarioID_ (this),
    Options_ (this),
    Environment_ (this),
    ForceSides_ (this),
    Organizations_ (this),
    Overlays_ (this),
    Installations_ (this),
    TacticalGraphics_ (this),
    MOOTWGraphics_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MilitaryScenarioType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ScenarioID
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ScenarioID",
            "",
            &::xsd::cxx::tree::factory_impl< ScenarioID_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ScenarioID_.present ())
          {
            ::std::unique_ptr< ScenarioID_type > r (
              dynamic_cast< ScenarioID_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ScenarioID_.set (::std::move (r));
            continue;
          }
        }
      }

      // Options
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Options",
            "",
            &::xsd::cxx::tree::factory_impl< Options_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Options_.present ())
          {
            ::std::unique_ptr< Options_type > r (
              dynamic_cast< Options_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Options_.set (::std::move (r));
            continue;
          }
        }
      }

      // Environment
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Environment",
            "",
            &::xsd::cxx::tree::factory_impl< Environment_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Environment_)
          {
            ::std::unique_ptr< Environment_type > r (
              dynamic_cast< Environment_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Environment_.set (::std::move (r));
            continue;
          }
        }
      }

      // ForceSides
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ForceSides",
            "",
            &::xsd::cxx::tree::factory_impl< ForceSides_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ForceSides_.present ())
          {
            ::std::unique_ptr< ForceSides_type > r (
              dynamic_cast< ForceSides_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ForceSides_.set (::std::move (r));
            continue;
          }
        }
      }

      // Organizations
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Organizations",
            "",
            &::xsd::cxx::tree::factory_impl< Organizations_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Organizations_)
          {
            ::std::unique_ptr< Organizations_type > r (
              dynamic_cast< Organizations_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Organizations_.set (::std::move (r));
            continue;
          }
        }
      }

      // Overlays
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Overlays",
            "",
            &::xsd::cxx::tree::factory_impl< Overlays_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Overlays_)
          {
            ::std::unique_ptr< Overlays_type > r (
              dynamic_cast< Overlays_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Overlays_.set (::std::move (r));
            continue;
          }
        }
      }

      // Installations
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Installations",
            "",
            &::xsd::cxx::tree::factory_impl< Installations_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Installations_)
          {
            ::std::unique_ptr< Installations_type > r (
              dynamic_cast< Installations_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Installations_.set (::std::move (r));
            continue;
          }
        }
      }

      // TacticalGraphics
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TacticalGraphics",
            "",
            &::xsd::cxx::tree::factory_impl< TacticalGraphics_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->TacticalGraphics_)
          {
            ::std::unique_ptr< TacticalGraphics_type > r (
              dynamic_cast< TacticalGraphics_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->TacticalGraphics_.set (::std::move (r));
            continue;
          }
        }
      }

      // MOOTWGraphics
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MOOTWGraphics",
            "",
            &::xsd::cxx::tree::factory_impl< MOOTWGraphics_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MOOTWGraphics_)
          {
            ::std::unique_ptr< MOOTWGraphics_type > r (
              dynamic_cast< MOOTWGraphics_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MOOTWGraphics_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ScenarioID_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ScenarioID",
        "");
    }

    if (!Options_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Options",
        "");
    }

    if (!ForceSides_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ForceSides",
        "");
    }
  }

  MilitaryScenarioType* MilitaryScenarioType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MilitaryScenarioType (*this, f, c);
  }

  MilitaryScenarioType& MilitaryScenarioType::
  operator= (const MilitaryScenarioType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ScenarioID_ = x.ScenarioID_;
      this->Options_ = x.Options_;
      this->Environment_ = x.Environment_;
      this->ForceSides_ = x.ForceSides_;
      this->Organizations_ = x.Organizations_;
      this->Overlays_ = x.Overlays_;
      this->Installations_ = x.Installations_;
      this->TacticalGraphics_ = x.TacticalGraphics_;
      this->MOOTWGraphics_ = x.MOOTWGraphics_;
    }

    return *this;
  }

  MilitaryScenarioType::
  ~MilitaryScenarioType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MilitaryScenarioType >
  _xsd_MilitaryScenarioType_type_factory_init (
    "MilitaryScenarioType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, MilitaryScenarioType >
  _xsd_MilitaryScenarioType_comparison_init;

  bool
  operator== (const MilitaryScenarioType& x, const MilitaryScenarioType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ScenarioID (), y.ScenarioID ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Options (), y.Options ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MilitaryScenarioType::Environment_optional a (x.Environment ()), b (y.Environment ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ForceSides (), y.ForceSides ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MilitaryScenarioType::Organizations_optional a (x.Organizations ()), b (y.Organizations ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MilitaryScenarioType::Overlays_optional a (x.Overlays ()), b (y.Overlays ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MilitaryScenarioType::Installations_optional a (x.Installations ()), b (y.Installations ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MilitaryScenarioType::TacticalGraphics_optional a (x.TacticalGraphics ()), b (y.TacticalGraphics ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MilitaryScenarioType::MOOTWGraphics_optional a (x.MOOTWGraphics ()), b (y.MOOTWGraphics ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const MilitaryScenarioType& x, const MilitaryScenarioType& y)
  {
    return !(x == y);
  }

  // MGRSType
  //

  MGRSType::
  MGRSType (const MGRSGridZone_type& MGRSGridZone,
            const MGRSGridSquare_type& MGRSGridSquare,
            const MGRSPrecision_type& MGRSPrecision,
            const MGRSEasting_type& MGRSEasting,
            const MGRSNorthing_type& MGRSNorthing)
  : ::xml_schema::type (),
    MGRSGridZone_ (MGRSGridZone, this),
    MGRSGridSquare_ (MGRSGridSquare, this),
    MGRSPrecision_ (MGRSPrecision, this),
    MGRSEasting_ (MGRSEasting, this),
    MGRSNorthing_ (MGRSNorthing, this),
    ElevationAGL_ (this)
  {
  }

  MGRSType::
  MGRSType (::std::unique_ptr< MGRSGridZone_type > MGRSGridZone,
            ::std::unique_ptr< MGRSGridSquare_type > MGRSGridSquare,
            ::std::unique_ptr< MGRSPrecision_type > MGRSPrecision,
            ::std::unique_ptr< MGRSEasting_type > MGRSEasting,
            ::std::unique_ptr< MGRSNorthing_type > MGRSNorthing)
  : ::xml_schema::type (),
    MGRSGridZone_ (std::move (MGRSGridZone), this),
    MGRSGridSquare_ (std::move (MGRSGridSquare), this),
    MGRSPrecision_ (std::move (MGRSPrecision), this),
    MGRSEasting_ (std::move (MGRSEasting), this),
    MGRSNorthing_ (std::move (MGRSNorthing), this),
    ElevationAGL_ (this)
  {
  }

  MGRSType::
  MGRSType (const MGRSType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    MGRSGridZone_ (x.MGRSGridZone_, f, this),
    MGRSGridSquare_ (x.MGRSGridSquare_, f, this),
    MGRSPrecision_ (x.MGRSPrecision_, f, this),
    MGRSEasting_ (x.MGRSEasting_, f, this),
    MGRSNorthing_ (x.MGRSNorthing_, f, this),
    ElevationAGL_ (x.ElevationAGL_, f, this)
  {
  }

  MGRSType::
  MGRSType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    MGRSGridZone_ (this),
    MGRSGridSquare_ (this),
    MGRSPrecision_ (this),
    MGRSEasting_ (this),
    MGRSNorthing_ (this),
    ElevationAGL_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MGRSType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MGRSGridZone
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MGRSGridZone",
            "",
            &::xsd::cxx::tree::factory_impl< MGRSGridZone_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MGRSGridZone_.present ())
          {
            ::std::unique_ptr< MGRSGridZone_type > r (
              dynamic_cast< MGRSGridZone_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MGRSGridZone_.set (::std::move (r));
            continue;
          }
        }
      }

      // MGRSGridSquare
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MGRSGridSquare",
            "",
            &::xsd::cxx::tree::factory_impl< MGRSGridSquare_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MGRSGridSquare_.present ())
          {
            ::std::unique_ptr< MGRSGridSquare_type > r (
              dynamic_cast< MGRSGridSquare_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MGRSGridSquare_.set (::std::move (r));
            continue;
          }
        }
      }

      // MGRSPrecision
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MGRSPrecision",
            "",
            &::xsd::cxx::tree::factory_impl< MGRSPrecision_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MGRSPrecision_.present ())
          {
            ::std::unique_ptr< MGRSPrecision_type > r (
              dynamic_cast< MGRSPrecision_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MGRSPrecision_.set (::std::move (r));
            continue;
          }
        }
      }

      // MGRSEasting
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MGRSEasting",
            "",
            &::xsd::cxx::tree::factory_impl< MGRSEasting_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MGRSEasting_.present ())
          {
            ::std::unique_ptr< MGRSEasting_type > r (
              dynamic_cast< MGRSEasting_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MGRSEasting_.set (::std::move (r));
            continue;
          }
        }
      }

      // MGRSNorthing
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MGRSNorthing",
            "",
            &::xsd::cxx::tree::factory_impl< MGRSNorthing_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MGRSNorthing_.present ())
          {
            ::std::unique_ptr< MGRSNorthing_type > r (
              dynamic_cast< MGRSNorthing_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MGRSNorthing_.set (::std::move (r));
            continue;
          }
        }
      }

      // ElevationAGL
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ElevationAGL",
            "",
            &::xsd::cxx::tree::factory_impl< ElevationAGL_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ElevationAGL_)
          {
            ::std::unique_ptr< ElevationAGL_type > r (
              dynamic_cast< ElevationAGL_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ElevationAGL_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!MGRSGridZone_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MGRSGridZone",
        "");
    }

    if (!MGRSGridSquare_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MGRSGridSquare",
        "");
    }

    if (!MGRSPrecision_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MGRSPrecision",
        "");
    }

    if (!MGRSEasting_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MGRSEasting",
        "");
    }

    if (!MGRSNorthing_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MGRSNorthing",
        "");
    }
  }

  MGRSType* MGRSType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MGRSType (*this, f, c);
  }

  MGRSType& MGRSType::
  operator= (const MGRSType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->MGRSGridZone_ = x.MGRSGridZone_;
      this->MGRSGridSquare_ = x.MGRSGridSquare_;
      this->MGRSPrecision_ = x.MGRSPrecision_;
      this->MGRSEasting_ = x.MGRSEasting_;
      this->MGRSNorthing_ = x.MGRSNorthing_;
      this->ElevationAGL_ = x.ElevationAGL_;
    }

    return *this;
  }

  MGRSType::
  ~MGRSType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MGRSType >
  _xsd_MGRSType_type_factory_init (
    "MGRSType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, MGRSType >
  _xsd_MGRSType_comparison_init;

  bool
  operator== (const MGRSType& x, const MGRSType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.MGRSGridZone (), y.MGRSGridZone ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.MGRSGridSquare (), y.MGRSGridSquare ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.MGRSPrecision (), y.MGRSPrecision ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.MGRSEasting (), y.MGRSEasting ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.MGRSNorthing (), y.MGRSNorthing ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MGRSType::ElevationAGL_optional a (x.ElevationAGL ()), b (y.ElevationAGL ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const MGRSType& x, const MGRSType& y)
  {
    return !(x == y);
  }

  // MOOTWDispositionType
  //

  MOOTWDispositionType::
  MOOTWDispositionType (const Location_type& Location)
  : ::xml_schema::type (),
    Location_ (Location, this),
    DirectionOfMovement_ (this),
    Speed_ (this)
  {
  }

  MOOTWDispositionType::
  MOOTWDispositionType (::std::unique_ptr< Location_type > Location)
  : ::xml_schema::type (),
    Location_ (std::move (Location), this),
    DirectionOfMovement_ (this),
    Speed_ (this)
  {
  }

  MOOTWDispositionType::
  MOOTWDispositionType (const MOOTWDispositionType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Location_ (x.Location_, f, this),
    DirectionOfMovement_ (x.DirectionOfMovement_, f, this),
    Speed_ (x.Speed_, f, this)
  {
  }

  MOOTWDispositionType::
  MOOTWDispositionType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Location_ (this),
    DirectionOfMovement_ (this),
    Speed_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MOOTWDispositionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Location
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Location",
            "",
            &::xsd::cxx::tree::factory_impl< Location_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Location_.present ())
          {
            ::std::unique_ptr< Location_type > r (
              dynamic_cast< Location_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Location_.set (::std::move (r));
            continue;
          }
        }
      }

      // DirectionOfMovement
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DirectionOfMovement",
            "",
            &::xsd::cxx::tree::factory_impl< DirectionOfMovement_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DirectionOfMovement_)
          {
            ::std::unique_ptr< DirectionOfMovement_type > r (
              dynamic_cast< DirectionOfMovement_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DirectionOfMovement_.set (::std::move (r));
            continue;
          }
        }
      }

      // Speed
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Speed",
            "",
            &::xsd::cxx::tree::factory_impl< Speed_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Speed_)
          {
            ::std::unique_ptr< Speed_type > r (
              dynamic_cast< Speed_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Speed_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Location_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Location",
        "");
    }
  }

  MOOTWDispositionType* MOOTWDispositionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MOOTWDispositionType (*this, f, c);
  }

  MOOTWDispositionType& MOOTWDispositionType::
  operator= (const MOOTWDispositionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Location_ = x.Location_;
      this->DirectionOfMovement_ = x.DirectionOfMovement_;
      this->Speed_ = x.Speed_;
    }

    return *this;
  }

  MOOTWDispositionType::
  ~MOOTWDispositionType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MOOTWDispositionType >
  _xsd_MOOTWDispositionType_type_factory_init (
    "MOOTWDispositionType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, MOOTWDispositionType >
  _xsd_MOOTWDispositionType_comparison_init;

  bool
  operator== (const MOOTWDispositionType& x, const MOOTWDispositionType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Location (), y.Location ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MOOTWDispositionType::DirectionOfMovement_optional a (x.DirectionOfMovement ()), b (y.DirectionOfMovement ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MOOTWDispositionType::Speed_optional a (x.Speed ()), b (y.Speed ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const MOOTWDispositionType& x, const MOOTWDispositionType& y)
  {
    return !(x == y);
  }

  // MOOTWGraphicsType
  //

  MOOTWGraphicsType::
  MOOTWGraphicsType ()
  : ::xml_schema::type (),
    MOOTWGraphic_ (this)
  {
  }

  MOOTWGraphicsType::
  MOOTWGraphicsType (const MOOTWGraphicsType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    MOOTWGraphic_ (x.MOOTWGraphic_, f, this)
  {
  }

  MOOTWGraphicsType::
  MOOTWGraphicsType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    MOOTWGraphic_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MOOTWGraphicsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MOOTWGraphic
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MOOTWGraphic",
            "",
            &::xsd::cxx::tree::factory_impl< MOOTWGraphic_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< MOOTWGraphic_type > r (
            dynamic_cast< MOOTWGraphic_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->MOOTWGraphic_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  MOOTWGraphicsType* MOOTWGraphicsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MOOTWGraphicsType (*this, f, c);
  }

  MOOTWGraphicsType& MOOTWGraphicsType::
  operator= (const MOOTWGraphicsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->MOOTWGraphic_ = x.MOOTWGraphic_;
    }

    return *this;
  }

  MOOTWGraphicsType::
  ~MOOTWGraphicsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MOOTWGraphicsType >
  _xsd_MOOTWGraphicsType_type_factory_init (
    "MOOTWGraphicsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, MOOTWGraphicsType >
  _xsd_MOOTWGraphicsType_comparison_init;

  bool
  operator== (const MOOTWGraphicsType& x, const MOOTWGraphicsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MOOTWGraphicsType::MOOTWGraphic_sequence a (x.MOOTWGraphic ()), b (y.MOOTWGraphic ());

      if (a.size () != b.size ())
        return false;

      for (MOOTWGraphicsType::MOOTWGraphic_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const MOOTWGraphicsType& x, const MOOTWGraphicsType& y)
  {
    return !(x == y);
  }

  // MOOTWGraphicType
  //

  MOOTWGraphicType::
  MOOTWGraphicType (const ObjectHandle_type& ObjectHandle,
                    const SymbolIdentifier_type& SymbolIdentifier,
                    const Affiliation_type& Affiliation,
                    const Owner_type& Owner,
                    const Disposition_type& Disposition)
  : ::xml_schema::type (),
    ObjectHandle_ (ObjectHandle, this),
    SymbolIdentifier_ (SymbolIdentifier, this),
    Affiliation_ (Affiliation, this),
    Owner_ (Owner, this),
    MOOTWSymbolModifiers_ (this),
    AssociatedOverlays_ (this),
    Disposition_ (Disposition, this)
  {
  }

  MOOTWGraphicType::
  MOOTWGraphicType (const ObjectHandle_type& ObjectHandle,
                    const SymbolIdentifier_type& SymbolIdentifier,
                    const Affiliation_type& Affiliation,
                    ::std::unique_ptr< Owner_type > Owner,
                    ::std::unique_ptr< Disposition_type > Disposition)
  : ::xml_schema::type (),
    ObjectHandle_ (ObjectHandle, this),
    SymbolIdentifier_ (SymbolIdentifier, this),
    Affiliation_ (Affiliation, this),
    Owner_ (std::move (Owner), this),
    MOOTWSymbolModifiers_ (this),
    AssociatedOverlays_ (this),
    Disposition_ (std::move (Disposition), this)
  {
  }

  MOOTWGraphicType::
  MOOTWGraphicType (::std::unique_ptr< ObjectHandle_type > ObjectHandle,
                    ::std::unique_ptr< SymbolIdentifier_type > SymbolIdentifier,
                    ::std::unique_ptr< Affiliation_type > Affiliation,
                    ::std::unique_ptr< Owner_type > Owner,
                    ::std::unique_ptr< Disposition_type > Disposition)
  : ::xml_schema::type (),
    ObjectHandle_ (std::move (ObjectHandle), this),
    SymbolIdentifier_ (std::move (SymbolIdentifier), this),
    Affiliation_ (std::move (Affiliation), this),
    Owner_ (std::move (Owner), this),
    MOOTWSymbolModifiers_ (this),
    AssociatedOverlays_ (this),
    Disposition_ (std::move (Disposition), this)
  {
  }

  MOOTWGraphicType::
  MOOTWGraphicType (const MOOTWGraphicType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ObjectHandle_ (x.ObjectHandle_, f, this),
    SymbolIdentifier_ (x.SymbolIdentifier_, f, this),
    Affiliation_ (x.Affiliation_, f, this),
    Owner_ (x.Owner_, f, this),
    MOOTWSymbolModifiers_ (x.MOOTWSymbolModifiers_, f, this),
    AssociatedOverlays_ (x.AssociatedOverlays_, f, this),
    Disposition_ (x.Disposition_, f, this)
  {
  }

  MOOTWGraphicType::
  MOOTWGraphicType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ObjectHandle_ (this),
    SymbolIdentifier_ (this),
    Affiliation_ (this),
    Owner_ (this),
    MOOTWSymbolModifiers_ (this),
    AssociatedOverlays_ (this),
    Disposition_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MOOTWGraphicType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ObjectHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ObjectHandle",
            "",
            &::xsd::cxx::tree::factory_impl< ObjectHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ObjectHandle_.present ())
          {
            ::std::unique_ptr< ObjectHandle_type > r (
              dynamic_cast< ObjectHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ObjectHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // SymbolIdentifier
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SymbolIdentifier",
            "",
            &::xsd::cxx::tree::factory_impl< SymbolIdentifier_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!SymbolIdentifier_.present ())
          {
            ::std::unique_ptr< SymbolIdentifier_type > r (
              dynamic_cast< SymbolIdentifier_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SymbolIdentifier_.set (::std::move (r));
            continue;
          }
        }
      }

      // Affiliation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Affiliation",
            "",
            &::xsd::cxx::tree::factory_impl< Affiliation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Affiliation_.present ())
          {
            ::std::unique_ptr< Affiliation_type > r (
              dynamic_cast< Affiliation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Affiliation_.set (::std::move (r));
            continue;
          }
        }
      }

      // Owner
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Owner",
            "",
            &::xsd::cxx::tree::factory_impl< Owner_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Owner_.present ())
          {
            ::std::unique_ptr< Owner_type > r (
              dynamic_cast< Owner_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Owner_.set (::std::move (r));
            continue;
          }
        }
      }

      // MOOTWSymbolModifiers
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MOOTWSymbolModifiers",
            "",
            &::xsd::cxx::tree::factory_impl< MOOTWSymbolModifiers_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MOOTWSymbolModifiers_)
          {
            ::std::unique_ptr< MOOTWSymbolModifiers_type > r (
              dynamic_cast< MOOTWSymbolModifiers_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MOOTWSymbolModifiers_.set (::std::move (r));
            continue;
          }
        }
      }

      // AssociatedOverlays
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AssociatedOverlays",
            "",
            &::xsd::cxx::tree::factory_impl< AssociatedOverlays_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AssociatedOverlays_)
          {
            ::std::unique_ptr< AssociatedOverlays_type > r (
              dynamic_cast< AssociatedOverlays_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AssociatedOverlays_.set (::std::move (r));
            continue;
          }
        }
      }

      // Disposition
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Disposition",
            "",
            &::xsd::cxx::tree::factory_impl< Disposition_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Disposition_.present ())
          {
            ::std::unique_ptr< Disposition_type > r (
              dynamic_cast< Disposition_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Disposition_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ObjectHandle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ObjectHandle",
        "");
    }

    if (!SymbolIdentifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SymbolIdentifier",
        "");
    }

    if (!Affiliation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Affiliation",
        "");
    }

    if (!Owner_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Owner",
        "");
    }

    if (!Disposition_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Disposition",
        "");
    }
  }

  MOOTWGraphicType* MOOTWGraphicType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MOOTWGraphicType (*this, f, c);
  }

  MOOTWGraphicType& MOOTWGraphicType::
  operator= (const MOOTWGraphicType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ObjectHandle_ = x.ObjectHandle_;
      this->SymbolIdentifier_ = x.SymbolIdentifier_;
      this->Affiliation_ = x.Affiliation_;
      this->Owner_ = x.Owner_;
      this->MOOTWSymbolModifiers_ = x.MOOTWSymbolModifiers_;
      this->AssociatedOverlays_ = x.AssociatedOverlays_;
      this->Disposition_ = x.Disposition_;
    }

    return *this;
  }

  MOOTWGraphicType::
  ~MOOTWGraphicType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MOOTWGraphicType >
  _xsd_MOOTWGraphicType_type_factory_init (
    "MOOTWGraphicType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, MOOTWGraphicType >
  _xsd_MOOTWGraphicType_comparison_init;

  bool
  operator== (const MOOTWGraphicType& x, const MOOTWGraphicType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ObjectHandle (), y.ObjectHandle ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.SymbolIdentifier (), y.SymbolIdentifier ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Affiliation (), y.Affiliation ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Owner (), y.Owner ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MOOTWGraphicType::MOOTWSymbolModifiers_optional a (x.MOOTWSymbolModifiers ()), b (y.MOOTWSymbolModifiers ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MOOTWGraphicType::AssociatedOverlays_optional a (x.AssociatedOverlays ()), b (y.AssociatedOverlays ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Disposition (), y.Disposition ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const MOOTWGraphicType& x, const MOOTWGraphicType& y)
  {
    return !(x == y);
  }

  // MOOTWSymbolModifiersType
  //

  MOOTWSymbolModifiersType::
  MOOTWSymbolModifiersType (const UniqueDesignation_type& UniqueDesignation)
  : ::xml_schema::type (),
    Echelon_ (this),
    ReinforcedReduced_ (this),
    FrameShapeModifier_ (this),
    StaffComments_ (this),
    AdditionalInfo_ (this),
    CombatEffectiveness_ (this),
    IFF_ (this),
    UniqueDesignation_ (UniqueDesignation, this),
    DateTimeGroup_ (this),
    SpecialC2HQ_ (this)
  {
  }

  MOOTWSymbolModifiersType::
  MOOTWSymbolModifiersType (::std::unique_ptr< UniqueDesignation_type > UniqueDesignation)
  : ::xml_schema::type (),
    Echelon_ (this),
    ReinforcedReduced_ (this),
    FrameShapeModifier_ (this),
    StaffComments_ (this),
    AdditionalInfo_ (this),
    CombatEffectiveness_ (this),
    IFF_ (this),
    UniqueDesignation_ (std::move (UniqueDesignation), this),
    DateTimeGroup_ (this),
    SpecialC2HQ_ (this)
  {
  }

  MOOTWSymbolModifiersType::
  MOOTWSymbolModifiersType (const MOOTWSymbolModifiersType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Echelon_ (x.Echelon_, f, this),
    ReinforcedReduced_ (x.ReinforcedReduced_, f, this),
    FrameShapeModifier_ (x.FrameShapeModifier_, f, this),
    StaffComments_ (x.StaffComments_, f, this),
    AdditionalInfo_ (x.AdditionalInfo_, f, this),
    CombatEffectiveness_ (x.CombatEffectiveness_, f, this),
    IFF_ (x.IFF_, f, this),
    UniqueDesignation_ (x.UniqueDesignation_, f, this),
    DateTimeGroup_ (x.DateTimeGroup_, f, this),
    SpecialC2HQ_ (x.SpecialC2HQ_, f, this)
  {
  }

  MOOTWSymbolModifiersType::
  MOOTWSymbolModifiersType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Echelon_ (this),
    ReinforcedReduced_ (this),
    FrameShapeModifier_ (this),
    StaffComments_ (this),
    AdditionalInfo_ (this),
    CombatEffectiveness_ (this),
    IFF_ (this),
    UniqueDesignation_ (this),
    DateTimeGroup_ (this),
    SpecialC2HQ_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MOOTWSymbolModifiersType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Echelon
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Echelon",
            "",
            &::xsd::cxx::tree::factory_impl< Echelon_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Echelon_)
          {
            ::std::unique_ptr< Echelon_type > r (
              dynamic_cast< Echelon_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Echelon_.set (::std::move (r));
            continue;
          }
        }
      }

      // ReinforcedReduced
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ReinforcedReduced",
            "",
            &::xsd::cxx::tree::factory_impl< ReinforcedReduced_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ReinforcedReduced_)
          {
            ::std::unique_ptr< ReinforcedReduced_type > r (
              dynamic_cast< ReinforcedReduced_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ReinforcedReduced_.set (::std::move (r));
            continue;
          }
        }
      }

      // FrameShapeModifier
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "FrameShapeModifier",
            "",
            &::xsd::cxx::tree::factory_impl< FrameShapeModifier_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->FrameShapeModifier_)
          {
            ::std::unique_ptr< FrameShapeModifier_type > r (
              dynamic_cast< FrameShapeModifier_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FrameShapeModifier_.set (::std::move (r));
            continue;
          }
        }
      }

      // StaffComments
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "StaffComments",
            "",
            &::xsd::cxx::tree::factory_impl< StaffComments_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->StaffComments_)
          {
            ::std::unique_ptr< StaffComments_type > r (
              dynamic_cast< StaffComments_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->StaffComments_.set (::std::move (r));
            continue;
          }
        }
      }

      // AdditionalInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AdditionalInfo",
            "",
            &::xsd::cxx::tree::factory_impl< AdditionalInfo_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AdditionalInfo_)
          {
            ::std::unique_ptr< AdditionalInfo_type > r (
              dynamic_cast< AdditionalInfo_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AdditionalInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      // CombatEffectiveness
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CombatEffectiveness",
            "",
            &::xsd::cxx::tree::factory_impl< CombatEffectiveness_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CombatEffectiveness_)
          {
            ::std::unique_ptr< CombatEffectiveness_type > r (
              dynamic_cast< CombatEffectiveness_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CombatEffectiveness_.set (::std::move (r));
            continue;
          }
        }
      }

      // IFF
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "IFF",
            "",
            &::xsd::cxx::tree::factory_impl< IFF_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->IFF_)
          {
            ::std::unique_ptr< IFF_type > r (
              dynamic_cast< IFF_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->IFF_.set (::std::move (r));
            continue;
          }
        }
      }

      // UniqueDesignation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UniqueDesignation",
            "",
            &::xsd::cxx::tree::factory_impl< UniqueDesignation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!UniqueDesignation_.present ())
          {
            ::std::unique_ptr< UniqueDesignation_type > r (
              dynamic_cast< UniqueDesignation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UniqueDesignation_.set (::std::move (r));
            continue;
          }
        }
      }

      // DateTimeGroup
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DateTimeGroup",
            "",
            &::xsd::cxx::tree::factory_impl< DateTimeGroup_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DateTimeGroup_)
          {
            ::std::unique_ptr< DateTimeGroup_type > r (
              dynamic_cast< DateTimeGroup_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DateTimeGroup_.set (::std::move (r));
            continue;
          }
        }
      }

      // SpecialC2HQ
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SpecialC2HQ",
            "",
            &::xsd::cxx::tree::factory_impl< SpecialC2HQ_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SpecialC2HQ_)
          {
            ::std::unique_ptr< SpecialC2HQ_type > r (
              dynamic_cast< SpecialC2HQ_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SpecialC2HQ_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!UniqueDesignation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "UniqueDesignation",
        "");
    }
  }

  MOOTWSymbolModifiersType* MOOTWSymbolModifiersType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MOOTWSymbolModifiersType (*this, f, c);
  }

  MOOTWSymbolModifiersType& MOOTWSymbolModifiersType::
  operator= (const MOOTWSymbolModifiersType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Echelon_ = x.Echelon_;
      this->ReinforcedReduced_ = x.ReinforcedReduced_;
      this->FrameShapeModifier_ = x.FrameShapeModifier_;
      this->StaffComments_ = x.StaffComments_;
      this->AdditionalInfo_ = x.AdditionalInfo_;
      this->CombatEffectiveness_ = x.CombatEffectiveness_;
      this->IFF_ = x.IFF_;
      this->UniqueDesignation_ = x.UniqueDesignation_;
      this->DateTimeGroup_ = x.DateTimeGroup_;
      this->SpecialC2HQ_ = x.SpecialC2HQ_;
    }

    return *this;
  }

  MOOTWSymbolModifiersType::
  ~MOOTWSymbolModifiersType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MOOTWSymbolModifiersType >
  _xsd_MOOTWSymbolModifiersType_type_factory_init (
    "MOOTWSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, MOOTWSymbolModifiersType >
  _xsd_MOOTWSymbolModifiersType_comparison_init;

  bool
  operator== (const MOOTWSymbolModifiersType& x, const MOOTWSymbolModifiersType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MOOTWSymbolModifiersType::Echelon_optional a (x.Echelon ()), b (y.Echelon ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MOOTWSymbolModifiersType::ReinforcedReduced_optional a (x.ReinforcedReduced ()), b (y.ReinforcedReduced ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MOOTWSymbolModifiersType::FrameShapeModifier_optional a (x.FrameShapeModifier ()), b (y.FrameShapeModifier ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MOOTWSymbolModifiersType::StaffComments_optional a (x.StaffComments ()), b (y.StaffComments ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MOOTWSymbolModifiersType::AdditionalInfo_optional a (x.AdditionalInfo ()), b (y.AdditionalInfo ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MOOTWSymbolModifiersType::CombatEffectiveness_optional a (x.CombatEffectiveness ()), b (y.CombatEffectiveness ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MOOTWSymbolModifiersType::IFF_optional a (x.IFF ()), b (y.IFF ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.UniqueDesignation (), y.UniqueDesignation ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MOOTWSymbolModifiersType::DateTimeGroup_optional a (x.DateTimeGroup ()), b (y.DateTimeGroup ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      MOOTWSymbolModifiersType::SpecialC2HQ_optional a (x.SpecialC2HQ ()), b (y.SpecialC2HQ ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const MOOTWSymbolModifiersType& x, const MOOTWSymbolModifiersType& y)
  {
    return !(x == y);
  }

  // NBCEventSymbolModifiersType
  //

  NBCEventSymbolModifiersType::
  NBCEventSymbolModifiersType (const Speed_type& Speed,
                               const DirectionOfMovement_type& DirectionOfMovement)
  : ::xml_schema::type (),
    Quantity_ (this),
    AdditionalInfo_ (this),
    UniqueDesignation_ (this),
    NBCType_ (this),
    DateTimeGroup_ (this),
    Speed_ (Speed, this),
    DirectionOfMovement_ (DirectionOfMovement, this)
  {
  }

  NBCEventSymbolModifiersType::
  NBCEventSymbolModifiersType (::std::unique_ptr< Speed_type > Speed,
                               ::std::unique_ptr< DirectionOfMovement_type > DirectionOfMovement)
  : ::xml_schema::type (),
    Quantity_ (this),
    AdditionalInfo_ (this),
    UniqueDesignation_ (this),
    NBCType_ (this),
    DateTimeGroup_ (this),
    Speed_ (std::move (Speed), this),
    DirectionOfMovement_ (std::move (DirectionOfMovement), this)
  {
  }

  NBCEventSymbolModifiersType::
  NBCEventSymbolModifiersType (const NBCEventSymbolModifiersType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Quantity_ (x.Quantity_, f, this),
    AdditionalInfo_ (x.AdditionalInfo_, f, this),
    UniqueDesignation_ (x.UniqueDesignation_, f, this),
    NBCType_ (x.NBCType_, f, this),
    DateTimeGroup_ (x.DateTimeGroup_, f, this),
    Speed_ (x.Speed_, f, this),
    DirectionOfMovement_ (x.DirectionOfMovement_, f, this)
  {
  }

  NBCEventSymbolModifiersType::
  NBCEventSymbolModifiersType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Quantity_ (this),
    AdditionalInfo_ (this),
    UniqueDesignation_ (this),
    NBCType_ (this),
    DateTimeGroup_ (this),
    Speed_ (this),
    DirectionOfMovement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void NBCEventSymbolModifiersType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Quantity
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Quantity",
            "",
            &::xsd::cxx::tree::factory_impl< Quantity_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Quantity_)
          {
            ::std::unique_ptr< Quantity_type > r (
              dynamic_cast< Quantity_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Quantity_.set (::std::move (r));
            continue;
          }
        }
      }

      // AdditionalInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AdditionalInfo",
            "",
            &::xsd::cxx::tree::factory_impl< AdditionalInfo_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AdditionalInfo_)
          {
            ::std::unique_ptr< AdditionalInfo_type > r (
              dynamic_cast< AdditionalInfo_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AdditionalInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      // UniqueDesignation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UniqueDesignation",
            "",
            &::xsd::cxx::tree::factory_impl< UniqueDesignation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->UniqueDesignation_)
          {
            ::std::unique_ptr< UniqueDesignation_type > r (
              dynamic_cast< UniqueDesignation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UniqueDesignation_.set (::std::move (r));
            continue;
          }
        }
      }

      // NBCType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "NBCType",
            "",
            &::xsd::cxx::tree::factory_impl< NBCType_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->NBCType_)
          {
            ::std::unique_ptr< NBCType_type > r (
              dynamic_cast< NBCType_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->NBCType_.set (::std::move (r));
            continue;
          }
        }
      }

      // DateTimeGroup
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DateTimeGroup",
            "",
            &::xsd::cxx::tree::factory_impl< DateTimeGroup_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DateTimeGroup_)
          {
            ::std::unique_ptr< DateTimeGroup_type > r (
              dynamic_cast< DateTimeGroup_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DateTimeGroup_.set (::std::move (r));
            continue;
          }
        }
      }

      // Speed
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Speed",
            "",
            &::xsd::cxx::tree::factory_impl< Speed_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Speed_.present ())
          {
            ::std::unique_ptr< Speed_type > r (
              dynamic_cast< Speed_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Speed_.set (::std::move (r));
            continue;
          }
        }
      }

      // DirectionOfMovement
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DirectionOfMovement",
            "",
            &::xsd::cxx::tree::factory_impl< DirectionOfMovement_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!DirectionOfMovement_.present ())
          {
            ::std::unique_ptr< DirectionOfMovement_type > r (
              dynamic_cast< DirectionOfMovement_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DirectionOfMovement_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Speed_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Speed",
        "");
    }

    if (!DirectionOfMovement_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DirectionOfMovement",
        "");
    }
  }

  NBCEventSymbolModifiersType* NBCEventSymbolModifiersType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NBCEventSymbolModifiersType (*this, f, c);
  }

  NBCEventSymbolModifiersType& NBCEventSymbolModifiersType::
  operator= (const NBCEventSymbolModifiersType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Quantity_ = x.Quantity_;
      this->AdditionalInfo_ = x.AdditionalInfo_;
      this->UniqueDesignation_ = x.UniqueDesignation_;
      this->NBCType_ = x.NBCType_;
      this->DateTimeGroup_ = x.DateTimeGroup_;
      this->Speed_ = x.Speed_;
      this->DirectionOfMovement_ = x.DirectionOfMovement_;
    }

    return *this;
  }

  NBCEventSymbolModifiersType::
  ~NBCEventSymbolModifiersType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, NBCEventSymbolModifiersType >
  _xsd_NBCEventSymbolModifiersType_type_factory_init (
    "NBCEventSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, NBCEventSymbolModifiersType >
  _xsd_NBCEventSymbolModifiersType_comparison_init;

  bool
  operator== (const NBCEventSymbolModifiersType& x, const NBCEventSymbolModifiersType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      NBCEventSymbolModifiersType::Quantity_optional a (x.Quantity ()), b (y.Quantity ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      NBCEventSymbolModifiersType::AdditionalInfo_optional a (x.AdditionalInfo ()), b (y.AdditionalInfo ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      NBCEventSymbolModifiersType::UniqueDesignation_optional a (x.UniqueDesignation ()), b (y.UniqueDesignation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      NBCEventSymbolModifiersType::NBCType_optional a (x.NBCType ()), b (y.NBCType ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      NBCEventSymbolModifiersType::DateTimeGroup_optional a (x.DateTimeGroup ()), b (y.DateTimeGroup ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Speed (), y.Speed ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.DirectionOfMovement (), y.DirectionOfMovement ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const NBCEventSymbolModifiersType& x, const NBCEventSymbolModifiersType& y)
  {
    return !(x == y);
  }

  // OptionsType
  //

  OptionsType::
  OptionsType (const MSDLVersion_type& MSDLVersion)
  : ::xml_schema::type (),
    MSDLVersion_ (MSDLVersion, this),
    OrganizationDetail_ (this),
    ScenarioDataStandards_ (this)
  {
  }

  OptionsType::
  OptionsType (::std::unique_ptr< MSDLVersion_type > MSDLVersion)
  : ::xml_schema::type (),
    MSDLVersion_ (std::move (MSDLVersion), this),
    OrganizationDetail_ (this),
    ScenarioDataStandards_ (this)
  {
  }

  OptionsType::
  OptionsType (const OptionsType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    MSDLVersion_ (x.MSDLVersion_, f, this),
    OrganizationDetail_ (x.OrganizationDetail_, f, this),
    ScenarioDataStandards_ (x.ScenarioDataStandards_, f, this)
  {
  }

  OptionsType::
  OptionsType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    MSDLVersion_ (this),
    OrganizationDetail_ (this),
    ScenarioDataStandards_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OptionsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MSDLVersion
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MSDLVersion",
            "",
            &::xsd::cxx::tree::factory_impl< MSDLVersion_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MSDLVersion_.present ())
          {
            ::std::unique_ptr< MSDLVersion_type > r (
              dynamic_cast< MSDLVersion_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MSDLVersion_.set (::std::move (r));
            continue;
          }
        }
      }

      // OrganizationDetail
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OrganizationDetail",
            "",
            &::xsd::cxx::tree::factory_impl< OrganizationDetail_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->OrganizationDetail_)
          {
            ::std::unique_ptr< OrganizationDetail_type > r (
              dynamic_cast< OrganizationDetail_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OrganizationDetail_.set (::std::move (r));
            continue;
          }
        }
      }

      // ScenarioDataStandards
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ScenarioDataStandards",
            "",
            &::xsd::cxx::tree::factory_impl< ScenarioDataStandards_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ScenarioDataStandards_)
          {
            ::std::unique_ptr< ScenarioDataStandards_type > r (
              dynamic_cast< ScenarioDataStandards_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ScenarioDataStandards_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!MSDLVersion_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MSDLVersion",
        "");
    }
  }

  OptionsType* OptionsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OptionsType (*this, f, c);
  }

  OptionsType& OptionsType::
  operator= (const OptionsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->MSDLVersion_ = x.MSDLVersion_;
      this->OrganizationDetail_ = x.OrganizationDetail_;
      this->ScenarioDataStandards_ = x.ScenarioDataStandards_;
    }

    return *this;
  }

  OptionsType::
  ~OptionsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OptionsType >
  _xsd_OptionsType_type_factory_init (
    "OptionsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, OptionsType >
  _xsd_OptionsType_comparison_init;

  bool
  operator== (const OptionsType& x, const OptionsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.MSDLVersion (), y.MSDLVersion ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      OptionsType::OrganizationDetail_optional a (x.OrganizationDetail ()), b (y.OrganizationDetail ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      OptionsType::ScenarioDataStandards_optional a (x.ScenarioDataStandards ()), b (y.ScenarioDataStandards ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const OptionsType& x, const OptionsType& y)
  {
    return !(x == y);
  }

  // OrganicRelationDataType
  //

  OrganicRelationDataType::
  OrganicRelationDataType ()
  : ::xml_schema::type (),
    OrganicForceSideHandle_ (this),
    OrganicSuperiorHandle_ (this)
  {
  }

  OrganicRelationDataType::
  OrganicRelationDataType (const OrganicRelationDataType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    OrganicForceSideHandle_ (x.OrganicForceSideHandle_, f, this),
    OrganicSuperiorHandle_ (x.OrganicSuperiorHandle_, f, this)
  {
  }

  OrganicRelationDataType::
  OrganicRelationDataType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    OrganicForceSideHandle_ (this),
    OrganicSuperiorHandle_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OrganicRelationDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OrganicForceSideHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OrganicForceSideHandle",
            "",
            &::xsd::cxx::tree::factory_impl< OrganicForceSideHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->OrganicForceSideHandle_)
          {
            ::std::unique_ptr< OrganicForceSideHandle_type > r (
              dynamic_cast< OrganicForceSideHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OrganicForceSideHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // OrganicSuperiorHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OrganicSuperiorHandle",
            "",
            &::xsd::cxx::tree::factory_impl< OrganicSuperiorHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->OrganicSuperiorHandle_)
          {
            ::std::unique_ptr< OrganicSuperiorHandle_type > r (
              dynamic_cast< OrganicSuperiorHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OrganicSuperiorHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  OrganicRelationDataType* OrganicRelationDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OrganicRelationDataType (*this, f, c);
  }

  OrganicRelationDataType& OrganicRelationDataType::
  operator= (const OrganicRelationDataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->OrganicForceSideHandle_ = x.OrganicForceSideHandle_;
      this->OrganicSuperiorHandle_ = x.OrganicSuperiorHandle_;
    }

    return *this;
  }

  OrganicRelationDataType::
  ~OrganicRelationDataType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OrganicRelationDataType >
  _xsd_OrganicRelationDataType_type_factory_init (
    "OrganicRelationDataType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, OrganicRelationDataType >
  _xsd_OrganicRelationDataType_comparison_init;

  bool
  operator== (const OrganicRelationDataType& x, const OrganicRelationDataType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      OrganicRelationDataType::OrganicForceSideHandle_optional a (x.OrganicForceSideHandle ()), b (y.OrganicForceSideHandle ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      OrganicRelationDataType::OrganicSuperiorHandle_optional a (x.OrganicSuperiorHandle ()), b (y.OrganicSuperiorHandle ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const OrganicRelationDataType& x, const OrganicRelationDataType& y)
  {
    return !(x == y);
  }

  // OrganicRelationType
  //

  OrganicRelationType::
  OrganicRelationType (const OrganicRelationData_type& OrganicRelationData,
                       const OrganicRelationChoice_type& OrganicRelationChoice)
  : ::xml_schema::type (),
    OrganicRelationData_ (OrganicRelationData, this),
    OrganicRelationChoice_ (OrganicRelationChoice, this)
  {
  }

  OrganicRelationType::
  OrganicRelationType (::std::unique_ptr< OrganicRelationData_type > OrganicRelationData,
                       const OrganicRelationChoice_type& OrganicRelationChoice)
  : ::xml_schema::type (),
    OrganicRelationData_ (std::move (OrganicRelationData), this),
    OrganicRelationChoice_ (OrganicRelationChoice, this)
  {
  }

  OrganicRelationType::
  OrganicRelationType (::std::unique_ptr< OrganicRelationData_type > OrganicRelationData,
                       ::std::unique_ptr< OrganicRelationChoice_type > OrganicRelationChoice)
  : ::xml_schema::type (),
    OrganicRelationData_ (std::move (OrganicRelationData), this),
    OrganicRelationChoice_ (std::move (OrganicRelationChoice), this)
  {
  }

  OrganicRelationType::
  OrganicRelationType (const OrganicRelationType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    OrganicRelationData_ (x.OrganicRelationData_, f, this),
    OrganicRelationChoice_ (x.OrganicRelationChoice_, f, this)
  {
  }

  OrganicRelationType::
  OrganicRelationType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    OrganicRelationData_ (this),
    OrganicRelationChoice_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OrganicRelationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OrganicRelationData
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OrganicRelationData",
            "",
            &::xsd::cxx::tree::factory_impl< OrganicRelationData_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!OrganicRelationData_.present ())
          {
            ::std::unique_ptr< OrganicRelationData_type > r (
              dynamic_cast< OrganicRelationData_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OrganicRelationData_.set (::std::move (r));
            continue;
          }
        }
      }

      // OrganicRelationChoice
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OrganicRelationChoice",
            "",
            &::xsd::cxx::tree::factory_impl< OrganicRelationChoice_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!OrganicRelationChoice_.present ())
          {
            ::std::unique_ptr< OrganicRelationChoice_type > r (
              dynamic_cast< OrganicRelationChoice_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OrganicRelationChoice_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!OrganicRelationData_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "OrganicRelationData",
        "");
    }

    if (!OrganicRelationChoice_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "OrganicRelationChoice",
        "");
    }
  }

  OrganicRelationType* OrganicRelationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OrganicRelationType (*this, f, c);
  }

  OrganicRelationType& OrganicRelationType::
  operator= (const OrganicRelationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->OrganicRelationData_ = x.OrganicRelationData_;
      this->OrganicRelationChoice_ = x.OrganicRelationChoice_;
    }

    return *this;
  }

  OrganicRelationType::
  ~OrganicRelationType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OrganicRelationType >
  _xsd_OrganicRelationType_type_factory_init (
    "OrganicRelationType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, OrganicRelationType >
  _xsd_OrganicRelationType_comparison_init;

  bool
  operator== (const OrganicRelationType& x, const OrganicRelationType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.OrganicRelationData (), y.OrganicRelationData ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.OrganicRelationChoice (), y.OrganicRelationChoice ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const OrganicRelationType& x, const OrganicRelationType& y)
  {
    return !(x == y);
  }

  // OrganizationDetailType
  //

  OrganizationDetailType::
  OrganizationDetailType (const AggregateBased_type& AggregateBased)
  : ::xml_schema::type (),
    AggregateBased_ (AggregateBased, this),
    AggregateEchelon_ (this)
  {
  }

  OrganizationDetailType::
  OrganizationDetailType (::std::unique_ptr< AggregateBased_type > AggregateBased)
  : ::xml_schema::type (),
    AggregateBased_ (std::move (AggregateBased), this),
    AggregateEchelon_ (this)
  {
  }

  OrganizationDetailType::
  OrganizationDetailType (const OrganizationDetailType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AggregateBased_ (x.AggregateBased_, f, this),
    AggregateEchelon_ (x.AggregateEchelon_, f, this)
  {
  }

  OrganizationDetailType::
  OrganizationDetailType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AggregateBased_ (this),
    AggregateEchelon_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OrganizationDetailType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AggregateBased
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AggregateBased",
            "",
            &::xsd::cxx::tree::factory_impl< AggregateBased_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!AggregateBased_.present ())
          {
            ::std::unique_ptr< AggregateBased_type > r (
              dynamic_cast< AggregateBased_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AggregateBased_.set (::std::move (r));
            continue;
          }
        }
      }

      // AggregateEchelon
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AggregateEchelon",
            "",
            &::xsd::cxx::tree::factory_impl< AggregateEchelon_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AggregateEchelon_)
          {
            ::std::unique_ptr< AggregateEchelon_type > r (
              dynamic_cast< AggregateEchelon_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AggregateEchelon_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!AggregateBased_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AggregateBased",
        "");
    }
  }

  OrganizationDetailType* OrganizationDetailType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OrganizationDetailType (*this, f, c);
  }

  OrganizationDetailType& OrganizationDetailType::
  operator= (const OrganizationDetailType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AggregateBased_ = x.AggregateBased_;
      this->AggregateEchelon_ = x.AggregateEchelon_;
    }

    return *this;
  }

  OrganizationDetailType::
  ~OrganizationDetailType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OrganizationDetailType >
  _xsd_OrganizationDetailType_type_factory_init (
    "OrganizationDetailType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, OrganizationDetailType >
  _xsd_OrganizationDetailType_comparison_init;

  bool
  operator== (const OrganizationDetailType& x, const OrganizationDetailType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.AggregateBased (), y.AggregateBased ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      OrganizationDetailType::AggregateEchelon_optional a (x.AggregateEchelon ()), b (y.AggregateEchelon ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const OrganizationDetailType& x, const OrganizationDetailType& y)
  {
    return !(x == y);
  }

  // OrganizationsType
  //

  OrganizationsType::
  OrganizationsType (const Units_type& Units)
  : ::xml_schema::type (),
    Units_ (Units, this),
    Equipment_ (this)
  {
  }

  OrganizationsType::
  OrganizationsType (::std::unique_ptr< Units_type > Units)
  : ::xml_schema::type (),
    Units_ (std::move (Units), this),
    Equipment_ (this)
  {
  }

  OrganizationsType::
  OrganizationsType (const OrganizationsType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Units_ (x.Units_, f, this),
    Equipment_ (x.Equipment_, f, this)
  {
  }

  OrganizationsType::
  OrganizationsType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Units_ (this),
    Equipment_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OrganizationsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Units
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Units",
            "",
            &::xsd::cxx::tree::factory_impl< Units_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Units_.present ())
          {
            ::std::unique_ptr< Units_type > r (
              dynamic_cast< Units_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Units_.set (::std::move (r));
            continue;
          }
        }
      }

      // Equipment
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Equipment",
            "",
            &::xsd::cxx::tree::factory_impl< Equipment_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Equipment_)
          {
            ::std::unique_ptr< Equipment_type > r (
              dynamic_cast< Equipment_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Equipment_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Units_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Units",
        "");
    }
  }

  OrganizationsType* OrganizationsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OrganizationsType (*this, f, c);
  }

  OrganizationsType& OrganizationsType::
  operator= (const OrganizationsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Units_ = x.Units_;
      this->Equipment_ = x.Equipment_;
    }

    return *this;
  }

  OrganizationsType::
  ~OrganizationsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OrganizationsType >
  _xsd_OrganizationsType_type_factory_init (
    "OrganizationsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, OrganizationsType >
  _xsd_OrganizationsType_comparison_init;

  bool
  operator== (const OrganizationsType& x, const OrganizationsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Units (), y.Units ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      OrganizationsType::Equipment_optional a (x.Equipment ()), b (y.Equipment ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const OrganizationsType& x, const OrganizationsType& y)
  {
    return !(x == y);
  }

  // OverlayHandlesType
  //

  OverlayHandlesType::
  OverlayHandlesType ()
  : ::xml_schema::type (),
    OverlayHandle_ (this)
  {
  }

  OverlayHandlesType::
  OverlayHandlesType (const OverlayHandlesType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    OverlayHandle_ (x.OverlayHandle_, f, this)
  {
  }

  OverlayHandlesType::
  OverlayHandlesType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    OverlayHandle_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OverlayHandlesType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OverlayHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OverlayHandle",
            "",
            &::xsd::cxx::tree::factory_impl< OverlayHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< OverlayHandle_type > r (
            dynamic_cast< OverlayHandle_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->OverlayHandle_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  OverlayHandlesType* OverlayHandlesType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OverlayHandlesType (*this, f, c);
  }

  OverlayHandlesType& OverlayHandlesType::
  operator= (const OverlayHandlesType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->OverlayHandle_ = x.OverlayHandle_;
    }

    return *this;
  }

  OverlayHandlesType::
  ~OverlayHandlesType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OverlayHandlesType >
  _xsd_OverlayHandlesType_type_factory_init (
    "OverlayHandlesType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, OverlayHandlesType >
  _xsd_OverlayHandlesType_comparison_init;

  bool
  operator== (const OverlayHandlesType& x, const OverlayHandlesType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      OverlayHandlesType::OverlayHandle_sequence a (x.OverlayHandle ()), b (y.OverlayHandle ());

      if (a.size () != b.size ())
        return false;

      for (OverlayHandlesType::OverlayHandle_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const OverlayHandlesType& x, const OverlayHandlesType& y)
  {
    return !(x == y);
  }

  // OverlaysType
  //

  OverlaysType::
  OverlaysType ()
  : ::xml_schema::type (),
    Overlay_ (this)
  {
  }

  OverlaysType::
  OverlaysType (const OverlaysType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Overlay_ (x.Overlay_, f, this)
  {
  }

  OverlaysType::
  OverlaysType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Overlay_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OverlaysType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Overlay
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Overlay",
            "",
            &::xsd::cxx::tree::factory_impl< Overlay_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< Overlay_type > r (
            dynamic_cast< Overlay_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Overlay_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  OverlaysType* OverlaysType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OverlaysType (*this, f, c);
  }

  OverlaysType& OverlaysType::
  operator= (const OverlaysType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Overlay_ = x.Overlay_;
    }

    return *this;
  }

  OverlaysType::
  ~OverlaysType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OverlaysType >
  _xsd_OverlaysType_type_factory_init (
    "OverlaysType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, OverlaysType >
  _xsd_OverlaysType_comparison_init;

  bool
  operator== (const OverlaysType& x, const OverlaysType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      OverlaysType::Overlay_sequence a (x.Overlay ()), b (y.Overlay ());

      if (a.size () != b.size ())
        return false;

      for (OverlaysType::Overlay_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const OverlaysType& x, const OverlaysType& y)
  {
    return !(x == y);
  }

  // OverlayType
  //

  OverlayType::
  OverlayType (const ObjectHandle_type& ObjectHandle,
               const OverlayType1_type& OverlayType1,
               const OverlayName_type& OverlayName)
  : ::xml_schema::type (),
    ObjectHandle_ (ObjectHandle, this),
    OverlayType1_ (OverlayType1, this),
    OverlayName_ (OverlayName, this)
  {
  }

  OverlayType::
  OverlayType (::std::unique_ptr< ObjectHandle_type > ObjectHandle,
               ::std::unique_ptr< OverlayType1_type > OverlayType1,
               ::std::unique_ptr< OverlayName_type > OverlayName)
  : ::xml_schema::type (),
    ObjectHandle_ (std::move (ObjectHandle), this),
    OverlayType1_ (std::move (OverlayType1), this),
    OverlayName_ (std::move (OverlayName), this)
  {
  }

  OverlayType::
  OverlayType (const OverlayType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ObjectHandle_ (x.ObjectHandle_, f, this),
    OverlayType1_ (x.OverlayType1_, f, this),
    OverlayName_ (x.OverlayName_, f, this)
  {
  }

  OverlayType::
  OverlayType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ObjectHandle_ (this),
    OverlayType1_ (this),
    OverlayName_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OverlayType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ObjectHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ObjectHandle",
            "",
            &::xsd::cxx::tree::factory_impl< ObjectHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ObjectHandle_.present ())
          {
            ::std::unique_ptr< ObjectHandle_type > r (
              dynamic_cast< ObjectHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ObjectHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // OverlayType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OverlayType",
            "",
            &::xsd::cxx::tree::factory_impl< OverlayType1_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!OverlayType1_.present ())
          {
            ::std::unique_ptr< OverlayType1_type > r (
              dynamic_cast< OverlayType1_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OverlayType1_.set (::std::move (r));
            continue;
          }
        }
      }

      // OverlayName
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OverlayName",
            "",
            &::xsd::cxx::tree::factory_impl< OverlayName_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!OverlayName_.present ())
          {
            ::std::unique_ptr< OverlayName_type > r (
              dynamic_cast< OverlayName_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OverlayName_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ObjectHandle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ObjectHandle",
        "");
    }

    if (!OverlayType1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "OverlayType",
        "");
    }

    if (!OverlayName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "OverlayName",
        "");
    }
  }

  OverlayType* OverlayType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OverlayType (*this, f, c);
  }

  OverlayType& OverlayType::
  operator= (const OverlayType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ObjectHandle_ = x.ObjectHandle_;
      this->OverlayType1_ = x.OverlayType1_;
      this->OverlayName_ = x.OverlayName_;
    }

    return *this;
  }

  OverlayType::
  ~OverlayType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OverlayType >
  _xsd_OverlayType_type_factory_init (
    "OverlayType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, OverlayType >
  _xsd_OverlayType_comparison_init;

  bool
  operator== (const OverlayType& x, const OverlayType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ObjectHandle (), y.ObjectHandle ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.OverlayType1 (), y.OverlayType1 ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.OverlayName (), y.OverlayName ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const OverlayType& x, const OverlayType& y)
  {
    return !(x == y);
  }

  // OwnerType
  //

  OwnerType::
  OwnerType (const OwnerChoice_type& OwnerChoice,
             const OwnerData_type& OwnerData)
  : ::xml_schema::type (),
    OwnerChoice_ (OwnerChoice, this),
    OwnerData_ (OwnerData, this)
  {
  }

  OwnerType::
  OwnerType (const OwnerChoice_type& OwnerChoice,
             ::std::unique_ptr< OwnerData_type > OwnerData)
  : ::xml_schema::type (),
    OwnerChoice_ (OwnerChoice, this),
    OwnerData_ (std::move (OwnerData), this)
  {
  }

  OwnerType::
  OwnerType (::std::unique_ptr< OwnerChoice_type > OwnerChoice,
             ::std::unique_ptr< OwnerData_type > OwnerData)
  : ::xml_schema::type (),
    OwnerChoice_ (std::move (OwnerChoice), this),
    OwnerData_ (std::move (OwnerData), this)
  {
  }

  OwnerType::
  OwnerType (const OwnerType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    OwnerChoice_ (x.OwnerChoice_, f, this),
    OwnerData_ (x.OwnerData_, f, this)
  {
  }

  OwnerType::
  OwnerType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    OwnerChoice_ (this),
    OwnerData_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OwnerType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OwnerChoice
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OwnerChoice",
            "",
            &::xsd::cxx::tree::factory_impl< OwnerChoice_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!OwnerChoice_.present ())
          {
            ::std::unique_ptr< OwnerChoice_type > r (
              dynamic_cast< OwnerChoice_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OwnerChoice_.set (::std::move (r));
            continue;
          }
        }
      }

      // OwnerData
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OwnerData",
            "",
            &::xsd::cxx::tree::factory_impl< OwnerData_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!OwnerData_.present ())
          {
            ::std::unique_ptr< OwnerData_type > r (
              dynamic_cast< OwnerData_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OwnerData_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!OwnerChoice_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "OwnerChoice",
        "");
    }

    if (!OwnerData_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "OwnerData",
        "");
    }
  }

  OwnerType* OwnerType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OwnerType (*this, f, c);
  }

  OwnerType& OwnerType::
  operator= (const OwnerType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->OwnerChoice_ = x.OwnerChoice_;
      this->OwnerData_ = x.OwnerData_;
    }

    return *this;
  }

  OwnerType::
  ~OwnerType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OwnerType >
  _xsd_OwnerType_type_factory_init (
    "OwnerType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, OwnerType >
  _xsd_OwnerType_comparison_init;

  bool
  operator== (const OwnerType& x, const OwnerType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.OwnerChoice (), y.OwnerChoice ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.OwnerData (), y.OwnerData ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const OwnerType& x, const OwnerType& y)
  {
    return !(x == y);
  }

  // OwnerDataType
  //

  OwnerDataType::
  OwnerDataType ()
  : ::xml_schema::type (),
    UnitOwnerHandle_ (this),
    ForceOwnerHandle_ (this)
  {
  }

  OwnerDataType::
  OwnerDataType (const OwnerDataType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    UnitOwnerHandle_ (x.UnitOwnerHandle_, f, this),
    ForceOwnerHandle_ (x.ForceOwnerHandle_, f, this)
  {
  }

  OwnerDataType::
  OwnerDataType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    UnitOwnerHandle_ (this),
    ForceOwnerHandle_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OwnerDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // UnitOwnerHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UnitOwnerHandle",
            "",
            &::xsd::cxx::tree::factory_impl< UnitOwnerHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->UnitOwnerHandle_)
          {
            ::std::unique_ptr< UnitOwnerHandle_type > r (
              dynamic_cast< UnitOwnerHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UnitOwnerHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // ForceOwnerHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ForceOwnerHandle",
            "",
            &::xsd::cxx::tree::factory_impl< ForceOwnerHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ForceOwnerHandle_)
          {
            ::std::unique_ptr< ForceOwnerHandle_type > r (
              dynamic_cast< ForceOwnerHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ForceOwnerHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  OwnerDataType* OwnerDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OwnerDataType (*this, f, c);
  }

  OwnerDataType& OwnerDataType::
  operator= (const OwnerDataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->UnitOwnerHandle_ = x.UnitOwnerHandle_;
      this->ForceOwnerHandle_ = x.ForceOwnerHandle_;
    }

    return *this;
  }

  OwnerDataType::
  ~OwnerDataType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OwnerDataType >
  _xsd_OwnerDataType_type_factory_init (
    "OwnerDataType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, OwnerDataType >
  _xsd_OwnerDataType_comparison_init;

  bool
  operator== (const OwnerDataType& x, const OwnerDataType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      OwnerDataType::UnitOwnerHandle_optional a (x.UnitOwnerHandle ()), b (y.UnitOwnerHandle ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      OwnerDataType::ForceOwnerHandle_optional a (x.ForceOwnerHandle ()), b (y.ForceOwnerHandle ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const OwnerDataType& x, const OwnerDataType& y)
  {
    return !(x == y);
  }

  // OwnFormationType
  //

  OwnFormationType::
  OwnFormationType (const FormationLocationType_type& FormationLocationType,
                    const FormationChoice_type& FormationChoice,
                    const FormationData_type& FormationData)
  : ::xml_schema::type (),
    FormationLocationType_ (FormationLocationType, this),
    FormationSpacing_ (this),
    FormationOrientation_ (this),
    FormationChoice_ (FormationChoice, this),
    FormationData_ (FormationData, this)
  {
  }

  OwnFormationType::
  OwnFormationType (const FormationLocationType_type& FormationLocationType,
                    const FormationChoice_type& FormationChoice,
                    ::std::unique_ptr< FormationData_type > FormationData)
  : ::xml_schema::type (),
    FormationLocationType_ (FormationLocationType, this),
    FormationSpacing_ (this),
    FormationOrientation_ (this),
    FormationChoice_ (FormationChoice, this),
    FormationData_ (std::move (FormationData), this)
  {
  }

  OwnFormationType::
  OwnFormationType (::std::unique_ptr< FormationLocationType_type > FormationLocationType,
                    ::std::unique_ptr< FormationChoice_type > FormationChoice,
                    ::std::unique_ptr< FormationData_type > FormationData)
  : ::xml_schema::type (),
    FormationLocationType_ (std::move (FormationLocationType), this),
    FormationSpacing_ (this),
    FormationOrientation_ (this),
    FormationChoice_ (std::move (FormationChoice), this),
    FormationData_ (std::move (FormationData), this)
  {
  }

  OwnFormationType::
  OwnFormationType (const OwnFormationType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    FormationLocationType_ (x.FormationLocationType_, f, this),
    FormationSpacing_ (x.FormationSpacing_, f, this),
    FormationOrientation_ (x.FormationOrientation_, f, this),
    FormationChoice_ (x.FormationChoice_, f, this),
    FormationData_ (x.FormationData_, f, this)
  {
  }

  OwnFormationType::
  OwnFormationType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    FormationLocationType_ (this),
    FormationSpacing_ (this),
    FormationOrientation_ (this),
    FormationChoice_ (this),
    FormationData_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OwnFormationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FormationLocationType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "FormationLocationType",
            "",
            &::xsd::cxx::tree::factory_impl< FormationLocationType_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!FormationLocationType_.present ())
          {
            ::std::unique_ptr< FormationLocationType_type > r (
              dynamic_cast< FormationLocationType_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FormationLocationType_.set (::std::move (r));
            continue;
          }
        }
      }

      // FormationSpacing
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "FormationSpacing",
            "",
            &::xsd::cxx::tree::factory_impl< FormationSpacing_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->FormationSpacing_)
          {
            ::std::unique_ptr< FormationSpacing_type > r (
              dynamic_cast< FormationSpacing_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FormationSpacing_.set (::std::move (r));
            continue;
          }
        }
      }

      // FormationOrientation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "FormationOrientation",
            "",
            &::xsd::cxx::tree::factory_impl< FormationOrientation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->FormationOrientation_)
          {
            ::std::unique_ptr< FormationOrientation_type > r (
              dynamic_cast< FormationOrientation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FormationOrientation_.set (::std::move (r));
            continue;
          }
        }
      }

      // FormationChoice
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "FormationChoice",
            "",
            &::xsd::cxx::tree::factory_impl< FormationChoice_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!FormationChoice_.present ())
          {
            ::std::unique_ptr< FormationChoice_type > r (
              dynamic_cast< FormationChoice_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FormationChoice_.set (::std::move (r));
            continue;
          }
        }
      }

      // FormationData
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "FormationData",
            "",
            &::xsd::cxx::tree::factory_impl< FormationData_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!FormationData_.present ())
          {
            ::std::unique_ptr< FormationData_type > r (
              dynamic_cast< FormationData_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FormationData_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!FormationLocationType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FormationLocationType",
        "");
    }

    if (!FormationChoice_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FormationChoice",
        "");
    }

    if (!FormationData_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FormationData",
        "");
    }
  }

  OwnFormationType* OwnFormationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OwnFormationType (*this, f, c);
  }

  OwnFormationType& OwnFormationType::
  operator= (const OwnFormationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->FormationLocationType_ = x.FormationLocationType_;
      this->FormationSpacing_ = x.FormationSpacing_;
      this->FormationOrientation_ = x.FormationOrientation_;
      this->FormationChoice_ = x.FormationChoice_;
      this->FormationData_ = x.FormationData_;
    }

    return *this;
  }

  OwnFormationType::
  ~OwnFormationType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OwnFormationType >
  _xsd_OwnFormationType_type_factory_init (
    "OwnFormationType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, OwnFormationType >
  _xsd_OwnFormationType_comparison_init;

  bool
  operator== (const OwnFormationType& x, const OwnFormationType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.FormationLocationType (), y.FormationLocationType ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      OwnFormationType::FormationSpacing_optional a (x.FormationSpacing ()), b (y.FormationSpacing ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      OwnFormationType::FormationOrientation_optional a (x.FormationOrientation ()), b (y.FormationOrientation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.FormationChoice (), y.FormationChoice ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.FormationData (), y.FormationData ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const OwnFormationType& x, const OwnFormationType& y)
  {
    return !(x == y);
  }

  // PointSymbolModifiersType
  //

  PointSymbolModifiersType::
  PointSymbolModifiersType (const UniqueDesignation_type& UniqueDesignation)
  : ::xml_schema::type (),
    AdditionalInfo_ (this),
    AdditionalInfo1_ (this),
    UniqueDesignation_ (UniqueDesignation, this),
    DateTimeGroup_ (this),
    DateTimeGroup1_ (this),
    Orientation_ (this)
  {
  }

  PointSymbolModifiersType::
  PointSymbolModifiersType (::std::unique_ptr< UniqueDesignation_type > UniqueDesignation)
  : ::xml_schema::type (),
    AdditionalInfo_ (this),
    AdditionalInfo1_ (this),
    UniqueDesignation_ (std::move (UniqueDesignation), this),
    DateTimeGroup_ (this),
    DateTimeGroup1_ (this),
    Orientation_ (this)
  {
  }

  PointSymbolModifiersType::
  PointSymbolModifiersType (const PointSymbolModifiersType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AdditionalInfo_ (x.AdditionalInfo_, f, this),
    AdditionalInfo1_ (x.AdditionalInfo1_, f, this),
    UniqueDesignation_ (x.UniqueDesignation_, f, this),
    DateTimeGroup_ (x.DateTimeGroup_, f, this),
    DateTimeGroup1_ (x.DateTimeGroup1_, f, this),
    Orientation_ (x.Orientation_, f, this)
  {
  }

  PointSymbolModifiersType::
  PointSymbolModifiersType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AdditionalInfo_ (this),
    AdditionalInfo1_ (this),
    UniqueDesignation_ (this),
    DateTimeGroup_ (this),
    DateTimeGroup1_ (this),
    Orientation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PointSymbolModifiersType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AdditionalInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AdditionalInfo",
            "",
            &::xsd::cxx::tree::factory_impl< AdditionalInfo_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AdditionalInfo_)
          {
            ::std::unique_ptr< AdditionalInfo_type > r (
              dynamic_cast< AdditionalInfo_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AdditionalInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      // AdditionalInfo1
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AdditionalInfo1",
            "",
            &::xsd::cxx::tree::factory_impl< AdditionalInfo1_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AdditionalInfo1_)
          {
            ::std::unique_ptr< AdditionalInfo1_type > r (
              dynamic_cast< AdditionalInfo1_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AdditionalInfo1_.set (::std::move (r));
            continue;
          }
        }
      }

      // UniqueDesignation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UniqueDesignation",
            "",
            &::xsd::cxx::tree::factory_impl< UniqueDesignation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!UniqueDesignation_.present ())
          {
            ::std::unique_ptr< UniqueDesignation_type > r (
              dynamic_cast< UniqueDesignation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UniqueDesignation_.set (::std::move (r));
            continue;
          }
        }
      }

      // DateTimeGroup
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DateTimeGroup",
            "",
            &::xsd::cxx::tree::factory_impl< DateTimeGroup_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DateTimeGroup_)
          {
            ::std::unique_ptr< DateTimeGroup_type > r (
              dynamic_cast< DateTimeGroup_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DateTimeGroup_.set (::std::move (r));
            continue;
          }
        }
      }

      // DateTimeGroup1
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DateTimeGroup1",
            "",
            &::xsd::cxx::tree::factory_impl< DateTimeGroup1_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DateTimeGroup1_)
          {
            ::std::unique_ptr< DateTimeGroup1_type > r (
              dynamic_cast< DateTimeGroup1_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DateTimeGroup1_.set (::std::move (r));
            continue;
          }
        }
      }

      // Orientation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Orientation",
            "",
            &::xsd::cxx::tree::factory_impl< Orientation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Orientation_)
          {
            ::std::unique_ptr< Orientation_type > r (
              dynamic_cast< Orientation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Orientation_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!UniqueDesignation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "UniqueDesignation",
        "");
    }
  }

  PointSymbolModifiersType* PointSymbolModifiersType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PointSymbolModifiersType (*this, f, c);
  }

  PointSymbolModifiersType& PointSymbolModifiersType::
  operator= (const PointSymbolModifiersType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AdditionalInfo_ = x.AdditionalInfo_;
      this->AdditionalInfo1_ = x.AdditionalInfo1_;
      this->UniqueDesignation_ = x.UniqueDesignation_;
      this->DateTimeGroup_ = x.DateTimeGroup_;
      this->DateTimeGroup1_ = x.DateTimeGroup1_;
      this->Orientation_ = x.Orientation_;
    }

    return *this;
  }

  PointSymbolModifiersType::
  ~PointSymbolModifiersType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointSymbolModifiersType >
  _xsd_PointSymbolModifiersType_type_factory_init (
    "PointSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, PointSymbolModifiersType >
  _xsd_PointSymbolModifiersType_comparison_init;

  bool
  operator== (const PointSymbolModifiersType& x, const PointSymbolModifiersType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      PointSymbolModifiersType::AdditionalInfo_optional a (x.AdditionalInfo ()), b (y.AdditionalInfo ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      PointSymbolModifiersType::AdditionalInfo1_optional a (x.AdditionalInfo1 ()), b (y.AdditionalInfo1 ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.UniqueDesignation (), y.UniqueDesignation ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      PointSymbolModifiersType::DateTimeGroup_optional a (x.DateTimeGroup ()), b (y.DateTimeGroup ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      PointSymbolModifiersType::DateTimeGroup1_optional a (x.DateTimeGroup1 ()), b (y.DateTimeGroup1 ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      PointSymbolModifiersType::Orientation_optional a (x.Orientation ()), b (y.Orientation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const PointSymbolModifiersType& x, const PointSymbolModifiersType& y)
  {
    return !(x == y);
  }

  // RectangleAreaType
  //

  RectangleAreaType::
  RectangleAreaType (const UpperRight_type& UpperRight,
                     const LowerLeft_type& LowerLeft)
  : ::xml_schema::type (),
    Name_ (this),
    UpperRight_ (UpperRight, this),
    LowerLeft_ (LowerLeft, this)
  {
  }

  RectangleAreaType::
  RectangleAreaType (::std::unique_ptr< UpperRight_type > UpperRight,
                     ::std::unique_ptr< LowerLeft_type > LowerLeft)
  : ::xml_schema::type (),
    Name_ (this),
    UpperRight_ (std::move (UpperRight), this),
    LowerLeft_ (std::move (LowerLeft), this)
  {
  }

  RectangleAreaType::
  RectangleAreaType (const RectangleAreaType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Name_ (x.Name_, f, this),
    UpperRight_ (x.UpperRight_, f, this),
    LowerLeft_ (x.LowerLeft_, f, this)
  {
  }

  RectangleAreaType::
  RectangleAreaType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Name_ (this),
    UpperRight_ (this),
    LowerLeft_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RectangleAreaType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Name
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Name",
            "",
            &::xsd::cxx::tree::factory_impl< Name_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Name_)
          {
            ::std::unique_ptr< Name_type > r (
              dynamic_cast< Name_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Name_.set (::std::move (r));
            continue;
          }
        }
      }

      // UpperRight
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UpperRight",
            "",
            &::xsd::cxx::tree::factory_impl< UpperRight_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!UpperRight_.present ())
          {
            ::std::unique_ptr< UpperRight_type > r (
              dynamic_cast< UpperRight_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UpperRight_.set (::std::move (r));
            continue;
          }
        }
      }

      // LowerLeft
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "LowerLeft",
            "",
            &::xsd::cxx::tree::factory_impl< LowerLeft_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!LowerLeft_.present ())
          {
            ::std::unique_ptr< LowerLeft_type > r (
              dynamic_cast< LowerLeft_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->LowerLeft_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!UpperRight_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "UpperRight",
        "");
    }

    if (!LowerLeft_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LowerLeft",
        "");
    }
  }

  RectangleAreaType* RectangleAreaType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RectangleAreaType (*this, f, c);
  }

  RectangleAreaType& RectangleAreaType::
  operator= (const RectangleAreaType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Name_ = x.Name_;
      this->UpperRight_ = x.UpperRight_;
      this->LowerLeft_ = x.LowerLeft_;
    }

    return *this;
  }

  RectangleAreaType::
  ~RectangleAreaType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RectangleAreaType >
  _xsd_RectangleAreaType_type_factory_init (
    "RectangleAreaType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, RectangleAreaType >
  _xsd_RectangleAreaType_comparison_init;

  bool
  operator== (const RectangleAreaType& x, const RectangleAreaType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      RectangleAreaType::Name_optional a (x.Name ()), b (y.Name ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.UpperRight (), y.UpperRight ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.LowerLeft (), y.LowerLeft ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const RectangleAreaType& x, const RectangleAreaType& y)
  {
    return !(x == y);
  }

  // ScenarioDataStandardsType
  //

  ScenarioDataStandardsType::
  ScenarioDataStandardsType (const SymbologyDataStandard_type& SymbologyDataStandard,
                             const CoordinateDataStandard_type& CoordinateDataStandard)
  : ::xml_schema::type (),
    SymbologyDataStandard_ (SymbologyDataStandard, this),
    CoordinateDataStandard_ (CoordinateDataStandard, this)
  {
  }

  ScenarioDataStandardsType::
  ScenarioDataStandardsType (::std::unique_ptr< SymbologyDataStandard_type > SymbologyDataStandard,
                             ::std::unique_ptr< CoordinateDataStandard_type > CoordinateDataStandard)
  : ::xml_schema::type (),
    SymbologyDataStandard_ (std::move (SymbologyDataStandard), this),
    CoordinateDataStandard_ (std::move (CoordinateDataStandard), this)
  {
  }

  ScenarioDataStandardsType::
  ScenarioDataStandardsType (const ScenarioDataStandardsType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SymbologyDataStandard_ (x.SymbologyDataStandard_, f, this),
    CoordinateDataStandard_ (x.CoordinateDataStandard_, f, this)
  {
  }

  ScenarioDataStandardsType::
  ScenarioDataStandardsType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SymbologyDataStandard_ (this),
    CoordinateDataStandard_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ScenarioDataStandardsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SymbologyDataStandard
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SymbologyDataStandard",
            "",
            &::xsd::cxx::tree::factory_impl< SymbologyDataStandard_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!SymbologyDataStandard_.present ())
          {
            ::std::unique_ptr< SymbologyDataStandard_type > r (
              dynamic_cast< SymbologyDataStandard_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SymbologyDataStandard_.set (::std::move (r));
            continue;
          }
        }
      }

      // CoordinateDataStandard
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CoordinateDataStandard",
            "",
            &::xsd::cxx::tree::factory_impl< CoordinateDataStandard_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!CoordinateDataStandard_.present ())
          {
            ::std::unique_ptr< CoordinateDataStandard_type > r (
              dynamic_cast< CoordinateDataStandard_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CoordinateDataStandard_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!SymbologyDataStandard_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SymbologyDataStandard",
        "");
    }

    if (!CoordinateDataStandard_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CoordinateDataStandard",
        "");
    }
  }

  ScenarioDataStandardsType* ScenarioDataStandardsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ScenarioDataStandardsType (*this, f, c);
  }

  ScenarioDataStandardsType& ScenarioDataStandardsType::
  operator= (const ScenarioDataStandardsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SymbologyDataStandard_ = x.SymbologyDataStandard_;
      this->CoordinateDataStandard_ = x.CoordinateDataStandard_;
    }

    return *this;
  }

  ScenarioDataStandardsType::
  ~ScenarioDataStandardsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ScenarioDataStandardsType >
  _xsd_ScenarioDataStandardsType_type_factory_init (
    "ScenarioDataStandardsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, ScenarioDataStandardsType >
  _xsd_ScenarioDataStandardsType_comparison_init;

  bool
  operator== (const ScenarioDataStandardsType& x, const ScenarioDataStandardsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.SymbologyDataStandard (), y.SymbologyDataStandard ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.CoordinateDataStandard (), y.CoordinateDataStandard ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const ScenarioDataStandardsType& x, const ScenarioDataStandardsType& y)
  {
    return !(x == y);
  }

  // ScenarioWeatherType
  //

  ScenarioWeatherType::
  ScenarioWeatherType ()
  : ::xml_schema::type (),
    Atmosphere_ (this),
    CloudCoverItems_ (this),
    Icing_ (this),
    LightItems_ (this),
    Precipitation_ (this),
    VisibilityItems_ (this),
    WindItems_ (this)
  {
  }

  ScenarioWeatherType::
  ScenarioWeatherType (const ScenarioWeatherType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Atmosphere_ (x.Atmosphere_, f, this),
    CloudCoverItems_ (x.CloudCoverItems_, f, this),
    Icing_ (x.Icing_, f, this),
    LightItems_ (x.LightItems_, f, this),
    Precipitation_ (x.Precipitation_, f, this),
    VisibilityItems_ (x.VisibilityItems_, f, this),
    WindItems_ (x.WindItems_, f, this)
  {
  }

  ScenarioWeatherType::
  ScenarioWeatherType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Atmosphere_ (this),
    CloudCoverItems_ (this),
    Icing_ (this),
    LightItems_ (this),
    Precipitation_ (this),
    VisibilityItems_ (this),
    WindItems_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ScenarioWeatherType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Atmosphere
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Atmosphere",
            "",
            &::xsd::cxx::tree::factory_impl< Atmosphere_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Atmosphere_)
          {
            ::std::unique_ptr< Atmosphere_type > r (
              dynamic_cast< Atmosphere_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Atmosphere_.set (::std::move (r));
            continue;
          }
        }
      }

      // CloudCoverItems
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CloudCoverItems",
            "",
            &::xsd::cxx::tree::factory_impl< CloudCoverItems_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CloudCoverItems_)
          {
            ::std::unique_ptr< CloudCoverItems_type > r (
              dynamic_cast< CloudCoverItems_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CloudCoverItems_.set (::std::move (r));
            continue;
          }
        }
      }

      // Icing
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Icing",
            "",
            &::xsd::cxx::tree::factory_impl< Icing_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Icing_)
          {
            ::std::unique_ptr< Icing_type > r (
              dynamic_cast< Icing_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Icing_.set (::std::move (r));
            continue;
          }
        }
      }

      // LightItems
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "LightItems",
            "",
            &::xsd::cxx::tree::factory_impl< LightItems_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->LightItems_)
          {
            ::std::unique_ptr< LightItems_type > r (
              dynamic_cast< LightItems_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->LightItems_.set (::std::move (r));
            continue;
          }
        }
      }

      // Precipitation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Precipitation",
            "",
            &::xsd::cxx::tree::factory_impl< Precipitation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Precipitation_)
          {
            ::std::unique_ptr< Precipitation_type > r (
              dynamic_cast< Precipitation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Precipitation_.set (::std::move (r));
            continue;
          }
        }
      }

      // VisibilityItems
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "VisibilityItems",
            "",
            &::xsd::cxx::tree::factory_impl< VisibilityItems_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->VisibilityItems_)
          {
            ::std::unique_ptr< VisibilityItems_type > r (
              dynamic_cast< VisibilityItems_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->VisibilityItems_.set (::std::move (r));
            continue;
          }
        }
      }

      // WindItems
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "WindItems",
            "",
            &::xsd::cxx::tree::factory_impl< WindItems_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->WindItems_)
          {
            ::std::unique_ptr< WindItems_type > r (
              dynamic_cast< WindItems_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->WindItems_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  ScenarioWeatherType* ScenarioWeatherType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ScenarioWeatherType (*this, f, c);
  }

  ScenarioWeatherType& ScenarioWeatherType::
  operator= (const ScenarioWeatherType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Atmosphere_ = x.Atmosphere_;
      this->CloudCoverItems_ = x.CloudCoverItems_;
      this->Icing_ = x.Icing_;
      this->LightItems_ = x.LightItems_;
      this->Precipitation_ = x.Precipitation_;
      this->VisibilityItems_ = x.VisibilityItems_;
      this->WindItems_ = x.WindItems_;
    }

    return *this;
  }

  ScenarioWeatherType::
  ~ScenarioWeatherType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ScenarioWeatherType >
  _xsd_ScenarioWeatherType_type_factory_init (
    "ScenarioWeatherType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, ScenarioWeatherType >
  _xsd_ScenarioWeatherType_comparison_init;

  bool
  operator== (const ScenarioWeatherType& x, const ScenarioWeatherType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      ScenarioWeatherType::Atmosphere_optional a (x.Atmosphere ()), b (y.Atmosphere ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      ScenarioWeatherType::CloudCoverItems_optional a (x.CloudCoverItems ()), b (y.CloudCoverItems ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      ScenarioWeatherType::Icing_optional a (x.Icing ()), b (y.Icing ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      ScenarioWeatherType::LightItems_optional a (x.LightItems ()), b (y.LightItems ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      ScenarioWeatherType::Precipitation_optional a (x.Precipitation ()), b (y.Precipitation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      ScenarioWeatherType::VisibilityItems_optional a (x.VisibilityItems ()), b (y.VisibilityItems ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      ScenarioWeatherType::WindItems_optional a (x.WindItems ()), b (y.WindItems ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const ScenarioWeatherType& x, const ScenarioWeatherType& y)
  {
    return !(x == y);
  }

  // StatusType
  //

  StatusType::
  StatusType ()
  : ::xml_schema::type (),
    MOPPLevel_ (this),
    WeaponControlStatus_ (this)
  {
  }

  StatusType::
  StatusType (const StatusType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    MOPPLevel_ (x.MOPPLevel_, f, this),
    WeaponControlStatus_ (x.WeaponControlStatus_, f, this)
  {
  }

  StatusType::
  StatusType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    MOPPLevel_ (this),
    WeaponControlStatus_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void StatusType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MOPPLevel
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MOPPLevel",
            "",
            &::xsd::cxx::tree::factory_impl< MOPPLevel_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MOPPLevel_)
          {
            ::std::unique_ptr< MOPPLevel_type > r (
              dynamic_cast< MOPPLevel_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MOPPLevel_.set (::std::move (r));
            continue;
          }
        }
      }

      // WeaponControlStatus
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "WeaponControlStatus",
            "",
            &::xsd::cxx::tree::factory_impl< WeaponControlStatus_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->WeaponControlStatus_)
          {
            ::std::unique_ptr< WeaponControlStatus_type > r (
              dynamic_cast< WeaponControlStatus_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->WeaponControlStatus_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  StatusType* StatusType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StatusType (*this, f, c);
  }

  StatusType& StatusType::
  operator= (const StatusType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->MOPPLevel_ = x.MOPPLevel_;
      this->WeaponControlStatus_ = x.WeaponControlStatus_;
    }

    return *this;
  }

  StatusType::
  ~StatusType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, StatusType >
  _xsd_StatusType_type_factory_init (
    "StatusType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, StatusType >
  _xsd_StatusType_comparison_init;

  bool
  operator== (const StatusType& x, const StatusType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      StatusType::MOPPLevel_optional a (x.MOPPLevel ()), b (y.MOPPLevel ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      StatusType::WeaponControlStatus_optional a (x.WeaponControlStatus ()), b (y.WeaponControlStatus ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const StatusType& x, const StatusType& y)
  {
    return !(x == y);
  }

  // SupportRelationsType
  //

  SupportRelationsType::
  SupportRelationsType ()
  : ::xml_schema::type (),
    SupportRelation_ (this)
  {
  }

  SupportRelationsType::
  SupportRelationsType (const SupportRelationsType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SupportRelation_ (x.SupportRelation_, f, this)
  {
  }

  SupportRelationsType::
  SupportRelationsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SupportRelation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SupportRelationsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SupportRelation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SupportRelation",
            "",
            &::xsd::cxx::tree::factory_impl< SupportRelation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< SupportRelation_type > r (
            dynamic_cast< SupportRelation_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->SupportRelation_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SupportRelationsType* SupportRelationsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SupportRelationsType (*this, f, c);
  }

  SupportRelationsType& SupportRelationsType::
  operator= (const SupportRelationsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SupportRelation_ = x.SupportRelation_;
    }

    return *this;
  }

  SupportRelationsType::
  ~SupportRelationsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SupportRelationsType >
  _xsd_SupportRelationsType_type_factory_init (
    "SupportRelationsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, SupportRelationsType >
  _xsd_SupportRelationsType_comparison_init;

  bool
  operator== (const SupportRelationsType& x, const SupportRelationsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      SupportRelationsType::SupportRelation_sequence a (x.SupportRelation ()), b (y.SupportRelation ());

      if (a.size () != b.size ())
        return false;

      for (SupportRelationsType::SupportRelation_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const SupportRelationsType& x, const SupportRelationsType& y)
  {
    return !(x == y);
  }

  // SupportRelationType
  //

  SupportRelationType::
  SupportRelationType (const SupportedUnitHandle_type& SupportedUnitHandle,
                       const SupportType_type& SupportType)
  : ::xml_schema::type (),
    SupportedUnitHandle_ (SupportedUnitHandle, this),
    PriorityToSupport_ (this),
    SupportType_ (SupportType, this),
    SupportRoleType_ (this)
  {
  }

  SupportRelationType::
  SupportRelationType (::std::unique_ptr< SupportedUnitHandle_type > SupportedUnitHandle,
                       ::std::unique_ptr< SupportType_type > SupportType)
  : ::xml_schema::type (),
    SupportedUnitHandle_ (std::move (SupportedUnitHandle), this),
    PriorityToSupport_ (this),
    SupportType_ (std::move (SupportType), this),
    SupportRoleType_ (this)
  {
  }

  SupportRelationType::
  SupportRelationType (const SupportRelationType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SupportedUnitHandle_ (x.SupportedUnitHandle_, f, this),
    PriorityToSupport_ (x.PriorityToSupport_, f, this),
    SupportType_ (x.SupportType_, f, this),
    SupportRoleType_ (x.SupportRoleType_, f, this)
  {
  }

  SupportRelationType::
  SupportRelationType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SupportedUnitHandle_ (this),
    PriorityToSupport_ (this),
    SupportType_ (this),
    SupportRoleType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SupportRelationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SupportedUnitHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SupportedUnitHandle",
            "",
            &::xsd::cxx::tree::factory_impl< SupportedUnitHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!SupportedUnitHandle_.present ())
          {
            ::std::unique_ptr< SupportedUnitHandle_type > r (
              dynamic_cast< SupportedUnitHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SupportedUnitHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // PriorityToSupport
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PriorityToSupport",
            "",
            &::xsd::cxx::tree::factory_impl< PriorityToSupport_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->PriorityToSupport_)
          {
            ::std::unique_ptr< PriorityToSupport_type > r (
              dynamic_cast< PriorityToSupport_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->PriorityToSupport_.set (::std::move (r));
            continue;
          }
        }
      }

      // SupportType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SupportType",
            "",
            &::xsd::cxx::tree::factory_impl< SupportType_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!SupportType_.present ())
          {
            ::std::unique_ptr< SupportType_type > r (
              dynamic_cast< SupportType_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SupportType_.set (::std::move (r));
            continue;
          }
        }
      }

      // SupportRoleType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SupportRoleType",
            "",
            &::xsd::cxx::tree::factory_impl< SupportRoleType_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SupportRoleType_)
          {
            ::std::unique_ptr< SupportRoleType_type > r (
              dynamic_cast< SupportRoleType_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SupportRoleType_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!SupportedUnitHandle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SupportedUnitHandle",
        "");
    }

    if (!SupportType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SupportType",
        "");
    }
  }

  SupportRelationType* SupportRelationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SupportRelationType (*this, f, c);
  }

  SupportRelationType& SupportRelationType::
  operator= (const SupportRelationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SupportedUnitHandle_ = x.SupportedUnitHandle_;
      this->PriorityToSupport_ = x.PriorityToSupport_;
      this->SupportType_ = x.SupportType_;
      this->SupportRoleType_ = x.SupportRoleType_;
    }

    return *this;
  }

  SupportRelationType::
  ~SupportRelationType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SupportRelationType >
  _xsd_SupportRelationType_type_factory_init (
    "SupportRelationType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, SupportRelationType >
  _xsd_SupportRelationType_comparison_init;

  bool
  operator== (const SupportRelationType& x, const SupportRelationType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.SupportedUnitHandle (), y.SupportedUnitHandle ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      SupportRelationType::PriorityToSupport_optional a (x.PriorityToSupport ()), b (y.PriorityToSupport ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.SupportType (), y.SupportType ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      SupportRelationType::SupportRoleType_optional a (x.SupportRoleType ()), b (y.SupportRoleType ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const SupportRelationType& x, const SupportRelationType& y)
  {
    return !(x == y);
  }

  // SymbolClassModifiersType
  //

  SymbolClassModifiersType::
  SymbolClassModifiersType ()
  : ::xml_schema::type (),
    PointSymbolModifiers_ (this),
    LineSymbolModifiers_ (this),
    AreaSymbolModifiers_ (this),
    BoundarySymbolModifiers_ (this),
    NBCEventSymbolModifiers_ (this),
    TaskSymbolModifiers_ (this)
  {
  }

  SymbolClassModifiersType::
  SymbolClassModifiersType (const SymbolClassModifiersType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    PointSymbolModifiers_ (x.PointSymbolModifiers_, f, this),
    LineSymbolModifiers_ (x.LineSymbolModifiers_, f, this),
    AreaSymbolModifiers_ (x.AreaSymbolModifiers_, f, this),
    BoundarySymbolModifiers_ (x.BoundarySymbolModifiers_, f, this),
    NBCEventSymbolModifiers_ (x.NBCEventSymbolModifiers_, f, this),
    TaskSymbolModifiers_ (x.TaskSymbolModifiers_, f, this)
  {
  }

  SymbolClassModifiersType::
  SymbolClassModifiersType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    PointSymbolModifiers_ (this),
    LineSymbolModifiers_ (this),
    AreaSymbolModifiers_ (this),
    BoundarySymbolModifiers_ (this),
    NBCEventSymbolModifiers_ (this),
    TaskSymbolModifiers_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SymbolClassModifiersType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PointSymbolModifiers
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PointSymbolModifiers",
            "",
            &::xsd::cxx::tree::factory_impl< PointSymbolModifiers_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->PointSymbolModifiers_)
          {
            ::std::unique_ptr< PointSymbolModifiers_type > r (
              dynamic_cast< PointSymbolModifiers_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->PointSymbolModifiers_.set (::std::move (r));
            continue;
          }
        }
      }

      // LineSymbolModifiers
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "LineSymbolModifiers",
            "",
            &::xsd::cxx::tree::factory_impl< LineSymbolModifiers_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->LineSymbolModifiers_)
          {
            ::std::unique_ptr< LineSymbolModifiers_type > r (
              dynamic_cast< LineSymbolModifiers_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->LineSymbolModifiers_.set (::std::move (r));
            continue;
          }
        }
      }

      // AreaSymbolModifiers
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AreaSymbolModifiers",
            "",
            &::xsd::cxx::tree::factory_impl< AreaSymbolModifiers_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AreaSymbolModifiers_)
          {
            ::std::unique_ptr< AreaSymbolModifiers_type > r (
              dynamic_cast< AreaSymbolModifiers_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AreaSymbolModifiers_.set (::std::move (r));
            continue;
          }
        }
      }

      // BoundarySymbolModifiers
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "BoundarySymbolModifiers",
            "",
            &::xsd::cxx::tree::factory_impl< BoundarySymbolModifiers_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->BoundarySymbolModifiers_)
          {
            ::std::unique_ptr< BoundarySymbolModifiers_type > r (
              dynamic_cast< BoundarySymbolModifiers_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->BoundarySymbolModifiers_.set (::std::move (r));
            continue;
          }
        }
      }

      // NBCEventSymbolModifiers
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "NBCEventSymbolModifiers",
            "",
            &::xsd::cxx::tree::factory_impl< NBCEventSymbolModifiers_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->NBCEventSymbolModifiers_)
          {
            ::std::unique_ptr< NBCEventSymbolModifiers_type > r (
              dynamic_cast< NBCEventSymbolModifiers_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->NBCEventSymbolModifiers_.set (::std::move (r));
            continue;
          }
        }
      }

      // TaskSymbolModifiers
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TaskSymbolModifiers",
            "",
            &::xsd::cxx::tree::factory_impl< TaskSymbolModifiers_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->TaskSymbolModifiers_)
          {
            ::std::unique_ptr< TaskSymbolModifiers_type > r (
              dynamic_cast< TaskSymbolModifiers_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->TaskSymbolModifiers_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  SymbolClassModifiersType* SymbolClassModifiersType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SymbolClassModifiersType (*this, f, c);
  }

  SymbolClassModifiersType& SymbolClassModifiersType::
  operator= (const SymbolClassModifiersType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->PointSymbolModifiers_ = x.PointSymbolModifiers_;
      this->LineSymbolModifiers_ = x.LineSymbolModifiers_;
      this->AreaSymbolModifiers_ = x.AreaSymbolModifiers_;
      this->BoundarySymbolModifiers_ = x.BoundarySymbolModifiers_;
      this->NBCEventSymbolModifiers_ = x.NBCEventSymbolModifiers_;
      this->TaskSymbolModifiers_ = x.TaskSymbolModifiers_;
    }

    return *this;
  }

  SymbolClassModifiersType::
  ~SymbolClassModifiersType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SymbolClassModifiersType >
  _xsd_SymbolClassModifiersType_type_factory_init (
    "SymbolClassModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, SymbolClassModifiersType >
  _xsd_SymbolClassModifiersType_comparison_init;

  bool
  operator== (const SymbolClassModifiersType& x, const SymbolClassModifiersType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      SymbolClassModifiersType::PointSymbolModifiers_optional a (x.PointSymbolModifiers ()), b (y.PointSymbolModifiers ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      SymbolClassModifiersType::LineSymbolModifiers_optional a (x.LineSymbolModifiers ()), b (y.LineSymbolModifiers ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      SymbolClassModifiersType::AreaSymbolModifiers_optional a (x.AreaSymbolModifiers ()), b (y.AreaSymbolModifiers ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      SymbolClassModifiersType::BoundarySymbolModifiers_optional a (x.BoundarySymbolModifiers ()), b (y.BoundarySymbolModifiers ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      SymbolClassModifiersType::NBCEventSymbolModifiers_optional a (x.NBCEventSymbolModifiers ()), b (y.NBCEventSymbolModifiers ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      SymbolClassModifiersType::TaskSymbolModifiers_optional a (x.TaskSymbolModifiers ()), b (y.TaskSymbolModifiers ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const SymbolClassModifiersType& x, const SymbolClassModifiersType& y)
  {
    return !(x == y);
  }

  // SymbologyDataStandardType
  //

  SymbologyDataStandardType::
  SymbologyDataStandardType (const StandardName_type& StandardName,
                             const MajorVersion_type& MajorVersion,
                             const MinorVersion_type& MinorVersion)
  : ::xml_schema::type (),
    StandardName_ (StandardName, this),
    MajorVersion_ (MajorVersion, this),
    MinorVersion_ (MinorVersion, this)
  {
  }

  SymbologyDataStandardType::
  SymbologyDataStandardType (::std::unique_ptr< StandardName_type > StandardName,
                             ::std::unique_ptr< MajorVersion_type > MajorVersion,
                             ::std::unique_ptr< MinorVersion_type > MinorVersion)
  : ::xml_schema::type (),
    StandardName_ (std::move (StandardName), this),
    MajorVersion_ (std::move (MajorVersion), this),
    MinorVersion_ (std::move (MinorVersion), this)
  {
  }

  SymbologyDataStandardType::
  SymbologyDataStandardType (const SymbologyDataStandardType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    StandardName_ (x.StandardName_, f, this),
    MajorVersion_ (x.MajorVersion_, f, this),
    MinorVersion_ (x.MinorVersion_, f, this)
  {
  }

  SymbologyDataStandardType::
  SymbologyDataStandardType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    StandardName_ (this),
    MajorVersion_ (this),
    MinorVersion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SymbologyDataStandardType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // StandardName
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "StandardName",
            "",
            &::xsd::cxx::tree::factory_impl< StandardName_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!StandardName_.present ())
          {
            ::std::unique_ptr< StandardName_type > r (
              dynamic_cast< StandardName_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->StandardName_.set (::std::move (r));
            continue;
          }
        }
      }

      // MajorVersion
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MajorVersion",
            "",
            &::xsd::cxx::tree::factory_impl< MajorVersion_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MajorVersion_.present ())
          {
            ::std::unique_ptr< MajorVersion_type > r (
              dynamic_cast< MajorVersion_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MajorVersion_.set (::std::move (r));
            continue;
          }
        }
      }

      // MinorVersion
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MinorVersion",
            "",
            &::xsd::cxx::tree::factory_impl< MinorVersion_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MinorVersion_.present ())
          {
            ::std::unique_ptr< MinorVersion_type > r (
              dynamic_cast< MinorVersion_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MinorVersion_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!StandardName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "StandardName",
        "");
    }

    if (!MajorVersion_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MajorVersion",
        "");
    }

    if (!MinorVersion_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MinorVersion",
        "");
    }
  }

  SymbologyDataStandardType* SymbologyDataStandardType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SymbologyDataStandardType (*this, f, c);
  }

  SymbologyDataStandardType& SymbologyDataStandardType::
  operator= (const SymbologyDataStandardType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->StandardName_ = x.StandardName_;
      this->MajorVersion_ = x.MajorVersion_;
      this->MinorVersion_ = x.MinorVersion_;
    }

    return *this;
  }

  SymbologyDataStandardType::
  ~SymbologyDataStandardType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SymbologyDataStandardType >
  _xsd_SymbologyDataStandardType_type_factory_init (
    "SymbologyDataStandardType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, SymbologyDataStandardType >
  _xsd_SymbologyDataStandardType_comparison_init;

  bool
  operator== (const SymbologyDataStandardType& x, const SymbologyDataStandardType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.StandardName (), y.StandardName ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.MajorVersion (), y.MajorVersion ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.MinorVersion (), y.MinorVersion ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const SymbologyDataStandardType& x, const SymbologyDataStandardType& y)
  {
    return !(x == y);
  }

  // TacticalGraphicsType
  //

  TacticalGraphicsType::
  TacticalGraphicsType ()
  : ::xml_schema::type (),
    TacticalGraphic_ (this)
  {
  }

  TacticalGraphicsType::
  TacticalGraphicsType (const TacticalGraphicsType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    TacticalGraphic_ (x.TacticalGraphic_, f, this)
  {
  }

  TacticalGraphicsType::
  TacticalGraphicsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    TacticalGraphic_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TacticalGraphicsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TacticalGraphic
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TacticalGraphic",
            "",
            &::xsd::cxx::tree::factory_impl< TacticalGraphic_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< TacticalGraphic_type > r (
            dynamic_cast< TacticalGraphic_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TacticalGraphic_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  TacticalGraphicsType* TacticalGraphicsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TacticalGraphicsType (*this, f, c);
  }

  TacticalGraphicsType& TacticalGraphicsType::
  operator= (const TacticalGraphicsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->TacticalGraphic_ = x.TacticalGraphic_;
    }

    return *this;
  }

  TacticalGraphicsType::
  ~TacticalGraphicsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TacticalGraphicsType >
  _xsd_TacticalGraphicsType_type_factory_init (
    "TacticalGraphicsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, TacticalGraphicsType >
  _xsd_TacticalGraphicsType_comparison_init;

  bool
  operator== (const TacticalGraphicsType& x, const TacticalGraphicsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      TacticalGraphicsType::TacticalGraphic_sequence a (x.TacticalGraphic ()), b (y.TacticalGraphic ());

      if (a.size () != b.size ())
        return false;

      for (TacticalGraphicsType::TacticalGraphic_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const TacticalGraphicsType& x, const TacticalGraphicsType& y)
  {
    return !(x == y);
  }

  // TacticalGraphicType
  //

  TacticalGraphicType::
  TacticalGraphicType (const ObjectHandle_type& ObjectHandle,
                       const SymbolIdentifier_type& SymbolIdentifier,
                       const Affiliation_type& Affiliation,
                       const Owner_type& Owner,
                       const AnchorPoints_type& AnchorPoints,
                       const SymbolClassChoice_type& SymbolClassChoice)
  : ::xml_schema::type (),
    ObjectHandle_ (ObjectHandle, this),
    SymbolIdentifier_ (SymbolIdentifier, this),
    Affiliation_ (Affiliation, this),
    Owner_ (Owner, this),
    AnchorPoints_ (AnchorPoints, this),
    AssociatedOverlays_ (this),
    SymbolClassData_ (this),
    SymbolClassChoice_ (SymbolClassChoice, this)
  {
  }

  TacticalGraphicType::
  TacticalGraphicType (const ObjectHandle_type& ObjectHandle,
                       const SymbolIdentifier_type& SymbolIdentifier,
                       const Affiliation_type& Affiliation,
                       ::std::unique_ptr< Owner_type > Owner,
                       ::std::unique_ptr< AnchorPoints_type > AnchorPoints,
                       const SymbolClassChoice_type& SymbolClassChoice)
  : ::xml_schema::type (),
    ObjectHandle_ (ObjectHandle, this),
    SymbolIdentifier_ (SymbolIdentifier, this),
    Affiliation_ (Affiliation, this),
    Owner_ (std::move (Owner), this),
    AnchorPoints_ (std::move (AnchorPoints), this),
    AssociatedOverlays_ (this),
    SymbolClassData_ (this),
    SymbolClassChoice_ (SymbolClassChoice, this)
  {
  }

  TacticalGraphicType::
  TacticalGraphicType (::std::unique_ptr< ObjectHandle_type > ObjectHandle,
                       ::std::unique_ptr< SymbolIdentifier_type > SymbolIdentifier,
                       ::std::unique_ptr< Affiliation_type > Affiliation,
                       ::std::unique_ptr< Owner_type > Owner,
                       ::std::unique_ptr< AnchorPoints_type > AnchorPoints,
                       ::std::unique_ptr< SymbolClassChoice_type > SymbolClassChoice)
  : ::xml_schema::type (),
    ObjectHandle_ (std::move (ObjectHandle), this),
    SymbolIdentifier_ (std::move (SymbolIdentifier), this),
    Affiliation_ (std::move (Affiliation), this),
    Owner_ (std::move (Owner), this),
    AnchorPoints_ (std::move (AnchorPoints), this),
    AssociatedOverlays_ (this),
    SymbolClassData_ (this),
    SymbolClassChoice_ (std::move (SymbolClassChoice), this)
  {
  }

  TacticalGraphicType::
  TacticalGraphicType (const TacticalGraphicType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ObjectHandle_ (x.ObjectHandle_, f, this),
    SymbolIdentifier_ (x.SymbolIdentifier_, f, this),
    Affiliation_ (x.Affiliation_, f, this),
    Owner_ (x.Owner_, f, this),
    AnchorPoints_ (x.AnchorPoints_, f, this),
    AssociatedOverlays_ (x.AssociatedOverlays_, f, this),
    SymbolClassData_ (x.SymbolClassData_, f, this),
    SymbolClassChoice_ (x.SymbolClassChoice_, f, this)
  {
  }

  TacticalGraphicType::
  TacticalGraphicType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ObjectHandle_ (this),
    SymbolIdentifier_ (this),
    Affiliation_ (this),
    Owner_ (this),
    AnchorPoints_ (this),
    AssociatedOverlays_ (this),
    SymbolClassData_ (this),
    SymbolClassChoice_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TacticalGraphicType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ObjectHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ObjectHandle",
            "",
            &::xsd::cxx::tree::factory_impl< ObjectHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ObjectHandle_.present ())
          {
            ::std::unique_ptr< ObjectHandle_type > r (
              dynamic_cast< ObjectHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ObjectHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // SymbolIdentifier
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SymbolIdentifier",
            "",
            &::xsd::cxx::tree::factory_impl< SymbolIdentifier_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!SymbolIdentifier_.present ())
          {
            ::std::unique_ptr< SymbolIdentifier_type > r (
              dynamic_cast< SymbolIdentifier_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SymbolIdentifier_.set (::std::move (r));
            continue;
          }
        }
      }

      // Affiliation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Affiliation",
            "",
            &::xsd::cxx::tree::factory_impl< Affiliation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Affiliation_.present ())
          {
            ::std::unique_ptr< Affiliation_type > r (
              dynamic_cast< Affiliation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Affiliation_.set (::std::move (r));
            continue;
          }
        }
      }

      // Owner
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Owner",
            "",
            &::xsd::cxx::tree::factory_impl< Owner_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Owner_.present ())
          {
            ::std::unique_ptr< Owner_type > r (
              dynamic_cast< Owner_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Owner_.set (::std::move (r));
            continue;
          }
        }
      }

      // AnchorPoints
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AnchorPoints",
            "",
            &::xsd::cxx::tree::factory_impl< AnchorPoints_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!AnchorPoints_.present ())
          {
            ::std::unique_ptr< AnchorPoints_type > r (
              dynamic_cast< AnchorPoints_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AnchorPoints_.set (::std::move (r));
            continue;
          }
        }
      }

      // AssociatedOverlays
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AssociatedOverlays",
            "",
            &::xsd::cxx::tree::factory_impl< AssociatedOverlays_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AssociatedOverlays_)
          {
            ::std::unique_ptr< AssociatedOverlays_type > r (
              dynamic_cast< AssociatedOverlays_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AssociatedOverlays_.set (::std::move (r));
            continue;
          }
        }
      }

      // SymbolClassData
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SymbolClassData",
            "",
            &::xsd::cxx::tree::factory_impl< SymbolClassData_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SymbolClassData_)
          {
            ::std::unique_ptr< SymbolClassData_type > r (
              dynamic_cast< SymbolClassData_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SymbolClassData_.set (::std::move (r));
            continue;
          }
        }
      }

      // SymbolClassChoice
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SymbolClassChoice",
            "",
            &::xsd::cxx::tree::factory_impl< SymbolClassChoice_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!SymbolClassChoice_.present ())
          {
            ::std::unique_ptr< SymbolClassChoice_type > r (
              dynamic_cast< SymbolClassChoice_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SymbolClassChoice_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ObjectHandle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ObjectHandle",
        "");
    }

    if (!SymbolIdentifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SymbolIdentifier",
        "");
    }

    if (!Affiliation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Affiliation",
        "");
    }

    if (!Owner_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Owner",
        "");
    }

    if (!AnchorPoints_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AnchorPoints",
        "");
    }

    if (!SymbolClassChoice_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SymbolClassChoice",
        "");
    }
  }

  TacticalGraphicType* TacticalGraphicType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TacticalGraphicType (*this, f, c);
  }

  TacticalGraphicType& TacticalGraphicType::
  operator= (const TacticalGraphicType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ObjectHandle_ = x.ObjectHandle_;
      this->SymbolIdentifier_ = x.SymbolIdentifier_;
      this->Affiliation_ = x.Affiliation_;
      this->Owner_ = x.Owner_;
      this->AnchorPoints_ = x.AnchorPoints_;
      this->AssociatedOverlays_ = x.AssociatedOverlays_;
      this->SymbolClassData_ = x.SymbolClassData_;
      this->SymbolClassChoice_ = x.SymbolClassChoice_;
    }

    return *this;
  }

  TacticalGraphicType::
  ~TacticalGraphicType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TacticalGraphicType >
  _xsd_TacticalGraphicType_type_factory_init (
    "TacticalGraphicType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, TacticalGraphicType >
  _xsd_TacticalGraphicType_comparison_init;

  bool
  operator== (const TacticalGraphicType& x, const TacticalGraphicType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ObjectHandle (), y.ObjectHandle ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.SymbolIdentifier (), y.SymbolIdentifier ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Affiliation (), y.Affiliation ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Owner (), y.Owner ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.AnchorPoints (), y.AnchorPoints ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      TacticalGraphicType::AssociatedOverlays_optional a (x.AssociatedOverlays ()), b (y.AssociatedOverlays ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      TacticalGraphicType::SymbolClassData_optional a (x.SymbolClassData ()), b (y.SymbolClassData ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.SymbolClassChoice (), y.SymbolClassChoice ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const TacticalGraphicType& x, const TacticalGraphicType& y)
  {
    return !(x == y);
  }

  // TaskSymbolModifiersType
  //

  TaskSymbolModifiersType::
  TaskSymbolModifiersType ()
  : ::xml_schema::type (),
    UniqueDesignation_ (this),
    DateTimeGroup_ (this)
  {
  }

  TaskSymbolModifiersType::
  TaskSymbolModifiersType (const TaskSymbolModifiersType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    UniqueDesignation_ (x.UniqueDesignation_, f, this),
    DateTimeGroup_ (x.DateTimeGroup_, f, this)
  {
  }

  TaskSymbolModifiersType::
  TaskSymbolModifiersType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    UniqueDesignation_ (this),
    DateTimeGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TaskSymbolModifiersType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // UniqueDesignation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UniqueDesignation",
            "",
            &::xsd::cxx::tree::factory_impl< UniqueDesignation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->UniqueDesignation_)
          {
            ::std::unique_ptr< UniqueDesignation_type > r (
              dynamic_cast< UniqueDesignation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UniqueDesignation_.set (::std::move (r));
            continue;
          }
        }
      }

      // DateTimeGroup
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DateTimeGroup",
            "",
            &::xsd::cxx::tree::factory_impl< DateTimeGroup_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DateTimeGroup_)
          {
            ::std::unique_ptr< DateTimeGroup_type > r (
              dynamic_cast< DateTimeGroup_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DateTimeGroup_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  TaskSymbolModifiersType* TaskSymbolModifiersType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TaskSymbolModifiersType (*this, f, c);
  }

  TaskSymbolModifiersType& TaskSymbolModifiersType::
  operator= (const TaskSymbolModifiersType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->UniqueDesignation_ = x.UniqueDesignation_;
      this->DateTimeGroup_ = x.DateTimeGroup_;
    }

    return *this;
  }

  TaskSymbolModifiersType::
  ~TaskSymbolModifiersType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TaskSymbolModifiersType >
  _xsd_TaskSymbolModifiersType_type_factory_init (
    "TaskSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, TaskSymbolModifiersType >
  _xsd_TaskSymbolModifiersType_comparison_init;

  bool
  operator== (const TaskSymbolModifiersType& x, const TaskSymbolModifiersType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      TaskSymbolModifiersType::UniqueDesignation_optional a (x.UniqueDesignation ()), b (y.UniqueDesignation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      TaskSymbolModifiersType::DateTimeGroup_optional a (x.DateTimeGroup ()), b (y.DateTimeGroup ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const TaskSymbolModifiersType& x, const TaskSymbolModifiersType& y)
  {
    return !(x == y);
  }

  // UnitDispositionType
  //

  UnitDispositionType::
  UnitDispositionType ()
  : ::xml_schema::type (),
    Location_ (this),
    DirectionOfMovement_ (this),
    Speed_ (this),
    FormationPosition_ (this),
    OwnFormation_ (this)
  {
  }

  UnitDispositionType::
  UnitDispositionType (const UnitDispositionType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Location_ (x.Location_, f, this),
    DirectionOfMovement_ (x.DirectionOfMovement_, f, this),
    Speed_ (x.Speed_, f, this),
    FormationPosition_ (x.FormationPosition_, f, this),
    OwnFormation_ (x.OwnFormation_, f, this)
  {
  }

  UnitDispositionType::
  UnitDispositionType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Location_ (this),
    DirectionOfMovement_ (this),
    Speed_ (this),
    FormationPosition_ (this),
    OwnFormation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void UnitDispositionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Location
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Location",
            "",
            &::xsd::cxx::tree::factory_impl< Location_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Location_)
          {
            ::std::unique_ptr< Location_type > r (
              dynamic_cast< Location_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Location_.set (::std::move (r));
            continue;
          }
        }
      }

      // DirectionOfMovement
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DirectionOfMovement",
            "",
            &::xsd::cxx::tree::factory_impl< DirectionOfMovement_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DirectionOfMovement_)
          {
            ::std::unique_ptr< DirectionOfMovement_type > r (
              dynamic_cast< DirectionOfMovement_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DirectionOfMovement_.set (::std::move (r));
            continue;
          }
        }
      }

      // Speed
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Speed",
            "",
            &::xsd::cxx::tree::factory_impl< Speed_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Speed_)
          {
            ::std::unique_ptr< Speed_type > r (
              dynamic_cast< Speed_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Speed_.set (::std::move (r));
            continue;
          }
        }
      }

      // FormationPosition
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "FormationPosition",
            "",
            &::xsd::cxx::tree::factory_impl< FormationPosition_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->FormationPosition_)
          {
            ::std::unique_ptr< FormationPosition_type > r (
              dynamic_cast< FormationPosition_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FormationPosition_.set (::std::move (r));
            continue;
          }
        }
      }

      // OwnFormation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OwnFormation",
            "",
            &::xsd::cxx::tree::factory_impl< OwnFormation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->OwnFormation_)
          {
            ::std::unique_ptr< OwnFormation_type > r (
              dynamic_cast< OwnFormation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OwnFormation_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  UnitDispositionType* UnitDispositionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UnitDispositionType (*this, f, c);
  }

  UnitDispositionType& UnitDispositionType::
  operator= (const UnitDispositionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Location_ = x.Location_;
      this->DirectionOfMovement_ = x.DirectionOfMovement_;
      this->Speed_ = x.Speed_;
      this->FormationPosition_ = x.FormationPosition_;
      this->OwnFormation_ = x.OwnFormation_;
    }

    return *this;
  }

  UnitDispositionType::
  ~UnitDispositionType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, UnitDispositionType >
  _xsd_UnitDispositionType_type_factory_init (
    "UnitDispositionType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, UnitDispositionType >
  _xsd_UnitDispositionType_comparison_init;

  bool
  operator== (const UnitDispositionType& x, const UnitDispositionType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitDispositionType::Location_optional a (x.Location ()), b (y.Location ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitDispositionType::DirectionOfMovement_optional a (x.DirectionOfMovement ()), b (y.DirectionOfMovement ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitDispositionType::Speed_optional a (x.Speed ()), b (y.Speed ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitDispositionType::FormationPosition_optional a (x.FormationPosition ()), b (y.FormationPosition ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitDispositionType::OwnFormation_optional a (x.OwnFormation ()), b (y.OwnFormation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const UnitDispositionType& x, const UnitDispositionType& y)
  {
    return !(x == y);
  }

  // UnitModelType
  //

  UnitModelType::
  UnitModelType ()
  : ::xml_schema::type (),
    Resolution_ (this),
    AggregateBased_ (this)
  {
  }

  UnitModelType::
  UnitModelType (const UnitModelType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Resolution_ (x.Resolution_, f, this),
    AggregateBased_ (x.AggregateBased_, f, this)
  {
  }

  UnitModelType::
  UnitModelType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Resolution_ (this),
    AggregateBased_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void UnitModelType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Resolution
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Resolution",
            "",
            &::xsd::cxx::tree::factory_impl< Resolution_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Resolution_)
          {
            ::std::unique_ptr< Resolution_type > r (
              dynamic_cast< Resolution_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Resolution_.set (::std::move (r));
            continue;
          }
        }
      }

      // AggregateBased
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AggregateBased",
            "",
            &::xsd::cxx::tree::factory_impl< AggregateBased_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AggregateBased_)
          {
            ::std::unique_ptr< AggregateBased_type > r (
              dynamic_cast< AggregateBased_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AggregateBased_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  UnitModelType* UnitModelType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UnitModelType (*this, f, c);
  }

  UnitModelType& UnitModelType::
  operator= (const UnitModelType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Resolution_ = x.Resolution_;
      this->AggregateBased_ = x.AggregateBased_;
    }

    return *this;
  }

  UnitModelType::
  ~UnitModelType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, UnitModelType >
  _xsd_UnitModelType_type_factory_init (
    "UnitModelType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, UnitModelType >
  _xsd_UnitModelType_comparison_init;

  bool
  operator== (const UnitModelType& x, const UnitModelType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitModelType::Resolution_optional a (x.Resolution ()), b (y.Resolution ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitModelType::AggregateBased_optional a (x.AggregateBased ()), b (y.AggregateBased ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const UnitModelType& x, const UnitModelType& y)
  {
    return !(x == y);
  }

  // UnitRelationsType
  //

  UnitRelationsType::
  UnitRelationsType (const ForceRelation_type& ForceRelation)
  : ::xml_schema::type (),
    ForceRelation_ (ForceRelation, this),
    SupportRelations_ (this),
    OrganicRelation_ (this)
  {
  }

  UnitRelationsType::
  UnitRelationsType (::std::unique_ptr< ForceRelation_type > ForceRelation)
  : ::xml_schema::type (),
    ForceRelation_ (std::move (ForceRelation), this),
    SupportRelations_ (this),
    OrganicRelation_ (this)
  {
  }

  UnitRelationsType::
  UnitRelationsType (const UnitRelationsType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ForceRelation_ (x.ForceRelation_, f, this),
    SupportRelations_ (x.SupportRelations_, f, this),
    OrganicRelation_ (x.OrganicRelation_, f, this)
  {
  }

  UnitRelationsType::
  UnitRelationsType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ForceRelation_ (this),
    SupportRelations_ (this),
    OrganicRelation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void UnitRelationsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ForceRelation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ForceRelation",
            "",
            &::xsd::cxx::tree::factory_impl< ForceRelation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ForceRelation_.present ())
          {
            ::std::unique_ptr< ForceRelation_type > r (
              dynamic_cast< ForceRelation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ForceRelation_.set (::std::move (r));
            continue;
          }
        }
      }

      // SupportRelations
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SupportRelations",
            "",
            &::xsd::cxx::tree::factory_impl< SupportRelations_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SupportRelations_)
          {
            ::std::unique_ptr< SupportRelations_type > r (
              dynamic_cast< SupportRelations_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SupportRelations_.set (::std::move (r));
            continue;
          }
        }
      }

      // OrganicRelation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OrganicRelation",
            "",
            &::xsd::cxx::tree::factory_impl< OrganicRelation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->OrganicRelation_)
          {
            ::std::unique_ptr< OrganicRelation_type > r (
              dynamic_cast< OrganicRelation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OrganicRelation_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ForceRelation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ForceRelation",
        "");
    }
  }

  UnitRelationsType* UnitRelationsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UnitRelationsType (*this, f, c);
  }

  UnitRelationsType& UnitRelationsType::
  operator= (const UnitRelationsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ForceRelation_ = x.ForceRelation_;
      this->SupportRelations_ = x.SupportRelations_;
      this->OrganicRelation_ = x.OrganicRelation_;
    }

    return *this;
  }

  UnitRelationsType::
  ~UnitRelationsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, UnitRelationsType >
  _xsd_UnitRelationsType_type_factory_init (
    "UnitRelationsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, UnitRelationsType >
  _xsd_UnitRelationsType_comparison_init;

  bool
  operator== (const UnitRelationsType& x, const UnitRelationsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ForceRelation (), y.ForceRelation ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitRelationsType::SupportRelations_optional a (x.SupportRelations ()), b (y.SupportRelations ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitRelationsType::OrganicRelation_optional a (x.OrganicRelation ()), b (y.OrganicRelation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const UnitRelationsType& x, const UnitRelationsType& y)
  {
    return !(x == y);
  }

  // UnitsType
  //

  UnitsType::
  UnitsType ()
  : ::xml_schema::type (),
    Unit_ (this)
  {
  }

  UnitsType::
  UnitsType (const UnitsType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Unit_ (x.Unit_, f, this)
  {
  }

  UnitsType::
  UnitsType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Unit_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void UnitsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Unit
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Unit",
            "",
            &::xsd::cxx::tree::factory_impl< Unit_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< Unit_type > r (
            dynamic_cast< Unit_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Unit_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  UnitsType* UnitsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UnitsType (*this, f, c);
  }

  UnitsType& UnitsType::
  operator= (const UnitsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Unit_ = x.Unit_;
    }

    return *this;
  }

  UnitsType::
  ~UnitsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, UnitsType >
  _xsd_UnitsType_type_factory_init (
    "UnitsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, UnitsType >
  _xsd_UnitsType_comparison_init;

  bool
  operator== (const UnitsType& x, const UnitsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitsType::Unit_sequence a (x.Unit ()), b (y.Unit ());

      if (a.size () != b.size ())
        return false;

      for (UnitsType::Unit_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const UnitsType& x, const UnitsType& y)
  {
    return !(x == y);
  }

  // UnitSymbolModifiersType
  //

  UnitSymbolModifiersType::
  UnitSymbolModifiersType (const UniqueDesignation_type& UniqueDesignation)
  : ::xml_schema::type (),
    Echelon_ (this),
    ReinforcedReduced_ (this),
    StaffComments_ (this),
    AdditionalInfo_ (this),
    CombatEffectiveness_ (this),
    HigherFormation_ (this),
    IFF_ (this),
    UniqueDesignation_ (UniqueDesignation, this),
    SpecialC2HQ_ (this)
  {
  }

  UnitSymbolModifiersType::
  UnitSymbolModifiersType (::std::unique_ptr< UniqueDesignation_type > UniqueDesignation)
  : ::xml_schema::type (),
    Echelon_ (this),
    ReinforcedReduced_ (this),
    StaffComments_ (this),
    AdditionalInfo_ (this),
    CombatEffectiveness_ (this),
    HigherFormation_ (this),
    IFF_ (this),
    UniqueDesignation_ (std::move (UniqueDesignation), this),
    SpecialC2HQ_ (this)
  {
  }

  UnitSymbolModifiersType::
  UnitSymbolModifiersType (const UnitSymbolModifiersType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Echelon_ (x.Echelon_, f, this),
    ReinforcedReduced_ (x.ReinforcedReduced_, f, this),
    StaffComments_ (x.StaffComments_, f, this),
    AdditionalInfo_ (x.AdditionalInfo_, f, this),
    CombatEffectiveness_ (x.CombatEffectiveness_, f, this),
    HigherFormation_ (x.HigherFormation_, f, this),
    IFF_ (x.IFF_, f, this),
    UniqueDesignation_ (x.UniqueDesignation_, f, this),
    SpecialC2HQ_ (x.SpecialC2HQ_, f, this)
  {
  }

  UnitSymbolModifiersType::
  UnitSymbolModifiersType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Echelon_ (this),
    ReinforcedReduced_ (this),
    StaffComments_ (this),
    AdditionalInfo_ (this),
    CombatEffectiveness_ (this),
    HigherFormation_ (this),
    IFF_ (this),
    UniqueDesignation_ (this),
    SpecialC2HQ_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void UnitSymbolModifiersType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Echelon
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Echelon",
            "",
            &::xsd::cxx::tree::factory_impl< Echelon_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Echelon_)
          {
            ::std::unique_ptr< Echelon_type > r (
              dynamic_cast< Echelon_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Echelon_.set (::std::move (r));
            continue;
          }
        }
      }

      // ReinforcedReduced
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ReinforcedReduced",
            "",
            &::xsd::cxx::tree::factory_impl< ReinforcedReduced_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ReinforcedReduced_)
          {
            ::std::unique_ptr< ReinforcedReduced_type > r (
              dynamic_cast< ReinforcedReduced_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ReinforcedReduced_.set (::std::move (r));
            continue;
          }
        }
      }

      // StaffComments
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "StaffComments",
            "",
            &::xsd::cxx::tree::factory_impl< StaffComments_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->StaffComments_)
          {
            ::std::unique_ptr< StaffComments_type > r (
              dynamic_cast< StaffComments_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->StaffComments_.set (::std::move (r));
            continue;
          }
        }
      }

      // AdditionalInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AdditionalInfo",
            "",
            &::xsd::cxx::tree::factory_impl< AdditionalInfo_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AdditionalInfo_)
          {
            ::std::unique_ptr< AdditionalInfo_type > r (
              dynamic_cast< AdditionalInfo_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AdditionalInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      // CombatEffectiveness
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CombatEffectiveness",
            "",
            &::xsd::cxx::tree::factory_impl< CombatEffectiveness_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CombatEffectiveness_)
          {
            ::std::unique_ptr< CombatEffectiveness_type > r (
              dynamic_cast< CombatEffectiveness_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CombatEffectiveness_.set (::std::move (r));
            continue;
          }
        }
      }

      // HigherFormation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HigherFormation",
            "",
            &::xsd::cxx::tree::factory_impl< HigherFormation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->HigherFormation_)
          {
            ::std::unique_ptr< HigherFormation_type > r (
              dynamic_cast< HigherFormation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->HigherFormation_.set (::std::move (r));
            continue;
          }
        }
      }

      // IFF
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "IFF",
            "",
            &::xsd::cxx::tree::factory_impl< IFF_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->IFF_)
          {
            ::std::unique_ptr< IFF_type > r (
              dynamic_cast< IFF_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->IFF_.set (::std::move (r));
            continue;
          }
        }
      }

      // UniqueDesignation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UniqueDesignation",
            "",
            &::xsd::cxx::tree::factory_impl< UniqueDesignation_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!UniqueDesignation_.present ())
          {
            ::std::unique_ptr< UniqueDesignation_type > r (
              dynamic_cast< UniqueDesignation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UniqueDesignation_.set (::std::move (r));
            continue;
          }
        }
      }

      // SpecialC2HQ
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SpecialC2HQ",
            "",
            &::xsd::cxx::tree::factory_impl< SpecialC2HQ_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SpecialC2HQ_)
          {
            ::std::unique_ptr< SpecialC2HQ_type > r (
              dynamic_cast< SpecialC2HQ_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SpecialC2HQ_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!UniqueDesignation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "UniqueDesignation",
        "");
    }
  }

  UnitSymbolModifiersType* UnitSymbolModifiersType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UnitSymbolModifiersType (*this, f, c);
  }

  UnitSymbolModifiersType& UnitSymbolModifiersType::
  operator= (const UnitSymbolModifiersType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Echelon_ = x.Echelon_;
      this->ReinforcedReduced_ = x.ReinforcedReduced_;
      this->StaffComments_ = x.StaffComments_;
      this->AdditionalInfo_ = x.AdditionalInfo_;
      this->CombatEffectiveness_ = x.CombatEffectiveness_;
      this->HigherFormation_ = x.HigherFormation_;
      this->IFF_ = x.IFF_;
      this->UniqueDesignation_ = x.UniqueDesignation_;
      this->SpecialC2HQ_ = x.SpecialC2HQ_;
    }

    return *this;
  }

  UnitSymbolModifiersType::
  ~UnitSymbolModifiersType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, UnitSymbolModifiersType >
  _xsd_UnitSymbolModifiersType_type_factory_init (
    "UnitSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, UnitSymbolModifiersType >
  _xsd_UnitSymbolModifiersType_comparison_init;

  bool
  operator== (const UnitSymbolModifiersType& x, const UnitSymbolModifiersType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitSymbolModifiersType::Echelon_optional a (x.Echelon ()), b (y.Echelon ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitSymbolModifiersType::ReinforcedReduced_optional a (x.ReinforcedReduced ()), b (y.ReinforcedReduced ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitSymbolModifiersType::StaffComments_optional a (x.StaffComments ()), b (y.StaffComments ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitSymbolModifiersType::AdditionalInfo_optional a (x.AdditionalInfo ()), b (y.AdditionalInfo ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitSymbolModifiersType::CombatEffectiveness_optional a (x.CombatEffectiveness ()), b (y.CombatEffectiveness ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitSymbolModifiersType::HigherFormation_optional a (x.HigherFormation ()), b (y.HigherFormation ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitSymbolModifiersType::IFF_optional a (x.IFF ()), b (y.IFF ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.UniqueDesignation (), y.UniqueDesignation ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitSymbolModifiersType::SpecialC2HQ_optional a (x.SpecialC2HQ ()), b (y.SpecialC2HQ ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const UnitSymbolModifiersType& x, const UnitSymbolModifiersType& y)
  {
    return !(x == y);
  }

  // UnitType
  //

  UnitType::
  UnitType (const ObjectHandle_type& ObjectHandle,
            const SymbolIdentifier_type& SymbolIdentifier,
            const Relations_type& Relations)
  : ::xml_schema::type (),
    ObjectHandle_ (ObjectHandle, this),
    SymbolIdentifier_ (SymbolIdentifier, this),
    Name_ (this),
    UnitSymbolModifiers_ (this),
    CommunicationNetInstances_ (this),
    Status_ (this),
    Disposition_ (this),
    Relations_ (Relations, this),
    Model_ (this)
  {
  }

  UnitType::
  UnitType (const ObjectHandle_type& ObjectHandle,
            const SymbolIdentifier_type& SymbolIdentifier,
            ::std::unique_ptr< Relations_type > Relations)
  : ::xml_schema::type (),
    ObjectHandle_ (ObjectHandle, this),
    SymbolIdentifier_ (SymbolIdentifier, this),
    Name_ (this),
    UnitSymbolModifiers_ (this),
    CommunicationNetInstances_ (this),
    Status_ (this),
    Disposition_ (this),
    Relations_ (std::move (Relations), this),
    Model_ (this)
  {
  }

  UnitType::
  UnitType (::std::unique_ptr< ObjectHandle_type > ObjectHandle,
            ::std::unique_ptr< SymbolIdentifier_type > SymbolIdentifier,
            ::std::unique_ptr< Relations_type > Relations)
  : ::xml_schema::type (),
    ObjectHandle_ (std::move (ObjectHandle), this),
    SymbolIdentifier_ (std::move (SymbolIdentifier), this),
    Name_ (this),
    UnitSymbolModifiers_ (this),
    CommunicationNetInstances_ (this),
    Status_ (this),
    Disposition_ (this),
    Relations_ (std::move (Relations), this),
    Model_ (this)
  {
  }

  UnitType::
  UnitType (const UnitType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ObjectHandle_ (x.ObjectHandle_, f, this),
    SymbolIdentifier_ (x.SymbolIdentifier_, f, this),
    Name_ (x.Name_, f, this),
    UnitSymbolModifiers_ (x.UnitSymbolModifiers_, f, this),
    CommunicationNetInstances_ (x.CommunicationNetInstances_, f, this),
    Status_ (x.Status_, f, this),
    Disposition_ (x.Disposition_, f, this),
    Relations_ (x.Relations_, f, this),
    Model_ (x.Model_, f, this)
  {
  }

  UnitType::
  UnitType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ObjectHandle_ (this),
    SymbolIdentifier_ (this),
    Name_ (this),
    UnitSymbolModifiers_ (this),
    CommunicationNetInstances_ (this),
    Status_ (this),
    Disposition_ (this),
    Relations_ (this),
    Model_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void UnitType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ObjectHandle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ObjectHandle",
            "",
            &::xsd::cxx::tree::factory_impl< ObjectHandle_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ObjectHandle_.present ())
          {
            ::std::unique_ptr< ObjectHandle_type > r (
              dynamic_cast< ObjectHandle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ObjectHandle_.set (::std::move (r));
            continue;
          }
        }
      }

      // SymbolIdentifier
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SymbolIdentifier",
            "",
            &::xsd::cxx::tree::factory_impl< SymbolIdentifier_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!SymbolIdentifier_.present ())
          {
            ::std::unique_ptr< SymbolIdentifier_type > r (
              dynamic_cast< SymbolIdentifier_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SymbolIdentifier_.set (::std::move (r));
            continue;
          }
        }
      }

      // Name
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Name",
            "",
            &::xsd::cxx::tree::factory_impl< Name_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Name_)
          {
            ::std::unique_ptr< Name_type > r (
              dynamic_cast< Name_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Name_.set (::std::move (r));
            continue;
          }
        }
      }

      // UnitSymbolModifiers
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UnitSymbolModifiers",
            "",
            &::xsd::cxx::tree::factory_impl< UnitSymbolModifiers_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->UnitSymbolModifiers_)
          {
            ::std::unique_ptr< UnitSymbolModifiers_type > r (
              dynamic_cast< UnitSymbolModifiers_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UnitSymbolModifiers_.set (::std::move (r));
            continue;
          }
        }
      }

      // CommunicationNetInstances
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CommunicationNetInstances",
            "",
            &::xsd::cxx::tree::factory_impl< CommunicationNetInstances_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CommunicationNetInstances_)
          {
            ::std::unique_ptr< CommunicationNetInstances_type > r (
              dynamic_cast< CommunicationNetInstances_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CommunicationNetInstances_.set (::std::move (r));
            continue;
          }
        }
      }

      // Status
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Status",
            "",
            &::xsd::cxx::tree::factory_impl< Status_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Status_)
          {
            ::std::unique_ptr< Status_type > r (
              dynamic_cast< Status_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Status_.set (::std::move (r));
            continue;
          }
        }
      }

      // Disposition
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Disposition",
            "",
            &::xsd::cxx::tree::factory_impl< Disposition_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Disposition_)
          {
            ::std::unique_ptr< Disposition_type > r (
              dynamic_cast< Disposition_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Disposition_.set (::std::move (r));
            continue;
          }
        }
      }

      // Relations
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Relations",
            "",
            &::xsd::cxx::tree::factory_impl< Relations_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Relations_.present ())
          {
            ::std::unique_ptr< Relations_type > r (
              dynamic_cast< Relations_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Relations_.set (::std::move (r));
            continue;
          }
        }
      }

      // Model
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Model",
            "",
            &::xsd::cxx::tree::factory_impl< Model_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Model_)
          {
            ::std::unique_ptr< Model_type > r (
              dynamic_cast< Model_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Model_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ObjectHandle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ObjectHandle",
        "");
    }

    if (!SymbolIdentifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SymbolIdentifier",
        "");
    }

    if (!Relations_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Relations",
        "");
    }
  }

  UnitType* UnitType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UnitType (*this, f, c);
  }

  UnitType& UnitType::
  operator= (const UnitType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ObjectHandle_ = x.ObjectHandle_;
      this->SymbolIdentifier_ = x.SymbolIdentifier_;
      this->Name_ = x.Name_;
      this->UnitSymbolModifiers_ = x.UnitSymbolModifiers_;
      this->CommunicationNetInstances_ = x.CommunicationNetInstances_;
      this->Status_ = x.Status_;
      this->Disposition_ = x.Disposition_;
      this->Relations_ = x.Relations_;
      this->Model_ = x.Model_;
    }

    return *this;
  }

  UnitType::
  ~UnitType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, UnitType >
  _xsd_UnitType_type_factory_init (
    "UnitType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, UnitType >
  _xsd_UnitType_comparison_init;

  bool
  operator== (const UnitType& x, const UnitType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.ObjectHandle (), y.ObjectHandle ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.SymbolIdentifier (), y.SymbolIdentifier ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitType::Name_optional a (x.Name ()), b (y.Name ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitType::UnitSymbolModifiers_optional a (x.UnitSymbolModifiers ()), b (y.UnitSymbolModifiers ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitType::CommunicationNetInstances_optional a (x.CommunicationNetInstances ()), b (y.CommunicationNetInstances ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitType::Status_optional a (x.Status ()), b (y.Status ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitType::Disposition_optional a (x.Disposition ()), b (y.Disposition ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.Relations (), y.Relations ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UnitType::Model_optional a (x.Model ()), b (y.Model ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const UnitType& x, const UnitType& y)
  {
    return !(x == y);
  }

  // UTMType
  //

  UTMType::
  UTMType (const UTMGridZone_type& UTMGridZone,
           const UTMEasting_type& UTMEasting,
           const UTMNorthing_type& UTMNorthing)
  : ::xml_schema::type (),
    UTMGridZone_ (UTMGridZone, this),
    UTMEasting_ (UTMEasting, this),
    UTMNorthing_ (UTMNorthing, this),
    ElevationAGL_ (this)
  {
  }

  UTMType::
  UTMType (::std::unique_ptr< UTMGridZone_type > UTMGridZone,
           ::std::unique_ptr< UTMEasting_type > UTMEasting,
           ::std::unique_ptr< UTMNorthing_type > UTMNorthing)
  : ::xml_schema::type (),
    UTMGridZone_ (std::move (UTMGridZone), this),
    UTMEasting_ (std::move (UTMEasting), this),
    UTMNorthing_ (std::move (UTMNorthing), this),
    ElevationAGL_ (this)
  {
  }

  UTMType::
  UTMType (const UTMType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    UTMGridZone_ (x.UTMGridZone_, f, this),
    UTMEasting_ (x.UTMEasting_, f, this),
    UTMNorthing_ (x.UTMNorthing_, f, this),
    ElevationAGL_ (x.ElevationAGL_, f, this)
  {
  }

  UTMType::
  UTMType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    UTMGridZone_ (this),
    UTMEasting_ (this),
    UTMNorthing_ (this),
    ElevationAGL_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void UTMType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // UTMGridZone
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UTMGridZone",
            "",
            &::xsd::cxx::tree::factory_impl< UTMGridZone_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!UTMGridZone_.present ())
          {
            ::std::unique_ptr< UTMGridZone_type > r (
              dynamic_cast< UTMGridZone_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UTMGridZone_.set (::std::move (r));
            continue;
          }
        }
      }

      // UTMEasting
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UTMEasting",
            "",
            &::xsd::cxx::tree::factory_impl< UTMEasting_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!UTMEasting_.present ())
          {
            ::std::unique_ptr< UTMEasting_type > r (
              dynamic_cast< UTMEasting_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UTMEasting_.set (::std::move (r));
            continue;
          }
        }
      }

      // UTMNorthing
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UTMNorthing",
            "",
            &::xsd::cxx::tree::factory_impl< UTMNorthing_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!UTMNorthing_.present ())
          {
            ::std::unique_ptr< UTMNorthing_type > r (
              dynamic_cast< UTMNorthing_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UTMNorthing_.set (::std::move (r));
            continue;
          }
        }
      }

      // ElevationAGL
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ElevationAGL",
            "",
            &::xsd::cxx::tree::factory_impl< ElevationAGL_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ElevationAGL_)
          {
            ::std::unique_ptr< ElevationAGL_type > r (
              dynamic_cast< ElevationAGL_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ElevationAGL_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!UTMGridZone_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "UTMGridZone",
        "");
    }

    if (!UTMEasting_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "UTMEasting",
        "");
    }

    if (!UTMNorthing_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "UTMNorthing",
        "");
    }
  }

  UTMType* UTMType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UTMType (*this, f, c);
  }

  UTMType& UTMType::
  operator= (const UTMType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->UTMGridZone_ = x.UTMGridZone_;
      this->UTMEasting_ = x.UTMEasting_;
      this->UTMNorthing_ = x.UTMNorthing_;
      this->ElevationAGL_ = x.ElevationAGL_;
    }

    return *this;
  }

  UTMType::
  ~UTMType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, UTMType >
  _xsd_UTMType_type_factory_init (
    "UTMType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, UTMType >
  _xsd_UTMType_comparison_init;

  bool
  operator== (const UTMType& x, const UTMType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.UTMGridZone (), y.UTMGridZone ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.UTMEasting (), y.UTMEasting ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.UTMNorthing (), y.UTMNorthing ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      UTMType::ElevationAGL_optional a (x.ElevationAGL ()), b (y.ElevationAGL ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const UTMType& x, const UTMType& y)
  {
    return !(x == y);
  }

  // VisibilityItemsType
  //

  VisibilityItemsType::
  VisibilityItemsType ()
  : ::xml_schema::type (),
    Visibility_ (this)
  {
  }

  VisibilityItemsType::
  VisibilityItemsType (const VisibilityItemsType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Visibility_ (x.Visibility_, f, this)
  {
  }

  VisibilityItemsType::
  VisibilityItemsType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Visibility_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VisibilityItemsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Visibility
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Visibility",
            "",
            &::xsd::cxx::tree::factory_impl< Visibility_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< Visibility_type > r (
            dynamic_cast< Visibility_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Visibility_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  VisibilityItemsType* VisibilityItemsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VisibilityItemsType (*this, f, c);
  }

  VisibilityItemsType& VisibilityItemsType::
  operator= (const VisibilityItemsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Visibility_ = x.Visibility_;
    }

    return *this;
  }

  VisibilityItemsType::
  ~VisibilityItemsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, VisibilityItemsType >
  _xsd_VisibilityItemsType_type_factory_init (
    "VisibilityItemsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, VisibilityItemsType >
  _xsd_VisibilityItemsType_comparison_init;

  bool
  operator== (const VisibilityItemsType& x, const VisibilityItemsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      VisibilityItemsType::Visibility_sequence a (x.Visibility ()), b (y.Visibility ());

      if (a.size () != b.size ())
        return false;

      for (VisibilityItemsType::Visibility_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const VisibilityItemsType& x, const VisibilityItemsType& y)
  {
    return !(x == y);
  }

  // WindItemsType
  //

  WindItemsType::
  WindItemsType ()
  : ::xml_schema::type (),
    Wind_ (this)
  {
  }

  WindItemsType::
  WindItemsType (const WindItemsType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Wind_ (x.Wind_, f, this)
  {
  }

  WindItemsType::
  WindItemsType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Wind_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void WindItemsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Wind
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Wind",
            "",
            &::xsd::cxx::tree::factory_impl< Wind_type >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< Wind_type > r (
            dynamic_cast< Wind_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Wind_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  WindItemsType* WindItemsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class WindItemsType (*this, f, c);
  }

  WindItemsType& WindItemsType::
  operator= (const WindItemsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Wind_ = x.Wind_;
    }

    return *this;
  }

  WindItemsType::
  ~WindItemsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, WindItemsType >
  _xsd_WindItemsType_type_factory_init (
    "WindItemsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, WindItemsType >
  _xsd_WindItemsType_comparison_init;

  bool
  operator== (const WindItemsType& x, const WindItemsType& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      WindItemsType::Wind_sequence a (x.Wind ()), b (y.Wind ());

      if (a.size () != b.size ())
        return false;

      for (WindItemsType::Wind_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const WindItemsType& x, const WindItemsType& y)
  {
    return !(x == y);
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace msdl_1
{
  ::std::ostream&
  operator<< (::std::ostream& o, const AnchorPointType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "AnchorChoice: ";
      om.insert (o, i.AnchorChoice ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Anchor: ";
      om.insert (o, i.Anchor ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, AnchorPointType >
  _xsd_AnchorPointType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const AnchorPointsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (AnchorPointsType::AnchorPoint_const_iterator
           b (i.AnchorPoint ().begin ()), e (i.AnchorPoint ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "AnchorPoint: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, AnchorPointsType >
  _xsd_AnchorPointsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const AnchorType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Location ())
      {
        o << ::std::endl << "Location: ";
        om.insert (o, *i.Location ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.PointSymbolHandle ())
      {
        o << ::std::endl << "PointSymbolHandle: ";
        om.insert (o, *i.PointSymbolHandle ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, AnchorType >
  _xsd_AnchorType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const AreaSymbolModifiersType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Echelon ())
      {
        o << ::std::endl << "Echelon: ";
        om.insert (o, *i.Echelon ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        o << ::std::endl << "AdditionalInfo: ";
        om.insert (o, *i.AdditionalInfo ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AdditionalInfo1 ())
      {
        o << ::std::endl << "AdditionalInfo1: ";
        om.insert (o, *i.AdditionalInfo1 ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AdditionalInfo2 ())
      {
        o << ::std::endl << "AdditionalInfo2: ";
        om.insert (o, *i.AdditionalInfo2 ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.UniqueDesignation ())
      {
        o << ::std::endl << "UniqueDesignation: ";
        om.insert (o, *i.UniqueDesignation ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        o << ::std::endl << "DateTimeGroup: ";
        om.insert (o, *i.DateTimeGroup ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DateTimeGroup1 ())
      {
        o << ::std::endl << "DateTimeGroup1: ";
        om.insert (o, *i.DateTimeGroup1 ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, AreaSymbolModifiersType >
  _xsd_AreaSymbolModifiersType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const AssociatedOverlaysType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "OverlayHandles: ";
      om.insert (o, i.OverlayHandles ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.SourceOverlayType ())
      {
        o << ::std::endl << "SourceOverlayType: ";
        om.insert (o, *i.SourceOverlayType ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, AssociatedOverlaysType >
  _xsd_AssociatedOverlaysType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const AssociationsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (AssociationsType::Association_const_iterator
           b (i.Association ().begin ()), e (i.Association ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "Association: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, AssociationsType >
  _xsd_AssociationsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const AssociationType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "AffiliateHandle: ";
      om.insert (o, i.AffiliateHandle ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Relationship: ";
      om.insert (o, i.Relationship ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, AssociationType >
  _xsd_AssociationType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const BoundarySymbolModifiersType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Echelon ())
      {
        o << ::std::endl << "Echelon: ";
        om.insert (o, *i.Echelon ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.UniqueDesignation ())
      {
        o << ::std::endl << "UniqueDesignation: ";
        om.insert (o, *i.UniqueDesignation ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.UniqueDesignation1 ())
      {
        o << ::std::endl << "UniqueDesignation1: ";
        om.insert (o, *i.UniqueDesignation1 ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, BoundarySymbolModifiersType >
  _xsd_BoundarySymbolModifiersType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const CloudCoverItemsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (CloudCoverItemsType::CloudCover_const_iterator
           b (i.CloudCover ().begin ()), e (i.CloudCover ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "CloudCover: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CloudCoverItemsType >
  _xsd_CloudCoverItemsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const CommandRelationType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "CommandingSuperiorHandle: ";
      om.insert (o, i.CommandingSuperiorHandle ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "CommandRelationshipType: ";
      om.insert (o, i.CommandRelationshipType ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CommandRelationType >
  _xsd_CommandRelationType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const CommunicationNetInstancesType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (CommunicationNetInstancesType::CommunicationNetInstance_const_iterator
           b (i.CommunicationNetInstance ().begin ()), e (i.CommunicationNetInstance ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "CommunicationNetInstance: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CommunicationNetInstancesType >
  _xsd_CommunicationNetInstancesType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const CommunicationNetInstanceType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.CommunicationNetType ())
      {
        o << ::std::endl << "CommunicationNetType: ";
        om.insert (o, *i.CommunicationNetType ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "CommunicationNetId: ";
      om.insert (o, i.CommunicationNetId ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "CommunicationService: ";
      om.insert (o, i.CommunicationService ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CommunicationNetInstanceType >
  _xsd_CommunicationNetInstanceType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const CommunicationNetReferencesType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (CommunicationNetReferencesType::CommunicationNetReference_const_iterator
           b (i.CommunicationNetReference ().begin ()), e (i.CommunicationNetReference ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "CommunicationNetReference: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CommunicationNetReferencesType >
  _xsd_CommunicationNetReferencesType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const CommunicationNetReferenceType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "CommunicationNetId: ";
      om.insert (o, i.CommunicationNetId ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "UnitOwnerHandle: ";
      om.insert (o, i.UnitOwnerHandle ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CommunicationNetReferenceType >
  _xsd_CommunicationNetReferenceType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const CoordinateDataStandardType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "CoordinateSystemType: ";
      om.insert (o, i.CoordinateSystemType ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "CoordinateSystemDatum: ";
      om.insert (o, i.CoordinateSystemDatum ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CoordinateDataStandardType >
  _xsd_CoordinateDataStandardType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const CoordinatesType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "CoordinateChoice: ";
      om.insert (o, i.CoordinateChoice ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "CoordinateData: ";
      om.insert (o, i.CoordinateData ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CoordinatesType >
  _xsd_CoordinatesType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const CoordinatePointType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.MGRS ())
      {
        o << ::std::endl << "MGRS: ";
        om.insert (o, *i.MGRS ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.UTM ())
      {
        o << ::std::endl << "UTM: ";
        om.insert (o, *i.UTM ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.GDC ())
      {
        o << ::std::endl << "GDC: ";
        om.insert (o, *i.GDC ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.GCC ())
      {
        o << ::std::endl << "GCC: ";
        om.insert (o, *i.GCC ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CoordinatePointType >
  _xsd_CoordinatePointType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const EnvironmentType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.ScenarioTime ())
      {
        o << ::std::endl << "ScenarioTime: ";
        om.insert (o, *i.ScenarioTime ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AreaOfInterest ())
      {
        o << ::std::endl << "AreaOfInterest: ";
        om.insert (o, *i.AreaOfInterest ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.ScenarioWeather ())
      {
        o << ::std::endl << "ScenarioWeather: ";
        om.insert (o, *i.ScenarioWeather ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.METOC ())
      {
        o << ::std::endl << "METOC: ";
        om.insert (o, *i.METOC ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnvironmentType >
  _xsd_EnvironmentType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const EquipmentDispositionType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Location: ";
      om.insert (o, i.Location ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DirectionOfMovement ())
      {
        o << ::std::endl << "DirectionOfMovement: ";
        om.insert (o, *i.DirectionOfMovement ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Speed ())
      {
        o << ::std::endl << "Speed: ";
        om.insert (o, *i.Speed ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.FormationPosition ())
      {
        o << ::std::endl << "FormationPosition: ";
        om.insert (o, *i.FormationPosition ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EquipmentDispositionType >
  _xsd_EquipmentDispositionType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const EquipmentItemType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ObjectHandle: ";
      om.insert (o, i.ObjectHandle ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "SymbolIdentifier: ";
      om.insert (o, i.SymbolIdentifier ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Name ())
      {
        o << ::std::endl << "Name: ";
        om.insert (o, *i.Name ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.EquipmentSymbolModifiers ())
      {
        o << ::std::endl << "EquipmentSymbolModifiers: ";
        om.insert (o, *i.EquipmentSymbolModifiers ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.CommunicationNetReferences ())
      {
        o << ::std::endl << "CommunicationNetReferences: ";
        om.insert (o, *i.CommunicationNetReferences ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Disposition: ";
      om.insert (o, i.Disposition ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Relations: ";
      om.insert (o, i.Relations ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Model ())
      {
        o << ::std::endl << "Model: ";
        om.insert (o, *i.Model ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EquipmentItemType >
  _xsd_EquipmentItemType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const EquipmentModelType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Resolution: ";
      om.insert (o, i.Resolution ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EquipmentModelType >
  _xsd_EquipmentModelType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const EquipmentRelationsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.OrganicSuperiorHandle ())
      {
        o << ::std::endl << "OrganicSuperiorHandle: ";
        om.insert (o, *i.OrganicSuperiorHandle ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "HoldingOrganization: ";
      om.insert (o, i.HoldingOrganization ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EquipmentRelationsType >
  _xsd_EquipmentRelationsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const EquipmentSymbolModifiersType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Quantity ())
      {
        o << ::std::endl << "Quantity: ";
        om.insert (o, *i.Quantity ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.StaffComments ())
      {
        o << ::std::endl << "StaffComments: ";
        om.insert (o, *i.StaffComments ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        o << ::std::endl << "AdditionalInfo: ";
        om.insert (o, *i.AdditionalInfo ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.CombatEffectiveness ())
      {
        o << ::std::endl << "CombatEffectiveness: ";
        om.insert (o, *i.CombatEffectiveness ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.IFF ())
      {
        o << ::std::endl << "IFF: ";
        om.insert (o, *i.IFF ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "UniqueDesignation: ";
      om.insert (o, i.UniqueDesignation ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.EquipmentType ())
      {
        o << ::std::endl << "EquipmentType: ";
        om.insert (o, *i.EquipmentType ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.TowedSonarArray ())
      {
        o << ::std::endl << "TowedSonarArray: ";
        om.insert (o, *i.TowedSonarArray ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EquipmentSymbolModifiersType >
  _xsd_EquipmentSymbolModifiersType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const EquipmentType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (EquipmentType::EquipmentItem_const_iterator
           b (i.EquipmentItem ().begin ()), e (i.EquipmentItem ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "EquipmentItem: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EquipmentType >
  _xsd_EquipmentType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const ForceRelationDataType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.CommandRelation ())
      {
        o << ::std::endl << "CommandRelation: ";
        om.insert (o, *i.CommandRelation ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.ForceSideHandle ())
      {
        o << ::std::endl << "ForceSideHandle: ";
        om.insert (o, *i.ForceSideHandle ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ForceRelationDataType >
  _xsd_ForceRelationDataType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const ForceRelationType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ForceRelationChoice: ";
      om.insert (o, i.ForceRelationChoice ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ForceRelationData: ";
      om.insert (o, i.ForceRelationData ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ForceRelationType >
  _xsd_ForceRelationType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const ForceSidesType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (ForceSidesType::ForceSide_const_iterator
           b (i.ForceSide ().begin ()), e (i.ForceSide ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "ForceSide: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ForceSidesType >
  _xsd_ForceSidesType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const ForceSideType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ObjectHandle: ";
      om.insert (o, i.ObjectHandle ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ForceSideName: ";
      om.insert (o, i.ForceSideName ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AllegianceHandle ())
      {
        o << ::std::endl << "AllegianceHandle: ";
        om.insert (o, *i.AllegianceHandle ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.MilitaryService ())
      {
        o << ::std::endl << "MilitaryService: ";
        om.insert (o, *i.MilitaryService ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.CountryCode ())
      {
        o << ::std::endl << "CountryCode: ";
        om.insert (o, *i.CountryCode ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Associations ())
      {
        o << ::std::endl << "Associations: ";
        om.insert (o, *i.Associations ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ForceSideType >
  _xsd_ForceSideType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const FormationDataType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.GroundFormationType ())
      {
        o << ::std::endl << "GroundFormationType: ";
        om.insert (o, *i.GroundFormationType ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AirFormationType ())
      {
        o << ::std::endl << "AirFormationType: ";
        om.insert (o, *i.AirFormationType ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.SurfaceFomationType ())
      {
        o << ::std::endl << "SurfaceFomationType: ";
        om.insert (o, *i.SurfaceFomationType ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.SubsurfaceFormationType ())
      {
        o << ::std::endl << "SubsurfaceFormationType: ";
        om.insert (o, *i.SubsurfaceFormationType ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, FormationDataType >
  _xsd_FormationDataType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const FormationPositionType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.OutOfFormation ())
      {
        o << ::std::endl << "OutOfFormation: ";
        om.insert (o, *i.OutOfFormation ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.FormationOrder ())
      {
        o << ::std::endl << "FormationOrder: ";
        om.insert (o, *i.FormationOrder ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.SensorOrientation ())
      {
        o << ::std::endl << "SensorOrientation: ";
        om.insert (o, *i.SensorOrientation ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, FormationPositionType >
  _xsd_FormationPositionType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const GCCType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "X: ";
      om.insert (o, i.X ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Y: ";
      om.insert (o, i.Y ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Z: ";
      om.insert (o, i.Z ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, GCCType >
  _xsd_GCCType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const GDCType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Latitude: ";
      om.insert (o, i.Latitude ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Longitude: ";
      om.insert (o, i.Longitude ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ElevationAGL: ";
      om.insert (o, i.ElevationAGL ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, GDCType >
  _xsd_GDCType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const InstallationsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (InstallationsType::Installation_const_iterator
           b (i.Installation ().begin ()), e (i.Installation ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "Installation: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, InstallationsType >
  _xsd_InstallationsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const InstallationSymbolModifiersType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.FrameShapeModifier ())
      {
        o << ::std::endl << "FrameShapeModifier: ";
        om.insert (o, *i.FrameShapeModifier ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.StaffComments ())
      {
        o << ::std::endl << "StaffComments: ";
        om.insert (o, *i.StaffComments ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        o << ::std::endl << "AdditionalInfo: ";
        om.insert (o, *i.AdditionalInfo ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.CombatEffectiveness ())
      {
        o << ::std::endl << "CombatEffectiveness: ";
        om.insert (o, *i.CombatEffectiveness ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.IFF ())
      {
        o << ::std::endl << "IFF: ";
        om.insert (o, *i.IFF ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "UniqueDesignation: ";
      om.insert (o, i.UniqueDesignation ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        o << ::std::endl << "DateTimeGroup: ";
        om.insert (o, *i.DateTimeGroup ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, InstallationSymbolModifiersType >
  _xsd_InstallationSymbolModifiersType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const InstallationType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ObjectHandle: ";
      om.insert (o, i.ObjectHandle ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "SymbolIdentifier: ";
      om.insert (o, i.SymbolIdentifier ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Affiliation: ";
      om.insert (o, i.Affiliation ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Owner: ";
      om.insert (o, i.Owner ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Location: ";
      om.insert (o, i.Location ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Orientation ())
      {
        o << ::std::endl << "Orientation: ";
        om.insert (o, *i.Orientation ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Name ())
      {
        o << ::std::endl << "Name: ";
        om.insert (o, *i.Name ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.InstallationSymbolModifiers ())
      {
        o << ::std::endl << "InstallationSymbolModifiers: ";
        om.insert (o, *i.InstallationSymbolModifiers ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AssociatedOverlays ())
      {
        o << ::std::endl << "AssociatedOverlays: ";
        om.insert (o, *i.AssociatedOverlays ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, InstallationType >
  _xsd_InstallationType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const LightItemsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (LightItemsType::Light_const_iterator
           b (i.Light ().begin ()), e (i.Light ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "Light: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, LightItemsType >
  _xsd_LightItemsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const LineSymbolModifiersType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.UniqueDesignation ())
      {
        o << ::std::endl << "UniqueDesignation: ";
        om.insert (o, *i.UniqueDesignation ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.UniqueDesignation1 ())
      {
        o << ::std::endl << "UniqueDesignation1: ";
        om.insert (o, *i.UniqueDesignation1 ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        o << ::std::endl << "DateTimeGroup: ";
        om.insert (o, *i.DateTimeGroup ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DateTimeGroup1 ())
      {
        o << ::std::endl << "DateTimeGroup1: ";
        om.insert (o, *i.DateTimeGroup1 ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, LineSymbolModifiersType >
  _xsd_LineSymbolModifiersType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const METOCDispositionType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "AnchorPoints: ";
      om.insert (o, i.AnchorPoints ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DirectionOfMovement ())
      {
        o << ::std::endl << "DirectionOfMovement: ";
        om.insert (o, *i.DirectionOfMovement ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Speed ())
      {
        o << ::std::endl << "Speed: ";
        om.insert (o, *i.Speed ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, METOCDispositionType >
  _xsd_METOCDispositionType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const METOCGraphicType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ObjectHandle: ";
      om.insert (o, i.ObjectHandle ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "SymbolIdentifier: ";
      om.insert (o, i.SymbolIdentifier ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "UniqueDesignation: ";
      om.insert (o, i.UniqueDesignation ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        o << ::std::endl << "DateTimeGroup: ";
        om.insert (o, *i.DateTimeGroup ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DateTimeGroup1 ())
      {
        o << ::std::endl << "DateTimeGroup1: ";
        om.insert (o, *i.DateTimeGroup1 ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Quantity ())
      {
        o << ::std::endl << "Quantity: ";
        om.insert (o, *i.Quantity ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        o << ::std::endl << "AdditionalInfo: ";
        om.insert (o, *i.AdditionalInfo ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Disposition: ";
      om.insert (o, i.Disposition ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, METOCGraphicType >
  _xsd_METOCGraphicType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const METOCType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (METOCType::METOCGraphic_const_iterator
           b (i.METOCGraphic ().begin ()), e (i.METOCGraphic ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "METOCGraphic: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, METOCType >
  _xsd_METOCType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const MilitaryScenarioType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ScenarioID: ";
      om.insert (o, i.ScenarioID ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Options: ";
      om.insert (o, i.Options ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Environment ())
      {
        o << ::std::endl << "Environment: ";
        om.insert (o, *i.Environment ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ForceSides: ";
      om.insert (o, i.ForceSides ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Organizations ())
      {
        o << ::std::endl << "Organizations: ";
        om.insert (o, *i.Organizations ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Overlays ())
      {
        o << ::std::endl << "Overlays: ";
        om.insert (o, *i.Overlays ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Installations ())
      {
        o << ::std::endl << "Installations: ";
        om.insert (o, *i.Installations ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.TacticalGraphics ())
      {
        o << ::std::endl << "TacticalGraphics: ";
        om.insert (o, *i.TacticalGraphics ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.MOOTWGraphics ())
      {
        o << ::std::endl << "MOOTWGraphics: ";
        om.insert (o, *i.MOOTWGraphics ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, MilitaryScenarioType >
  _xsd_MilitaryScenarioType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const MGRSType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "MGRSGridZone: ";
      om.insert (o, i.MGRSGridZone ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "MGRSGridSquare: ";
      om.insert (o, i.MGRSGridSquare ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "MGRSPrecision: ";
      om.insert (o, i.MGRSPrecision ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "MGRSEasting: ";
      om.insert (o, i.MGRSEasting ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "MGRSNorthing: ";
      om.insert (o, i.MGRSNorthing ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.ElevationAGL ())
      {
        o << ::std::endl << "ElevationAGL: ";
        om.insert (o, *i.ElevationAGL ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, MGRSType >
  _xsd_MGRSType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const MOOTWDispositionType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Location: ";
      om.insert (o, i.Location ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DirectionOfMovement ())
      {
        o << ::std::endl << "DirectionOfMovement: ";
        om.insert (o, *i.DirectionOfMovement ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Speed ())
      {
        o << ::std::endl << "Speed: ";
        om.insert (o, *i.Speed ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, MOOTWDispositionType >
  _xsd_MOOTWDispositionType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const MOOTWGraphicsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (MOOTWGraphicsType::MOOTWGraphic_const_iterator
           b (i.MOOTWGraphic ().begin ()), e (i.MOOTWGraphic ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "MOOTWGraphic: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, MOOTWGraphicsType >
  _xsd_MOOTWGraphicsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const MOOTWGraphicType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ObjectHandle: ";
      om.insert (o, i.ObjectHandle ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "SymbolIdentifier: ";
      om.insert (o, i.SymbolIdentifier ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Affiliation: ";
      om.insert (o, i.Affiliation ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Owner: ";
      om.insert (o, i.Owner ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.MOOTWSymbolModifiers ())
      {
        o << ::std::endl << "MOOTWSymbolModifiers: ";
        om.insert (o, *i.MOOTWSymbolModifiers ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AssociatedOverlays ())
      {
        o << ::std::endl << "AssociatedOverlays: ";
        om.insert (o, *i.AssociatedOverlays ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Disposition: ";
      om.insert (o, i.Disposition ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, MOOTWGraphicType >
  _xsd_MOOTWGraphicType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const MOOTWSymbolModifiersType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Echelon ())
      {
        o << ::std::endl << "Echelon: ";
        om.insert (o, *i.Echelon ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.ReinforcedReduced ())
      {
        o << ::std::endl << "ReinforcedReduced: ";
        om.insert (o, *i.ReinforcedReduced ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.FrameShapeModifier ())
      {
        o << ::std::endl << "FrameShapeModifier: ";
        om.insert (o, *i.FrameShapeModifier ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.StaffComments ())
      {
        o << ::std::endl << "StaffComments: ";
        om.insert (o, *i.StaffComments ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        o << ::std::endl << "AdditionalInfo: ";
        om.insert (o, *i.AdditionalInfo ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.CombatEffectiveness ())
      {
        o << ::std::endl << "CombatEffectiveness: ";
        om.insert (o, *i.CombatEffectiveness ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.IFF ())
      {
        o << ::std::endl << "IFF: ";
        om.insert (o, *i.IFF ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "UniqueDesignation: ";
      om.insert (o, i.UniqueDesignation ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        o << ::std::endl << "DateTimeGroup: ";
        om.insert (o, *i.DateTimeGroup ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.SpecialC2HQ ())
      {
        o << ::std::endl << "SpecialC2HQ: ";
        om.insert (o, *i.SpecialC2HQ ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, MOOTWSymbolModifiersType >
  _xsd_MOOTWSymbolModifiersType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const NBCEventSymbolModifiersType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Quantity ())
      {
        o << ::std::endl << "Quantity: ";
        om.insert (o, *i.Quantity ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        o << ::std::endl << "AdditionalInfo: ";
        om.insert (o, *i.AdditionalInfo ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.UniqueDesignation ())
      {
        o << ::std::endl << "UniqueDesignation: ";
        om.insert (o, *i.UniqueDesignation ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.NBCType ())
      {
        o << ::std::endl << "NBCType: ";
        om.insert (o, *i.NBCType ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        o << ::std::endl << "DateTimeGroup: ";
        om.insert (o, *i.DateTimeGroup ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Speed: ";
      om.insert (o, i.Speed ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "DirectionOfMovement: ";
      om.insert (o, i.DirectionOfMovement ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, NBCEventSymbolModifiersType >
  _xsd_NBCEventSymbolModifiersType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const OptionsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "MSDLVersion: ";
      om.insert (o, i.MSDLVersion ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.OrganizationDetail ())
      {
        o << ::std::endl << "OrganizationDetail: ";
        om.insert (o, *i.OrganizationDetail ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.ScenarioDataStandards ())
      {
        o << ::std::endl << "ScenarioDataStandards: ";
        om.insert (o, *i.ScenarioDataStandards ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, OptionsType >
  _xsd_OptionsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const OrganicRelationDataType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.OrganicForceSideHandle ())
      {
        o << ::std::endl << "OrganicForceSideHandle: ";
        om.insert (o, *i.OrganicForceSideHandle ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.OrganicSuperiorHandle ())
      {
        o << ::std::endl << "OrganicSuperiorHandle: ";
        om.insert (o, *i.OrganicSuperiorHandle ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, OrganicRelationDataType >
  _xsd_OrganicRelationDataType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const OrganicRelationType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "OrganicRelationData: ";
      om.insert (o, i.OrganicRelationData ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "OrganicRelationChoice: ";
      om.insert (o, i.OrganicRelationChoice ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, OrganicRelationType >
  _xsd_OrganicRelationType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const OrganizationDetailType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "AggregateBased: ";
      om.insert (o, i.AggregateBased ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AggregateEchelon ())
      {
        o << ::std::endl << "AggregateEchelon: ";
        om.insert (o, *i.AggregateEchelon ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, OrganizationDetailType >
  _xsd_OrganizationDetailType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const OrganizationsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Units: ";
      om.insert (o, i.Units ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Equipment ())
      {
        o << ::std::endl << "Equipment: ";
        om.insert (o, *i.Equipment ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, OrganizationsType >
  _xsd_OrganizationsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const OverlayHandlesType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (OverlayHandlesType::OverlayHandle_const_iterator
           b (i.OverlayHandle ().begin ()), e (i.OverlayHandle ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "OverlayHandle: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, OverlayHandlesType >
  _xsd_OverlayHandlesType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const OverlaysType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (OverlaysType::Overlay_const_iterator
           b (i.Overlay ().begin ()), e (i.Overlay ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "Overlay: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, OverlaysType >
  _xsd_OverlaysType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const OverlayType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ObjectHandle: ";
      om.insert (o, i.ObjectHandle ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "OverlayType: ";
      om.insert (o, i.OverlayType1 ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "OverlayName: ";
      om.insert (o, i.OverlayName ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, OverlayType >
  _xsd_OverlayType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const OwnerType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "OwnerChoice: ";
      om.insert (o, i.OwnerChoice ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "OwnerData: ";
      om.insert (o, i.OwnerData ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, OwnerType >
  _xsd_OwnerType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const OwnerDataType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.UnitOwnerHandle ())
      {
        o << ::std::endl << "UnitOwnerHandle: ";
        om.insert (o, *i.UnitOwnerHandle ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.ForceOwnerHandle ())
      {
        o << ::std::endl << "ForceOwnerHandle: ";
        om.insert (o, *i.ForceOwnerHandle ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, OwnerDataType >
  _xsd_OwnerDataType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const OwnFormationType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "FormationLocationType: ";
      om.insert (o, i.FormationLocationType ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.FormationSpacing ())
      {
        o << ::std::endl << "FormationSpacing: ";
        om.insert (o, *i.FormationSpacing ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.FormationOrientation ())
      {
        o << ::std::endl << "FormationOrientation: ";
        om.insert (o, *i.FormationOrientation ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "FormationChoice: ";
      om.insert (o, i.FormationChoice ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "FormationData: ";
      om.insert (o, i.FormationData ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, OwnFormationType >
  _xsd_OwnFormationType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const PointSymbolModifiersType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        o << ::std::endl << "AdditionalInfo: ";
        om.insert (o, *i.AdditionalInfo ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AdditionalInfo1 ())
      {
        o << ::std::endl << "AdditionalInfo1: ";
        om.insert (o, *i.AdditionalInfo1 ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "UniqueDesignation: ";
      om.insert (o, i.UniqueDesignation ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        o << ::std::endl << "DateTimeGroup: ";
        om.insert (o, *i.DateTimeGroup ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DateTimeGroup1 ())
      {
        o << ::std::endl << "DateTimeGroup1: ";
        om.insert (o, *i.DateTimeGroup1 ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Orientation ())
      {
        o << ::std::endl << "Orientation: ";
        om.insert (o, *i.Orientation ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, PointSymbolModifiersType >
  _xsd_PointSymbolModifiersType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const RectangleAreaType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Name ())
      {
        o << ::std::endl << "Name: ";
        om.insert (o, *i.Name ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "UpperRight: ";
      om.insert (o, i.UpperRight ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "LowerLeft: ";
      om.insert (o, i.LowerLeft ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, RectangleAreaType >
  _xsd_RectangleAreaType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const ScenarioDataStandardsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "SymbologyDataStandard: ";
      om.insert (o, i.SymbologyDataStandard ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "CoordinateDataStandard: ";
      om.insert (o, i.CoordinateDataStandard ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ScenarioDataStandardsType >
  _xsd_ScenarioDataStandardsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const ScenarioWeatherType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Atmosphere ())
      {
        o << ::std::endl << "Atmosphere: ";
        om.insert (o, *i.Atmosphere ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.CloudCoverItems ())
      {
        o << ::std::endl << "CloudCoverItems: ";
        om.insert (o, *i.CloudCoverItems ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Icing ())
      {
        o << ::std::endl << "Icing: ";
        om.insert (o, *i.Icing ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.LightItems ())
      {
        o << ::std::endl << "LightItems: ";
        om.insert (o, *i.LightItems ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Precipitation ())
      {
        o << ::std::endl << "Precipitation: ";
        om.insert (o, *i.Precipitation ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.VisibilityItems ())
      {
        o << ::std::endl << "VisibilityItems: ";
        om.insert (o, *i.VisibilityItems ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.WindItems ())
      {
        o << ::std::endl << "WindItems: ";
        om.insert (o, *i.WindItems ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ScenarioWeatherType >
  _xsd_ScenarioWeatherType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const StatusType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.MOPPLevel ())
      {
        o << ::std::endl << "MOPPLevel: ";
        om.insert (o, *i.MOPPLevel ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.WeaponControlStatus ())
      {
        o << ::std::endl << "WeaponControlStatus: ";
        om.insert (o, *i.WeaponControlStatus ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, StatusType >
  _xsd_StatusType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const SupportRelationsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (SupportRelationsType::SupportRelation_const_iterator
           b (i.SupportRelation ().begin ()), e (i.SupportRelation ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "SupportRelation: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SupportRelationsType >
  _xsd_SupportRelationsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const SupportRelationType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "SupportedUnitHandle: ";
      om.insert (o, i.SupportedUnitHandle ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.PriorityToSupport ())
      {
        o << ::std::endl << "PriorityToSupport: ";
        om.insert (o, *i.PriorityToSupport ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "SupportType: ";
      om.insert (o, i.SupportType ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.SupportRoleType ())
      {
        o << ::std::endl << "SupportRoleType: ";
        om.insert (o, *i.SupportRoleType ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SupportRelationType >
  _xsd_SupportRelationType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const SymbolClassModifiersType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.PointSymbolModifiers ())
      {
        o << ::std::endl << "PointSymbolModifiers: ";
        om.insert (o, *i.PointSymbolModifiers ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.LineSymbolModifiers ())
      {
        o << ::std::endl << "LineSymbolModifiers: ";
        om.insert (o, *i.LineSymbolModifiers ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AreaSymbolModifiers ())
      {
        o << ::std::endl << "AreaSymbolModifiers: ";
        om.insert (o, *i.AreaSymbolModifiers ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.BoundarySymbolModifiers ())
      {
        o << ::std::endl << "BoundarySymbolModifiers: ";
        om.insert (o, *i.BoundarySymbolModifiers ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.NBCEventSymbolModifiers ())
      {
        o << ::std::endl << "NBCEventSymbolModifiers: ";
        om.insert (o, *i.NBCEventSymbolModifiers ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.TaskSymbolModifiers ())
      {
        o << ::std::endl << "TaskSymbolModifiers: ";
        om.insert (o, *i.TaskSymbolModifiers ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SymbolClassModifiersType >
  _xsd_SymbolClassModifiersType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const SymbologyDataStandardType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "StandardName: ";
      om.insert (o, i.StandardName ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "MajorVersion: ";
      om.insert (o, i.MajorVersion ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "MinorVersion: ";
      om.insert (o, i.MinorVersion ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SymbologyDataStandardType >
  _xsd_SymbologyDataStandardType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const TacticalGraphicsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (TacticalGraphicsType::TacticalGraphic_const_iterator
           b (i.TacticalGraphic ().begin ()), e (i.TacticalGraphic ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "TacticalGraphic: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, TacticalGraphicsType >
  _xsd_TacticalGraphicsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const TacticalGraphicType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ObjectHandle: ";
      om.insert (o, i.ObjectHandle ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "SymbolIdentifier: ";
      om.insert (o, i.SymbolIdentifier ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Affiliation: ";
      om.insert (o, i.Affiliation ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Owner: ";
      om.insert (o, i.Owner ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "AnchorPoints: ";
      om.insert (o, i.AnchorPoints ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AssociatedOverlays ())
      {
        o << ::std::endl << "AssociatedOverlays: ";
        om.insert (o, *i.AssociatedOverlays ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.SymbolClassData ())
      {
        o << ::std::endl << "SymbolClassData: ";
        om.insert (o, *i.SymbolClassData ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "SymbolClassChoice: ";
      om.insert (o, i.SymbolClassChoice ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, TacticalGraphicType >
  _xsd_TacticalGraphicType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const TaskSymbolModifiersType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.UniqueDesignation ())
      {
        o << ::std::endl << "UniqueDesignation: ";
        om.insert (o, *i.UniqueDesignation ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        o << ::std::endl << "DateTimeGroup: ";
        om.insert (o, *i.DateTimeGroup ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, TaskSymbolModifiersType >
  _xsd_TaskSymbolModifiersType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const UnitDispositionType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Location ())
      {
        o << ::std::endl << "Location: ";
        om.insert (o, *i.Location ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DirectionOfMovement ())
      {
        o << ::std::endl << "DirectionOfMovement: ";
        om.insert (o, *i.DirectionOfMovement ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Speed ())
      {
        o << ::std::endl << "Speed: ";
        om.insert (o, *i.Speed ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.FormationPosition ())
      {
        o << ::std::endl << "FormationPosition: ";
        om.insert (o, *i.FormationPosition ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.OwnFormation ())
      {
        o << ::std::endl << "OwnFormation: ";
        om.insert (o, *i.OwnFormation ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, UnitDispositionType >
  _xsd_UnitDispositionType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const UnitModelType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Resolution ())
      {
        o << ::std::endl << "Resolution: ";
        om.insert (o, *i.Resolution ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AggregateBased ())
      {
        o << ::std::endl << "AggregateBased: ";
        om.insert (o, *i.AggregateBased ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, UnitModelType >
  _xsd_UnitModelType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const UnitRelationsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ForceRelation: ";
      om.insert (o, i.ForceRelation ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.SupportRelations ())
      {
        o << ::std::endl << "SupportRelations: ";
        om.insert (o, *i.SupportRelations ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.OrganicRelation ())
      {
        o << ::std::endl << "OrganicRelation: ";
        om.insert (o, *i.OrganicRelation ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, UnitRelationsType >
  _xsd_UnitRelationsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const UnitsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (UnitsType::Unit_const_iterator
           b (i.Unit ().begin ()), e (i.Unit ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "Unit: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, UnitsType >
  _xsd_UnitsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const UnitSymbolModifiersType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Echelon ())
      {
        o << ::std::endl << "Echelon: ";
        om.insert (o, *i.Echelon ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.ReinforcedReduced ())
      {
        o << ::std::endl << "ReinforcedReduced: ";
        om.insert (o, *i.ReinforcedReduced ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.StaffComments ())
      {
        o << ::std::endl << "StaffComments: ";
        om.insert (o, *i.StaffComments ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        o << ::std::endl << "AdditionalInfo: ";
        om.insert (o, *i.AdditionalInfo ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.CombatEffectiveness ())
      {
        o << ::std::endl << "CombatEffectiveness: ";
        om.insert (o, *i.CombatEffectiveness ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.HigherFormation ())
      {
        o << ::std::endl << "HigherFormation: ";
        om.insert (o, *i.HigherFormation ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.IFF ())
      {
        o << ::std::endl << "IFF: ";
        om.insert (o, *i.IFF ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "UniqueDesignation: ";
      om.insert (o, i.UniqueDesignation ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.SpecialC2HQ ())
      {
        o << ::std::endl << "SpecialC2HQ: ";
        om.insert (o, *i.SpecialC2HQ ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, UnitSymbolModifiersType >
  _xsd_UnitSymbolModifiersType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const UnitType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "ObjectHandle: ";
      om.insert (o, i.ObjectHandle ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "SymbolIdentifier: ";
      om.insert (o, i.SymbolIdentifier ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Name ())
      {
        o << ::std::endl << "Name: ";
        om.insert (o, *i.Name ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.UnitSymbolModifiers ())
      {
        o << ::std::endl << "UnitSymbolModifiers: ";
        om.insert (o, *i.UnitSymbolModifiers ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.CommunicationNetInstances ())
      {
        o << ::std::endl << "CommunicationNetInstances: ";
        om.insert (o, *i.CommunicationNetInstances ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Status ())
      {
        o << ::std::endl << "Status: ";
        om.insert (o, *i.Status ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Disposition ())
      {
        o << ::std::endl << "Disposition: ";
        om.insert (o, *i.Disposition ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "Relations: ";
      om.insert (o, i.Relations ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Model ())
      {
        o << ::std::endl << "Model: ";
        om.insert (o, *i.Model ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, UnitType >
  _xsd_UnitType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const UTMType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "UTMGridZone: ";
      om.insert (o, i.UTMGridZone ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "UTMEasting: ";
      om.insert (o, i.UTMEasting ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "UTMNorthing: ";
      om.insert (o, i.UTMNorthing ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.ElevationAGL ())
      {
        o << ::std::endl << "ElevationAGL: ";
        om.insert (o, *i.ElevationAGL ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, UTMType >
  _xsd_UTMType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const VisibilityItemsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (VisibilityItemsType::Visibility_const_iterator
           b (i.Visibility ().begin ()), e (i.Visibility ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "Visibility: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, VisibilityItemsType >
  _xsd_VisibilityItemsType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const WindItemsType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (WindItemsType::Wind_const_iterator
           b (i.Wind ().begin ()), e (i.Wind ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "Wind: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, WindItemsType >
  _xsd_WindItemsType_std_ostream_init;
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace msdl_1
{
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace msdl_1
{
  void
  operator<< (::xercesc::DOMElement& e, const AnchorPointType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // AnchorChoice
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AnchorPointType::AnchorChoice_type& x (i.AnchorChoice ());
      if (typeid (AnchorPointType::AnchorChoice_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AnchorChoice",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "AnchorChoice",
          "",
          false, false, e, x);
    }

    // Anchor
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AnchorPointType::Anchor_type& x (i.Anchor ());
      if (typeid (AnchorPointType::Anchor_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Anchor",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Anchor",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AnchorPointType >
  _xsd_AnchorPointType_type_serializer_init (
    "AnchorPointType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const AnchorPointsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // AnchorPoint
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AnchorPointsType::AnchorPoint_const_iterator
           b (i.AnchorPoint ().begin ()), n (i.AnchorPoint ().end ());
           b != n; ++b)
      {
        if (typeid (AnchorPointsType::AnchorPoint_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AnchorPoint",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "AnchorPoint",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AnchorPointsType >
  _xsd_AnchorPointsType_type_serializer_init (
    "AnchorPointsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const AnchorType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Location
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Location ())
      {
        const AnchorType::Location_type& x (*i.Location ());
        if (typeid (AnchorType::Location_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Location",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Location",
            "",
            false, false, e, x);
      }
    }

    // PointSymbolHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.PointSymbolHandle ())
      {
        const AnchorType::PointSymbolHandle_type& x (*i.PointSymbolHandle ());
        if (typeid (AnchorType::PointSymbolHandle_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PointSymbolHandle",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "PointSymbolHandle",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AnchorType >
  _xsd_AnchorType_type_serializer_init (
    "AnchorType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const AreaSymbolModifiersType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Echelon
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Echelon ())
      {
        const AreaSymbolModifiersType::Echelon_type& x (*i.Echelon ());
        if (typeid (AreaSymbolModifiersType::Echelon_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Echelon",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Echelon",
            "",
            false, false, e, x);
      }
    }

    // AdditionalInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        const AreaSymbolModifiersType::AdditionalInfo_type& x (*i.AdditionalInfo ());
        if (typeid (AreaSymbolModifiersType::AdditionalInfo_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AdditionalInfo",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AdditionalInfo",
            "",
            false, false, e, x);
      }
    }

    // AdditionalInfo1
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AdditionalInfo1 ())
      {
        const AreaSymbolModifiersType::AdditionalInfo1_type& x (*i.AdditionalInfo1 ());
        if (typeid (AreaSymbolModifiersType::AdditionalInfo1_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AdditionalInfo1",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AdditionalInfo1",
            "",
            false, false, e, x);
      }
    }

    // AdditionalInfo2
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AdditionalInfo2 ())
      {
        const AreaSymbolModifiersType::AdditionalInfo2_type& x (*i.AdditionalInfo2 ());
        if (typeid (AreaSymbolModifiersType::AdditionalInfo2_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AdditionalInfo2",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AdditionalInfo2",
            "",
            false, false, e, x);
      }
    }

    // UniqueDesignation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.UniqueDesignation ())
      {
        const AreaSymbolModifiersType::UniqueDesignation_type& x (*i.UniqueDesignation ());
        if (typeid (AreaSymbolModifiersType::UniqueDesignation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UniqueDesignation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "UniqueDesignation",
            "",
            false, false, e, x);
      }
    }

    // DateTimeGroup
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        const AreaSymbolModifiersType::DateTimeGroup_type& x (*i.DateTimeGroup ());
        if (typeid (AreaSymbolModifiersType::DateTimeGroup_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DateTimeGroup",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DateTimeGroup",
            "",
            false, false, e, x);
      }
    }

    // DateTimeGroup1
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DateTimeGroup1 ())
      {
        const AreaSymbolModifiersType::DateTimeGroup1_type& x (*i.DateTimeGroup1 ());
        if (typeid (AreaSymbolModifiersType::DateTimeGroup1_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DateTimeGroup1",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DateTimeGroup1",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AreaSymbolModifiersType >
  _xsd_AreaSymbolModifiersType_type_serializer_init (
    "AreaSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const AssociatedOverlaysType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // OverlayHandles
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AssociatedOverlaysType::OverlayHandles_type& x (i.OverlayHandles ());
      if (typeid (AssociatedOverlaysType::OverlayHandles_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OverlayHandles",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "OverlayHandles",
          "",
          false, false, e, x);
    }

    // SourceOverlayType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.SourceOverlayType ())
      {
        const AssociatedOverlaysType::SourceOverlayType_type& x (*i.SourceOverlayType ());
        if (typeid (AssociatedOverlaysType::SourceOverlayType_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SourceOverlayType",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SourceOverlayType",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AssociatedOverlaysType >
  _xsd_AssociatedOverlaysType_type_serializer_init (
    "AssociatedOverlaysType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const AssociationsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Association
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AssociationsType::Association_const_iterator
           b (i.Association ().begin ()), n (i.Association ().end ());
           b != n; ++b)
      {
        if (typeid (AssociationsType::Association_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Association",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Association",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AssociationsType >
  _xsd_AssociationsType_type_serializer_init (
    "AssociationsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const AssociationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // AffiliateHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AssociationType::AffiliateHandle_type& x (i.AffiliateHandle ());
      if (typeid (AssociationType::AffiliateHandle_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AffiliateHandle",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "AffiliateHandle",
          "",
          false, false, e, x);
    }

    // Relationship
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AssociationType::Relationship_type& x (i.Relationship ());
      if (typeid (AssociationType::Relationship_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Relationship",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Relationship",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AssociationType >
  _xsd_AssociationType_type_serializer_init (
    "AssociationType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const BoundarySymbolModifiersType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Echelon
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Echelon ())
      {
        const BoundarySymbolModifiersType::Echelon_type& x (*i.Echelon ());
        if (typeid (BoundarySymbolModifiersType::Echelon_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Echelon",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Echelon",
            "",
            false, false, e, x);
      }
    }

    // UniqueDesignation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.UniqueDesignation ())
      {
        const BoundarySymbolModifiersType::UniqueDesignation_type& x (*i.UniqueDesignation ());
        if (typeid (BoundarySymbolModifiersType::UniqueDesignation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UniqueDesignation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "UniqueDesignation",
            "",
            false, false, e, x);
      }
    }

    // UniqueDesignation1
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.UniqueDesignation1 ())
      {
        const BoundarySymbolModifiersType::UniqueDesignation1_type& x (*i.UniqueDesignation1 ());
        if (typeid (BoundarySymbolModifiersType::UniqueDesignation1_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UniqueDesignation1",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "UniqueDesignation1",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BoundarySymbolModifiersType >
  _xsd_BoundarySymbolModifiersType_type_serializer_init (
    "BoundarySymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const CloudCoverItemsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CloudCover
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (CloudCoverItemsType::CloudCover_const_iterator
           b (i.CloudCover ().begin ()), n (i.CloudCover ().end ());
           b != n; ++b)
      {
        if (typeid (CloudCoverItemsType::CloudCover_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CloudCover",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "CloudCover",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CloudCoverItemsType >
  _xsd_CloudCoverItemsType_type_serializer_init (
    "CloudCoverItemsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const CommandRelationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CommandingSuperiorHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const CommandRelationType::CommandingSuperiorHandle_type& x (i.CommandingSuperiorHandle ());
      if (typeid (CommandRelationType::CommandingSuperiorHandle_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CommandingSuperiorHandle",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "CommandingSuperiorHandle",
          "",
          false, false, e, x);
    }

    // CommandRelationshipType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const CommandRelationType::CommandRelationshipType_type& x (i.CommandRelationshipType ());
      if (typeid (CommandRelationType::CommandRelationshipType_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CommandRelationshipType",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "CommandRelationshipType",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CommandRelationType >
  _xsd_CommandRelationType_type_serializer_init (
    "CommandRelationType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const CommunicationNetInstancesType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CommunicationNetInstance
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (CommunicationNetInstancesType::CommunicationNetInstance_const_iterator
           b (i.CommunicationNetInstance ().begin ()), n (i.CommunicationNetInstance ().end ());
           b != n; ++b)
      {
        if (typeid (CommunicationNetInstancesType::CommunicationNetInstance_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CommunicationNetInstance",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "CommunicationNetInstance",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CommunicationNetInstancesType >
  _xsd_CommunicationNetInstancesType_type_serializer_init (
    "CommunicationNetInstancesType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const CommunicationNetInstanceType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CommunicationNetType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CommunicationNetType ())
      {
        const CommunicationNetInstanceType::CommunicationNetType_type& x (*i.CommunicationNetType ());
        if (typeid (CommunicationNetInstanceType::CommunicationNetType_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CommunicationNetType",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CommunicationNetType",
            "",
            false, false, e, x);
      }
    }

    // CommunicationNetId
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const CommunicationNetInstanceType::CommunicationNetId_type& x (i.CommunicationNetId ());
      if (typeid (CommunicationNetInstanceType::CommunicationNetId_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CommunicationNetId",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "CommunicationNetId",
          "",
          false, false, e, x);
    }

    // CommunicationService
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const CommunicationNetInstanceType::CommunicationService_type& x (i.CommunicationService ());
      if (typeid (CommunicationNetInstanceType::CommunicationService_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CommunicationService",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "CommunicationService",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CommunicationNetInstanceType >
  _xsd_CommunicationNetInstanceType_type_serializer_init (
    "CommunicationNetInstanceType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const CommunicationNetReferencesType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CommunicationNetReference
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (CommunicationNetReferencesType::CommunicationNetReference_const_iterator
           b (i.CommunicationNetReference ().begin ()), n (i.CommunicationNetReference ().end ());
           b != n; ++b)
      {
        if (typeid (CommunicationNetReferencesType::CommunicationNetReference_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CommunicationNetReference",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "CommunicationNetReference",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CommunicationNetReferencesType >
  _xsd_CommunicationNetReferencesType_type_serializer_init (
    "CommunicationNetReferencesType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const CommunicationNetReferenceType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CommunicationNetId
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const CommunicationNetReferenceType::CommunicationNetId_type& x (i.CommunicationNetId ());
      if (typeid (CommunicationNetReferenceType::CommunicationNetId_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CommunicationNetId",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "CommunicationNetId",
          "",
          false, false, e, x);
    }

    // UnitOwnerHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const CommunicationNetReferenceType::UnitOwnerHandle_type& x (i.UnitOwnerHandle ());
      if (typeid (CommunicationNetReferenceType::UnitOwnerHandle_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitOwnerHandle",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "UnitOwnerHandle",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CommunicationNetReferenceType >
  _xsd_CommunicationNetReferenceType_type_serializer_init (
    "CommunicationNetReferenceType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const CoordinateDataStandardType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CoordinateSystemType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const CoordinateDataStandardType::CoordinateSystemType_type& x (i.CoordinateSystemType ());
      if (typeid (CoordinateDataStandardType::CoordinateSystemType_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoordinateSystemType",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "CoordinateSystemType",
          "",
          false, false, e, x);
    }

    // CoordinateSystemDatum
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const CoordinateDataStandardType::CoordinateSystemDatum_type& x (i.CoordinateSystemDatum ());
      if (typeid (CoordinateDataStandardType::CoordinateSystemDatum_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoordinateSystemDatum",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "CoordinateSystemDatum",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CoordinateDataStandardType >
  _xsd_CoordinateDataStandardType_type_serializer_init (
    "CoordinateDataStandardType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const CoordinatesType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CoordinateChoice
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const CoordinatesType::CoordinateChoice_type& x (i.CoordinateChoice ());
      if (typeid (CoordinatesType::CoordinateChoice_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoordinateChoice",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "CoordinateChoice",
          "",
          false, false, e, x);
    }

    // CoordinateData
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const CoordinatesType::CoordinateData_type& x (i.CoordinateData ());
      if (typeid (CoordinatesType::CoordinateData_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoordinateData",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "CoordinateData",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CoordinatesType >
  _xsd_CoordinatesType_type_serializer_init (
    "CoordinatesType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const CoordinatePointType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // MGRS
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MGRS ())
      {
        const CoordinatePointType::MGRS_type& x (*i.MGRS ());
        if (typeid (CoordinatePointType::MGRS_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MGRS",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MGRS",
            "",
            false, false, e, x);
      }
    }

    // UTM
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.UTM ())
      {
        const CoordinatePointType::UTM_type& x (*i.UTM ());
        if (typeid (CoordinatePointType::UTM_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UTM",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "UTM",
            "",
            false, false, e, x);
      }
    }

    // GDC
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.GDC ())
      {
        const CoordinatePointType::GDC_type& x (*i.GDC ());
        if (typeid (CoordinatePointType::GDC_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "GDC",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "GDC",
            "",
            false, false, e, x);
      }
    }

    // GCC
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.GCC ())
      {
        const CoordinatePointType::GCC_type& x (*i.GCC ());
        if (typeid (CoordinatePointType::GCC_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "GCC",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "GCC",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CoordinatePointType >
  _xsd_CoordinatePointType_type_serializer_init (
    "CoordinatePointType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const EnvironmentType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ScenarioTime
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ScenarioTime ())
      {
        const EnvironmentType::ScenarioTime_type& x (*i.ScenarioTime ());
        if (typeid (EnvironmentType::ScenarioTime_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ScenarioTime",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ScenarioTime",
            "",
            false, false, e, x);
      }
    }

    // AreaOfInterest
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AreaOfInterest ())
      {
        const EnvironmentType::AreaOfInterest_type& x (*i.AreaOfInterest ());
        if (typeid (EnvironmentType::AreaOfInterest_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AreaOfInterest",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AreaOfInterest",
            "",
            false, false, e, x);
      }
    }

    // ScenarioWeather
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ScenarioWeather ())
      {
        const EnvironmentType::ScenarioWeather_type& x (*i.ScenarioWeather ());
        if (typeid (EnvironmentType::ScenarioWeather_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ScenarioWeather",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ScenarioWeather",
            "",
            false, false, e, x);
      }
    }

    // METOC
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.METOC ())
      {
        const EnvironmentType::METOC_type& x (*i.METOC ());
        if (typeid (EnvironmentType::METOC_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "METOC",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "METOC",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnvironmentType >
  _xsd_EnvironmentType_type_serializer_init (
    "EnvironmentType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const EquipmentDispositionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Location
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const EquipmentDispositionType::Location_type& x (i.Location ());
      if (typeid (EquipmentDispositionType::Location_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Location",
          "",
          false, false, e, x);
    }

    // DirectionOfMovement
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DirectionOfMovement ())
      {
        const EquipmentDispositionType::DirectionOfMovement_type& x (*i.DirectionOfMovement ());
        if (typeid (EquipmentDispositionType::DirectionOfMovement_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DirectionOfMovement",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DirectionOfMovement",
            "",
            false, false, e, x);
      }
    }

    // Speed
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Speed ())
      {
        const EquipmentDispositionType::Speed_type& x (*i.Speed ());
        if (typeid (EquipmentDispositionType::Speed_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Speed",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Speed",
            "",
            false, false, e, x);
      }
    }

    // FormationPosition
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.FormationPosition ())
      {
        const EquipmentDispositionType::FormationPosition_type& x (*i.FormationPosition ());
        if (typeid (EquipmentDispositionType::FormationPosition_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "FormationPosition",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "FormationPosition",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EquipmentDispositionType >
  _xsd_EquipmentDispositionType_type_serializer_init (
    "EquipmentDispositionType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const EquipmentItemType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ObjectHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const EquipmentItemType::ObjectHandle_type& x (i.ObjectHandle ());
      if (typeid (EquipmentItemType::ObjectHandle_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ObjectHandle",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ObjectHandle",
          "",
          false, false, e, x);
    }

    // SymbolIdentifier
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const EquipmentItemType::SymbolIdentifier_type& x (i.SymbolIdentifier ());
      if (typeid (EquipmentItemType::SymbolIdentifier_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SymbolIdentifier",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SymbolIdentifier",
          "",
          false, false, e, x);
    }

    // Name
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Name ())
      {
        const EquipmentItemType::Name_type& x (*i.Name ());
        if (typeid (EquipmentItemType::Name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Name",
            "",
            false, false, e, x);
      }
    }

    // EquipmentSymbolModifiers
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.EquipmentSymbolModifiers ())
      {
        const EquipmentItemType::EquipmentSymbolModifiers_type& x (*i.EquipmentSymbolModifiers ());
        if (typeid (EquipmentItemType::EquipmentSymbolModifiers_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EquipmentSymbolModifiers",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EquipmentSymbolModifiers",
            "",
            false, false, e, x);
      }
    }

    // CommunicationNetReferences
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CommunicationNetReferences ())
      {
        const EquipmentItemType::CommunicationNetReferences_type& x (*i.CommunicationNetReferences ());
        if (typeid (EquipmentItemType::CommunicationNetReferences_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CommunicationNetReferences",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CommunicationNetReferences",
            "",
            false, false, e, x);
      }
    }

    // Disposition
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const EquipmentItemType::Disposition_type& x (i.Disposition ());
      if (typeid (EquipmentItemType::Disposition_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Disposition",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Disposition",
          "",
          false, false, e, x);
    }

    // Relations
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const EquipmentItemType::Relations_type& x (i.Relations ());
      if (typeid (EquipmentItemType::Relations_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Relations",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Relations",
          "",
          false, false, e, x);
    }

    // Model
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Model ())
      {
        const EquipmentItemType::Model_type& x (*i.Model ());
        if (typeid (EquipmentItemType::Model_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Model",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Model",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EquipmentItemType >
  _xsd_EquipmentItemType_type_serializer_init (
    "EquipmentItemType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const EquipmentModelType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Resolution
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const EquipmentModelType::Resolution_type& x (i.Resolution ());
      if (typeid (EquipmentModelType::Resolution_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Resolution",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Resolution",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EquipmentModelType >
  _xsd_EquipmentModelType_type_serializer_init (
    "EquipmentModelType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const EquipmentRelationsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // OrganicSuperiorHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.OrganicSuperiorHandle ())
      {
        const EquipmentRelationsType::OrganicSuperiorHandle_type& x (*i.OrganicSuperiorHandle ());
        if (typeid (EquipmentRelationsType::OrganicSuperiorHandle_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OrganicSuperiorHandle",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "OrganicSuperiorHandle",
            "",
            false, false, e, x);
      }
    }

    // HoldingOrganization
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const EquipmentRelationsType::HoldingOrganization_type& x (i.HoldingOrganization ());
      if (typeid (EquipmentRelationsType::HoldingOrganization_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "HoldingOrganization",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "HoldingOrganization",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EquipmentRelationsType >
  _xsd_EquipmentRelationsType_type_serializer_init (
    "EquipmentRelationsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const EquipmentSymbolModifiersType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Quantity
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Quantity ())
      {
        const EquipmentSymbolModifiersType::Quantity_type& x (*i.Quantity ());
        if (typeid (EquipmentSymbolModifiersType::Quantity_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Quantity",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Quantity",
            "",
            false, false, e, x);
      }
    }

    // StaffComments
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.StaffComments ())
      {
        const EquipmentSymbolModifiersType::StaffComments_type& x (*i.StaffComments ());
        if (typeid (EquipmentSymbolModifiersType::StaffComments_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "StaffComments",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "StaffComments",
            "",
            false, false, e, x);
      }
    }

    // AdditionalInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        const EquipmentSymbolModifiersType::AdditionalInfo_type& x (*i.AdditionalInfo ());
        if (typeid (EquipmentSymbolModifiersType::AdditionalInfo_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AdditionalInfo",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AdditionalInfo",
            "",
            false, false, e, x);
      }
    }

    // CombatEffectiveness
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CombatEffectiveness ())
      {
        const EquipmentSymbolModifiersType::CombatEffectiveness_type& x (*i.CombatEffectiveness ());
        if (typeid (EquipmentSymbolModifiersType::CombatEffectiveness_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CombatEffectiveness",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CombatEffectiveness",
            "",
            false, false, e, x);
      }
    }

    // IFF
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.IFF ())
      {
        const EquipmentSymbolModifiersType::IFF_type& x (*i.IFF ());
        if (typeid (EquipmentSymbolModifiersType::IFF_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "IFF",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "IFF",
            "",
            false, false, e, x);
      }
    }

    // UniqueDesignation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const EquipmentSymbolModifiersType::UniqueDesignation_type& x (i.UniqueDesignation ());
      if (typeid (EquipmentSymbolModifiersType::UniqueDesignation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UniqueDesignation",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "UniqueDesignation",
          "",
          false, false, e, x);
    }

    // EquipmentType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.EquipmentType ())
      {
        const EquipmentSymbolModifiersType::EquipmentType_type& x (*i.EquipmentType ());
        if (typeid (EquipmentSymbolModifiersType::EquipmentType_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EquipmentType",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EquipmentType",
            "",
            false, false, e, x);
      }
    }

    // TowedSonarArray
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.TowedSonarArray ())
      {
        const EquipmentSymbolModifiersType::TowedSonarArray_type& x (*i.TowedSonarArray ());
        if (typeid (EquipmentSymbolModifiersType::TowedSonarArray_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TowedSonarArray",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "TowedSonarArray",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EquipmentSymbolModifiersType >
  _xsd_EquipmentSymbolModifiersType_type_serializer_init (
    "EquipmentSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const EquipmentType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // EquipmentItem
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (EquipmentType::EquipmentItem_const_iterator
           b (i.EquipmentItem ().begin ()), n (i.EquipmentItem ().end ());
           b != n; ++b)
      {
        if (typeid (EquipmentType::EquipmentItem_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EquipmentItem",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "EquipmentItem",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EquipmentType >
  _xsd_EquipmentType_type_serializer_init (
    "EquipmentType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const ForceRelationDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CommandRelation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CommandRelation ())
      {
        const ForceRelationDataType::CommandRelation_type& x (*i.CommandRelation ());
        if (typeid (ForceRelationDataType::CommandRelation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CommandRelation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CommandRelation",
            "",
            false, false, e, x);
      }
    }

    // ForceSideHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ForceSideHandle ())
      {
        const ForceRelationDataType::ForceSideHandle_type& x (*i.ForceSideHandle ());
        if (typeid (ForceRelationDataType::ForceSideHandle_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ForceSideHandle",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ForceSideHandle",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ForceRelationDataType >
  _xsd_ForceRelationDataType_type_serializer_init (
    "ForceRelationDataType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const ForceRelationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ForceRelationChoice
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ForceRelationType::ForceRelationChoice_type& x (i.ForceRelationChoice ());
      if (typeid (ForceRelationType::ForceRelationChoice_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ForceRelationChoice",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ForceRelationChoice",
          "",
          false, false, e, x);
    }

    // ForceRelationData
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ForceRelationType::ForceRelationData_type& x (i.ForceRelationData ());
      if (typeid (ForceRelationType::ForceRelationData_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ForceRelationData",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ForceRelationData",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ForceRelationType >
  _xsd_ForceRelationType_type_serializer_init (
    "ForceRelationType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const ForceSidesType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ForceSide
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ForceSidesType::ForceSide_const_iterator
           b (i.ForceSide ().begin ()), n (i.ForceSide ().end ());
           b != n; ++b)
      {
        if (typeid (ForceSidesType::ForceSide_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ForceSide",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ForceSide",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ForceSidesType >
  _xsd_ForceSidesType_type_serializer_init (
    "ForceSidesType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const ForceSideType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ObjectHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ForceSideType::ObjectHandle_type& x (i.ObjectHandle ());
      if (typeid (ForceSideType::ObjectHandle_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ObjectHandle",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ObjectHandle",
          "",
          false, false, e, x);
    }

    // ForceSideName
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ForceSideType::ForceSideName_type& x (i.ForceSideName ());
      if (typeid (ForceSideType::ForceSideName_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ForceSideName",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ForceSideName",
          "",
          false, false, e, x);
    }

    // AllegianceHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AllegianceHandle ())
      {
        const ForceSideType::AllegianceHandle_type& x (*i.AllegianceHandle ());
        if (typeid (ForceSideType::AllegianceHandle_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AllegianceHandle",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AllegianceHandle",
            "",
            false, false, e, x);
      }
    }

    // MilitaryService
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MilitaryService ())
      {
        const ForceSideType::MilitaryService_type& x (*i.MilitaryService ());
        if (typeid (ForceSideType::MilitaryService_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MilitaryService",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MilitaryService",
            "",
            false, false, e, x);
      }
    }

    // CountryCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CountryCode ())
      {
        const ForceSideType::CountryCode_type& x (*i.CountryCode ());
        if (typeid (ForceSideType::CountryCode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CountryCode",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CountryCode",
            "",
            false, false, e, x);
      }
    }

    // Associations
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Associations ())
      {
        const ForceSideType::Associations_type& x (*i.Associations ());
        if (typeid (ForceSideType::Associations_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Associations",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Associations",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ForceSideType >
  _xsd_ForceSideType_type_serializer_init (
    "ForceSideType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const FormationDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // GroundFormationType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.GroundFormationType ())
      {
        const FormationDataType::GroundFormationType_type& x (*i.GroundFormationType ());
        if (typeid (FormationDataType::GroundFormationType_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "GroundFormationType",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "GroundFormationType",
            "",
            false, false, e, x);
      }
    }

    // AirFormationType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AirFormationType ())
      {
        const FormationDataType::AirFormationType_type& x (*i.AirFormationType ());
        if (typeid (FormationDataType::AirFormationType_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AirFormationType",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AirFormationType",
            "",
            false, false, e, x);
      }
    }

    // SurfaceFomationType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.SurfaceFomationType ())
      {
        const FormationDataType::SurfaceFomationType_type& x (*i.SurfaceFomationType ());
        if (typeid (FormationDataType::SurfaceFomationType_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SurfaceFomationType",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SurfaceFomationType",
            "",
            false, false, e, x);
      }
    }

    // SubsurfaceFormationType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.SubsurfaceFormationType ())
      {
        const FormationDataType::SubsurfaceFormationType_type& x (*i.SubsurfaceFormationType ());
        if (typeid (FormationDataType::SubsurfaceFormationType_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SubsurfaceFormationType",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SubsurfaceFormationType",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FormationDataType >
  _xsd_FormationDataType_type_serializer_init (
    "FormationDataType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const FormationPositionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // OutOfFormation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.OutOfFormation ())
      {
        const FormationPositionType::OutOfFormation_type& x (*i.OutOfFormation ());
        if (typeid (FormationPositionType::OutOfFormation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OutOfFormation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "OutOfFormation",
            "",
            false, false, e, x);
      }
    }

    // FormationOrder
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.FormationOrder ())
      {
        const FormationPositionType::FormationOrder_type& x (*i.FormationOrder ());
        if (typeid (FormationPositionType::FormationOrder_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "FormationOrder",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "FormationOrder",
            "",
            false, false, e, x);
      }
    }

    // SensorOrientation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.SensorOrientation ())
      {
        const FormationPositionType::SensorOrientation_type& x (*i.SensorOrientation ());
        if (typeid (FormationPositionType::SensorOrientation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SensorOrientation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SensorOrientation",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FormationPositionType >
  _xsd_FormationPositionType_type_serializer_init (
    "FormationPositionType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const GCCType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // X
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const GCCType::X_type& x (i.X ());
      if (typeid (GCCType::X_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "X",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "X",
          "",
          false, false, e, x);
    }

    // Y
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const GCCType::Y_type& x (i.Y ());
      if (typeid (GCCType::Y_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Y",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Y",
          "",
          false, false, e, x);
    }

    // Z
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const GCCType::Z_type& x (i.Z ());
      if (typeid (GCCType::Z_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Z",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Z",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GCCType >
  _xsd_GCCType_type_serializer_init (
    "GCCType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const GDCType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Latitude
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const GDCType::Latitude_type& x (i.Latitude ());
      if (typeid (GDCType::Latitude_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Latitude",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Latitude",
          "",
          false, false, e, x);
    }

    // Longitude
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const GDCType::Longitude_type& x (i.Longitude ());
      if (typeid (GDCType::Longitude_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Longitude",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Longitude",
          "",
          false, false, e, x);
    }

    // ElevationAGL
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const GDCType::ElevationAGL_type& x (i.ElevationAGL ());
      if (typeid (GDCType::ElevationAGL_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ElevationAGL",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ElevationAGL",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GDCType >
  _xsd_GDCType_type_serializer_init (
    "GDCType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const InstallationsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Installation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (InstallationsType::Installation_const_iterator
           b (i.Installation ().begin ()), n (i.Installation ().end ());
           b != n; ++b)
      {
        if (typeid (InstallationsType::Installation_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Installation",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Installation",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InstallationsType >
  _xsd_InstallationsType_type_serializer_init (
    "InstallationsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const InstallationSymbolModifiersType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // FrameShapeModifier
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.FrameShapeModifier ())
      {
        const InstallationSymbolModifiersType::FrameShapeModifier_type& x (*i.FrameShapeModifier ());
        if (typeid (InstallationSymbolModifiersType::FrameShapeModifier_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "FrameShapeModifier",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "FrameShapeModifier",
            "",
            false, false, e, x);
      }
    }

    // StaffComments
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.StaffComments ())
      {
        const InstallationSymbolModifiersType::StaffComments_type& x (*i.StaffComments ());
        if (typeid (InstallationSymbolModifiersType::StaffComments_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "StaffComments",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "StaffComments",
            "",
            false, false, e, x);
      }
    }

    // AdditionalInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        const InstallationSymbolModifiersType::AdditionalInfo_type& x (*i.AdditionalInfo ());
        if (typeid (InstallationSymbolModifiersType::AdditionalInfo_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AdditionalInfo",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AdditionalInfo",
            "",
            false, false, e, x);
      }
    }

    // CombatEffectiveness
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CombatEffectiveness ())
      {
        const InstallationSymbolModifiersType::CombatEffectiveness_type& x (*i.CombatEffectiveness ());
        if (typeid (InstallationSymbolModifiersType::CombatEffectiveness_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CombatEffectiveness",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CombatEffectiveness",
            "",
            false, false, e, x);
      }
    }

    // IFF
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.IFF ())
      {
        const InstallationSymbolModifiersType::IFF_type& x (*i.IFF ());
        if (typeid (InstallationSymbolModifiersType::IFF_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "IFF",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "IFF",
            "",
            false, false, e, x);
      }
    }

    // UniqueDesignation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const InstallationSymbolModifiersType::UniqueDesignation_type& x (i.UniqueDesignation ());
      if (typeid (InstallationSymbolModifiersType::UniqueDesignation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UniqueDesignation",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "UniqueDesignation",
          "",
          false, false, e, x);
    }

    // DateTimeGroup
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        const InstallationSymbolModifiersType::DateTimeGroup_type& x (*i.DateTimeGroup ());
        if (typeid (InstallationSymbolModifiersType::DateTimeGroup_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DateTimeGroup",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DateTimeGroup",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InstallationSymbolModifiersType >
  _xsd_InstallationSymbolModifiersType_type_serializer_init (
    "InstallationSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const InstallationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ObjectHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const InstallationType::ObjectHandle_type& x (i.ObjectHandle ());
      if (typeid (InstallationType::ObjectHandle_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ObjectHandle",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ObjectHandle",
          "",
          false, false, e, x);
    }

    // SymbolIdentifier
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const InstallationType::SymbolIdentifier_type& x (i.SymbolIdentifier ());
      if (typeid (InstallationType::SymbolIdentifier_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SymbolIdentifier",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SymbolIdentifier",
          "",
          false, false, e, x);
    }

    // Affiliation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const InstallationType::Affiliation_type& x (i.Affiliation ());
      if (typeid (InstallationType::Affiliation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Affiliation",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Affiliation",
          "",
          false, false, e, x);
    }

    // Owner
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const InstallationType::Owner_type& x (i.Owner ());
      if (typeid (InstallationType::Owner_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Owner",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Owner",
          "",
          false, false, e, x);
    }

    // Location
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const InstallationType::Location_type& x (i.Location ());
      if (typeid (InstallationType::Location_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Location",
          "",
          false, false, e, x);
    }

    // Orientation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Orientation ())
      {
        const InstallationType::Orientation_type& x (*i.Orientation ());
        if (typeid (InstallationType::Orientation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Orientation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Orientation",
            "",
            false, false, e, x);
      }
    }

    // Name
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Name ())
      {
        const InstallationType::Name_type& x (*i.Name ());
        if (typeid (InstallationType::Name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Name",
            "",
            false, false, e, x);
      }
    }

    // InstallationSymbolModifiers
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.InstallationSymbolModifiers ())
      {
        const InstallationType::InstallationSymbolModifiers_type& x (*i.InstallationSymbolModifiers ());
        if (typeid (InstallationType::InstallationSymbolModifiers_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "InstallationSymbolModifiers",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "InstallationSymbolModifiers",
            "",
            false, false, e, x);
      }
    }

    // AssociatedOverlays
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AssociatedOverlays ())
      {
        const InstallationType::AssociatedOverlays_type& x (*i.AssociatedOverlays ());
        if (typeid (InstallationType::AssociatedOverlays_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AssociatedOverlays",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AssociatedOverlays",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InstallationType >
  _xsd_InstallationType_type_serializer_init (
    "InstallationType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const LightItemsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Light
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (LightItemsType::Light_const_iterator
           b (i.Light ().begin ()), n (i.Light ().end ());
           b != n; ++b)
      {
        if (typeid (LightItemsType::Light_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Light",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Light",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LightItemsType >
  _xsd_LightItemsType_type_serializer_init (
    "LightItemsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const LineSymbolModifiersType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // UniqueDesignation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.UniqueDesignation ())
      {
        const LineSymbolModifiersType::UniqueDesignation_type& x (*i.UniqueDesignation ());
        if (typeid (LineSymbolModifiersType::UniqueDesignation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UniqueDesignation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "UniqueDesignation",
            "",
            false, false, e, x);
      }
    }

    // UniqueDesignation1
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.UniqueDesignation1 ())
      {
        const LineSymbolModifiersType::UniqueDesignation1_type& x (*i.UniqueDesignation1 ());
        if (typeid (LineSymbolModifiersType::UniqueDesignation1_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UniqueDesignation1",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "UniqueDesignation1",
            "",
            false, false, e, x);
      }
    }

    // DateTimeGroup
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        const LineSymbolModifiersType::DateTimeGroup_type& x (*i.DateTimeGroup ());
        if (typeid (LineSymbolModifiersType::DateTimeGroup_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DateTimeGroup",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DateTimeGroup",
            "",
            false, false, e, x);
      }
    }

    // DateTimeGroup1
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DateTimeGroup1 ())
      {
        const LineSymbolModifiersType::DateTimeGroup1_type& x (*i.DateTimeGroup1 ());
        if (typeid (LineSymbolModifiersType::DateTimeGroup1_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DateTimeGroup1",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DateTimeGroup1",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LineSymbolModifiersType >
  _xsd_LineSymbolModifiersType_type_serializer_init (
    "LineSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const METOCDispositionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // AnchorPoints
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const METOCDispositionType::AnchorPoints_type& x (i.AnchorPoints ());
      if (typeid (METOCDispositionType::AnchorPoints_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AnchorPoints",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "AnchorPoints",
          "",
          false, false, e, x);
    }

    // DirectionOfMovement
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DirectionOfMovement ())
      {
        const METOCDispositionType::DirectionOfMovement_type& x (*i.DirectionOfMovement ());
        if (typeid (METOCDispositionType::DirectionOfMovement_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DirectionOfMovement",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DirectionOfMovement",
            "",
            false, false, e, x);
      }
    }

    // Speed
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Speed ())
      {
        const METOCDispositionType::Speed_type& x (*i.Speed ());
        if (typeid (METOCDispositionType::Speed_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Speed",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Speed",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, METOCDispositionType >
  _xsd_METOCDispositionType_type_serializer_init (
    "METOCDispositionType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const METOCGraphicType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ObjectHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const METOCGraphicType::ObjectHandle_type& x (i.ObjectHandle ());
      if (typeid (METOCGraphicType::ObjectHandle_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ObjectHandle",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ObjectHandle",
          "",
          false, false, e, x);
    }

    // SymbolIdentifier
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const METOCGraphicType::SymbolIdentifier_type& x (i.SymbolIdentifier ());
      if (typeid (METOCGraphicType::SymbolIdentifier_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SymbolIdentifier",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SymbolIdentifier",
          "",
          false, false, e, x);
    }

    // UniqueDesignation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const METOCGraphicType::UniqueDesignation_type& x (i.UniqueDesignation ());
      if (typeid (METOCGraphicType::UniqueDesignation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UniqueDesignation",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "UniqueDesignation",
          "",
          false, false, e, x);
    }

    // DateTimeGroup
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        const METOCGraphicType::DateTimeGroup_type& x (*i.DateTimeGroup ());
        if (typeid (METOCGraphicType::DateTimeGroup_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DateTimeGroup",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DateTimeGroup",
            "",
            false, false, e, x);
      }
    }

    // DateTimeGroup1
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DateTimeGroup1 ())
      {
        const METOCGraphicType::DateTimeGroup1_type& x (*i.DateTimeGroup1 ());
        if (typeid (METOCGraphicType::DateTimeGroup1_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DateTimeGroup1",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DateTimeGroup1",
            "",
            false, false, e, x);
      }
    }

    // Quantity
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Quantity ())
      {
        const METOCGraphicType::Quantity_type& x (*i.Quantity ());
        if (typeid (METOCGraphicType::Quantity_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Quantity",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Quantity",
            "",
            false, false, e, x);
      }
    }

    // AdditionalInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        const METOCGraphicType::AdditionalInfo_type& x (*i.AdditionalInfo ());
        if (typeid (METOCGraphicType::AdditionalInfo_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AdditionalInfo",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AdditionalInfo",
            "",
            false, false, e, x);
      }
    }

    // Disposition
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const METOCGraphicType::Disposition_type& x (i.Disposition ());
      if (typeid (METOCGraphicType::Disposition_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Disposition",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Disposition",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, METOCGraphicType >
  _xsd_METOCGraphicType_type_serializer_init (
    "METOCGraphicType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const METOCType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // METOCGraphic
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (METOCType::METOCGraphic_const_iterator
           b (i.METOCGraphic ().begin ()), n (i.METOCGraphic ().end ());
           b != n; ++b)
      {
        if (typeid (METOCType::METOCGraphic_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "METOCGraphic",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "METOCGraphic",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, METOCType >
  _xsd_METOCType_type_serializer_init (
    "METOCType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const MilitaryScenarioType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ScenarioID
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MilitaryScenarioType::ScenarioID_type& x (i.ScenarioID ());
      if (typeid (MilitaryScenarioType::ScenarioID_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ScenarioID",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ScenarioID",
          "",
          false, false, e, x);
    }

    // Options
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MilitaryScenarioType::Options_type& x (i.Options ());
      if (typeid (MilitaryScenarioType::Options_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Options",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Options",
          "",
          false, false, e, x);
    }

    // Environment
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Environment ())
      {
        const MilitaryScenarioType::Environment_type& x (*i.Environment ());
        if (typeid (MilitaryScenarioType::Environment_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Environment",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Environment",
            "",
            false, false, e, x);
      }
    }

    // ForceSides
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MilitaryScenarioType::ForceSides_type& x (i.ForceSides ());
      if (typeid (MilitaryScenarioType::ForceSides_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ForceSides",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ForceSides",
          "",
          false, false, e, x);
    }

    // Organizations
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Organizations ())
      {
        const MilitaryScenarioType::Organizations_type& x (*i.Organizations ());
        if (typeid (MilitaryScenarioType::Organizations_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Organizations",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Organizations",
            "",
            false, false, e, x);
      }
    }

    // Overlays
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Overlays ())
      {
        const MilitaryScenarioType::Overlays_type& x (*i.Overlays ());
        if (typeid (MilitaryScenarioType::Overlays_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Overlays",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Overlays",
            "",
            false, false, e, x);
      }
    }

    // Installations
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Installations ())
      {
        const MilitaryScenarioType::Installations_type& x (*i.Installations ());
        if (typeid (MilitaryScenarioType::Installations_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Installations",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Installations",
            "",
            false, false, e, x);
      }
    }

    // TacticalGraphics
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.TacticalGraphics ())
      {
        const MilitaryScenarioType::TacticalGraphics_type& x (*i.TacticalGraphics ());
        if (typeid (MilitaryScenarioType::TacticalGraphics_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TacticalGraphics",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "TacticalGraphics",
            "",
            false, false, e, x);
      }
    }

    // MOOTWGraphics
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MOOTWGraphics ())
      {
        const MilitaryScenarioType::MOOTWGraphics_type& x (*i.MOOTWGraphics ());
        if (typeid (MilitaryScenarioType::MOOTWGraphics_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MOOTWGraphics",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MOOTWGraphics",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MilitaryScenarioType >
  _xsd_MilitaryScenarioType_type_serializer_init (
    "MilitaryScenarioType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const MGRSType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // MGRSGridZone
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MGRSType::MGRSGridZone_type& x (i.MGRSGridZone ());
      if (typeid (MGRSType::MGRSGridZone_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MGRSGridZone",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MGRSGridZone",
          "",
          false, false, e, x);
    }

    // MGRSGridSquare
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MGRSType::MGRSGridSquare_type& x (i.MGRSGridSquare ());
      if (typeid (MGRSType::MGRSGridSquare_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MGRSGridSquare",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MGRSGridSquare",
          "",
          false, false, e, x);
    }

    // MGRSPrecision
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MGRSType::MGRSPrecision_type& x (i.MGRSPrecision ());
      if (typeid (MGRSType::MGRSPrecision_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MGRSPrecision",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MGRSPrecision",
          "",
          false, false, e, x);
    }

    // MGRSEasting
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MGRSType::MGRSEasting_type& x (i.MGRSEasting ());
      if (typeid (MGRSType::MGRSEasting_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MGRSEasting",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MGRSEasting",
          "",
          false, false, e, x);
    }

    // MGRSNorthing
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MGRSType::MGRSNorthing_type& x (i.MGRSNorthing ());
      if (typeid (MGRSType::MGRSNorthing_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MGRSNorthing",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MGRSNorthing",
          "",
          false, false, e, x);
    }

    // ElevationAGL
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ElevationAGL ())
      {
        const MGRSType::ElevationAGL_type& x (*i.ElevationAGL ());
        if (typeid (MGRSType::ElevationAGL_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ElevationAGL",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ElevationAGL",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MGRSType >
  _xsd_MGRSType_type_serializer_init (
    "MGRSType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const MOOTWDispositionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Location
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MOOTWDispositionType::Location_type& x (i.Location ());
      if (typeid (MOOTWDispositionType::Location_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Location",
          "",
          false, false, e, x);
    }

    // DirectionOfMovement
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DirectionOfMovement ())
      {
        const MOOTWDispositionType::DirectionOfMovement_type& x (*i.DirectionOfMovement ());
        if (typeid (MOOTWDispositionType::DirectionOfMovement_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DirectionOfMovement",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DirectionOfMovement",
            "",
            false, false, e, x);
      }
    }

    // Speed
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Speed ())
      {
        const MOOTWDispositionType::Speed_type& x (*i.Speed ());
        if (typeid (MOOTWDispositionType::Speed_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Speed",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Speed",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MOOTWDispositionType >
  _xsd_MOOTWDispositionType_type_serializer_init (
    "MOOTWDispositionType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const MOOTWGraphicsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // MOOTWGraphic
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (MOOTWGraphicsType::MOOTWGraphic_const_iterator
           b (i.MOOTWGraphic ().begin ()), n (i.MOOTWGraphic ().end ());
           b != n; ++b)
      {
        if (typeid (MOOTWGraphicsType::MOOTWGraphic_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MOOTWGraphic",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "MOOTWGraphic",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MOOTWGraphicsType >
  _xsd_MOOTWGraphicsType_type_serializer_init (
    "MOOTWGraphicsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const MOOTWGraphicType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ObjectHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MOOTWGraphicType::ObjectHandle_type& x (i.ObjectHandle ());
      if (typeid (MOOTWGraphicType::ObjectHandle_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ObjectHandle",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ObjectHandle",
          "",
          false, false, e, x);
    }

    // SymbolIdentifier
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MOOTWGraphicType::SymbolIdentifier_type& x (i.SymbolIdentifier ());
      if (typeid (MOOTWGraphicType::SymbolIdentifier_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SymbolIdentifier",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SymbolIdentifier",
          "",
          false, false, e, x);
    }

    // Affiliation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MOOTWGraphicType::Affiliation_type& x (i.Affiliation ());
      if (typeid (MOOTWGraphicType::Affiliation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Affiliation",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Affiliation",
          "",
          false, false, e, x);
    }

    // Owner
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MOOTWGraphicType::Owner_type& x (i.Owner ());
      if (typeid (MOOTWGraphicType::Owner_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Owner",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Owner",
          "",
          false, false, e, x);
    }

    // MOOTWSymbolModifiers
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MOOTWSymbolModifiers ())
      {
        const MOOTWGraphicType::MOOTWSymbolModifiers_type& x (*i.MOOTWSymbolModifiers ());
        if (typeid (MOOTWGraphicType::MOOTWSymbolModifiers_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MOOTWSymbolModifiers",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MOOTWSymbolModifiers",
            "",
            false, false, e, x);
      }
    }

    // AssociatedOverlays
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AssociatedOverlays ())
      {
        const MOOTWGraphicType::AssociatedOverlays_type& x (*i.AssociatedOverlays ());
        if (typeid (MOOTWGraphicType::AssociatedOverlays_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AssociatedOverlays",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AssociatedOverlays",
            "",
            false, false, e, x);
      }
    }

    // Disposition
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MOOTWGraphicType::Disposition_type& x (i.Disposition ());
      if (typeid (MOOTWGraphicType::Disposition_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Disposition",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Disposition",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MOOTWGraphicType >
  _xsd_MOOTWGraphicType_type_serializer_init (
    "MOOTWGraphicType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const MOOTWSymbolModifiersType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Echelon
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Echelon ())
      {
        const MOOTWSymbolModifiersType::Echelon_type& x (*i.Echelon ());
        if (typeid (MOOTWSymbolModifiersType::Echelon_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Echelon",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Echelon",
            "",
            false, false, e, x);
      }
    }

    // ReinforcedReduced
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ReinforcedReduced ())
      {
        const MOOTWSymbolModifiersType::ReinforcedReduced_type& x (*i.ReinforcedReduced ());
        if (typeid (MOOTWSymbolModifiersType::ReinforcedReduced_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ReinforcedReduced",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ReinforcedReduced",
            "",
            false, false, e, x);
      }
    }

    // FrameShapeModifier
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.FrameShapeModifier ())
      {
        const MOOTWSymbolModifiersType::FrameShapeModifier_type& x (*i.FrameShapeModifier ());
        if (typeid (MOOTWSymbolModifiersType::FrameShapeModifier_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "FrameShapeModifier",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "FrameShapeModifier",
            "",
            false, false, e, x);
      }
    }

    // StaffComments
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.StaffComments ())
      {
        const MOOTWSymbolModifiersType::StaffComments_type& x (*i.StaffComments ());
        if (typeid (MOOTWSymbolModifiersType::StaffComments_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "StaffComments",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "StaffComments",
            "",
            false, false, e, x);
      }
    }

    // AdditionalInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        const MOOTWSymbolModifiersType::AdditionalInfo_type& x (*i.AdditionalInfo ());
        if (typeid (MOOTWSymbolModifiersType::AdditionalInfo_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AdditionalInfo",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AdditionalInfo",
            "",
            false, false, e, x);
      }
    }

    // CombatEffectiveness
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CombatEffectiveness ())
      {
        const MOOTWSymbolModifiersType::CombatEffectiveness_type& x (*i.CombatEffectiveness ());
        if (typeid (MOOTWSymbolModifiersType::CombatEffectiveness_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CombatEffectiveness",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CombatEffectiveness",
            "",
            false, false, e, x);
      }
    }

    // IFF
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.IFF ())
      {
        const MOOTWSymbolModifiersType::IFF_type& x (*i.IFF ());
        if (typeid (MOOTWSymbolModifiersType::IFF_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "IFF",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "IFF",
            "",
            false, false, e, x);
      }
    }

    // UniqueDesignation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MOOTWSymbolModifiersType::UniqueDesignation_type& x (i.UniqueDesignation ());
      if (typeid (MOOTWSymbolModifiersType::UniqueDesignation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UniqueDesignation",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "UniqueDesignation",
          "",
          false, false, e, x);
    }

    // DateTimeGroup
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        const MOOTWSymbolModifiersType::DateTimeGroup_type& x (*i.DateTimeGroup ());
        if (typeid (MOOTWSymbolModifiersType::DateTimeGroup_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DateTimeGroup",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DateTimeGroup",
            "",
            false, false, e, x);
      }
    }

    // SpecialC2HQ
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.SpecialC2HQ ())
      {
        const MOOTWSymbolModifiersType::SpecialC2HQ_type& x (*i.SpecialC2HQ ());
        if (typeid (MOOTWSymbolModifiersType::SpecialC2HQ_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SpecialC2HQ",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SpecialC2HQ",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MOOTWSymbolModifiersType >
  _xsd_MOOTWSymbolModifiersType_type_serializer_init (
    "MOOTWSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const NBCEventSymbolModifiersType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Quantity
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Quantity ())
      {
        const NBCEventSymbolModifiersType::Quantity_type& x (*i.Quantity ());
        if (typeid (NBCEventSymbolModifiersType::Quantity_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Quantity",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Quantity",
            "",
            false, false, e, x);
      }
    }

    // AdditionalInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        const NBCEventSymbolModifiersType::AdditionalInfo_type& x (*i.AdditionalInfo ());
        if (typeid (NBCEventSymbolModifiersType::AdditionalInfo_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AdditionalInfo",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AdditionalInfo",
            "",
            false, false, e, x);
      }
    }

    // UniqueDesignation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.UniqueDesignation ())
      {
        const NBCEventSymbolModifiersType::UniqueDesignation_type& x (*i.UniqueDesignation ());
        if (typeid (NBCEventSymbolModifiersType::UniqueDesignation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UniqueDesignation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "UniqueDesignation",
            "",
            false, false, e, x);
      }
    }

    // NBCType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.NBCType ())
      {
        const NBCEventSymbolModifiersType::NBCType_type& x (*i.NBCType ());
        if (typeid (NBCEventSymbolModifiersType::NBCType_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "NBCType",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "NBCType",
            "",
            false, false, e, x);
      }
    }

    // DateTimeGroup
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        const NBCEventSymbolModifiersType::DateTimeGroup_type& x (*i.DateTimeGroup ());
        if (typeid (NBCEventSymbolModifiersType::DateTimeGroup_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DateTimeGroup",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DateTimeGroup",
            "",
            false, false, e, x);
      }
    }

    // Speed
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const NBCEventSymbolModifiersType::Speed_type& x (i.Speed ());
      if (typeid (NBCEventSymbolModifiersType::Speed_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Speed",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Speed",
          "",
          false, false, e, x);
    }

    // DirectionOfMovement
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const NBCEventSymbolModifiersType::DirectionOfMovement_type& x (i.DirectionOfMovement ());
      if (typeid (NBCEventSymbolModifiersType::DirectionOfMovement_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DirectionOfMovement",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "DirectionOfMovement",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NBCEventSymbolModifiersType >
  _xsd_NBCEventSymbolModifiersType_type_serializer_init (
    "NBCEventSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const OptionsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // MSDLVersion
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const OptionsType::MSDLVersion_type& x (i.MSDLVersion ());
      if (typeid (OptionsType::MSDLVersion_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MSDLVersion",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MSDLVersion",
          "",
          false, false, e, x);
    }

    // OrganizationDetail
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.OrganizationDetail ())
      {
        const OptionsType::OrganizationDetail_type& x (*i.OrganizationDetail ());
        if (typeid (OptionsType::OrganizationDetail_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OrganizationDetail",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "OrganizationDetail",
            "",
            false, false, e, x);
      }
    }

    // ScenarioDataStandards
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ScenarioDataStandards ())
      {
        const OptionsType::ScenarioDataStandards_type& x (*i.ScenarioDataStandards ());
        if (typeid (OptionsType::ScenarioDataStandards_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ScenarioDataStandards",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ScenarioDataStandards",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OptionsType >
  _xsd_OptionsType_type_serializer_init (
    "OptionsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const OrganicRelationDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // OrganicForceSideHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.OrganicForceSideHandle ())
      {
        const OrganicRelationDataType::OrganicForceSideHandle_type& x (*i.OrganicForceSideHandle ());
        if (typeid (OrganicRelationDataType::OrganicForceSideHandle_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OrganicForceSideHandle",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "OrganicForceSideHandle",
            "",
            false, false, e, x);
      }
    }

    // OrganicSuperiorHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.OrganicSuperiorHandle ())
      {
        const OrganicRelationDataType::OrganicSuperiorHandle_type& x (*i.OrganicSuperiorHandle ());
        if (typeid (OrganicRelationDataType::OrganicSuperiorHandle_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OrganicSuperiorHandle",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "OrganicSuperiorHandle",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OrganicRelationDataType >
  _xsd_OrganicRelationDataType_type_serializer_init (
    "OrganicRelationDataType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const OrganicRelationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // OrganicRelationData
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const OrganicRelationType::OrganicRelationData_type& x (i.OrganicRelationData ());
      if (typeid (OrganicRelationType::OrganicRelationData_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OrganicRelationData",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "OrganicRelationData",
          "",
          false, false, e, x);
    }

    // OrganicRelationChoice
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const OrganicRelationType::OrganicRelationChoice_type& x (i.OrganicRelationChoice ());
      if (typeid (OrganicRelationType::OrganicRelationChoice_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OrganicRelationChoice",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "OrganicRelationChoice",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OrganicRelationType >
  _xsd_OrganicRelationType_type_serializer_init (
    "OrganicRelationType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const OrganizationDetailType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // AggregateBased
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const OrganizationDetailType::AggregateBased_type& x (i.AggregateBased ());
      if (typeid (OrganizationDetailType::AggregateBased_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AggregateBased",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "AggregateBased",
          "",
          false, false, e, x);
    }

    // AggregateEchelon
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AggregateEchelon ())
      {
        const OrganizationDetailType::AggregateEchelon_type& x (*i.AggregateEchelon ());
        if (typeid (OrganizationDetailType::AggregateEchelon_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AggregateEchelon",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AggregateEchelon",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OrganizationDetailType >
  _xsd_OrganizationDetailType_type_serializer_init (
    "OrganizationDetailType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const OrganizationsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Units
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const OrganizationsType::Units_type& x (i.Units ());
      if (typeid (OrganizationsType::Units_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Units",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Units",
          "",
          false, false, e, x);
    }

    // Equipment
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Equipment ())
      {
        const OrganizationsType::Equipment_type& x (*i.Equipment ());
        if (typeid (OrganizationsType::Equipment_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Equipment",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Equipment",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OrganizationsType >
  _xsd_OrganizationsType_type_serializer_init (
    "OrganizationsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const OverlayHandlesType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // OverlayHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (OverlayHandlesType::OverlayHandle_const_iterator
           b (i.OverlayHandle ().begin ()), n (i.OverlayHandle ().end ());
           b != n; ++b)
      {
        if (typeid (OverlayHandlesType::OverlayHandle_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OverlayHandle",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "OverlayHandle",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OverlayHandlesType >
  _xsd_OverlayHandlesType_type_serializer_init (
    "OverlayHandlesType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const OverlaysType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Overlay
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (OverlaysType::Overlay_const_iterator
           b (i.Overlay ().begin ()), n (i.Overlay ().end ());
           b != n; ++b)
      {
        if (typeid (OverlaysType::Overlay_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Overlay",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Overlay",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OverlaysType >
  _xsd_OverlaysType_type_serializer_init (
    "OverlaysType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const OverlayType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ObjectHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const OverlayType::ObjectHandle_type& x (i.ObjectHandle ());
      if (typeid (OverlayType::ObjectHandle_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ObjectHandle",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ObjectHandle",
          "",
          false, false, e, x);
    }

    // OverlayType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const OverlayType::OverlayType1_type& x (i.OverlayType1 ());
      if (typeid (OverlayType::OverlayType1_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OverlayType",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "OverlayType",
          "",
          false, false, e, x);
    }

    // OverlayName
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const OverlayType::OverlayName_type& x (i.OverlayName ());
      if (typeid (OverlayType::OverlayName_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OverlayName",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "OverlayName",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OverlayType >
  _xsd_OverlayType_type_serializer_init (
    "OverlayType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const OwnerType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // OwnerChoice
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const OwnerType::OwnerChoice_type& x (i.OwnerChoice ());
      if (typeid (OwnerType::OwnerChoice_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OwnerChoice",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "OwnerChoice",
          "",
          false, false, e, x);
    }

    // OwnerData
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const OwnerType::OwnerData_type& x (i.OwnerData ());
      if (typeid (OwnerType::OwnerData_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OwnerData",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "OwnerData",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OwnerType >
  _xsd_OwnerType_type_serializer_init (
    "OwnerType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const OwnerDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // UnitOwnerHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.UnitOwnerHandle ())
      {
        const OwnerDataType::UnitOwnerHandle_type& x (*i.UnitOwnerHandle ());
        if (typeid (OwnerDataType::UnitOwnerHandle_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UnitOwnerHandle",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "UnitOwnerHandle",
            "",
            false, false, e, x);
      }
    }

    // ForceOwnerHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ForceOwnerHandle ())
      {
        const OwnerDataType::ForceOwnerHandle_type& x (*i.ForceOwnerHandle ());
        if (typeid (OwnerDataType::ForceOwnerHandle_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ForceOwnerHandle",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ForceOwnerHandle",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OwnerDataType >
  _xsd_OwnerDataType_type_serializer_init (
    "OwnerDataType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const OwnFormationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // FormationLocationType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const OwnFormationType::FormationLocationType_type& x (i.FormationLocationType ());
      if (typeid (OwnFormationType::FormationLocationType_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FormationLocationType",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "FormationLocationType",
          "",
          false, false, e, x);
    }

    // FormationSpacing
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.FormationSpacing ())
      {
        const OwnFormationType::FormationSpacing_type& x (*i.FormationSpacing ());
        if (typeid (OwnFormationType::FormationSpacing_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "FormationSpacing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "FormationSpacing",
            "",
            false, false, e, x);
      }
    }

    // FormationOrientation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.FormationOrientation ())
      {
        const OwnFormationType::FormationOrientation_type& x (*i.FormationOrientation ());
        if (typeid (OwnFormationType::FormationOrientation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "FormationOrientation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "FormationOrientation",
            "",
            false, false, e, x);
      }
    }

    // FormationChoice
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const OwnFormationType::FormationChoice_type& x (i.FormationChoice ());
      if (typeid (OwnFormationType::FormationChoice_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FormationChoice",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "FormationChoice",
          "",
          false, false, e, x);
    }

    // FormationData
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const OwnFormationType::FormationData_type& x (i.FormationData ());
      if (typeid (OwnFormationType::FormationData_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FormationData",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "FormationData",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OwnFormationType >
  _xsd_OwnFormationType_type_serializer_init (
    "OwnFormationType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const PointSymbolModifiersType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // AdditionalInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        const PointSymbolModifiersType::AdditionalInfo_type& x (*i.AdditionalInfo ());
        if (typeid (PointSymbolModifiersType::AdditionalInfo_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AdditionalInfo",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AdditionalInfo",
            "",
            false, false, e, x);
      }
    }

    // AdditionalInfo1
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AdditionalInfo1 ())
      {
        const PointSymbolModifiersType::AdditionalInfo1_type& x (*i.AdditionalInfo1 ());
        if (typeid (PointSymbolModifiersType::AdditionalInfo1_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AdditionalInfo1",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AdditionalInfo1",
            "",
            false, false, e, x);
      }
    }

    // UniqueDesignation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const PointSymbolModifiersType::UniqueDesignation_type& x (i.UniqueDesignation ());
      if (typeid (PointSymbolModifiersType::UniqueDesignation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UniqueDesignation",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "UniqueDesignation",
          "",
          false, false, e, x);
    }

    // DateTimeGroup
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        const PointSymbolModifiersType::DateTimeGroup_type& x (*i.DateTimeGroup ());
        if (typeid (PointSymbolModifiersType::DateTimeGroup_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DateTimeGroup",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DateTimeGroup",
            "",
            false, false, e, x);
      }
    }

    // DateTimeGroup1
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DateTimeGroup1 ())
      {
        const PointSymbolModifiersType::DateTimeGroup1_type& x (*i.DateTimeGroup1 ());
        if (typeid (PointSymbolModifiersType::DateTimeGroup1_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DateTimeGroup1",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DateTimeGroup1",
            "",
            false, false, e, x);
      }
    }

    // Orientation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Orientation ())
      {
        const PointSymbolModifiersType::Orientation_type& x (*i.Orientation ());
        if (typeid (PointSymbolModifiersType::Orientation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Orientation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Orientation",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointSymbolModifiersType >
  _xsd_PointSymbolModifiersType_type_serializer_init (
    "PointSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const RectangleAreaType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Name
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Name ())
      {
        const RectangleAreaType::Name_type& x (*i.Name ());
        if (typeid (RectangleAreaType::Name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Name",
            "",
            false, false, e, x);
      }
    }

    // UpperRight
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const RectangleAreaType::UpperRight_type& x (i.UpperRight ());
      if (typeid (RectangleAreaType::UpperRight_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UpperRight",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "UpperRight",
          "",
          false, false, e, x);
    }

    // LowerLeft
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const RectangleAreaType::LowerLeft_type& x (i.LowerLeft ());
      if (typeid (RectangleAreaType::LowerLeft_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LowerLeft",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "LowerLeft",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RectangleAreaType >
  _xsd_RectangleAreaType_type_serializer_init (
    "RectangleAreaType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const ScenarioDataStandardsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // SymbologyDataStandard
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ScenarioDataStandardsType::SymbologyDataStandard_type& x (i.SymbologyDataStandard ());
      if (typeid (ScenarioDataStandardsType::SymbologyDataStandard_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SymbologyDataStandard",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SymbologyDataStandard",
          "",
          false, false, e, x);
    }

    // CoordinateDataStandard
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ScenarioDataStandardsType::CoordinateDataStandard_type& x (i.CoordinateDataStandard ());
      if (typeid (ScenarioDataStandardsType::CoordinateDataStandard_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoordinateDataStandard",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "CoordinateDataStandard",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ScenarioDataStandardsType >
  _xsd_ScenarioDataStandardsType_type_serializer_init (
    "ScenarioDataStandardsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const ScenarioWeatherType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Atmosphere
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Atmosphere ())
      {
        const ScenarioWeatherType::Atmosphere_type& x (*i.Atmosphere ());
        if (typeid (ScenarioWeatherType::Atmosphere_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Atmosphere",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Atmosphere",
            "",
            false, false, e, x);
      }
    }

    // CloudCoverItems
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CloudCoverItems ())
      {
        const ScenarioWeatherType::CloudCoverItems_type& x (*i.CloudCoverItems ());
        if (typeid (ScenarioWeatherType::CloudCoverItems_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CloudCoverItems",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CloudCoverItems",
            "",
            false, false, e, x);
      }
    }

    // Icing
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Icing ())
      {
        const ScenarioWeatherType::Icing_type& x (*i.Icing ());
        if (typeid (ScenarioWeatherType::Icing_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Icing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Icing",
            "",
            false, false, e, x);
      }
    }

    // LightItems
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.LightItems ())
      {
        const ScenarioWeatherType::LightItems_type& x (*i.LightItems ());
        if (typeid (ScenarioWeatherType::LightItems_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "LightItems",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "LightItems",
            "",
            false, false, e, x);
      }
    }

    // Precipitation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Precipitation ())
      {
        const ScenarioWeatherType::Precipitation_type& x (*i.Precipitation ());
        if (typeid (ScenarioWeatherType::Precipitation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Precipitation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Precipitation",
            "",
            false, false, e, x);
      }
    }

    // VisibilityItems
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.VisibilityItems ())
      {
        const ScenarioWeatherType::VisibilityItems_type& x (*i.VisibilityItems ());
        if (typeid (ScenarioWeatherType::VisibilityItems_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "VisibilityItems",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "VisibilityItems",
            "",
            false, false, e, x);
      }
    }

    // WindItems
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.WindItems ())
      {
        const ScenarioWeatherType::WindItems_type& x (*i.WindItems ());
        if (typeid (ScenarioWeatherType::WindItems_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "WindItems",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "WindItems",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ScenarioWeatherType >
  _xsd_ScenarioWeatherType_type_serializer_init (
    "ScenarioWeatherType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const StatusType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // MOPPLevel
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MOPPLevel ())
      {
        const StatusType::MOPPLevel_type& x (*i.MOPPLevel ());
        if (typeid (StatusType::MOPPLevel_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MOPPLevel",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MOPPLevel",
            "",
            false, false, e, x);
      }
    }

    // WeaponControlStatus
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.WeaponControlStatus ())
      {
        const StatusType::WeaponControlStatus_type& x (*i.WeaponControlStatus ());
        if (typeid (StatusType::WeaponControlStatus_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "WeaponControlStatus",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "WeaponControlStatus",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StatusType >
  _xsd_StatusType_type_serializer_init (
    "StatusType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const SupportRelationsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // SupportRelation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SupportRelationsType::SupportRelation_const_iterator
           b (i.SupportRelation ().begin ()), n (i.SupportRelation ().end ());
           b != n; ++b)
      {
        if (typeid (SupportRelationsType::SupportRelation_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SupportRelation",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "SupportRelation",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SupportRelationsType >
  _xsd_SupportRelationsType_type_serializer_init (
    "SupportRelationsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const SupportRelationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // SupportedUnitHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const SupportRelationType::SupportedUnitHandle_type& x (i.SupportedUnitHandle ());
      if (typeid (SupportRelationType::SupportedUnitHandle_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SupportedUnitHandle",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SupportedUnitHandle",
          "",
          false, false, e, x);
    }

    // PriorityToSupport
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.PriorityToSupport ())
      {
        const SupportRelationType::PriorityToSupport_type& x (*i.PriorityToSupport ());
        if (typeid (SupportRelationType::PriorityToSupport_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PriorityToSupport",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "PriorityToSupport",
            "",
            false, false, e, x);
      }
    }

    // SupportType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const SupportRelationType::SupportType_type& x (i.SupportType ());
      if (typeid (SupportRelationType::SupportType_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SupportType",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SupportType",
          "",
          false, false, e, x);
    }

    // SupportRoleType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.SupportRoleType ())
      {
        const SupportRelationType::SupportRoleType_type& x (*i.SupportRoleType ());
        if (typeid (SupportRelationType::SupportRoleType_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SupportRoleType",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SupportRoleType",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SupportRelationType >
  _xsd_SupportRelationType_type_serializer_init (
    "SupportRelationType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const SymbolClassModifiersType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // PointSymbolModifiers
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.PointSymbolModifiers ())
      {
        const SymbolClassModifiersType::PointSymbolModifiers_type& x (*i.PointSymbolModifiers ());
        if (typeid (SymbolClassModifiersType::PointSymbolModifiers_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PointSymbolModifiers",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "PointSymbolModifiers",
            "",
            false, false, e, x);
      }
    }

    // LineSymbolModifiers
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.LineSymbolModifiers ())
      {
        const SymbolClassModifiersType::LineSymbolModifiers_type& x (*i.LineSymbolModifiers ());
        if (typeid (SymbolClassModifiersType::LineSymbolModifiers_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "LineSymbolModifiers",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "LineSymbolModifiers",
            "",
            false, false, e, x);
      }
    }

    // AreaSymbolModifiers
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AreaSymbolModifiers ())
      {
        const SymbolClassModifiersType::AreaSymbolModifiers_type& x (*i.AreaSymbolModifiers ());
        if (typeid (SymbolClassModifiersType::AreaSymbolModifiers_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AreaSymbolModifiers",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AreaSymbolModifiers",
            "",
            false, false, e, x);
      }
    }

    // BoundarySymbolModifiers
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.BoundarySymbolModifiers ())
      {
        const SymbolClassModifiersType::BoundarySymbolModifiers_type& x (*i.BoundarySymbolModifiers ());
        if (typeid (SymbolClassModifiersType::BoundarySymbolModifiers_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "BoundarySymbolModifiers",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "BoundarySymbolModifiers",
            "",
            false, false, e, x);
      }
    }

    // NBCEventSymbolModifiers
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.NBCEventSymbolModifiers ())
      {
        const SymbolClassModifiersType::NBCEventSymbolModifiers_type& x (*i.NBCEventSymbolModifiers ());
        if (typeid (SymbolClassModifiersType::NBCEventSymbolModifiers_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "NBCEventSymbolModifiers",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "NBCEventSymbolModifiers",
            "",
            false, false, e, x);
      }
    }

    // TaskSymbolModifiers
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.TaskSymbolModifiers ())
      {
        const SymbolClassModifiersType::TaskSymbolModifiers_type& x (*i.TaskSymbolModifiers ());
        if (typeid (SymbolClassModifiersType::TaskSymbolModifiers_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TaskSymbolModifiers",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "TaskSymbolModifiers",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SymbolClassModifiersType >
  _xsd_SymbolClassModifiersType_type_serializer_init (
    "SymbolClassModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const SymbologyDataStandardType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // StandardName
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const SymbologyDataStandardType::StandardName_type& x (i.StandardName ());
      if (typeid (SymbologyDataStandardType::StandardName_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StandardName",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "StandardName",
          "",
          false, false, e, x);
    }

    // MajorVersion
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const SymbologyDataStandardType::MajorVersion_type& x (i.MajorVersion ());
      if (typeid (SymbologyDataStandardType::MajorVersion_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MajorVersion",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MajorVersion",
          "",
          false, false, e, x);
    }

    // MinorVersion
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const SymbologyDataStandardType::MinorVersion_type& x (i.MinorVersion ());
      if (typeid (SymbologyDataStandardType::MinorVersion_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinorVersion",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MinorVersion",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SymbologyDataStandardType >
  _xsd_SymbologyDataStandardType_type_serializer_init (
    "SymbologyDataStandardType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const TacticalGraphicsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // TacticalGraphic
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (TacticalGraphicsType::TacticalGraphic_const_iterator
           b (i.TacticalGraphic ().begin ()), n (i.TacticalGraphic ().end ());
           b != n; ++b)
      {
        if (typeid (TacticalGraphicsType::TacticalGraphic_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TacticalGraphic",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "TacticalGraphic",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TacticalGraphicsType >
  _xsd_TacticalGraphicsType_type_serializer_init (
    "TacticalGraphicsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const TacticalGraphicType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ObjectHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const TacticalGraphicType::ObjectHandle_type& x (i.ObjectHandle ());
      if (typeid (TacticalGraphicType::ObjectHandle_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ObjectHandle",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ObjectHandle",
          "",
          false, false, e, x);
    }

    // SymbolIdentifier
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const TacticalGraphicType::SymbolIdentifier_type& x (i.SymbolIdentifier ());
      if (typeid (TacticalGraphicType::SymbolIdentifier_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SymbolIdentifier",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SymbolIdentifier",
          "",
          false, false, e, x);
    }

    // Affiliation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const TacticalGraphicType::Affiliation_type& x (i.Affiliation ());
      if (typeid (TacticalGraphicType::Affiliation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Affiliation",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Affiliation",
          "",
          false, false, e, x);
    }

    // Owner
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const TacticalGraphicType::Owner_type& x (i.Owner ());
      if (typeid (TacticalGraphicType::Owner_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Owner",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Owner",
          "",
          false, false, e, x);
    }

    // AnchorPoints
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const TacticalGraphicType::AnchorPoints_type& x (i.AnchorPoints ());
      if (typeid (TacticalGraphicType::AnchorPoints_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AnchorPoints",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "AnchorPoints",
          "",
          false, false, e, x);
    }

    // AssociatedOverlays
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AssociatedOverlays ())
      {
        const TacticalGraphicType::AssociatedOverlays_type& x (*i.AssociatedOverlays ());
        if (typeid (TacticalGraphicType::AssociatedOverlays_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AssociatedOverlays",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AssociatedOverlays",
            "",
            false, false, e, x);
      }
    }

    // SymbolClassData
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.SymbolClassData ())
      {
        const TacticalGraphicType::SymbolClassData_type& x (*i.SymbolClassData ());
        if (typeid (TacticalGraphicType::SymbolClassData_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SymbolClassData",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SymbolClassData",
            "",
            false, false, e, x);
      }
    }

    // SymbolClassChoice
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const TacticalGraphicType::SymbolClassChoice_type& x (i.SymbolClassChoice ());
      if (typeid (TacticalGraphicType::SymbolClassChoice_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SymbolClassChoice",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SymbolClassChoice",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TacticalGraphicType >
  _xsd_TacticalGraphicType_type_serializer_init (
    "TacticalGraphicType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const TaskSymbolModifiersType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // UniqueDesignation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.UniqueDesignation ())
      {
        const TaskSymbolModifiersType::UniqueDesignation_type& x (*i.UniqueDesignation ());
        if (typeid (TaskSymbolModifiersType::UniqueDesignation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UniqueDesignation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "UniqueDesignation",
            "",
            false, false, e, x);
      }
    }

    // DateTimeGroup
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DateTimeGroup ())
      {
        const TaskSymbolModifiersType::DateTimeGroup_type& x (*i.DateTimeGroup ());
        if (typeid (TaskSymbolModifiersType::DateTimeGroup_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DateTimeGroup",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DateTimeGroup",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TaskSymbolModifiersType >
  _xsd_TaskSymbolModifiersType_type_serializer_init (
    "TaskSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const UnitDispositionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Location
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Location ())
      {
        const UnitDispositionType::Location_type& x (*i.Location ());
        if (typeid (UnitDispositionType::Location_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Location",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Location",
            "",
            false, false, e, x);
      }
    }

    // DirectionOfMovement
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DirectionOfMovement ())
      {
        const UnitDispositionType::DirectionOfMovement_type& x (*i.DirectionOfMovement ());
        if (typeid (UnitDispositionType::DirectionOfMovement_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DirectionOfMovement",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DirectionOfMovement",
            "",
            false, false, e, x);
      }
    }

    // Speed
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Speed ())
      {
        const UnitDispositionType::Speed_type& x (*i.Speed ());
        if (typeid (UnitDispositionType::Speed_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Speed",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Speed",
            "",
            false, false, e, x);
      }
    }

    // FormationPosition
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.FormationPosition ())
      {
        const UnitDispositionType::FormationPosition_type& x (*i.FormationPosition ());
        if (typeid (UnitDispositionType::FormationPosition_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "FormationPosition",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "FormationPosition",
            "",
            false, false, e, x);
      }
    }

    // OwnFormation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.OwnFormation ())
      {
        const UnitDispositionType::OwnFormation_type& x (*i.OwnFormation ());
        if (typeid (UnitDispositionType::OwnFormation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OwnFormation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "OwnFormation",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, UnitDispositionType >
  _xsd_UnitDispositionType_type_serializer_init (
    "UnitDispositionType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const UnitModelType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Resolution
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Resolution ())
      {
        const UnitModelType::Resolution_type& x (*i.Resolution ());
        if (typeid (UnitModelType::Resolution_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Resolution",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Resolution",
            "",
            false, false, e, x);
      }
    }

    // AggregateBased
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AggregateBased ())
      {
        const UnitModelType::AggregateBased_type& x (*i.AggregateBased ());
        if (typeid (UnitModelType::AggregateBased_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AggregateBased",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AggregateBased",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, UnitModelType >
  _xsd_UnitModelType_type_serializer_init (
    "UnitModelType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const UnitRelationsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ForceRelation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const UnitRelationsType::ForceRelation_type& x (i.ForceRelation ());
      if (typeid (UnitRelationsType::ForceRelation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ForceRelation",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ForceRelation",
          "",
          false, false, e, x);
    }

    // SupportRelations
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.SupportRelations ())
      {
        const UnitRelationsType::SupportRelations_type& x (*i.SupportRelations ());
        if (typeid (UnitRelationsType::SupportRelations_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SupportRelations",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SupportRelations",
            "",
            false, false, e, x);
      }
    }

    // OrganicRelation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.OrganicRelation ())
      {
        const UnitRelationsType::OrganicRelation_type& x (*i.OrganicRelation ());
        if (typeid (UnitRelationsType::OrganicRelation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OrganicRelation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "OrganicRelation",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, UnitRelationsType >
  _xsd_UnitRelationsType_type_serializer_init (
    "UnitRelationsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const UnitsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Unit
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (UnitsType::Unit_const_iterator
           b (i.Unit ().begin ()), n (i.Unit ().end ());
           b != n; ++b)
      {
        if (typeid (UnitsType::Unit_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Unit",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Unit",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, UnitsType >
  _xsd_UnitsType_type_serializer_init (
    "UnitsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const UnitSymbolModifiersType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Echelon
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Echelon ())
      {
        const UnitSymbolModifiersType::Echelon_type& x (*i.Echelon ());
        if (typeid (UnitSymbolModifiersType::Echelon_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Echelon",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Echelon",
            "",
            false, false, e, x);
      }
    }

    // ReinforcedReduced
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ReinforcedReduced ())
      {
        const UnitSymbolModifiersType::ReinforcedReduced_type& x (*i.ReinforcedReduced ());
        if (typeid (UnitSymbolModifiersType::ReinforcedReduced_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ReinforcedReduced",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ReinforcedReduced",
            "",
            false, false, e, x);
      }
    }

    // StaffComments
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.StaffComments ())
      {
        const UnitSymbolModifiersType::StaffComments_type& x (*i.StaffComments ());
        if (typeid (UnitSymbolModifiersType::StaffComments_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "StaffComments",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "StaffComments",
            "",
            false, false, e, x);
      }
    }

    // AdditionalInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AdditionalInfo ())
      {
        const UnitSymbolModifiersType::AdditionalInfo_type& x (*i.AdditionalInfo ());
        if (typeid (UnitSymbolModifiersType::AdditionalInfo_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AdditionalInfo",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AdditionalInfo",
            "",
            false, false, e, x);
      }
    }

    // CombatEffectiveness
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CombatEffectiveness ())
      {
        const UnitSymbolModifiersType::CombatEffectiveness_type& x (*i.CombatEffectiveness ());
        if (typeid (UnitSymbolModifiersType::CombatEffectiveness_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CombatEffectiveness",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CombatEffectiveness",
            "",
            false, false, e, x);
      }
    }

    // HigherFormation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.HigherFormation ())
      {
        const UnitSymbolModifiersType::HigherFormation_type& x (*i.HigherFormation ());
        if (typeid (UnitSymbolModifiersType::HigherFormation_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "HigherFormation",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "HigherFormation",
            "",
            false, false, e, x);
      }
    }

    // IFF
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.IFF ())
      {
        const UnitSymbolModifiersType::IFF_type& x (*i.IFF ());
        if (typeid (UnitSymbolModifiersType::IFF_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "IFF",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "IFF",
            "",
            false, false, e, x);
      }
    }

    // UniqueDesignation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const UnitSymbolModifiersType::UniqueDesignation_type& x (i.UniqueDesignation ());
      if (typeid (UnitSymbolModifiersType::UniqueDesignation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UniqueDesignation",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "UniqueDesignation",
          "",
          false, false, e, x);
    }

    // SpecialC2HQ
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.SpecialC2HQ ())
      {
        const UnitSymbolModifiersType::SpecialC2HQ_type& x (*i.SpecialC2HQ ());
        if (typeid (UnitSymbolModifiersType::SpecialC2HQ_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SpecialC2HQ",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SpecialC2HQ",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, UnitSymbolModifiersType >
  _xsd_UnitSymbolModifiersType_type_serializer_init (
    "UnitSymbolModifiersType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const UnitType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ObjectHandle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const UnitType::ObjectHandle_type& x (i.ObjectHandle ());
      if (typeid (UnitType::ObjectHandle_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ObjectHandle",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ObjectHandle",
          "",
          false, false, e, x);
    }

    // SymbolIdentifier
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const UnitType::SymbolIdentifier_type& x (i.SymbolIdentifier ());
      if (typeid (UnitType::SymbolIdentifier_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SymbolIdentifier",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SymbolIdentifier",
          "",
          false, false, e, x);
    }

    // Name
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Name ())
      {
        const UnitType::Name_type& x (*i.Name ());
        if (typeid (UnitType::Name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Name",
            "",
            false, false, e, x);
      }
    }

    // UnitSymbolModifiers
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.UnitSymbolModifiers ())
      {
        const UnitType::UnitSymbolModifiers_type& x (*i.UnitSymbolModifiers ());
        if (typeid (UnitType::UnitSymbolModifiers_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UnitSymbolModifiers",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "UnitSymbolModifiers",
            "",
            false, false, e, x);
      }
    }

    // CommunicationNetInstances
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CommunicationNetInstances ())
      {
        const UnitType::CommunicationNetInstances_type& x (*i.CommunicationNetInstances ());
        if (typeid (UnitType::CommunicationNetInstances_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CommunicationNetInstances",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CommunicationNetInstances",
            "",
            false, false, e, x);
      }
    }

    // Status
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Status ())
      {
        const UnitType::Status_type& x (*i.Status ());
        if (typeid (UnitType::Status_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Status",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Status",
            "",
            false, false, e, x);
      }
    }

    // Disposition
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Disposition ())
      {
        const UnitType::Disposition_type& x (*i.Disposition ());
        if (typeid (UnitType::Disposition_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Disposition",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Disposition",
            "",
            false, false, e, x);
      }
    }

    // Relations
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const UnitType::Relations_type& x (i.Relations ());
      if (typeid (UnitType::Relations_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Relations",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Relations",
          "",
          false, false, e, x);
    }

    // Model
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Model ())
      {
        const UnitType::Model_type& x (*i.Model ());
        if (typeid (UnitType::Model_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Model",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Model",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, UnitType >
  _xsd_UnitType_type_serializer_init (
    "UnitType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const UTMType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // UTMGridZone
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const UTMType::UTMGridZone_type& x (i.UTMGridZone ());
      if (typeid (UTMType::UTMGridZone_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UTMGridZone",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "UTMGridZone",
          "",
          false, false, e, x);
    }

    // UTMEasting
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const UTMType::UTMEasting_type& x (i.UTMEasting ());
      if (typeid (UTMType::UTMEasting_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UTMEasting",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "UTMEasting",
          "",
          false, false, e, x);
    }

    // UTMNorthing
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const UTMType::UTMNorthing_type& x (i.UTMNorthing ());
      if (typeid (UTMType::UTMNorthing_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UTMNorthing",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "UTMNorthing",
          "",
          false, false, e, x);
    }

    // ElevationAGL
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ElevationAGL ())
      {
        const UTMType::ElevationAGL_type& x (*i.ElevationAGL ());
        if (typeid (UTMType::ElevationAGL_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ElevationAGL",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ElevationAGL",
            "",
            false, false, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, UTMType >
  _xsd_UTMType_type_serializer_init (
    "UTMType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const VisibilityItemsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Visibility
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (VisibilityItemsType::Visibility_const_iterator
           b (i.Visibility ().begin ()), n (i.Visibility ().end ());
           b != n; ++b)
      {
        if (typeid (VisibilityItemsType::Visibility_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Visibility",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Visibility",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VisibilityItemsType >
  _xsd_VisibilityItemsType_type_serializer_init (
    "VisibilityItemsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");


  void
  operator<< (::xercesc::DOMElement& e, const WindItemsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Wind
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (WindItemsType::Wind_const_iterator
           b (i.Wind ().begin ()), n (i.Wind ().end ());
           b != n; ++b)
      {
        if (typeid (WindItemsType::Wind_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Wind",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Wind",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, WindItemsType >
  _xsd_WindItemsType_type_serializer_init (
    "WindItemsType",
    "urn:sisostds:scenario:military:data:draft:msdl:1");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

