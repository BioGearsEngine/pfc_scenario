// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "pfc_scenario_complex_types_0.3.hxx"

namespace pfc
{
  namespace schema
  {
    // summary
    // 

    const summary::title_optional& summary::
    title () const
    {
      return this->title_;
    }

    summary::title_optional& summary::
    title ()
    {
      return this->title_;
    }

    void summary::
    title (const title_type& x)
    {
      this->title_.set (x);
    }

    void summary::
    title (const title_optional& x)
    {
      this->title_ = x;
    }

    void summary::
    title (::std::unique_ptr< title_type > x)
    {
      this->title_.set (std::move (x));
    }

    const summary::description_optional& summary::
    description () const
    {
      return this->description_;
    }

    summary::description_optional& summary::
    description ()
    {
      return this->description_;
    }

    void summary::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void summary::
    description (const description_optional& x)
    {
      this->description_ = x;
    }

    void summary::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const summary::version_optional& summary::
    version () const
    {
      return this->version_;
    }

    summary::version_optional& summary::
    version ()
    {
      return this->version_;
    }

    void summary::
    version (const version_type& x)
    {
      this->version_.set (x);
    }

    void summary::
    version (const version_optional& x)
    {
      this->version_ = x;
    }

    void summary::
    version (::std::unique_ptr< version_type > x)
    {
      this->version_.set (std::move (x));
    }

    const summary::classification_optional& summary::
    classification () const
    {
      return this->classification_;
    }

    summary::classification_optional& summary::
    classification ()
    {
      return this->classification_;
    }

    void summary::
    classification (const classification_type& x)
    {
      this->classification_.set (x);
    }

    void summary::
    classification (const classification_optional& x)
    {
      this->classification_ = x;
    }

    void summary::
    classification (::std::unique_ptr< classification_type > x)
    {
      this->classification_.set (std::move (x));
    }

    const summary::keywords_optional& summary::
    keywords () const
    {
      return this->keywords_;
    }

    summary::keywords_optional& summary::
    keywords ()
    {
      return this->keywords_;
    }

    void summary::
    keywords (const keywords_type& x)
    {
      this->keywords_.set (x);
    }

    void summary::
    keywords (const keywords_optional& x)
    {
      this->keywords_ = x;
    }

    void summary::
    keywords (::std::unique_ptr< keywords_type > x)
    {
      this->keywords_.set (std::move (x));
    }

    const summary::domain_optional& summary::
    domain () const
    {
      return this->domain_;
    }

    summary::domain_optional& summary::
    domain ()
    {
      return this->domain_;
    }

    void summary::
    domain (const domain_type& x)
    {
      this->domain_.set (x);
    }

    void summary::
    domain (const domain_optional& x)
    {
      this->domain_ = x;
    }

    void summary::
    domain (::std::unique_ptr< domain_type > x)
    {
      this->domain_.set (std::move (x));
    }

    const summary::limitations_optional& summary::
    limitations () const
    {
      return this->limitations_;
    }

    summary::limitations_optional& summary::
    limitations ()
    {
      return this->limitations_;
    }

    void summary::
    limitations (const limitations_type& x)
    {
      this->limitations_.set (x);
    }

    void summary::
    limitations (const limitations_optional& x)
    {
      this->limitations_ = x;
    }

    void summary::
    limitations (::std::unique_ptr< limitations_type > x)
    {
      this->limitations_.set (std::move (x));
    }


    // author
    // 

    const author::first_name_optional& author::
    first_name () const
    {
      return this->first_name_;
    }

    author::first_name_optional& author::
    first_name ()
    {
      return this->first_name_;
    }

    void author::
    first_name (const first_name_type& x)
    {
      this->first_name_.set (x);
    }

    void author::
    first_name (const first_name_optional& x)
    {
      this->first_name_ = x;
    }

    void author::
    first_name (::std::unique_ptr< first_name_type > x)
    {
      this->first_name_.set (std::move (x));
    }

    const author::last_name_optional& author::
    last_name () const
    {
      return this->last_name_;
    }

    author::last_name_optional& author::
    last_name ()
    {
      return this->last_name_;
    }

    void author::
    last_name (const last_name_type& x)
    {
      this->last_name_.set (x);
    }

    void author::
    last_name (const last_name_optional& x)
    {
      this->last_name_ = x;
    }

    void author::
    last_name (::std::unique_ptr< last_name_type > x)
    {
      this->last_name_.set (std::move (x));
    }

    const author::organization_optional& author::
    organization () const
    {
      return this->organization_;
    }

    author::organization_optional& author::
    organization ()
    {
      return this->organization_;
    }

    void author::
    organization (const organization_type& x)
    {
      this->organization_.set (x);
    }

    void author::
    organization (const organization_optional& x)
    {
      this->organization_ = x;
    }

    void author::
    organization (::std::unique_ptr< organization_type > x)
    {
      this->organization_.set (std::move (x));
    }

    const author::phone_number_optional& author::
    phone_number () const
    {
      return this->phone_number_;
    }

    author::phone_number_optional& author::
    phone_number ()
    {
      return this->phone_number_;
    }

    void author::
    phone_number (const phone_number_type& x)
    {
      this->phone_number_.set (x);
    }

    void author::
    phone_number (const phone_number_optional& x)
    {
      this->phone_number_ = x;
    }

    void author::
    phone_number (::std::unique_ptr< phone_number_type > x)
    {
      this->phone_number_.set (std::move (x));
    }

    const author::email_optional& author::
    email () const
    {
      return this->email_;
    }

    author::email_optional& author::
    email ()
    {
      return this->email_;
    }

    void author::
    email (const email_type& x)
    {
      this->email_.set (x);
    }

    void author::
    email (const email_optional& x)
    {
      this->email_ = x;
    }

    void author::
    email (::std::unique_ptr< email_type > x)
    {
      this->email_.set (std::move (x));
    }

    const author::zip_optional& author::
    zip () const
    {
      return this->zip_;
    }

    author::zip_optional& author::
    zip ()
    {
      return this->zip_;
    }

    void author::
    zip (const zip_type& x)
    {
      this->zip_.set (x);
    }

    void author::
    zip (const zip_optional& x)
    {
      this->zip_ = x;
    }

    void author::
    zip (::std::unique_ptr< zip_type > x)
    {
      this->zip_.set (std::move (x));
    }

    const author::state_optional& author::
    state () const
    {
      return this->state_;
    }

    author::state_optional& author::
    state ()
    {
      return this->state_;
    }

    void author::
    state (const state_type& x)
    {
      this->state_.set (x);
    }

    void author::
    state (const state_optional& x)
    {
      this->state_ = x;
    }

    void author::
    state (::std::unique_ptr< state_type > x)
    {
      this->state_.set (std::move (x));
    }

    const author::country_optional& author::
    country () const
    {
      return this->country_;
    }

    author::country_optional& author::
    country ()
    {
      return this->country_;
    }

    void author::
    country (const country_type& x)
    {
      this->country_.set (x);
    }

    void author::
    country (const country_optional& x)
    {
      this->country_ = x;
    }

    void author::
    country (::std::unique_ptr< country_type > x)
    {
      this->country_.set (std::move (x));
    }


    // equipment_definition_list
    // 

    const equipment_definition_list::equipment_sequence& equipment_definition_list::
    equipment () const
    {
      return this->equipment_;
    }

    equipment_definition_list::equipment_sequence& equipment_definition_list::
    equipment ()
    {
      return this->equipment_;
    }

    void equipment_definition_list::
    equipment (const equipment_sequence& s)
    {
      this->equipment_ = s;
    }


    // equipment
    // 

    const equipment::id_type& equipment::
    id () const
    {
      return this->id_.get ();
    }

    equipment::id_type& equipment::
    id ()
    {
      return this->id_.get ();
    }

    void equipment::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void equipment::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const equipment::name_type& equipment::
    name () const
    {
      return this->name_.get ();
    }

    equipment::name_type& equipment::
    name ()
    {
      return this->name_.get ();
    }

    void equipment::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void equipment::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const equipment::type_optional& equipment::
    type () const
    {
      return this->type_;
    }

    equipment::type_optional& equipment::
    type ()
    {
      return this->type_;
    }

    void equipment::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void equipment::
    type (const type_optional& x)
    {
      this->type_ = x;
    }

    const equipment::description_type& equipment::
    description () const
    {
      return this->description_.get ();
    }

    equipment::description_type& equipment::
    description ()
    {
      return this->description_.get ();
    }

    void equipment::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void equipment::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const equipment::citations_type& equipment::
    citations () const
    {
      return this->citations_.get ();
    }

    equipment::citations_type& equipment::
    citations ()
    {
      return this->citations_.get ();
    }

    void equipment::
    citations (const citations_type& x)
    {
      this->citations_.set (x);
    }

    void equipment::
    citations (::std::unique_ptr< citations_type > x)
    {
      this->citations_.set (std::move (x));
    }

    const equipment::image_optional& equipment::
    image () const
    {
      return this->image_;
    }

    equipment::image_optional& equipment::
    image ()
    {
      return this->image_;
    }

    void equipment::
    image (const image_type& x)
    {
      this->image_.set (x);
    }

    void equipment::
    image (const image_optional& x)
    {
      this->image_ = x;
    }

    void equipment::
    image (::std::unique_ptr< image_type > x)
    {
      this->image_.set (std::move (x));
    }


    // trauma_definition_list
    // 

    const trauma_definition_list::trauma_sequence& trauma_definition_list::
    trauma () const
    {
      return this->trauma_;
    }

    trauma_definition_list::trauma_sequence& trauma_definition_list::
    trauma ()
    {
      return this->trauma_;
    }

    void trauma_definition_list::
    trauma (const trauma_sequence& s)
    {
      this->trauma_ = s;
    }


    // trauma
    // 

    const trauma::id_type& trauma::
    id () const
    {
      return this->id_.get ();
    }

    trauma::id_type& trauma::
    id ()
    {
      return this->id_.get ();
    }

    void trauma::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void trauma::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const trauma::common_name_optional& trauma::
    common_name () const
    {
      return this->common_name_;
    }

    trauma::common_name_optional& trauma::
    common_name ()
    {
      return this->common_name_;
    }

    void trauma::
    common_name (const common_name_type& x)
    {
      this->common_name_.set (x);
    }

    void trauma::
    common_name (const common_name_optional& x)
    {
      this->common_name_ = x;
    }

    void trauma::
    common_name (::std::unique_ptr< common_name_type > x)
    {
      this->common_name_.set (std::move (x));
    }

    const trauma::medical_name_type& trauma::
    medical_name () const
    {
      return this->medical_name_.get ();
    }

    trauma::medical_name_type& trauma::
    medical_name ()
    {
      return this->medical_name_.get ();
    }

    void trauma::
    medical_name (const medical_name_type& x)
    {
      this->medical_name_.set (x);
    }

    void trauma::
    medical_name (::std::unique_ptr< medical_name_type > x)
    {
      this->medical_name_.set (std::move (x));
    }

    const trauma::citations_type& trauma::
    citations () const
    {
      return this->citations_.get ();
    }

    trauma::citations_type& trauma::
    citations ()
    {
      return this->citations_.get ();
    }

    void trauma::
    citations (const citations_type& x)
    {
      this->citations_.set (x);
    }

    void trauma::
    citations (::std::unique_ptr< citations_type > x)
    {
      this->citations_.set (std::move (x));
    }

    const trauma::description_type& trauma::
    description () const
    {
      return this->description_.get ();
    }

    trauma::description_type& trauma::
    description ()
    {
      return this->description_.get ();
    }

    void trauma::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void trauma::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const trauma::severity_range_type& trauma::
    severity_range () const
    {
      return this->severity_range_.get ();
    }

    trauma::severity_range_type& trauma::
    severity_range ()
    {
      return this->severity_range_.get ();
    }

    void trauma::
    severity_range (const severity_range_type& x)
    {
      this->severity_range_.set (x);
    }

    void trauma::
    severity_range (::std::unique_ptr< severity_range_type > x)
    {
      this->severity_range_.set (std::move (x));
    }


    // trauma_severity_range
    // 

    const trauma_severity_range::numeric_range_optional& trauma_severity_range::
    numeric_range () const
    {
      return this->numeric_range_;
    }

    trauma_severity_range::numeric_range_optional& trauma_severity_range::
    numeric_range ()
    {
      return this->numeric_range_;
    }

    void trauma_severity_range::
    numeric_range (const numeric_range_type& x)
    {
      this->numeric_range_.set (x);
    }

    void trauma_severity_range::
    numeric_range (const numeric_range_optional& x)
    {
      this->numeric_range_ = x;
    }

    void trauma_severity_range::
    numeric_range (::std::unique_ptr< numeric_range_type > x)
    {
      this->numeric_range_.set (std::move (x));
    }

    const trauma_severity_range::token_range_optional& trauma_severity_range::
    token_range () const
    {
      return this->token_range_;
    }

    trauma_severity_range::token_range_optional& trauma_severity_range::
    token_range ()
    {
      return this->token_range_;
    }

    void trauma_severity_range::
    token_range (const token_range_type& x)
    {
      this->token_range_.set (x);
    }

    void trauma_severity_range::
    token_range (const token_range_optional& x)
    {
      this->token_range_ = x;
    }

    void trauma_severity_range::
    token_range (::std::unique_ptr< token_range_type > x)
    {
      this->token_range_.set (std::move (x));
    }


    // numeric_range
    // 

    const numeric_range::lower_bound_type& numeric_range::
    lower_bound () const
    {
      return this->lower_bound_.get ();
    }

    numeric_range::lower_bound_type& numeric_range::
    lower_bound ()
    {
      return this->lower_bound_.get ();
    }

    void numeric_range::
    lower_bound (const lower_bound_type& x)
    {
      this->lower_bound_.set (x);
    }

    const numeric_range::upper_bound_type& numeric_range::
    upper_bound () const
    {
      return this->upper_bound_.get ();
    }

    numeric_range::upper_bound_type& numeric_range::
    upper_bound ()
    {
      return this->upper_bound_.get ();
    }

    void numeric_range::
    upper_bound (const upper_bound_type& x)
    {
      this->upper_bound_.set (x);
    }

    const numeric_range::median_optional& numeric_range::
    median () const
    {
      return this->median_;
    }

    numeric_range::median_optional& numeric_range::
    median ()
    {
      return this->median_;
    }

    void numeric_range::
    median (const median_type& x)
    {
      this->median_.set (x);
    }

    void numeric_range::
    median (const median_optional& x)
    {
      this->median_ = x;
    }

    const numeric_range::unit_optional& numeric_range::
    unit () const
    {
      return this->unit_;
    }

    numeric_range::unit_optional& numeric_range::
    unit ()
    {
      return this->unit_;
    }

    void numeric_range::
    unit (const unit_type& x)
    {
      this->unit_.set (x);
    }

    void numeric_range::
    unit (const unit_optional& x)
    {
      this->unit_ = x;
    }

    void numeric_range::
    unit (::std::unique_ptr< unit_type > x)
    {
      this->unit_.set (std::move (x));
    }


    // token_range
    // 

    const token_range::token_sequence& token_range::
    token () const
    {
      return this->token_;
    }

    token_range::token_sequence& token_range::
    token ()
    {
      return this->token_;
    }

    void token_range::
    token (const token_sequence& s)
    {
      this->token_ = s;
    }


    // citation_ref_list
    // 

    const citation_ref_list::citation_ref_sequence& citation_ref_list::
    citation_ref () const
    {
      return this->citation_ref_;
    }

    citation_ref_list::citation_ref_sequence& citation_ref_list::
    citation_ref ()
    {
      return this->citation_ref_;
    }

    void citation_ref_list::
    citation_ref (const citation_ref_sequence& s)
    {
      this->citation_ref_ = s;
    }


    // treatment_plan_definition_list
    // 

    const treatment_plan_definition_list::treatment_plan_sequence& treatment_plan_definition_list::
    treatment_plan () const
    {
      return this->treatment_plan_;
    }

    treatment_plan_definition_list::treatment_plan_sequence& treatment_plan_definition_list::
    treatment_plan ()
    {
      return this->treatment_plan_;
    }

    void treatment_plan_definition_list::
    treatment_plan (const treatment_plan_sequence& s)
    {
      this->treatment_plan_ = s;
    }


    // treatment_plan
    // 

    const treatment_plan::id_type& treatment_plan::
    id () const
    {
      return this->id_.get ();
    }

    treatment_plan::id_type& treatment_plan::
    id ()
    {
      return this->id_.get ();
    }

    void treatment_plan::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void treatment_plan::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const treatment_plan::common_name_optional& treatment_plan::
    common_name () const
    {
      return this->common_name_;
    }

    treatment_plan::common_name_optional& treatment_plan::
    common_name ()
    {
      return this->common_name_;
    }

    void treatment_plan::
    common_name (const common_name_type& x)
    {
      this->common_name_.set (x);
    }

    void treatment_plan::
    common_name (const common_name_optional& x)
    {
      this->common_name_ = x;
    }

    void treatment_plan::
    common_name (::std::unique_ptr< common_name_type > x)
    {
      this->common_name_.set (std::move (x));
    }

    const treatment_plan::medical_name_optional& treatment_plan::
    medical_name () const
    {
      return this->medical_name_;
    }

    treatment_plan::medical_name_optional& treatment_plan::
    medical_name ()
    {
      return this->medical_name_;
    }

    void treatment_plan::
    medical_name (const medical_name_type& x)
    {
      this->medical_name_.set (x);
    }

    void treatment_plan::
    medical_name (const medical_name_optional& x)
    {
      this->medical_name_ = x;
    }

    void treatment_plan::
    medical_name (::std::unique_ptr< medical_name_type > x)
    {
      this->medical_name_.set (std::move (x));
    }

    const treatment_plan::description_type& treatment_plan::
    description () const
    {
      return this->description_.get ();
    }

    treatment_plan::description_type& treatment_plan::
    description ()
    {
      return this->description_.get ();
    }

    void treatment_plan::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void treatment_plan::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const treatment_plan::required_equipment_type& treatment_plan::
    required_equipment () const
    {
      return this->required_equipment_.get ();
    }

    treatment_plan::required_equipment_type& treatment_plan::
    required_equipment ()
    {
      return this->required_equipment_.get ();
    }

    void treatment_plan::
    required_equipment (const required_equipment_type& x)
    {
      this->required_equipment_.set (x);
    }

    void treatment_plan::
    required_equipment (::std::unique_ptr< required_equipment_type > x)
    {
      this->required_equipment_.set (std::move (x));
    }

    const treatment_plan::references_type& treatment_plan::
    references () const
    {
      return this->references_.get ();
    }

    treatment_plan::references_type& treatment_plan::
    references ()
    {
      return this->references_.get ();
    }

    void treatment_plan::
    references (const references_type& x)
    {
      this->references_.set (x);
    }

    void treatment_plan::
    references (::std::unique_ptr< references_type > x)
    {
      this->references_.set (std::move (x));
    }


    // equipment_ref_list
    // 

    const equipment_ref_list::equipment_refs_sequence& equipment_ref_list::
    equipment_refs () const
    {
      return this->equipment_refs_;
    }

    equipment_ref_list::equipment_refs_sequence& equipment_ref_list::
    equipment_refs ()
    {
      return this->equipment_refs_;
    }

    void equipment_ref_list::
    equipment_refs (const equipment_refs_sequence& s)
    {
      this->equipment_refs_ = s;
    }


    // medical_reference_list
    // 

    const medical_reference_list::citations_type& medical_reference_list::
    citations () const
    {
      return this->citations_.get ();
    }

    medical_reference_list::citations_type& medical_reference_list::
    citations ()
    {
      return this->citations_.get ();
    }

    void medical_reference_list::
    citations (const citations_type& x)
    {
      this->citations_.set (x);
    }

    void medical_reference_list::
    citations (::std::unique_ptr< citations_type > x)
    {
      this->citations_.set (std::move (x));
    }

    const medical_reference_list::cpgs_type& medical_reference_list::
    cpgs () const
    {
      return this->cpgs_.get ();
    }

    medical_reference_list::cpgs_type& medical_reference_list::
    cpgs ()
    {
      return this->cpgs_.get ();
    }

    void medical_reference_list::
    cpgs (const cpgs_type& x)
    {
      this->cpgs_.set (x);
    }

    void medical_reference_list::
    cpgs (::std::unique_ptr< cpgs_type > x)
    {
      this->cpgs_.set (std::move (x));
    }


    // cpg_ref_list
    // 

    const cpg_ref_list::cpg_ref_sequence& cpg_ref_list::
    cpg_ref () const
    {
      return this->cpg_ref_;
    }

    cpg_ref_list::cpg_ref_sequence& cpg_ref_list::
    cpg_ref ()
    {
      return this->cpg_ref_;
    }

    void cpg_ref_list::
    cpg_ref (const cpg_ref_sequence& s)
    {
      this->cpg_ref_ = s;
    }


    // cpg_list
    // 

    const cpg_list::cpg_sequence& cpg_list::
    cpg () const
    {
      return this->cpg_;
    }

    cpg_list::cpg_sequence& cpg_list::
    cpg ()
    {
      return this->cpg_;
    }

    void cpg_list::
    cpg (const cpg_sequence& s)
    {
      this->cpg_ = s;
    }


    // cpg
    // 

    const cpg::name_type& cpg::
    name () const
    {
      return this->name_.get ();
    }

    cpg::name_type& cpg::
    name ()
    {
      return this->name_.get ();
    }

    void cpg::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void cpg::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const cpg::description_type& cpg::
    description () const
    {
      return this->description_.get ();
    }

    cpg::description_type& cpg::
    description ()
    {
      return this->description_.get ();
    }

    void cpg::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void cpg::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const cpg::citation_ref_type& cpg::
    citation_ref () const
    {
      return this->citation_ref_.get ();
    }

    cpg::citation_ref_type& cpg::
    citation_ref ()
    {
      return this->citation_ref_.get ();
    }

    void cpg::
    citation_ref (const citation_ref_type& x)
    {
      this->citation_ref_.set (x);
    }

    void cpg::
    citation_ref (::std::unique_ptr< citation_ref_type > x)
    {
      this->citation_ref_.set (std::move (x));
    }


    // learning_objective_reference_list
    // 

    const learning_objective_reference_list::objective_sequence& learning_objective_reference_list::
    objective () const
    {
      return this->objective_;
    }

    learning_objective_reference_list::objective_sequence& learning_objective_reference_list::
    objective ()
    {
      return this->objective_;
    }

    void learning_objective_reference_list::
    objective (const objective_sequence& s)
    {
      this->objective_ = s;
    }


    // treatment_plan_ref_list
    // 

    const treatment_plan_ref_list::treatment_plan_sequence& treatment_plan_ref_list::
    treatment_plan () const
    {
      return this->treatment_plan_;
    }

    treatment_plan_ref_list::treatment_plan_sequence& treatment_plan_ref_list::
    treatment_plan ()
    {
      return this->treatment_plan_;
    }

    void treatment_plan_ref_list::
    treatment_plan (const treatment_plan_sequence& s)
    {
      this->treatment_plan_ = s;
    }


    // trauma_profile_list
    // 

    const trauma_profile_list::trauma_profile_sequence& trauma_profile_list::
    trauma_profile () const
    {
      return this->trauma_profile_;
    }

    trauma_profile_list::trauma_profile_sequence& trauma_profile_list::
    trauma_profile ()
    {
      return this->trauma_profile_;
    }

    void trauma_profile_list::
    trauma_profile (const trauma_profile_sequence& s)
    {
      this->trauma_profile_ = s;
    }


    // trauma_profile
    // 

    const trauma_profile::id_type& trauma_profile::
    id () const
    {
      return this->id_.get ();
    }

    trauma_profile::id_type& trauma_profile::
    id ()
    {
      return this->id_.get ();
    }

    void trauma_profile::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void trauma_profile::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const trauma_profile::name_type& trauma_profile::
    name () const
    {
      return this->name_.get ();
    }

    trauma_profile::name_type& trauma_profile::
    name ()
    {
      return this->name_.get ();
    }

    void trauma_profile::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void trauma_profile::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const trauma_profile::physiology_state_optional& trauma_profile::
    physiology_state () const
    {
      return this->physiology_state_;
    }

    trauma_profile::physiology_state_optional& trauma_profile::
    physiology_state ()
    {
      return this->physiology_state_;
    }

    void trauma_profile::
    physiology_state (const physiology_state_type& x)
    {
      this->physiology_state_.set (x);
    }

    void trauma_profile::
    physiology_state (const physiology_state_optional& x)
    {
      this->physiology_state_ = x;
    }

    void trauma_profile::
    physiology_state (::std::unique_ptr< physiology_state_type > x)
    {
      this->physiology_state_.set (std::move (x));
    }

    const trauma_profile::injuries_type& trauma_profile::
    injuries () const
    {
      return this->injuries_.get ();
    }

    trauma_profile::injuries_type& trauma_profile::
    injuries ()
    {
      return this->injuries_.get ();
    }

    void trauma_profile::
    injuries (const injuries_type& x)
    {
      this->injuries_.set (x);
    }

    void trauma_profile::
    injuries (::std::unique_ptr< injuries_type > x)
    {
      this->injuries_.set (std::move (x));
    }

    const trauma_profile::treatments_type& trauma_profile::
    treatments () const
    {
      return this->treatments_.get ();
    }

    trauma_profile::treatments_type& trauma_profile::
    treatments ()
    {
      return this->treatments_.get ();
    }

    void trauma_profile::
    treatments (const treatments_type& x)
    {
      this->treatments_.set (x);
    }

    void trauma_profile::
    treatments (::std::unique_ptr< treatments_type > x)
    {
      this->treatments_.set (std::move (x));
    }


    // trauma_profile_ref_list
    // 

    const trauma_profile_ref_list::trauma_profile_sequence& trauma_profile_ref_list::
    trauma_profile () const
    {
      return this->trauma_profile_;
    }

    trauma_profile_ref_list::trauma_profile_sequence& trauma_profile_ref_list::
    trauma_profile ()
    {
      return this->trauma_profile_;
    }

    void trauma_profile_ref_list::
    trauma_profile (const trauma_profile_sequence& s)
    {
      this->trauma_profile_ = s;
    }


    // trauma_occurence_list
    // 

    const trauma_occurence_list::trauma_sequence& trauma_occurence_list::
    trauma () const
    {
      return this->trauma_;
    }

    trauma_occurence_list::trauma_sequence& trauma_occurence_list::
    trauma ()
    {
      return this->trauma_;
    }

    void trauma_occurence_list::
    trauma (const trauma_sequence& s)
    {
      this->trauma_ = s;
    }


    // trauma_occurence
    // 

    const trauma_occurence::id_type& trauma_occurence::
    id () const
    {
      return this->id_.get ();
    }

    trauma_occurence::id_type& trauma_occurence::
    id ()
    {
      return this->id_.get ();
    }

    void trauma_occurence::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void trauma_occurence::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const trauma_occurence::location_type& trauma_occurence::
    location () const
    {
      return this->location_.get ();
    }

    trauma_occurence::location_type& trauma_occurence::
    location ()
    {
      return this->location_.get ();
    }

    void trauma_occurence::
    location (const location_type& x)
    {
      this->location_.set (x);
    }

    void trauma_occurence::
    location (::std::unique_ptr< location_type > x)
    {
      this->location_.set (std::move (x));
    }

    const trauma_occurence::description_type& trauma_occurence::
    description () const
    {
      return this->description_.get ();
    }

    trauma_occurence::description_type& trauma_occurence::
    description ()
    {
      return this->description_.get ();
    }

    void trauma_occurence::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void trauma_occurence::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const trauma_occurence::severity_type& trauma_occurence::
    severity () const
    {
      return this->severity_.get ();
    }

    trauma_occurence::severity_type& trauma_occurence::
    severity ()
    {
      return this->severity_.get ();
    }

    void trauma_occurence::
    severity (const severity_type& x)
    {
      this->severity_.set (x);
    }

    void trauma_occurence::
    severity (::std::unique_ptr< severity_type > x)
    {
      this->severity_.set (std::move (x));
    }


    // medical_scenario_syllabus
    // 

    const medical_scenario_syllabus::learning_objectives_type& medical_scenario_syllabus::
    learning_objectives () const
    {
      return this->learning_objectives_.get ();
    }

    medical_scenario_syllabus::learning_objectives_type& medical_scenario_syllabus::
    learning_objectives ()
    {
      return this->learning_objectives_.get ();
    }

    void medical_scenario_syllabus::
    learning_objectives (const learning_objectives_type& x)
    {
      this->learning_objectives_.set (x);
    }

    void medical_scenario_syllabus::
    learning_objectives (::std::unique_ptr< learning_objectives_type > x)
    {
      this->learning_objectives_.set (std::move (x));
    }

    const medical_scenario_syllabus::learning_assessments_type& medical_scenario_syllabus::
    learning_assessments () const
    {
      return this->learning_assessments_.get ();
    }

    medical_scenario_syllabus::learning_assessments_type& medical_scenario_syllabus::
    learning_assessments ()
    {
      return this->learning_assessments_.get ();
    }

    void medical_scenario_syllabus::
    learning_assessments (const learning_assessments_type& x)
    {
      this->learning_assessments_.set (x);
    }

    void medical_scenario_syllabus::
    learning_assessments (::std::unique_ptr< learning_assessments_type > x)
    {
      this->learning_assessments_.set (std::move (x));
    }


    // learning_objective_list
    // 

    const learning_objective_list::objective_sequence& learning_objective_list::
    objective () const
    {
      return this->objective_;
    }

    learning_objective_list::objective_sequence& learning_objective_list::
    objective ()
    {
      return this->objective_;
    }

    void learning_objective_list::
    objective (const objective_sequence& s)
    {
      this->objective_ = s;
    }


    // learning_objective
    // 

    const learning_objective::id_type& learning_objective::
    id () const
    {
      return this->id_.get ();
    }

    learning_objective::id_type& learning_objective::
    id ()
    {
      return this->id_.get ();
    }

    void learning_objective::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void learning_objective::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const learning_objective::name_type& learning_objective::
    name () const
    {
      return this->name_.get ();
    }

    learning_objective::name_type& learning_objective::
    name ()
    {
      return this->name_.get ();
    }

    void learning_objective::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void learning_objective::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const learning_objective::description_type& learning_objective::
    description () const
    {
      return this->description_.get ();
    }

    learning_objective::description_type& learning_objective::
    description ()
    {
      return this->description_.get ();
    }

    void learning_objective::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void learning_objective::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const learning_objective::references_type& learning_objective::
    references () const
    {
      return this->references_.get ();
    }

    learning_objective::references_type& learning_objective::
    references ()
    {
      return this->references_.get ();
    }

    void learning_objective::
    references (const references_type& x)
    {
      this->references_.set (x);
    }

    void learning_objective::
    references (::std::unique_ptr< references_type > x)
    {
      this->references_.set (std::move (x));
    }

    const learning_objective::relates_to_type& learning_objective::
    relates_to () const
    {
      return this->relates_to_.get ();
    }

    learning_objective::relates_to_type& learning_objective::
    relates_to ()
    {
      return this->relates_to_.get ();
    }

    void learning_objective::
    relates_to (const relates_to_type& x)
    {
      this->relates_to_.set (x);
    }

    void learning_objective::
    relates_to (::std::unique_ptr< relates_to_type > x)
    {
      this->relates_to_.set (std::move (x));
    }


    // assessment_list
    // 

    const assessment_list::total_points_type& assessment_list::
    total_points () const
    {
      return this->total_points_.get ();
    }

    assessment_list::total_points_type& assessment_list::
    total_points ()
    {
      return this->total_points_.get ();
    }

    void assessment_list::
    total_points (const total_points_type& x)
    {
      this->total_points_.set (x);
    }

    assessment_list::total_points_type assessment_list::
    total_points_default_value ()
    {
      return total_points_type (0LL);
    }

    const assessment_list::assessment_sequence& assessment_list::
    assessment () const
    {
      return this->assessment_;
    }

    assessment_list::assessment_sequence& assessment_list::
    assessment ()
    {
      return this->assessment_;
    }

    void assessment_list::
    assessment (const assessment_sequence& s)
    {
      this->assessment_ = s;
    }


    // assessment
    // 

    const assessment::id_type& assessment::
    id () const
    {
      return this->id_.get ();
    }

    assessment::id_type& assessment::
    id ()
    {
      return this->id_.get ();
    }

    void assessment::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void assessment::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const assessment::objective_id_type& assessment::
    objective_id () const
    {
      return this->objective_id_.get ();
    }

    assessment::objective_id_type& assessment::
    objective_id ()
    {
      return this->objective_id_.get ();
    }

    void assessment::
    objective_id (const objective_id_type& x)
    {
      this->objective_id_.set (x);
    }

    void assessment::
    objective_id (::std::unique_ptr< objective_id_type > x)
    {
      this->objective_id_.set (std::move (x));
    }

    const assessment::name_type& assessment::
    name () const
    {
      return this->name_.get ();
    }

    assessment::name_type& assessment::
    name ()
    {
      return this->name_.get ();
    }

    void assessment::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void assessment::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const assessment::description_type& assessment::
    description () const
    {
      return this->description_.get ();
    }

    assessment::description_type& assessment::
    description ()
    {
      return this->description_.get ();
    }

    void assessment::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void assessment::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const assessment::points_avaiable_type& assessment::
    points_avaiable () const
    {
      return this->points_avaiable_.get ();
    }

    assessment::points_avaiable_type& assessment::
    points_avaiable ()
    {
      return this->points_avaiable_.get ();
    }

    void assessment::
    points_avaiable (const points_avaiable_type& x)
    {
      this->points_avaiable_.set (x);
    }

    const assessment::criteria_type& assessment::
    criteria () const
    {
      return this->criteria_.get ();
    }

    assessment::criteria_type& assessment::
    criteria ()
    {
      return this->criteria_.get ();
    }

    void assessment::
    criteria (const criteria_type& x)
    {
      this->criteria_.set (x);
    }

    void assessment::
    criteria (::std::unique_ptr< criteria_type > x)
    {
      this->criteria_.set (std::move (x));
    }


    // medical_scenario
    // 

    const medical_scenario::id_type& medical_scenario::
    id () const
    {
      return this->id_.get ();
    }

    medical_scenario::id_type& medical_scenario::
    id ()
    {
      return this->id_.get ();
    }

    void medical_scenario::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void medical_scenario::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const medical_scenario::roles_type& medical_scenario::
    roles () const
    {
      return this->roles_.get ();
    }

    medical_scenario::roles_type& medical_scenario::
    roles ()
    {
      return this->roles_.get ();
    }

    void medical_scenario::
    roles (const roles_type& x)
    {
      this->roles_.set (x);
    }

    void medical_scenario::
    roles (::std::unique_ptr< roles_type > x)
    {
      this->roles_.set (std::move (x));
    }

    const medical_scenario::training_script_type& medical_scenario::
    training_script () const
    {
      return this->training_script_.get ();
    }

    medical_scenario::training_script_type& medical_scenario::
    training_script ()
    {
      return this->training_script_.get ();
    }

    void medical_scenario::
    training_script (const training_script_type& x)
    {
      this->training_script_.set (x);
    }

    void medical_scenario::
    training_script (::std::unique_ptr< training_script_type > x)
    {
      this->training_script_.set (std::move (x));
    }


    // role_list
    // 

    const role_list::role_sequence& role_list::
    role () const
    {
      return this->role_;
    }

    role_list::role_sequence& role_list::
    role ()
    {
      return this->role_;
    }

    void role_list::
    role (const role_sequence& s)
    {
      this->role_ = s;
    }


    // role
    // 

    const role::id_type& role::
    id () const
    {
      return this->id_.get ();
    }

    role::id_type& role::
    id ()
    {
      return this->id_.get ();
    }

    void role::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void role::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const role::name_type& role::
    name () const
    {
      return this->name_.get ();
    }

    role::name_type& role::
    name ()
    {
      return this->name_.get ();
    }

    void role::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void role::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const role::short_name_type& role::
    short_name () const
    {
      return this->short_name_.get ();
    }

    role::short_name_type& role::
    short_name ()
    {
      return this->short_name_.get ();
    }

    void role::
    short_name (const short_name_type& x)
    {
      this->short_name_.set (x);
    }

    void role::
    short_name (::std::unique_ptr< short_name_type > x)
    {
      this->short_name_.set (std::move (x));
    }

    const role::trauma_profile_ref_optional& role::
    trauma_profile_ref () const
    {
      return this->trauma_profile_ref_;
    }

    role::trauma_profile_ref_optional& role::
    trauma_profile_ref ()
    {
      return this->trauma_profile_ref_;
    }

    void role::
    trauma_profile_ref (const trauma_profile_ref_type& x)
    {
      this->trauma_profile_ref_.set (x);
    }

    void role::
    trauma_profile_ref (const trauma_profile_ref_optional& x)
    {
      this->trauma_profile_ref_ = x;
    }

    void role::
    trauma_profile_ref (::std::unique_ptr< trauma_profile_ref_type > x)
    {
      this->trauma_profile_ref_.set (std::move (x));
    }

    const role::description_type& role::
    description () const
    {
      return this->description_.get ();
    }

    role::description_type& role::
    description ()
    {
      return this->description_.get ();
    }

    void role::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void role::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }


    // role_ref_list
    // 

    const role_ref_list::role_ref_sequence& role_ref_list::
    role_ref () const
    {
      return this->role_ref_;
    }

    role_ref_list::role_ref_sequence& role_ref_list::
    role_ref ()
    {
      return this->role_ref_;
    }

    void role_ref_list::
    role_ref (const role_ref_sequence& s)
    {
      this->role_ref_ = s;
    }


    // item_list
    // 

    const item_list::item_sequence& item_list::
    item () const
    {
      return this->item_;
    }

    item_list::item_sequence& item_list::
    item ()
    {
      return this->item_;
    }

    void item_list::
    item (const item_sequence& s)
    {
      this->item_ = s;
    }


    // item
    // 

    const item::short_name_type& item::
    short_name () const
    {
      return this->short_name_.get ();
    }

    item::short_name_type& item::
    short_name ()
    {
      return this->short_name_.get ();
    }

    void item::
    short_name (const short_name_type& x)
    {
      this->short_name_.set (x);
    }

    void item::
    short_name (::std::unique_ptr< short_name_type > x)
    {
      this->short_name_.set (std::move (x));
    }

    const item::equipment_id_type& item::
    equipment_id () const
    {
      return this->equipment_id_.get ();
    }

    item::equipment_id_type& item::
    equipment_id ()
    {
      return this->equipment_id_.get ();
    }

    void item::
    equipment_id (const equipment_id_type& x)
    {
      this->equipment_id_.set (x);
    }

    void item::
    equipment_id (::std::unique_ptr< equipment_id_type > x)
    {
      this->equipment_id_.set (std::move (x));
    }

    const item::description_type& item::
    description () const
    {
      return this->description_.get ();
    }

    item::description_type& item::
    description ()
    {
      return this->description_.get ();
    }

    void item::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void item::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const item::properties_type& item::
    properties () const
    {
      return this->properties_.get ();
    }

    item::properties_type& item::
    properties ()
    {
      return this->properties_.get ();
    }

    void item::
    properties (const properties_type& x)
    {
      this->properties_.set (x);
    }

    void item::
    properties (::std::unique_ptr< properties_type > x)
    {
      this->properties_.set (std::move (x));
    }


    // scene_list
    // 

    const scene_list::scene_sequence& scene_list::
    scene () const
    {
      return this->scene_;
    }

    scene_list::scene_sequence& scene_list::
    scene ()
    {
      return this->scene_;
    }

    void scene_list::
    scene (const scene_sequence& s)
    {
      this->scene_ = s;
    }


    // scene
    // 

    const scene::location_id_type& scene::
    location_id () const
    {
      return this->location_id_.get ();
    }

    scene::location_id_type& scene::
    location_id ()
    {
      return this->location_id_.get ();
    }

    void scene::
    location_id (const location_id_type& x)
    {
      this->location_id_.set (x);
    }

    void scene::
    location_id (::std::unique_ptr< location_id_type > x)
    {
      this->location_id_.set (std::move (x));
    }

    const scene::name_type& scene::
    name () const
    {
      return this->name_.get ();
    }

    scene::name_type& scene::
    name ()
    {
      return this->name_.get ();
    }

    void scene::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void scene::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const scene::description_type& scene::
    description () const
    {
      return this->description_.get ();
    }

    scene::description_type& scene::
    description ()
    {
      return this->description_.get ();
    }

    void scene::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void scene::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const scene::time_of_day_type& scene::
    time_of_day () const
    {
      return this->time_of_day_.get ();
    }

    scene::time_of_day_type& scene::
    time_of_day ()
    {
      return this->time_of_day_.get ();
    }

    void scene::
    time_of_day (const time_of_day_type& x)
    {
      this->time_of_day_.set (x);
    }

    void scene::
    time_of_day (::std::unique_ptr< time_of_day_type > x)
    {
      this->time_of_day_.set (std::move (x));
    }

    const scene::time_in_simulation_type& scene::
    time_in_simulation () const
    {
      return this->time_in_simulation_.get ();
    }

    scene::time_in_simulation_type& scene::
    time_in_simulation ()
    {
      return this->time_in_simulation_.get ();
    }

    void scene::
    time_in_simulation (const time_in_simulation_type& x)
    {
      this->time_in_simulation_.set (x);
    }

    const scene::events_type& scene::
    events () const
    {
      return this->events_.get ();
    }

    scene::events_type& scene::
    events ()
    {
      return this->events_.get ();
    }

    void scene::
    events (const events_type& x)
    {
      this->events_.set (x);
    }

    void scene::
    events (::std::unique_ptr< events_type > x)
    {
      this->events_.set (std::move (x));
    }

    const scene::items_type& scene::
    items () const
    {
      return this->items_.get ();
    }

    scene::items_type& scene::
    items ()
    {
      return this->items_.get ();
    }

    void scene::
    items (const items_type& x)
    {
      this->items_.set (x);
    }

    void scene::
    items (::std::unique_ptr< items_type > x)
    {
      this->items_.set (std::move (x));
    }

    const scene::roles_type& scene::
    roles () const
    {
      return this->roles_.get ();
    }

    scene::roles_type& scene::
    roles ()
    {
      return this->roles_.get ();
    }

    void scene::
    roles (const roles_type& x)
    {
      this->roles_.set (x);
    }

    void scene::
    roles (::std::unique_ptr< roles_type > x)
    {
      this->roles_.set (std::move (x));
    }


    // event_list
    // 

    const event_list::event_sequence& event_list::
    event () const
    {
      return this->event_;
    }

    event_list::event_sequence& event_list::
    event ()
    {
      return this->event_;
    }

    void event_list::
    event (const event_sequence& s)
    {
      this->event_ = s;
    }


    // event
    // 

    const event::id_type& event::
    id () const
    {
      return this->id_.get ();
    }

    event::id_type& event::
    id ()
    {
      return this->id_.get ();
    }

    void event::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void event::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }

    const event::name_type& event::
    name () const
    {
      return this->name_.get ();
    }

    event::name_type& event::
    name ()
    {
      return this->name_.get ();
    }

    void event::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void event::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const event::category_type& event::
    category () const
    {
      return this->category_.get ();
    }

    event::category_type& event::
    category ()
    {
      return this->category_.get ();
    }

    void event::
    category (const category_type& x)
    {
      this->category_.set (x);
    }

    void event::
    category (::std::unique_ptr< category_type > x)
    {
      this->category_.set (std::move (x));
    }

    const event::fidelity_type& event::
    fidelity () const
    {
      return this->fidelity_.get ();
    }

    event::fidelity_type& event::
    fidelity ()
    {
      return this->fidelity_.get ();
    }

    void event::
    fidelity (const fidelity_type& x)
    {
      this->fidelity_.set (x);
    }

    void event::
    fidelity (::std::unique_ptr< fidelity_type > x)
    {
      this->fidelity_.set (std::move (x));
    }

    const event::actor_1_type& event::
    actor_1 () const
    {
      return this->actor_1_.get ();
    }

    event::actor_1_type& event::
    actor_1 ()
    {
      return this->actor_1_.get ();
    }

    void event::
    actor_1 (const actor_1_type& x)
    {
      this->actor_1_.set (x);
    }

    void event::
    actor_1 (::std::unique_ptr< actor_1_type > x)
    {
      this->actor_1_.set (std::move (x));
    }

    const event::actor_2_type& event::
    actor_2 () const
    {
      return this->actor_2_.get ();
    }

    event::actor_2_type& event::
    actor_2 ()
    {
      return this->actor_2_.get ();
    }

    void event::
    actor_2 (const actor_2_type& x)
    {
      this->actor_2_.set (x);
    }

    void event::
    actor_2 (::std::unique_ptr< actor_2_type > x)
    {
      this->actor_2_.set (std::move (x));
    }

    const event::equipment_type& event::
    equipment () const
    {
      return this->equipment_.get ();
    }

    event::equipment_type& event::
    equipment ()
    {
      return this->equipment_.get ();
    }

    void event::
    equipment (const equipment_type& x)
    {
      this->equipment_.set (x);
    }

    void event::
    equipment (::std::unique_ptr< equipment_type > x)
    {
      this->equipment_.set (std::move (x));
    }

    const event::details_type& event::
    details () const
    {
      return this->details_.get ();
    }

    event::details_type& event::
    details ()
    {
      return this->details_.get ();
    }

    void event::
    details (const details_type& x)
    {
      this->details_.set (x);
    }

    void event::
    details (::std::unique_ptr< details_type > x)
    {
      this->details_.set (std::move (x));
    }

    const event::description_type& event::
    description () const
    {
      return this->description_.get ();
    }

    event::description_type& event::
    description ()
    {
      return this->description_.get ();
    }

    void event::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void event::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }


    // event_category_enum
    // 

    event_category_enum::
    event_category_enum (value v)
    : ::xml_schema::string (_xsd_event_category_enum_literals_[v])
    {
    }

    event_category_enum::
    event_category_enum (const char* v)
    : ::xml_schema::string (v)
    {
    }

    event_category_enum::
    event_category_enum (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    event_category_enum::
    event_category_enum (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    event_category_enum::
    event_category_enum (const event_category_enum& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    event_category_enum& event_category_enum::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_event_category_enum_literals_[v]);

      return *this;
    }


    // event_fidelity_enum
    // 

    event_fidelity_enum::
    event_fidelity_enum (value v)
    : ::xml_schema::string (_xsd_event_fidelity_enum_literals_[v])
    {
    }

    event_fidelity_enum::
    event_fidelity_enum (const char* v)
    : ::xml_schema::string (v)
    {
    }

    event_fidelity_enum::
    event_fidelity_enum (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    event_fidelity_enum::
    event_fidelity_enum (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    event_fidelity_enum::
    event_fidelity_enum (const event_fidelity_enum& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    event_fidelity_enum& event_fidelity_enum::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_event_fidelity_enum_literals_[v]);

      return *this;
    }


    // citation_list
    // 

    const citation_list::citation_sequence& citation_list::
    citation () const
    {
      return this->citation_;
    }

    citation_list::citation_sequence& citation_list::
    citation ()
    {
      return this->citation_;
    }

    void citation_list::
    citation (const citation_sequence& s)
    {
      this->citation_ = s;
    }


    // citation
    // 

    const citation::uuid_type& citation::
    uuid () const
    {
      return this->uuid_.get ();
    }

    citation::uuid_type& citation::
    uuid ()
    {
      return this->uuid_.get ();
    }

    void citation::
    uuid (const uuid_type& x)
    {
      this->uuid_.set (x);
    }

    void citation::
    uuid (::std::unique_ptr< uuid_type > x)
    {
      this->uuid_.set (std::move (x));
    }

    const citation::key_optional& citation::
    key () const
    {
      return this->key_;
    }

    citation::key_optional& citation::
    key ()
    {
      return this->key_;
    }

    void citation::
    key (const key_type& x)
    {
      this->key_.set (x);
    }

    void citation::
    key (const key_optional& x)
    {
      this->key_ = x;
    }

    void citation::
    key (::std::unique_ptr< key_type > x)
    {
      this->key_.set (std::move (x));
    }

    const citation::authors_sequence& citation::
    authors () const
    {
      return this->authors_;
    }

    citation::authors_sequence& citation::
    authors ()
    {
      return this->authors_;
    }

    void citation::
    authors (const authors_sequence& s)
    {
      this->authors_ = s;
    }

    const citation::title_type& citation::
    title () const
    {
      return this->title_.get ();
    }

    citation::title_type& citation::
    title ()
    {
      return this->title_.get ();
    }

    void citation::
    title (const title_type& x)
    {
      this->title_.set (x);
    }

    void citation::
    title (::std::unique_ptr< title_type > x)
    {
      this->title_.set (std::move (x));
    }

    const citation::date_type& citation::
    date () const
    {
      return this->date_.get ();
    }

    citation::date_type& citation::
    date ()
    {
      return this->date_.get ();
    }

    void citation::
    date (const date_type& x)
    {
      this->date_.set (x);
    }

    void citation::
    date (::std::unique_ptr< date_type > x)
    {
      this->date_.set (std::move (x));
    }

    const citation::page_optional& citation::
    page () const
    {
      return this->page_;
    }

    citation::page_optional& citation::
    page ()
    {
      return this->page_;
    }

    void citation::
    page (const page_type& x)
    {
      this->page_.set (x);
    }

    void citation::
    page (const page_optional& x)
    {
      this->page_ = x;
    }

    void citation::
    page (::std::unique_ptr< page_type > x)
    {
      this->page_.set (std::move (x));
    }

    const citation::accessed_optional& citation::
    accessed () const
    {
      return this->accessed_;
    }

    citation::accessed_optional& citation::
    accessed ()
    {
      return this->accessed_;
    }

    void citation::
    accessed (const accessed_type& x)
    {
      this->accessed_.set (x);
    }

    void citation::
    accessed (const accessed_optional& x)
    {
      this->accessed_ = x;
    }

    void citation::
    accessed (::std::unique_ptr< accessed_type > x)
    {
      this->accessed_.set (std::move (x));
    }


    // properties_list
    // 

    const properties_list::property_sequence& properties_list::
    property () const
    {
      return this->property_;
    }

    properties_list::property_sequence& properties_list::
    property ()
    {
      return this->property_;
    }

    void properties_list::
    property (const property_sequence& s)
    {
      this->property_ = s;
    }


    // property
    // 

    const property::name_type& property::
    name () const
    {
      return this->name_.get ();
    }

    property::name_type& property::
    name ()
    {
      return this->name_.get ();
    }

    void property::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void property::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const property::type_type& property::
    type () const
    {
      return this->type_.get ();
    }

    property::type_type& property::
    type ()
    {
      return this->type_.get ();
    }

    void property::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void property::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }


    // property_value_list
    // 

    const property_value_list::value_sequence& property_value_list::
    value () const
    {
      return this->value_;
    }

    property_value_list::value_sequence& property_value_list::
    value ()
    {
      return this->value_;
    }

    void property_value_list::
    value (const value_sequence& s)
    {
      this->value_ = s;
    }


    // property_value
    // 

    const property_value::name_type& property_value::
    name () const
    {
      return this->name_.get ();
    }

    property_value::name_type& property_value::
    name ()
    {
      return this->name_.get ();
    }

    void property_value::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void property_value::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const property_value::value_type& property_value::
    value () const
    {
      return this->value_.get ();
    }

    property_value::value_type& property_value::
    value ()
    {
      return this->value_.get ();
    }

    void property_value::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void property_value::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }


    // relates_to
    // 

    const relates_to::treatment_plans_type& relates_to::
    treatment_plans () const
    {
      return this->treatment_plans_.get ();
    }

    relates_to::treatment_plans_type& relates_to::
    treatment_plans ()
    {
      return this->treatment_plans_.get ();
    }

    void relates_to::
    treatment_plans (const treatment_plans_type& x)
    {
      this->treatment_plans_.set (x);
    }

    void relates_to::
    treatment_plans (::std::unique_ptr< treatment_plans_type > x)
    {
      this->treatment_plans_.set (std::move (x));
    }

    const relates_to::trauma_profiles_type& relates_to::
    trauma_profiles () const
    {
      return this->trauma_profiles_.get ();
    }

    relates_to::trauma_profiles_type& relates_to::
    trauma_profiles ()
    {
      return this->trauma_profiles_.get ();
    }

    void relates_to::
    trauma_profiles (const trauma_profiles_type& x)
    {
      this->trauma_profiles_.set (x);
    }

    void relates_to::
    trauma_profiles (::std::unique_ptr< trauma_profiles_type > x)
    {
      this->trauma_profiles_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace pfc
{
  namespace schema
  {
    // summary
    //

    summary::
    summary ()
    : ::xml_schema::type (),
      title_ (this),
      description_ (this),
      version_ (this),
      classification_ (this),
      keywords_ (this),
      domain_ (this),
      limitations_ (this)
    {
    }

    summary::
    summary (const summary& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      title_ (x.title_, f, this),
      description_ (x.description_, f, this),
      version_ (x.version_, f, this),
      classification_ (x.classification_, f, this),
      keywords_ (x.keywords_, f, this),
      domain_ (x.domain_, f, this),
      limitations_ (x.limitations_, f, this)
    {
    }

    summary::
    summary (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      title_ (this),
      description_ (this),
      version_ (this),
      classification_ (this),
      keywords_ (this),
      domain_ (this),
      limitations_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void summary::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // title
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "title",
              "",
              &::xsd::cxx::tree::factory_impl< title_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->title_)
            {
              ::std::unique_ptr< title_type > r (
                dynamic_cast< title_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->title_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->description_)
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // version
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "version",
              "",
              &::xsd::cxx::tree::factory_impl< version_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->version_)
            {
              ::std::unique_ptr< version_type > r (
                dynamic_cast< version_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->version_.set (::std::move (r));
              continue;
            }
          }
        }

        // classification
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "classification",
              "",
              &::xsd::cxx::tree::factory_impl< classification_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->classification_)
            {
              ::std::unique_ptr< classification_type > r (
                dynamic_cast< classification_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->classification_.set (::std::move (r));
              continue;
            }
          }
        }

        // keywords
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "keywords",
              "",
              &::xsd::cxx::tree::factory_impl< keywords_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->keywords_)
            {
              ::std::unique_ptr< keywords_type > r (
                dynamic_cast< keywords_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->keywords_.set (::std::move (r));
              continue;
            }
          }
        }

        // domain
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "domain",
              "",
              &::xsd::cxx::tree::factory_impl< domain_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->domain_)
            {
              ::std::unique_ptr< domain_type > r (
                dynamic_cast< domain_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->domain_.set (::std::move (r));
              continue;
            }
          }
        }

        // limitations
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "limitations",
              "",
              &::xsd::cxx::tree::factory_impl< limitations_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->limitations_)
            {
              ::std::unique_ptr< limitations_type > r (
                dynamic_cast< limitations_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->limitations_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    summary* summary::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class summary (*this, f, c);
    }

    summary& summary::
    operator= (const summary& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->title_ = x.title_;
        this->description_ = x.description_;
        this->version_ = x.version_;
        this->classification_ = x.classification_;
        this->keywords_ = x.keywords_;
        this->domain_ = x.domain_;
        this->limitations_ = x.limitations_;
      }

      return *this;
    }

    summary::
    ~summary ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, summary >
    _xsd_summary_type_factory_init (
      "summary",
      "com:ara:pfc:training:1");

    // author
    //

    author::
    author ()
    : ::xml_schema::type (),
      first_name_ (this),
      last_name_ (this),
      organization_ (this),
      phone_number_ (this),
      email_ (this),
      zip_ (this),
      state_ (this),
      country_ (this)
    {
    }

    author::
    author (const author& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      first_name_ (x.first_name_, f, this),
      last_name_ (x.last_name_, f, this),
      organization_ (x.organization_, f, this),
      phone_number_ (x.phone_number_, f, this),
      email_ (x.email_, f, this),
      zip_ (x.zip_, f, this),
      state_ (x.state_, f, this),
      country_ (x.country_, f, this)
    {
    }

    author::
    author (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      first_name_ (this),
      last_name_ (this),
      organization_ (this),
      phone_number_ (this),
      email_ (this),
      zip_ (this),
      state_ (this),
      country_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void author::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // first_name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "first_name",
              "",
              &::xsd::cxx::tree::factory_impl< first_name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->first_name_)
            {
              ::std::unique_ptr< first_name_type > r (
                dynamic_cast< first_name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->first_name_.set (::std::move (r));
              continue;
            }
          }
        }

        // last_name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "last_name",
              "",
              &::xsd::cxx::tree::factory_impl< last_name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->last_name_)
            {
              ::std::unique_ptr< last_name_type > r (
                dynamic_cast< last_name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->last_name_.set (::std::move (r));
              continue;
            }
          }
        }

        // organization
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "organization",
              "",
              &::xsd::cxx::tree::factory_impl< organization_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->organization_)
            {
              ::std::unique_ptr< organization_type > r (
                dynamic_cast< organization_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->organization_.set (::std::move (r));
              continue;
            }
          }
        }

        // phone_number
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "phone_number",
              "",
              &::xsd::cxx::tree::factory_impl< phone_number_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->phone_number_)
            {
              ::std::unique_ptr< phone_number_type > r (
                dynamic_cast< phone_number_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->phone_number_.set (::std::move (r));
              continue;
            }
          }
        }

        // email
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "email",
              "",
              &::xsd::cxx::tree::factory_impl< email_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->email_)
            {
              ::std::unique_ptr< email_type > r (
                dynamic_cast< email_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->email_.set (::std::move (r));
              continue;
            }
          }
        }

        // zip
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "zip",
              "",
              &::xsd::cxx::tree::factory_impl< zip_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->zip_)
            {
              ::std::unique_ptr< zip_type > r (
                dynamic_cast< zip_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->zip_.set (::std::move (r));
              continue;
            }
          }
        }

        // state
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "state",
              "",
              &::xsd::cxx::tree::factory_impl< state_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->state_)
            {
              ::std::unique_ptr< state_type > r (
                dynamic_cast< state_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->state_.set (::std::move (r));
              continue;
            }
          }
        }

        // country
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "country",
              "",
              &::xsd::cxx::tree::factory_impl< country_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->country_)
            {
              ::std::unique_ptr< country_type > r (
                dynamic_cast< country_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->country_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    author* author::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class author (*this, f, c);
    }

    author& author::
    operator= (const author& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->first_name_ = x.first_name_;
        this->last_name_ = x.last_name_;
        this->organization_ = x.organization_;
        this->phone_number_ = x.phone_number_;
        this->email_ = x.email_;
        this->zip_ = x.zip_;
        this->state_ = x.state_;
        this->country_ = x.country_;
      }

      return *this;
    }

    author::
    ~author ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, author >
    _xsd_author_type_factory_init (
      "author",
      "com:ara:pfc:training:1");

    // equipment_definition_list
    //

    equipment_definition_list::
    equipment_definition_list ()
    : ::xml_schema::type (),
      equipment_ (this)
    {
    }

    equipment_definition_list::
    equipment_definition_list (const equipment_definition_list& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      equipment_ (x.equipment_, f, this)
    {
    }

    equipment_definition_list::
    equipment_definition_list (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      equipment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void equipment_definition_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // equipment
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "equipment",
              "",
              &::xsd::cxx::tree::factory_impl< equipment_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< equipment_type > r (
              dynamic_cast< equipment_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->equipment_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    equipment_definition_list* equipment_definition_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class equipment_definition_list (*this, f, c);
    }

    equipment_definition_list& equipment_definition_list::
    operator= (const equipment_definition_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->equipment_ = x.equipment_;
      }

      return *this;
    }

    equipment_definition_list::
    ~equipment_definition_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, equipment_definition_list >
    _xsd_equipment_definition_list_type_factory_init (
      "equipment-definition-list",
      "com:ara:pfc:training:1");

    // equipment
    //

    equipment::
    equipment (const id_type& id,
               const name_type& name,
               const description_type& description,
               const citations_type& citations)
    : ::xml_schema::type (),
      id_ (id, this),
      name_ (name, this),
      type_ (this),
      description_ (description, this),
      citations_ (citations, this),
      image_ (this)
    {
    }

    equipment::
    equipment (const id_type& id,
               const name_type& name,
               const description_type& description,
               ::std::unique_ptr< citations_type > citations)
    : ::xml_schema::type (),
      id_ (id, this),
      name_ (name, this),
      type_ (this),
      description_ (description, this),
      citations_ (std::move (citations), this),
      image_ (this)
    {
    }

    equipment::
    equipment (::std::unique_ptr< id_type > id,
               ::std::unique_ptr< name_type > name,
               ::std::unique_ptr< description_type > description,
               ::std::unique_ptr< citations_type > citations)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      name_ (std::move (name), this),
      type_ (this),
      description_ (std::move (description), this),
      citations_ (std::move (citations), this),
      image_ (this)
    {
    }

    equipment::
    equipment (const equipment& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this),
      description_ (x.description_, f, this),
      citations_ (x.citations_, f, this),
      image_ (x.image_, f, this)
    {
    }

    equipment::
    equipment (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      name_ (this),
      type_ (this),
      description_ (this),
      citations_ (this),
      image_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void equipment::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // type
        //
        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          if (!this->type_)
          {
            this->type_.set (type_traits::create (i, f, this));
            continue;
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // citations
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "citations",
              "",
              &::xsd::cxx::tree::factory_impl< citations_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!citations_.present ())
            {
              ::std::unique_ptr< citations_type > r (
                dynamic_cast< citations_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->citations_.set (::std::move (r));
              continue;
            }
          }
        }

        // image
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "image",
              "",
              &::xsd::cxx::tree::factory_impl< image_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->image_)
            {
              ::std::unique_ptr< image_type > r (
                dynamic_cast< image_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->image_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!citations_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "citations",
          "");
      }
    }

    equipment* equipment::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class equipment (*this, f, c);
    }

    equipment& equipment::
    operator= (const equipment& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->name_ = x.name_;
        this->type_ = x.type_;
        this->description_ = x.description_;
        this->citations_ = x.citations_;
        this->image_ = x.image_;
      }

      return *this;
    }

    equipment::
    ~equipment ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, equipment >
    _xsd_equipment_type_factory_init (
      "equipment",
      "com:ara:pfc:training:1");

    // trauma_definition_list
    //

    trauma_definition_list::
    trauma_definition_list ()
    : ::xml_schema::type (),
      trauma_ (this)
    {
    }

    trauma_definition_list::
    trauma_definition_list (const trauma_definition_list& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      trauma_ (x.trauma_, f, this)
    {
    }

    trauma_definition_list::
    trauma_definition_list (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      trauma_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void trauma_definition_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // trauma
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "trauma",
              "",
              &::xsd::cxx::tree::factory_impl< trauma_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< trauma_type > r (
              dynamic_cast< trauma_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->trauma_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    trauma_definition_list* trauma_definition_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class trauma_definition_list (*this, f, c);
    }

    trauma_definition_list& trauma_definition_list::
    operator= (const trauma_definition_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->trauma_ = x.trauma_;
      }

      return *this;
    }

    trauma_definition_list::
    ~trauma_definition_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, trauma_definition_list >
    _xsd_trauma_definition_list_type_factory_init (
      "trauma-definition-list",
      "com:ara:pfc:training:1");

    // trauma
    //

    trauma::
    trauma (const id_type& id,
            const medical_name_type& medical_name,
            const citations_type& citations,
            const description_type& description,
            const severity_range_type& severity_range)
    : ::xml_schema::type (),
      id_ (id, this),
      common_name_ (this),
      medical_name_ (medical_name, this),
      citations_ (citations, this),
      description_ (description, this),
      severity_range_ (severity_range, this)
    {
    }

    trauma::
    trauma (const id_type& id,
            const medical_name_type& medical_name,
            ::std::unique_ptr< citations_type > citations,
            const description_type& description,
            ::std::unique_ptr< severity_range_type > severity_range)
    : ::xml_schema::type (),
      id_ (id, this),
      common_name_ (this),
      medical_name_ (medical_name, this),
      citations_ (std::move (citations), this),
      description_ (description, this),
      severity_range_ (std::move (severity_range), this)
    {
    }

    trauma::
    trauma (::std::unique_ptr< id_type > id,
            ::std::unique_ptr< medical_name_type > medical_name,
            ::std::unique_ptr< citations_type > citations,
            ::std::unique_ptr< description_type > description,
            ::std::unique_ptr< severity_range_type > severity_range)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      common_name_ (this),
      medical_name_ (std::move (medical_name), this),
      citations_ (std::move (citations), this),
      description_ (std::move (description), this),
      severity_range_ (std::move (severity_range), this)
    {
    }

    trauma::
    trauma (const trauma& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      common_name_ (x.common_name_, f, this),
      medical_name_ (x.medical_name_, f, this),
      citations_ (x.citations_, f, this),
      description_ (x.description_, f, this),
      severity_range_ (x.severity_range_, f, this)
    {
    }

    trauma::
    trauma (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      common_name_ (this),
      medical_name_ (this),
      citations_ (this),
      description_ (this),
      severity_range_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void trauma::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // common-name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "common-name",
              "",
              &::xsd::cxx::tree::factory_impl< common_name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->common_name_)
            {
              ::std::unique_ptr< common_name_type > r (
                dynamic_cast< common_name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->common_name_.set (::std::move (r));
              continue;
            }
          }
        }

        // medical-name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "medical-name",
              "",
              &::xsd::cxx::tree::factory_impl< medical_name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!medical_name_.present ())
            {
              ::std::unique_ptr< medical_name_type > r (
                dynamic_cast< medical_name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->medical_name_.set (::std::move (r));
              continue;
            }
          }
        }

        // citations
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "citations",
              "",
              &::xsd::cxx::tree::factory_impl< citations_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!citations_.present ())
            {
              ::std::unique_ptr< citations_type > r (
                dynamic_cast< citations_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->citations_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // severity-range
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "severity-range",
              "",
              &::xsd::cxx::tree::factory_impl< severity_range_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!severity_range_.present ())
            {
              ::std::unique_ptr< severity_range_type > r (
                dynamic_cast< severity_range_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->severity_range_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!medical_name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "medical-name",
          "");
      }

      if (!citations_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "citations",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!severity_range_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "severity-range",
          "");
      }
    }

    trauma* trauma::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class trauma (*this, f, c);
    }

    trauma& trauma::
    operator= (const trauma& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->common_name_ = x.common_name_;
        this->medical_name_ = x.medical_name_;
        this->citations_ = x.citations_;
        this->description_ = x.description_;
        this->severity_range_ = x.severity_range_;
      }

      return *this;
    }

    trauma::
    ~trauma ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, trauma >
    _xsd_trauma_type_factory_init (
      "trauma",
      "com:ara:pfc:training:1");

    // trauma_severity_range
    //

    trauma_severity_range::
    trauma_severity_range ()
    : ::xml_schema::type (),
      numeric_range_ (this),
      token_range_ (this)
    {
    }

    trauma_severity_range::
    trauma_severity_range (const trauma_severity_range& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      numeric_range_ (x.numeric_range_, f, this),
      token_range_ (x.token_range_, f, this)
    {
    }

    trauma_severity_range::
    trauma_severity_range (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      numeric_range_ (this),
      token_range_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void trauma_severity_range::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // numeric-range
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "numeric-range",
              "",
              &::xsd::cxx::tree::factory_impl< numeric_range_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->numeric_range_)
            {
              ::std::unique_ptr< numeric_range_type > r (
                dynamic_cast< numeric_range_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->numeric_range_.set (::std::move (r));
              continue;
            }
          }
        }

        // token-range
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "token-range",
              "",
              &::xsd::cxx::tree::factory_impl< token_range_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->token_range_)
            {
              ::std::unique_ptr< token_range_type > r (
                dynamic_cast< token_range_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->token_range_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    trauma_severity_range* trauma_severity_range::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class trauma_severity_range (*this, f, c);
    }

    trauma_severity_range& trauma_severity_range::
    operator= (const trauma_severity_range& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->numeric_range_ = x.numeric_range_;
        this->token_range_ = x.token_range_;
      }

      return *this;
    }

    trauma_severity_range::
    ~trauma_severity_range ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, trauma_severity_range >
    _xsd_trauma_severity_range_type_factory_init (
      "trauma-severity-range",
      "com:ara:pfc:training:1");

    // numeric_range
    //

    numeric_range::
    numeric_range (const lower_bound_type& lower_bound,
                   const upper_bound_type& upper_bound)
    : ::xml_schema::type (),
      lower_bound_ (lower_bound, this),
      upper_bound_ (upper_bound, this),
      median_ (this),
      unit_ (this)
    {
    }

    numeric_range::
    numeric_range (const numeric_range& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      lower_bound_ (x.lower_bound_, f, this),
      upper_bound_ (x.upper_bound_, f, this),
      median_ (x.median_, f, this),
      unit_ (x.unit_, f, this)
    {
    }

    numeric_range::
    numeric_range (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      lower_bound_ (this),
      upper_bound_ (this),
      median_ (this),
      unit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void numeric_range::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // lower_bound
        //
        if (n.name () == "lower_bound" && n.namespace_ ().empty ())
        {
          if (!lower_bound_.present ())
          {
            this->lower_bound_.set (lower_bound_traits::create (i, f, this));
            continue;
          }
        }

        // upper_bound
        //
        if (n.name () == "upper_bound" && n.namespace_ ().empty ())
        {
          if (!upper_bound_.present ())
          {
            this->upper_bound_.set (upper_bound_traits::create (i, f, this));
            continue;
          }
        }

        // median
        //
        if (n.name () == "median" && n.namespace_ ().empty ())
        {
          if (!this->median_)
          {
            this->median_.set (median_traits::create (i, f, this));
            continue;
          }
        }

        // unit
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "unit",
              "",
              &::xsd::cxx::tree::factory_impl< unit_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->unit_)
            {
              ::std::unique_ptr< unit_type > r (
                dynamic_cast< unit_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->unit_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!lower_bound_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "lower_bound",
          "");
      }

      if (!upper_bound_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "upper_bound",
          "");
      }
    }

    numeric_range* numeric_range::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class numeric_range (*this, f, c);
    }

    numeric_range& numeric_range::
    operator= (const numeric_range& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->lower_bound_ = x.lower_bound_;
        this->upper_bound_ = x.upper_bound_;
        this->median_ = x.median_;
        this->unit_ = x.unit_;
      }

      return *this;
    }

    numeric_range::
    ~numeric_range ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, numeric_range >
    _xsd_numeric_range_type_factory_init (
      "numeric-range",
      "com:ara:pfc:training:1");

    // token_range
    //

    token_range::
    token_range ()
    : ::xml_schema::type (),
      token_ (this)
    {
    }

    token_range::
    token_range (const token_range& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      token_ (x.token_, f, this)
    {
    }

    token_range::
    token_range (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      token_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void token_range::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // token
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "token",
              "",
              &::xsd::cxx::tree::factory_impl< token_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< token_type > r (
              dynamic_cast< token_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->token_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    token_range* token_range::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class token_range (*this, f, c);
    }

    token_range& token_range::
    operator= (const token_range& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->token_ = x.token_;
      }

      return *this;
    }

    token_range::
    ~token_range ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, token_range >
    _xsd_token_range_type_factory_init (
      "token-range",
      "com:ara:pfc:training:1");

    // citation_ref_list
    //

    citation_ref_list::
    citation_ref_list ()
    : ::xml_schema::type (),
      citation_ref_ (this)
    {
    }

    citation_ref_list::
    citation_ref_list (const citation_ref_list& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      citation_ref_ (x.citation_ref_, f, this)
    {
    }

    citation_ref_list::
    citation_ref_list (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      citation_ref_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void citation_ref_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // citation-ref
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "citation-ref",
              "",
              &::xsd::cxx::tree::factory_impl< citation_ref_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< citation_ref_type > r (
              dynamic_cast< citation_ref_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->citation_ref_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    citation_ref_list* citation_ref_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class citation_ref_list (*this, f, c);
    }

    citation_ref_list& citation_ref_list::
    operator= (const citation_ref_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->citation_ref_ = x.citation_ref_;
      }

      return *this;
    }

    citation_ref_list::
    ~citation_ref_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, citation_ref_list >
    _xsd_citation_ref_list_type_factory_init (
      "citation-ref-list",
      "com:ara:pfc:training:1");

    // treatment_plan_definition_list
    //

    treatment_plan_definition_list::
    treatment_plan_definition_list ()
    : ::xml_schema::type (),
      treatment_plan_ (this)
    {
    }

    treatment_plan_definition_list::
    treatment_plan_definition_list (const treatment_plan_definition_list& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      treatment_plan_ (x.treatment_plan_, f, this)
    {
    }

    treatment_plan_definition_list::
    treatment_plan_definition_list (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      treatment_plan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void treatment_plan_definition_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // treatment-plan
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "treatment-plan",
              "",
              &::xsd::cxx::tree::factory_impl< treatment_plan_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< treatment_plan_type > r (
              dynamic_cast< treatment_plan_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->treatment_plan_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    treatment_plan_definition_list* treatment_plan_definition_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class treatment_plan_definition_list (*this, f, c);
    }

    treatment_plan_definition_list& treatment_plan_definition_list::
    operator= (const treatment_plan_definition_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->treatment_plan_ = x.treatment_plan_;
      }

      return *this;
    }

    treatment_plan_definition_list::
    ~treatment_plan_definition_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, treatment_plan_definition_list >
    _xsd_treatment_plan_definition_list_type_factory_init (
      "treatment-plan-definition-list",
      "com:ara:pfc:training:1");

    // treatment_plan
    //

    treatment_plan::
    treatment_plan (const id_type& id,
                    const description_type& description,
                    const required_equipment_type& required_equipment,
                    const references_type& references)
    : ::xml_schema::type (),
      id_ (id, this),
      common_name_ (this),
      medical_name_ (this),
      description_ (description, this),
      required_equipment_ (required_equipment, this),
      references_ (references, this)
    {
    }

    treatment_plan::
    treatment_plan (const id_type& id,
                    const description_type& description,
                    ::std::unique_ptr< required_equipment_type > required_equipment,
                    ::std::unique_ptr< references_type > references)
    : ::xml_schema::type (),
      id_ (id, this),
      common_name_ (this),
      medical_name_ (this),
      description_ (description, this),
      required_equipment_ (std::move (required_equipment), this),
      references_ (std::move (references), this)
    {
    }

    treatment_plan::
    treatment_plan (::std::unique_ptr< id_type > id,
                    ::std::unique_ptr< description_type > description,
                    ::std::unique_ptr< required_equipment_type > required_equipment,
                    ::std::unique_ptr< references_type > references)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      common_name_ (this),
      medical_name_ (this),
      description_ (std::move (description), this),
      required_equipment_ (std::move (required_equipment), this),
      references_ (std::move (references), this)
    {
    }

    treatment_plan::
    treatment_plan (const treatment_plan& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      common_name_ (x.common_name_, f, this),
      medical_name_ (x.medical_name_, f, this),
      description_ (x.description_, f, this),
      required_equipment_ (x.required_equipment_, f, this),
      references_ (x.references_, f, this)
    {
    }

    treatment_plan::
    treatment_plan (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      common_name_ (this),
      medical_name_ (this),
      description_ (this),
      required_equipment_ (this),
      references_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void treatment_plan::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // common-name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "common-name",
              "",
              &::xsd::cxx::tree::factory_impl< common_name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->common_name_)
            {
              ::std::unique_ptr< common_name_type > r (
                dynamic_cast< common_name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->common_name_.set (::std::move (r));
              continue;
            }
          }
        }

        // medical-name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "medical-name",
              "",
              &::xsd::cxx::tree::factory_impl< medical_name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->medical_name_)
            {
              ::std::unique_ptr< medical_name_type > r (
                dynamic_cast< medical_name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->medical_name_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // required-equipment
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "required-equipment",
              "",
              &::xsd::cxx::tree::factory_impl< required_equipment_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!required_equipment_.present ())
            {
              ::std::unique_ptr< required_equipment_type > r (
                dynamic_cast< required_equipment_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->required_equipment_.set (::std::move (r));
              continue;
            }
          }
        }

        // references
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "references",
              "",
              &::xsd::cxx::tree::factory_impl< references_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!references_.present ())
            {
              ::std::unique_ptr< references_type > r (
                dynamic_cast< references_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->references_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!required_equipment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "required-equipment",
          "");
      }

      if (!references_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "references",
          "");
      }
    }

    treatment_plan* treatment_plan::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class treatment_plan (*this, f, c);
    }

    treatment_plan& treatment_plan::
    operator= (const treatment_plan& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->common_name_ = x.common_name_;
        this->medical_name_ = x.medical_name_;
        this->description_ = x.description_;
        this->required_equipment_ = x.required_equipment_;
        this->references_ = x.references_;
      }

      return *this;
    }

    treatment_plan::
    ~treatment_plan ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, treatment_plan >
    _xsd_treatment_plan_type_factory_init (
      "treatment-plan",
      "com:ara:pfc:training:1");

    // equipment_ref_list
    //

    equipment_ref_list::
    equipment_ref_list ()
    : ::xml_schema::type (),
      equipment_refs_ (this)
    {
    }

    equipment_ref_list::
    equipment_ref_list (const equipment_ref_list& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      equipment_refs_ (x.equipment_refs_, f, this)
    {
    }

    equipment_ref_list::
    equipment_ref_list (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      equipment_refs_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void equipment_ref_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // equipment-refs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "equipment-refs",
              "",
              &::xsd::cxx::tree::factory_impl< equipment_refs_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< equipment_refs_type > r (
              dynamic_cast< equipment_refs_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->equipment_refs_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    equipment_ref_list* equipment_ref_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class equipment_ref_list (*this, f, c);
    }

    equipment_ref_list& equipment_ref_list::
    operator= (const equipment_ref_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->equipment_refs_ = x.equipment_refs_;
      }

      return *this;
    }

    equipment_ref_list::
    ~equipment_ref_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, equipment_ref_list >
    _xsd_equipment_ref_list_type_factory_init (
      "equipment-ref-list",
      "com:ara:pfc:training:1");

    // medical_reference_list
    //

    medical_reference_list::
    medical_reference_list (const citations_type& citations,
                            const cpgs_type& cpgs)
    : ::xml_schema::type (),
      citations_ (citations, this),
      cpgs_ (cpgs, this)
    {
    }

    medical_reference_list::
    medical_reference_list (::std::unique_ptr< citations_type > citations,
                            ::std::unique_ptr< cpgs_type > cpgs)
    : ::xml_schema::type (),
      citations_ (std::move (citations), this),
      cpgs_ (std::move (cpgs), this)
    {
    }

    medical_reference_list::
    medical_reference_list (const medical_reference_list& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      citations_ (x.citations_, f, this),
      cpgs_ (x.cpgs_, f, this)
    {
    }

    medical_reference_list::
    medical_reference_list (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      citations_ (this),
      cpgs_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void medical_reference_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // citations
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "citations",
              "",
              &::xsd::cxx::tree::factory_impl< citations_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!citations_.present ())
            {
              ::std::unique_ptr< citations_type > r (
                dynamic_cast< citations_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->citations_.set (::std::move (r));
              continue;
            }
          }
        }

        // cpgs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "cpgs",
              "",
              &::xsd::cxx::tree::factory_impl< cpgs_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!cpgs_.present ())
            {
              ::std::unique_ptr< cpgs_type > r (
                dynamic_cast< cpgs_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->cpgs_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!citations_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "citations",
          "");
      }

      if (!cpgs_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "cpgs",
          "");
      }
    }

    medical_reference_list* medical_reference_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class medical_reference_list (*this, f, c);
    }

    medical_reference_list& medical_reference_list::
    operator= (const medical_reference_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->citations_ = x.citations_;
        this->cpgs_ = x.cpgs_;
      }

      return *this;
    }

    medical_reference_list::
    ~medical_reference_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, medical_reference_list >
    _xsd_medical_reference_list_type_factory_init (
      "medical-reference-list",
      "com:ara:pfc:training:1");

    // cpg_ref_list
    //

    cpg_ref_list::
    cpg_ref_list ()
    : ::xml_schema::type (),
      cpg_ref_ (this)
    {
    }

    cpg_ref_list::
    cpg_ref_list (const cpg_ref_list& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      cpg_ref_ (x.cpg_ref_, f, this)
    {
    }

    cpg_ref_list::
    cpg_ref_list (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      cpg_ref_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void cpg_ref_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // cpg-ref
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "cpg-ref",
              "",
              &::xsd::cxx::tree::factory_impl< cpg_ref_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< cpg_ref_type > r (
              dynamic_cast< cpg_ref_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->cpg_ref_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    cpg_ref_list* cpg_ref_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class cpg_ref_list (*this, f, c);
    }

    cpg_ref_list& cpg_ref_list::
    operator= (const cpg_ref_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->cpg_ref_ = x.cpg_ref_;
      }

      return *this;
    }

    cpg_ref_list::
    ~cpg_ref_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, cpg_ref_list >
    _xsd_cpg_ref_list_type_factory_init (
      "cpg-ref-list",
      "com:ara:pfc:training:1");

    // cpg_list
    //

    cpg_list::
    cpg_list ()
    : ::xml_schema::type (),
      cpg_ (this)
    {
    }

    cpg_list::
    cpg_list (const cpg_list& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      cpg_ (x.cpg_, f, this)
    {
    }

    cpg_list::
    cpg_list (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      cpg_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void cpg_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // cpg
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "cpg",
              "",
              &::xsd::cxx::tree::factory_impl< cpg_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< cpg_type > r (
              dynamic_cast< cpg_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->cpg_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    cpg_list* cpg_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class cpg_list (*this, f, c);
    }

    cpg_list& cpg_list::
    operator= (const cpg_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->cpg_ = x.cpg_;
      }

      return *this;
    }

    cpg_list::
    ~cpg_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, cpg_list >
    _xsd_cpg_list_type_factory_init (
      "cpg-list",
      "com:ara:pfc:training:1");

    // cpg
    //

    cpg::
    cpg (const name_type& name,
         const description_type& description,
         const citation_ref_type& citation_ref)
    : ::xml_schema::type (),
      name_ (name, this),
      description_ (description, this),
      citation_ref_ (citation_ref, this)
    {
    }

    cpg::
    cpg (::std::unique_ptr< name_type > name,
         ::std::unique_ptr< description_type > description,
         ::std::unique_ptr< citation_ref_type > citation_ref)
    : ::xml_schema::type (),
      name_ (std::move (name), this),
      description_ (std::move (description), this),
      citation_ref_ (std::move (citation_ref), this)
    {
    }

    cpg::
    cpg (const cpg& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      description_ (x.description_, f, this),
      citation_ref_ (x.citation_ref_, f, this)
    {
    }

    cpg::
    cpg (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      description_ (this),
      citation_ref_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void cpg::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // citation-ref
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "citation-ref",
              "",
              &::xsd::cxx::tree::factory_impl< citation_ref_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!citation_ref_.present ())
            {
              ::std::unique_ptr< citation_ref_type > r (
                dynamic_cast< citation_ref_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->citation_ref_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!citation_ref_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "citation-ref",
          "");
      }
    }

    cpg* cpg::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class cpg (*this, f, c);
    }

    cpg& cpg::
    operator= (const cpg& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->description_ = x.description_;
        this->citation_ref_ = x.citation_ref_;
      }

      return *this;
    }

    cpg::
    ~cpg ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, cpg >
    _xsd_cpg_type_factory_init (
      "cpg",
      "com:ara:pfc:training:1");

    // learning_objective_reference_list
    //

    learning_objective_reference_list::
    learning_objective_reference_list ()
    : ::xml_schema::type (),
      objective_ (this)
    {
    }

    learning_objective_reference_list::
    learning_objective_reference_list (const learning_objective_reference_list& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      objective_ (x.objective_, f, this)
    {
    }

    learning_objective_reference_list::
    learning_objective_reference_list (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      objective_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void learning_objective_reference_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // objective
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "objective",
              "",
              &::xsd::cxx::tree::factory_impl< objective_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< objective_type > r (
              dynamic_cast< objective_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->objective_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    learning_objective_reference_list* learning_objective_reference_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class learning_objective_reference_list (*this, f, c);
    }

    learning_objective_reference_list& learning_objective_reference_list::
    operator= (const learning_objective_reference_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->objective_ = x.objective_;
      }

      return *this;
    }

    learning_objective_reference_list::
    ~learning_objective_reference_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, learning_objective_reference_list >
    _xsd_learning_objective_reference_list_type_factory_init (
      "learning-objective-reference-list",
      "com:ara:pfc:training:1");

    // treatment_plan_ref_list
    //

    treatment_plan_ref_list::
    treatment_plan_ref_list ()
    : ::xml_schema::type (),
      treatment_plan_ (this)
    {
    }

    treatment_plan_ref_list::
    treatment_plan_ref_list (const treatment_plan_ref_list& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      treatment_plan_ (x.treatment_plan_, f, this)
    {
    }

    treatment_plan_ref_list::
    treatment_plan_ref_list (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      treatment_plan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void treatment_plan_ref_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // treatment-plan
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "treatment-plan",
              "",
              &::xsd::cxx::tree::factory_impl< treatment_plan_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< treatment_plan_type > r (
              dynamic_cast< treatment_plan_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->treatment_plan_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    treatment_plan_ref_list* treatment_plan_ref_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class treatment_plan_ref_list (*this, f, c);
    }

    treatment_plan_ref_list& treatment_plan_ref_list::
    operator= (const treatment_plan_ref_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->treatment_plan_ = x.treatment_plan_;
      }

      return *this;
    }

    treatment_plan_ref_list::
    ~treatment_plan_ref_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, treatment_plan_ref_list >
    _xsd_treatment_plan_ref_list_type_factory_init (
      "treatment-plan-ref-list",
      "com:ara:pfc:training:1");

    // trauma_profile_list
    //

    trauma_profile_list::
    trauma_profile_list ()
    : ::xml_schema::type (),
      trauma_profile_ (this)
    {
    }

    trauma_profile_list::
    trauma_profile_list (const trauma_profile_list& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      trauma_profile_ (x.trauma_profile_, f, this)
    {
    }

    trauma_profile_list::
    trauma_profile_list (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      trauma_profile_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void trauma_profile_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // trauma-profile
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "trauma-profile",
              "",
              &::xsd::cxx::tree::factory_impl< trauma_profile_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< trauma_profile_type > r (
              dynamic_cast< trauma_profile_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->trauma_profile_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    trauma_profile_list* trauma_profile_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class trauma_profile_list (*this, f, c);
    }

    trauma_profile_list& trauma_profile_list::
    operator= (const trauma_profile_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->trauma_profile_ = x.trauma_profile_;
      }

      return *this;
    }

    trauma_profile_list::
    ~trauma_profile_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, trauma_profile_list >
    _xsd_trauma_profile_list_type_factory_init (
      "trauma-profile-list",
      "com:ara:pfc:training:1");

    // trauma_profile
    //

    trauma_profile::
    trauma_profile (const id_type& id,
                    const name_type& name,
                    const injuries_type& injuries,
                    const treatments_type& treatments)
    : ::xml_schema::type (),
      id_ (id, this),
      name_ (name, this),
      physiology_state_ (this),
      injuries_ (injuries, this),
      treatments_ (treatments, this)
    {
    }

    trauma_profile::
    trauma_profile (const id_type& id,
                    const name_type& name,
                    ::std::unique_ptr< injuries_type > injuries,
                    ::std::unique_ptr< treatments_type > treatments)
    : ::xml_schema::type (),
      id_ (id, this),
      name_ (name, this),
      physiology_state_ (this),
      injuries_ (std::move (injuries), this),
      treatments_ (std::move (treatments), this)
    {
    }

    trauma_profile::
    trauma_profile (::std::unique_ptr< id_type > id,
                    ::std::unique_ptr< name_type > name,
                    ::std::unique_ptr< injuries_type > injuries,
                    ::std::unique_ptr< treatments_type > treatments)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      name_ (std::move (name), this),
      physiology_state_ (this),
      injuries_ (std::move (injuries), this),
      treatments_ (std::move (treatments), this)
    {
    }

    trauma_profile::
    trauma_profile (const trauma_profile& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      name_ (x.name_, f, this),
      physiology_state_ (x.physiology_state_, f, this),
      injuries_ (x.injuries_, f, this),
      treatments_ (x.treatments_, f, this)
    {
    }

    trauma_profile::
    trauma_profile (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      name_ (this),
      physiology_state_ (this),
      injuries_ (this),
      treatments_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void trauma_profile::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // physiology-state
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "physiology-state",
              "",
              &::xsd::cxx::tree::factory_impl< physiology_state_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->physiology_state_)
            {
              ::std::unique_ptr< physiology_state_type > r (
                dynamic_cast< physiology_state_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->physiology_state_.set (::std::move (r));
              continue;
            }
          }
        }

        // injuries
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "injuries",
              "",
              &::xsd::cxx::tree::factory_impl< injuries_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!injuries_.present ())
            {
              ::std::unique_ptr< injuries_type > r (
                dynamic_cast< injuries_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->injuries_.set (::std::move (r));
              continue;
            }
          }
        }

        // treatments
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "treatments",
              "",
              &::xsd::cxx::tree::factory_impl< treatments_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!treatments_.present ())
            {
              ::std::unique_ptr< treatments_type > r (
                dynamic_cast< treatments_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->treatments_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!injuries_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "injuries",
          "");
      }

      if (!treatments_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "treatments",
          "");
      }
    }

    trauma_profile* trauma_profile::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class trauma_profile (*this, f, c);
    }

    trauma_profile& trauma_profile::
    operator= (const trauma_profile& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->name_ = x.name_;
        this->physiology_state_ = x.physiology_state_;
        this->injuries_ = x.injuries_;
        this->treatments_ = x.treatments_;
      }

      return *this;
    }

    trauma_profile::
    ~trauma_profile ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, trauma_profile >
    _xsd_trauma_profile_type_factory_init (
      "trauma-profile",
      "com:ara:pfc:training:1");

    // trauma_profile_ref_list
    //

    trauma_profile_ref_list::
    trauma_profile_ref_list ()
    : ::xml_schema::type (),
      trauma_profile_ (this)
    {
    }

    trauma_profile_ref_list::
    trauma_profile_ref_list (const trauma_profile_ref_list& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      trauma_profile_ (x.trauma_profile_, f, this)
    {
    }

    trauma_profile_ref_list::
    trauma_profile_ref_list (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      trauma_profile_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void trauma_profile_ref_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // trauma-profile
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "trauma-profile",
              "",
              &::xsd::cxx::tree::factory_impl< trauma_profile_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< trauma_profile_type > r (
              dynamic_cast< trauma_profile_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->trauma_profile_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    trauma_profile_ref_list* trauma_profile_ref_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class trauma_profile_ref_list (*this, f, c);
    }

    trauma_profile_ref_list& trauma_profile_ref_list::
    operator= (const trauma_profile_ref_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->trauma_profile_ = x.trauma_profile_;
      }

      return *this;
    }

    trauma_profile_ref_list::
    ~trauma_profile_ref_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, trauma_profile_ref_list >
    _xsd_trauma_profile_ref_list_type_factory_init (
      "trauma-profile-ref-list",
      "com:ara:pfc:training:1");

    // trauma_occurence_list
    //

    trauma_occurence_list::
    trauma_occurence_list ()
    : ::xml_schema::type (),
      trauma_ (this)
    {
    }

    trauma_occurence_list::
    trauma_occurence_list (const trauma_occurence_list& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      trauma_ (x.trauma_, f, this)
    {
    }

    trauma_occurence_list::
    trauma_occurence_list (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      trauma_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void trauma_occurence_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // trauma
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "trauma",
              "",
              &::xsd::cxx::tree::factory_impl< trauma_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< trauma_type > r (
              dynamic_cast< trauma_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->trauma_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    trauma_occurence_list* trauma_occurence_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class trauma_occurence_list (*this, f, c);
    }

    trauma_occurence_list& trauma_occurence_list::
    operator= (const trauma_occurence_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->trauma_ = x.trauma_;
      }

      return *this;
    }

    trauma_occurence_list::
    ~trauma_occurence_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, trauma_occurence_list >
    _xsd_trauma_occurence_list_type_factory_init (
      "trauma-occurence-list",
      "com:ara:pfc:training:1");

    // trauma_occurence
    //

    trauma_occurence::
    trauma_occurence (const id_type& id,
                      const location_type& location,
                      const description_type& description,
                      const severity_type& severity)
    : ::xml_schema::type (),
      id_ (id, this),
      location_ (location, this),
      description_ (description, this),
      severity_ (severity, this)
    {
    }

    trauma_occurence::
    trauma_occurence (::std::unique_ptr< id_type > id,
                      ::std::unique_ptr< location_type > location,
                      ::std::unique_ptr< description_type > description,
                      ::std::unique_ptr< severity_type > severity)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      location_ (std::move (location), this),
      description_ (std::move (description), this),
      severity_ (std::move (severity), this)
    {
    }

    trauma_occurence::
    trauma_occurence (const trauma_occurence& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      location_ (x.location_, f, this),
      description_ (x.description_, f, this),
      severity_ (x.severity_, f, this)
    {
    }

    trauma_occurence::
    trauma_occurence (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      location_ (this),
      description_ (this),
      severity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void trauma_occurence::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // location
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "location",
              "",
              &::xsd::cxx::tree::factory_impl< location_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!location_.present ())
            {
              ::std::unique_ptr< location_type > r (
                dynamic_cast< location_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->location_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // severity
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "severity",
              "",
              &::xsd::cxx::tree::factory_impl< severity_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!severity_.present ())
            {
              ::std::unique_ptr< severity_type > r (
                dynamic_cast< severity_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->severity_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "location",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!severity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "severity",
          "");
      }
    }

    trauma_occurence* trauma_occurence::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class trauma_occurence (*this, f, c);
    }

    trauma_occurence& trauma_occurence::
    operator= (const trauma_occurence& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->location_ = x.location_;
        this->description_ = x.description_;
        this->severity_ = x.severity_;
      }

      return *this;
    }

    trauma_occurence::
    ~trauma_occurence ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, trauma_occurence >
    _xsd_trauma_occurence_type_factory_init (
      "trauma-occurence",
      "com:ara:pfc:training:1");

    // medical_scenario_syllabus
    //

    medical_scenario_syllabus::
    medical_scenario_syllabus (const learning_objectives_type& learning_objectives,
                               const learning_assessments_type& learning_assessments)
    : ::xml_schema::type (),
      learning_objectives_ (learning_objectives, this),
      learning_assessments_ (learning_assessments, this)
    {
    }

    medical_scenario_syllabus::
    medical_scenario_syllabus (::std::unique_ptr< learning_objectives_type > learning_objectives,
                               ::std::unique_ptr< learning_assessments_type > learning_assessments)
    : ::xml_schema::type (),
      learning_objectives_ (std::move (learning_objectives), this),
      learning_assessments_ (std::move (learning_assessments), this)
    {
    }

    medical_scenario_syllabus::
    medical_scenario_syllabus (const medical_scenario_syllabus& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      learning_objectives_ (x.learning_objectives_, f, this),
      learning_assessments_ (x.learning_assessments_, f, this)
    {
    }

    medical_scenario_syllabus::
    medical_scenario_syllabus (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      learning_objectives_ (this),
      learning_assessments_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void medical_scenario_syllabus::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // learning-objectives
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "learning-objectives",
              "",
              &::xsd::cxx::tree::factory_impl< learning_objectives_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!learning_objectives_.present ())
            {
              ::std::unique_ptr< learning_objectives_type > r (
                dynamic_cast< learning_objectives_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->learning_objectives_.set (::std::move (r));
              continue;
            }
          }
        }

        // learning-assessments
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "learning-assessments",
              "",
              &::xsd::cxx::tree::factory_impl< learning_assessments_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!learning_assessments_.present ())
            {
              ::std::unique_ptr< learning_assessments_type > r (
                dynamic_cast< learning_assessments_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->learning_assessments_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!learning_objectives_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "learning-objectives",
          "");
      }

      if (!learning_assessments_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "learning-assessments",
          "");
      }
    }

    medical_scenario_syllabus* medical_scenario_syllabus::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class medical_scenario_syllabus (*this, f, c);
    }

    medical_scenario_syllabus& medical_scenario_syllabus::
    operator= (const medical_scenario_syllabus& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->learning_objectives_ = x.learning_objectives_;
        this->learning_assessments_ = x.learning_assessments_;
      }

      return *this;
    }

    medical_scenario_syllabus::
    ~medical_scenario_syllabus ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, medical_scenario_syllabus >
    _xsd_medical_scenario_syllabus_type_factory_init (
      "medical-scenario-syllabus",
      "com:ara:pfc:training:1");

    // learning_objective_list
    //

    learning_objective_list::
    learning_objective_list ()
    : ::xml_schema::type (),
      objective_ (this)
    {
    }

    learning_objective_list::
    learning_objective_list (const learning_objective_list& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      objective_ (x.objective_, f, this)
    {
    }

    learning_objective_list::
    learning_objective_list (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      objective_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void learning_objective_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // objective
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "objective",
              "",
              &::xsd::cxx::tree::factory_impl< objective_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< objective_type > r (
              dynamic_cast< objective_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->objective_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    learning_objective_list* learning_objective_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class learning_objective_list (*this, f, c);
    }

    learning_objective_list& learning_objective_list::
    operator= (const learning_objective_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->objective_ = x.objective_;
      }

      return *this;
    }

    learning_objective_list::
    ~learning_objective_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, learning_objective_list >
    _xsd_learning_objective_list_type_factory_init (
      "learning-objective-list",
      "com:ara:pfc:training:1");

    // learning_objective
    //

    learning_objective::
    learning_objective (const id_type& id,
                        const name_type& name,
                        const description_type& description,
                        const references_type& references,
                        const relates_to_type& relates_to)
    : ::xml_schema::type (),
      id_ (id, this),
      name_ (name, this),
      description_ (description, this),
      references_ (references, this),
      relates_to_ (relates_to, this)
    {
    }

    learning_objective::
    learning_objective (const id_type& id,
                        const name_type& name,
                        const description_type& description,
                        ::std::unique_ptr< references_type > references,
                        ::std::unique_ptr< relates_to_type > relates_to)
    : ::xml_schema::type (),
      id_ (id, this),
      name_ (name, this),
      description_ (description, this),
      references_ (std::move (references), this),
      relates_to_ (std::move (relates_to), this)
    {
    }

    learning_objective::
    learning_objective (::std::unique_ptr< id_type > id,
                        ::std::unique_ptr< name_type > name,
                        ::std::unique_ptr< description_type > description,
                        ::std::unique_ptr< references_type > references,
                        ::std::unique_ptr< relates_to_type > relates_to)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      name_ (std::move (name), this),
      description_ (std::move (description), this),
      references_ (std::move (references), this),
      relates_to_ (std::move (relates_to), this)
    {
    }

    learning_objective::
    learning_objective (const learning_objective& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      name_ (x.name_, f, this),
      description_ (x.description_, f, this),
      references_ (x.references_, f, this),
      relates_to_ (x.relates_to_, f, this)
    {
    }

    learning_objective::
    learning_objective (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      name_ (this),
      description_ (this),
      references_ (this),
      relates_to_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void learning_objective::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // references
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "references",
              "",
              &::xsd::cxx::tree::factory_impl< references_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!references_.present ())
            {
              ::std::unique_ptr< references_type > r (
                dynamic_cast< references_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->references_.set (::std::move (r));
              continue;
            }
          }
        }

        // relates-to
        //
        if (n.name () == "relates-to" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< relates_to_type > r (
            relates_to_traits::create (i, f, this));

          if (!relates_to_.present ())
          {
            this->relates_to_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!references_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "references",
          "");
      }

      if (!relates_to_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "relates-to",
          "");
      }
    }

    learning_objective* learning_objective::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class learning_objective (*this, f, c);
    }

    learning_objective& learning_objective::
    operator= (const learning_objective& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->name_ = x.name_;
        this->description_ = x.description_;
        this->references_ = x.references_;
        this->relates_to_ = x.relates_to_;
      }

      return *this;
    }

    learning_objective::
    ~learning_objective ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, learning_objective >
    _xsd_learning_objective_type_factory_init (
      "learning-objective",
      "com:ara:pfc:training:1");

    // assessment_list
    //

    assessment_list::
    assessment_list (const total_points_type& total_points)
    : ::xml_schema::type (),
      total_points_ (total_points, this),
      assessment_ (this)
    {
    }

    assessment_list::
    assessment_list (const assessment_list& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      total_points_ (x.total_points_, f, this),
      assessment_ (x.assessment_, f, this)
    {
    }

    assessment_list::
    assessment_list (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      total_points_ (this),
      assessment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void assessment_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // total-points
        //
        if (n.name () == "total-points" && n.namespace_ ().empty ())
        {
          if (!total_points_.present ())
          {
            this->total_points_.set (total_points_traits::create (i, f, this));
            continue;
          }
        }

        // assessment
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "assessment",
              "",
              &::xsd::cxx::tree::factory_impl< assessment_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< assessment_type > r (
              dynamic_cast< assessment_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->assessment_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!total_points_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "total-points",
          "");
      }
    }

    assessment_list* assessment_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class assessment_list (*this, f, c);
    }

    assessment_list& assessment_list::
    operator= (const assessment_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->total_points_ = x.total_points_;
        this->assessment_ = x.assessment_;
      }

      return *this;
    }

    assessment_list::
    ~assessment_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, assessment_list >
    _xsd_assessment_list_type_factory_init (
      "assessment-list",
      "com:ara:pfc:training:1");

    // assessment
    //

    assessment::
    assessment (const id_type& id,
                const objective_id_type& objective_id,
                const name_type& name,
                const description_type& description,
                const points_avaiable_type& points_avaiable,
                const criteria_type& criteria)
    : ::xml_schema::type (),
      id_ (id, this),
      objective_id_ (objective_id, this),
      name_ (name, this),
      description_ (description, this),
      points_avaiable_ (points_avaiable, this),
      criteria_ (criteria, this)
    {
    }

    assessment::
    assessment (::std::unique_ptr< id_type > id,
                ::std::unique_ptr< objective_id_type > objective_id,
                ::std::unique_ptr< name_type > name,
                ::std::unique_ptr< description_type > description,
                const points_avaiable_type& points_avaiable,
                ::std::unique_ptr< criteria_type > criteria)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      objective_id_ (std::move (objective_id), this),
      name_ (std::move (name), this),
      description_ (std::move (description), this),
      points_avaiable_ (points_avaiable, this),
      criteria_ (std::move (criteria), this)
    {
    }

    assessment::
    assessment (const assessment& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      objective_id_ (x.objective_id_, f, this),
      name_ (x.name_, f, this),
      description_ (x.description_, f, this),
      points_avaiable_ (x.points_avaiable_, f, this),
      criteria_ (x.criteria_, f, this)
    {
    }

    assessment::
    assessment (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      objective_id_ (this),
      name_ (this),
      description_ (this),
      points_avaiable_ (this),
      criteria_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void assessment::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // objective-id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "objective-id",
              "",
              &::xsd::cxx::tree::factory_impl< objective_id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!objective_id_.present ())
            {
              ::std::unique_ptr< objective_id_type > r (
                dynamic_cast< objective_id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->objective_id_.set (::std::move (r));
              continue;
            }
          }
        }

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // points-avaiable
        //
        if (n.name () == "points-avaiable" && n.namespace_ ().empty ())
        {
          if (!points_avaiable_.present ())
          {
            this->points_avaiable_.set (points_avaiable_traits::create (i, f, this));
            continue;
          }
        }

        // criteria
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "criteria",
              "",
              &::xsd::cxx::tree::factory_impl< criteria_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!criteria_.present ())
            {
              ::std::unique_ptr< criteria_type > r (
                dynamic_cast< criteria_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->criteria_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!objective_id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "objective-id",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!points_avaiable_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "points-avaiable",
          "");
      }

      if (!criteria_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "criteria",
          "");
      }
    }

    assessment* assessment::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class assessment (*this, f, c);
    }

    assessment& assessment::
    operator= (const assessment& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->objective_id_ = x.objective_id_;
        this->name_ = x.name_;
        this->description_ = x.description_;
        this->points_avaiable_ = x.points_avaiable_;
        this->criteria_ = x.criteria_;
      }

      return *this;
    }

    assessment::
    ~assessment ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, assessment >
    _xsd_assessment_type_factory_init (
      "assessment",
      "com:ara:pfc:training:1");

    // medical_scenario
    //

    medical_scenario::
    medical_scenario (const id_type& id,
                      const roles_type& roles,
                      const training_script_type& training_script)
    : ::xml_schema::type (),
      id_ (id, this),
      roles_ (roles, this),
      training_script_ (training_script, this)
    {
    }

    medical_scenario::
    medical_scenario (const id_type& id,
                      ::std::unique_ptr< roles_type > roles,
                      ::std::unique_ptr< training_script_type > training_script)
    : ::xml_schema::type (),
      id_ (id, this),
      roles_ (std::move (roles), this),
      training_script_ (std::move (training_script), this)
    {
    }

    medical_scenario::
    medical_scenario (::std::unique_ptr< id_type > id,
                      ::std::unique_ptr< roles_type > roles,
                      ::std::unique_ptr< training_script_type > training_script)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      roles_ (std::move (roles), this),
      training_script_ (std::move (training_script), this)
    {
    }

    medical_scenario::
    medical_scenario (const medical_scenario& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      roles_ (x.roles_, f, this),
      training_script_ (x.training_script_, f, this)
    {
    }

    medical_scenario::
    medical_scenario (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      roles_ (this),
      training_script_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void medical_scenario::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // roles
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "roles",
              "",
              &::xsd::cxx::tree::factory_impl< roles_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!roles_.present ())
            {
              ::std::unique_ptr< roles_type > r (
                dynamic_cast< roles_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->roles_.set (::std::move (r));
              continue;
            }
          }
        }

        // training-script
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "training-script",
              "",
              &::xsd::cxx::tree::factory_impl< training_script_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!training_script_.present ())
            {
              ::std::unique_ptr< training_script_type > r (
                dynamic_cast< training_script_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->training_script_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!roles_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "roles",
          "");
      }

      if (!training_script_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "training-script",
          "");
      }
    }

    medical_scenario* medical_scenario::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class medical_scenario (*this, f, c);
    }

    medical_scenario& medical_scenario::
    operator= (const medical_scenario& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->roles_ = x.roles_;
        this->training_script_ = x.training_script_;
      }

      return *this;
    }

    medical_scenario::
    ~medical_scenario ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, medical_scenario >
    _xsd_medical_scenario_type_factory_init (
      "medical-scenario",
      "com:ara:pfc:training:1");

    // role_list
    //

    role_list::
    role_list ()
    : ::xml_schema::type (),
      role_ (this)
    {
    }

    role_list::
    role_list (const role_list& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      role_ (x.role_, f, this)
    {
    }

    role_list::
    role_list (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      role_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void role_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // role
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "role",
              "",
              &::xsd::cxx::tree::factory_impl< role_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< role_type > r (
              dynamic_cast< role_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->role_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    role_list* role_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class role_list (*this, f, c);
    }

    role_list& role_list::
    operator= (const role_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->role_ = x.role_;
      }

      return *this;
    }

    role_list::
    ~role_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, role_list >
    _xsd_role_list_type_factory_init (
      "role-list",
      "com:ara:pfc:training:1");

    // role
    //

    role::
    role (const id_type& id,
          const name_type& name,
          const short_name_type& short_name,
          const description_type& description)
    : ::xml_schema::type (),
      id_ (id, this),
      name_ (name, this),
      short_name_ (short_name, this),
      trauma_profile_ref_ (this),
      description_ (description, this)
    {
    }

    role::
    role (::std::unique_ptr< id_type > id,
          ::std::unique_ptr< name_type > name,
          ::std::unique_ptr< short_name_type > short_name,
          ::std::unique_ptr< description_type > description)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      name_ (std::move (name), this),
      short_name_ (std::move (short_name), this),
      trauma_profile_ref_ (this),
      description_ (std::move (description), this)
    {
    }

    role::
    role (const role& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      name_ (x.name_, f, this),
      short_name_ (x.short_name_, f, this),
      trauma_profile_ref_ (x.trauma_profile_ref_, f, this),
      description_ (x.description_, f, this)
    {
    }

    role::
    role (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      name_ (this),
      short_name_ (this),
      trauma_profile_ref_ (this),
      description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void role::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // short-name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "short-name",
              "",
              &::xsd::cxx::tree::factory_impl< short_name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!short_name_.present ())
            {
              ::std::unique_ptr< short_name_type > r (
                dynamic_cast< short_name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->short_name_.set (::std::move (r));
              continue;
            }
          }
        }

        // trauma-profile-ref
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "trauma-profile-ref",
              "",
              &::xsd::cxx::tree::factory_impl< trauma_profile_ref_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->trauma_profile_ref_)
            {
              ::std::unique_ptr< trauma_profile_ref_type > r (
                dynamic_cast< trauma_profile_ref_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->trauma_profile_ref_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!short_name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "short-name",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }
    }

    role* role::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class role (*this, f, c);
    }

    role& role::
    operator= (const role& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->name_ = x.name_;
        this->short_name_ = x.short_name_;
        this->trauma_profile_ref_ = x.trauma_profile_ref_;
        this->description_ = x.description_;
      }

      return *this;
    }

    role::
    ~role ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, role >
    _xsd_role_type_factory_init (
      "role",
      "com:ara:pfc:training:1");

    // role_ref_list
    //

    role_ref_list::
    role_ref_list ()
    : ::xml_schema::type (),
      role_ref_ (this)
    {
    }

    role_ref_list::
    role_ref_list (const role_ref_list& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      role_ref_ (x.role_ref_, f, this)
    {
    }

    role_ref_list::
    role_ref_list (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      role_ref_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void role_ref_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // role-ref
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "role-ref",
              "",
              &::xsd::cxx::tree::factory_impl< role_ref_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< role_ref_type > r (
              dynamic_cast< role_ref_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->role_ref_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    role_ref_list* role_ref_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class role_ref_list (*this, f, c);
    }

    role_ref_list& role_ref_list::
    operator= (const role_ref_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->role_ref_ = x.role_ref_;
      }

      return *this;
    }

    role_ref_list::
    ~role_ref_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, role_ref_list >
    _xsd_role_ref_list_type_factory_init (
      "role-ref-list",
      "com:ara:pfc:training:1");

    // item_list
    //

    item_list::
    item_list ()
    : ::xml_schema::type (),
      item_ (this)
    {
    }

    item_list::
    item_list (const item_list& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      item_ (x.item_, f, this)
    {
    }

    item_list::
    item_list (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      item_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void item_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // item
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "item",
              "",
              &::xsd::cxx::tree::factory_impl< item_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< item_type > r (
              dynamic_cast< item_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->item_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    item_list* item_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class item_list (*this, f, c);
    }

    item_list& item_list::
    operator= (const item_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->item_ = x.item_;
      }

      return *this;
    }

    item_list::
    ~item_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, item_list >
    _xsd_item_list_type_factory_init (
      "item-list",
      "com:ara:pfc:training:1");

    // item
    //

    item::
    item (const short_name_type& short_name,
          const equipment_id_type& equipment_id,
          const description_type& description,
          const properties_type& properties)
    : ::xml_schema::type (),
      short_name_ (short_name, this),
      equipment_id_ (equipment_id, this),
      description_ (description, this),
      properties_ (properties, this)
    {
    }

    item::
    item (const short_name_type& short_name,
          const equipment_id_type& equipment_id,
          const description_type& description,
          ::std::unique_ptr< properties_type > properties)
    : ::xml_schema::type (),
      short_name_ (short_name, this),
      equipment_id_ (equipment_id, this),
      description_ (description, this),
      properties_ (std::move (properties), this)
    {
    }

    item::
    item (::std::unique_ptr< short_name_type > short_name,
          ::std::unique_ptr< equipment_id_type > equipment_id,
          ::std::unique_ptr< description_type > description,
          ::std::unique_ptr< properties_type > properties)
    : ::xml_schema::type (),
      short_name_ (std::move (short_name), this),
      equipment_id_ (std::move (equipment_id), this),
      description_ (std::move (description), this),
      properties_ (std::move (properties), this)
    {
    }

    item::
    item (const item& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      short_name_ (x.short_name_, f, this),
      equipment_id_ (x.equipment_id_, f, this),
      description_ (x.description_, f, this),
      properties_ (x.properties_, f, this)
    {
    }

    item::
    item (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      short_name_ (this),
      equipment_id_ (this),
      description_ (this),
      properties_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void item::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // short-name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "short-name",
              "",
              &::xsd::cxx::tree::factory_impl< short_name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!short_name_.present ())
            {
              ::std::unique_ptr< short_name_type > r (
                dynamic_cast< short_name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->short_name_.set (::std::move (r));
              continue;
            }
          }
        }

        // equipment-id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "equipment-id",
              "",
              &::xsd::cxx::tree::factory_impl< equipment_id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!equipment_id_.present ())
            {
              ::std::unique_ptr< equipment_id_type > r (
                dynamic_cast< equipment_id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->equipment_id_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // properties
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "properties",
              "",
              &::xsd::cxx::tree::factory_impl< properties_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!properties_.present ())
            {
              ::std::unique_ptr< properties_type > r (
                dynamic_cast< properties_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->properties_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!short_name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "short-name",
          "");
      }

      if (!equipment_id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "equipment-id",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!properties_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "properties",
          "");
      }
    }

    item* item::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class item (*this, f, c);
    }

    item& item::
    operator= (const item& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->short_name_ = x.short_name_;
        this->equipment_id_ = x.equipment_id_;
        this->description_ = x.description_;
        this->properties_ = x.properties_;
      }

      return *this;
    }

    item::
    ~item ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, item >
    _xsd_item_type_factory_init (
      "item",
      "com:ara:pfc:training:1");

    // scene_list
    //

    scene_list::
    scene_list ()
    : ::xml_schema::type (),
      scene_ (this)
    {
    }

    scene_list::
    scene_list (const scene_list& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      scene_ (x.scene_, f, this)
    {
    }

    scene_list::
    scene_list (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      scene_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void scene_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // scene
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "scene",
              "",
              &::xsd::cxx::tree::factory_impl< scene_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< scene_type > r (
              dynamic_cast< scene_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->scene_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    scene_list* scene_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class scene_list (*this, f, c);
    }

    scene_list& scene_list::
    operator= (const scene_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->scene_ = x.scene_;
      }

      return *this;
    }

    scene_list::
    ~scene_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, scene_list >
    _xsd_scene_list_type_factory_init (
      "scene-list",
      "com:ara:pfc:training:1");

    // scene
    //

    scene::
    scene (const location_id_type& location_id,
           const name_type& name,
           const description_type& description,
           const time_of_day_type& time_of_day,
           const time_in_simulation_type& time_in_simulation,
           const events_type& events,
           const items_type& items,
           const roles_type& roles)
    : ::xml_schema::type (),
      location_id_ (location_id, this),
      name_ (name, this),
      description_ (description, this),
      time_of_day_ (time_of_day, this),
      time_in_simulation_ (time_in_simulation, this),
      events_ (events, this),
      items_ (items, this),
      roles_ (roles, this)
    {
    }

    scene::
    scene (const location_id_type& location_id,
           const name_type& name,
           const description_type& description,
           const time_of_day_type& time_of_day,
           const time_in_simulation_type& time_in_simulation,
           ::std::unique_ptr< events_type > events,
           ::std::unique_ptr< items_type > items,
           ::std::unique_ptr< roles_type > roles)
    : ::xml_schema::type (),
      location_id_ (location_id, this),
      name_ (name, this),
      description_ (description, this),
      time_of_day_ (time_of_day, this),
      time_in_simulation_ (time_in_simulation, this),
      events_ (std::move (events), this),
      items_ (std::move (items), this),
      roles_ (std::move (roles), this)
    {
    }

    scene::
    scene (::std::unique_ptr< location_id_type > location_id,
           ::std::unique_ptr< name_type > name,
           ::std::unique_ptr< description_type > description,
           ::std::unique_ptr< time_of_day_type > time_of_day,
           const time_in_simulation_type& time_in_simulation,
           ::std::unique_ptr< events_type > events,
           ::std::unique_ptr< items_type > items,
           ::std::unique_ptr< roles_type > roles)
    : ::xml_schema::type (),
      location_id_ (std::move (location_id), this),
      name_ (std::move (name), this),
      description_ (std::move (description), this),
      time_of_day_ (std::move (time_of_day), this),
      time_in_simulation_ (time_in_simulation, this),
      events_ (std::move (events), this),
      items_ (std::move (items), this),
      roles_ (std::move (roles), this)
    {
    }

    scene::
    scene (const scene& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      location_id_ (x.location_id_, f, this),
      name_ (x.name_, f, this),
      description_ (x.description_, f, this),
      time_of_day_ (x.time_of_day_, f, this),
      time_in_simulation_ (x.time_in_simulation_, f, this),
      events_ (x.events_, f, this),
      items_ (x.items_, f, this),
      roles_ (x.roles_, f, this)
    {
    }

    scene::
    scene (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      location_id_ (this),
      name_ (this),
      description_ (this),
      time_of_day_ (this),
      time_in_simulation_ (this),
      events_ (this),
      items_ (this),
      roles_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void scene::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // location-id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "location-id",
              "",
              &::xsd::cxx::tree::factory_impl< location_id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!location_id_.present ())
            {
              ::std::unique_ptr< location_id_type > r (
                dynamic_cast< location_id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->location_id_.set (::std::move (r));
              continue;
            }
          }
        }

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // time-of-day
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "time-of-day",
              "",
              &::xsd::cxx::tree::factory_impl< time_of_day_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!time_of_day_.present ())
            {
              ::std::unique_ptr< time_of_day_type > r (
                dynamic_cast< time_of_day_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->time_of_day_.set (::std::move (r));
              continue;
            }
          }
        }

        // time-in-simulation
        //
        if (n.name () == "time-in-simulation" && n.namespace_ ().empty ())
        {
          if (!time_in_simulation_.present ())
          {
            this->time_in_simulation_.set (time_in_simulation_traits::create (i, f, this));
            continue;
          }
        }

        // events
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "events",
              "",
              &::xsd::cxx::tree::factory_impl< events_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!events_.present ())
            {
              ::std::unique_ptr< events_type > r (
                dynamic_cast< events_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->events_.set (::std::move (r));
              continue;
            }
          }
        }

        // items
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "items",
              "",
              &::xsd::cxx::tree::factory_impl< items_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!items_.present ())
            {
              ::std::unique_ptr< items_type > r (
                dynamic_cast< items_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->items_.set (::std::move (r));
              continue;
            }
          }
        }

        // roles
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "roles",
              "",
              &::xsd::cxx::tree::factory_impl< roles_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!roles_.present ())
            {
              ::std::unique_ptr< roles_type > r (
                dynamic_cast< roles_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->roles_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!location_id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "location-id",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }

      if (!time_of_day_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "time-of-day",
          "");
      }

      if (!time_in_simulation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "time-in-simulation",
          "");
      }

      if (!events_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "events",
          "");
      }

      if (!items_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "items",
          "");
      }

      if (!roles_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "roles",
          "");
      }
    }

    scene* scene::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class scene (*this, f, c);
    }

    scene& scene::
    operator= (const scene& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->location_id_ = x.location_id_;
        this->name_ = x.name_;
        this->description_ = x.description_;
        this->time_of_day_ = x.time_of_day_;
        this->time_in_simulation_ = x.time_in_simulation_;
        this->events_ = x.events_;
        this->items_ = x.items_;
        this->roles_ = x.roles_;
      }

      return *this;
    }

    scene::
    ~scene ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, scene >
    _xsd_scene_type_factory_init (
      "scene",
      "com:ara:pfc:training:1");

    // event_list
    //

    event_list::
    event_list ()
    : ::xml_schema::type (),
      event_ (this)
    {
    }

    event_list::
    event_list (const event_list& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      event_ (x.event_, f, this)
    {
    }

    event_list::
    event_list (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      event_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void event_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // event
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "event",
              "",
              &::xsd::cxx::tree::factory_impl< event_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< event_type > r (
              dynamic_cast< event_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->event_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    event_list* event_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class event_list (*this, f, c);
    }

    event_list& event_list::
    operator= (const event_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->event_ = x.event_;
      }

      return *this;
    }

    event_list::
    ~event_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, event_list >
    _xsd_event_list_type_factory_init (
      "event-list",
      "com:ara:pfc:training:1");

    // event
    //

    event::
    event (const id_type& id,
           const name_type& name,
           const category_type& category,
           const fidelity_type& fidelity,
           const actor_1_type& actor_1,
           const actor_2_type& actor_2,
           const equipment_type& equipment,
           const details_type& details,
           const description_type& description)
    : ::xml_schema::type (),
      id_ (id, this),
      name_ (name, this),
      category_ (category, this),
      fidelity_ (fidelity, this),
      actor_1_ (actor_1, this),
      actor_2_ (actor_2, this),
      equipment_ (equipment, this),
      details_ (details, this),
      description_ (description, this)
    {
    }

    event::
    event (::std::unique_ptr< id_type > id,
           ::std::unique_ptr< name_type > name,
           ::std::unique_ptr< category_type > category,
           ::std::unique_ptr< fidelity_type > fidelity,
           ::std::unique_ptr< actor_1_type > actor_1,
           ::std::unique_ptr< actor_2_type > actor_2,
           ::std::unique_ptr< equipment_type > equipment,
           ::std::unique_ptr< details_type > details,
           ::std::unique_ptr< description_type > description)
    : ::xml_schema::type (),
      id_ (std::move (id), this),
      name_ (std::move (name), this),
      category_ (std::move (category), this),
      fidelity_ (std::move (fidelity), this),
      actor_1_ (std::move (actor_1), this),
      actor_2_ (std::move (actor_2), this),
      equipment_ (std::move (equipment), this),
      details_ (std::move (details), this),
      description_ (std::move (description), this)
    {
    }

    event::
    event (const event& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      name_ (x.name_, f, this),
      category_ (x.category_, f, this),
      fidelity_ (x.fidelity_, f, this),
      actor_1_ (x.actor_1_, f, this),
      actor_2_ (x.actor_2_, f, this),
      equipment_ (x.equipment_, f, this),
      details_ (x.details_, f, this),
      description_ (x.description_, f, this)
    {
    }

    event::
    event (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      name_ (this),
      category_ (this),
      fidelity_ (this),
      actor_1_ (this),
      actor_2_ (this),
      equipment_ (this),
      details_ (this),
      description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void event::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "id",
              "",
              &::xsd::cxx::tree::factory_impl< id_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!id_.present ())
            {
              ::std::unique_ptr< id_type > r (
                dynamic_cast< id_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->id_.set (::std::move (r));
              continue;
            }
          }
        }

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // category
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "category",
              "",
              &::xsd::cxx::tree::factory_impl< category_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!category_.present ())
            {
              ::std::unique_ptr< category_type > r (
                dynamic_cast< category_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->category_.set (::std::move (r));
              continue;
            }
          }
        }

        // fidelity
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "fidelity",
              "",
              &::xsd::cxx::tree::factory_impl< fidelity_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!fidelity_.present ())
            {
              ::std::unique_ptr< fidelity_type > r (
                dynamic_cast< fidelity_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->fidelity_.set (::std::move (r));
              continue;
            }
          }
        }

        // actor_1
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "actor_1",
              "",
              &::xsd::cxx::tree::factory_impl< actor_1_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!actor_1_.present ())
            {
              ::std::unique_ptr< actor_1_type > r (
                dynamic_cast< actor_1_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->actor_1_.set (::std::move (r));
              continue;
            }
          }
        }

        // actor_2
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "actor_2",
              "",
              &::xsd::cxx::tree::factory_impl< actor_2_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!actor_2_.present ())
            {
              ::std::unique_ptr< actor_2_type > r (
                dynamic_cast< actor_2_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->actor_2_.set (::std::move (r));
              continue;
            }
          }
        }

        // equipment
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "equipment",
              "",
              &::xsd::cxx::tree::factory_impl< equipment_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!equipment_.present ())
            {
              ::std::unique_ptr< equipment_type > r (
                dynamic_cast< equipment_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->equipment_.set (::std::move (r));
              continue;
            }
          }
        }

        // details
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "details",
              "",
              &::xsd::cxx::tree::factory_impl< details_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!details_.present ())
            {
              ::std::unique_ptr< details_type > r (
                dynamic_cast< details_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->details_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!category_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "category",
          "");
      }

      if (!fidelity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "fidelity",
          "");
      }

      if (!actor_1_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "actor_1",
          "");
      }

      if (!actor_2_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "actor_2",
          "");
      }

      if (!equipment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "equipment",
          "");
      }

      if (!details_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "details",
          "");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "");
      }
    }

    event* event::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class event (*this, f, c);
    }

    event& event::
    operator= (const event& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->name_ = x.name_;
        this->category_ = x.category_;
        this->fidelity_ = x.fidelity_;
        this->actor_1_ = x.actor_1_;
        this->actor_2_ = x.actor_2_;
        this->equipment_ = x.equipment_;
        this->details_ = x.details_;
        this->description_ = x.description_;
      }

      return *this;
    }

    event::
    ~event ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, event >
    _xsd_event_type_factory_init (
      "event",
      "com:ara:pfc:training:1");

    // event_category_enum
    //

    event_category_enum::
    event_category_enum (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_event_category_enum_convert ();
    }

    event_category_enum::
    event_category_enum (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_event_category_enum_convert ();
    }

    event_category_enum::
    event_category_enum (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_event_category_enum_convert ();
    }

    event_category_enum* event_category_enum::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class event_category_enum (*this, f, c);
    }

    event_category_enum::value event_category_enum::
    _xsd_event_category_enum_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_event_category_enum_literals_);
      const value* i (::std::lower_bound (
                        _xsd_event_category_enum_indexes_,
                        _xsd_event_category_enum_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_event_category_enum_indexes_ + 5 || _xsd_event_category_enum_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const event_category_enum::
    _xsd_event_category_enum_literals_[5] =
    {
      "ACTION",
      "DIALOG",
      "MOVMENT",
      "SOUND",
      "ENVIRONMENT"
    };

    const event_category_enum::value event_category_enum::
    _xsd_event_category_enum_indexes_[5] =
    {
      ::pfc::schema::event_category_enum::ACTION,
      ::pfc::schema::event_category_enum::DIALOG,
      ::pfc::schema::event_category_enum::ENVIRONMENT,
      ::pfc::schema::event_category_enum::MOVMENT,
      ::pfc::schema::event_category_enum::SOUND
    };

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, event_category_enum >
    _xsd_event_category_enum_type_factory_init (
      "event-category-enum",
      "com:ara:pfc:training:1");

    // event_fidelity_enum
    //

    event_fidelity_enum::
    event_fidelity_enum (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_event_fidelity_enum_convert ();
    }

    event_fidelity_enum::
    event_fidelity_enum (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_event_fidelity_enum_convert ();
    }

    event_fidelity_enum::
    event_fidelity_enum (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_event_fidelity_enum_convert ();
    }

    event_fidelity_enum* event_fidelity_enum::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class event_fidelity_enum (*this, f, c);
    }

    event_fidelity_enum::value event_fidelity_enum::
    _xsd_event_fidelity_enum_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_event_fidelity_enum_literals_);
      const value* i (::std::lower_bound (
                        _xsd_event_fidelity_enum_indexes_,
                        _xsd_event_fidelity_enum_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_event_fidelity_enum_indexes_ + 3 || _xsd_event_fidelity_enum_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const event_fidelity_enum::
    _xsd_event_fidelity_enum_literals_[3] =
    {
      "LOW",
      "MEDIUM",
      "HIGH"
    };

    const event_fidelity_enum::value event_fidelity_enum::
    _xsd_event_fidelity_enum_indexes_[3] =
    {
      ::pfc::schema::event_fidelity_enum::HIGH,
      ::pfc::schema::event_fidelity_enum::LOW,
      ::pfc::schema::event_fidelity_enum::MEDIUM
    };

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, event_fidelity_enum >
    _xsd_event_fidelity_enum_type_factory_init (
      "event-fidelity-enum",
      "com:ara:pfc:training:1");

    // citation_list
    //

    citation_list::
    citation_list ()
    : ::xml_schema::type (),
      citation_ (this)
    {
    }

    citation_list::
    citation_list (const citation_list& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      citation_ (x.citation_, f, this)
    {
    }

    citation_list::
    citation_list (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      citation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void citation_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // citation
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "citation",
              "",
              &::xsd::cxx::tree::factory_impl< citation_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< citation_type > r (
              dynamic_cast< citation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->citation_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    citation_list* citation_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class citation_list (*this, f, c);
    }

    citation_list& citation_list::
    operator= (const citation_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->citation_ = x.citation_;
      }

      return *this;
    }

    citation_list::
    ~citation_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, citation_list >
    _xsd_citation_list_type_factory_init (
      "citation-list",
      "com:ara:pfc:training:1");

    // citation
    //

    citation::
    citation (const uuid_type& uuid,
              const title_type& title,
              const date_type& date)
    : ::xml_schema::type (),
      uuid_ (uuid, this),
      key_ (this),
      authors_ (this),
      title_ (title, this),
      date_ (date, this),
      page_ (this),
      accessed_ (this)
    {
    }

    citation::
    citation (::std::unique_ptr< uuid_type > uuid,
              ::std::unique_ptr< title_type > title,
              ::std::unique_ptr< date_type > date)
    : ::xml_schema::type (),
      uuid_ (std::move (uuid), this),
      key_ (this),
      authors_ (this),
      title_ (std::move (title), this),
      date_ (std::move (date), this),
      page_ (this),
      accessed_ (this)
    {
    }

    citation::
    citation (const citation& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uuid_ (x.uuid_, f, this),
      key_ (x.key_, f, this),
      authors_ (x.authors_, f, this),
      title_ (x.title_, f, this),
      date_ (x.date_, f, this),
      page_ (x.page_, f, this),
      accessed_ (x.accessed_, f, this)
    {
    }

    citation::
    citation (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uuid_ (this),
      key_ (this),
      authors_ (this),
      title_ (this),
      date_ (this),
      page_ (this),
      accessed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void citation::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uuid
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "uuid",
              "",
              &::xsd::cxx::tree::factory_impl< uuid_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!uuid_.present ())
            {
              ::std::unique_ptr< uuid_type > r (
                dynamic_cast< uuid_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->uuid_.set (::std::move (r));
              continue;
            }
          }
        }

        // key
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "key",
              "",
              &::xsd::cxx::tree::factory_impl< key_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->key_)
            {
              ::std::unique_ptr< key_type > r (
                dynamic_cast< key_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->key_.set (::std::move (r));
              continue;
            }
          }
        }

        // authors
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "authors",
              "",
              &::xsd::cxx::tree::factory_impl< authors_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< authors_type > r (
              dynamic_cast< authors_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->authors_.push_back (::std::move (r));
            continue;
          }
        }

        // title
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "title",
              "",
              &::xsd::cxx::tree::factory_impl< title_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!title_.present ())
            {
              ::std::unique_ptr< title_type > r (
                dynamic_cast< title_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->title_.set (::std::move (r));
              continue;
            }
          }
        }

        // date
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "date",
              "",
              &::xsd::cxx::tree::factory_impl< date_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!date_.present ())
            {
              ::std::unique_ptr< date_type > r (
                dynamic_cast< date_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->date_.set (::std::move (r));
              continue;
            }
          }
        }

        // page
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "page",
              "",
              &::xsd::cxx::tree::factory_impl< page_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->page_)
            {
              ::std::unique_ptr< page_type > r (
                dynamic_cast< page_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->page_.set (::std::move (r));
              continue;
            }
          }
        }

        // accessed
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "accessed",
              "",
              &::xsd::cxx::tree::factory_impl< accessed_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->accessed_)
            {
              ::std::unique_ptr< accessed_type > r (
                dynamic_cast< accessed_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->accessed_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!uuid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "uuid",
          "");
      }

      if (!title_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "title",
          "");
      }

      if (!date_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "date",
          "");
      }
    }

    citation* citation::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class citation (*this, f, c);
    }

    citation& citation::
    operator= (const citation& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->uuid_ = x.uuid_;
        this->key_ = x.key_;
        this->authors_ = x.authors_;
        this->title_ = x.title_;
        this->date_ = x.date_;
        this->page_ = x.page_;
        this->accessed_ = x.accessed_;
      }

      return *this;
    }

    citation::
    ~citation ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, citation >
    _xsd_citation_type_factory_init (
      "citation",
      "com:ara:pfc:training:1");

    // properties_list
    //

    properties_list::
    properties_list ()
    : ::xml_schema::type (),
      property_ (this)
    {
    }

    properties_list::
    properties_list (const properties_list& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      property_ (x.property_, f, this)
    {
    }

    properties_list::
    properties_list (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      property_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void properties_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // property
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "property",
              "",
              &::xsd::cxx::tree::factory_impl< property_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< property_type > r (
              dynamic_cast< property_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->property_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    properties_list* properties_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class properties_list (*this, f, c);
    }

    properties_list& properties_list::
    operator= (const properties_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->property_ = x.property_;
      }

      return *this;
    }

    properties_list::
    ~properties_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, properties_list >
    _xsd_properties_list_type_factory_init (
      "properties-list",
      "com:ara:pfc:training:1");

    // property
    //

    property::
    property (const name_type& name,
              const type_type& type)
    : ::xml_schema::type (),
      name_ (name, this),
      type_ (type, this)
    {
    }

    property::
    property (::std::unique_ptr< name_type > name,
              ::std::unique_ptr< type_type > type)
    : ::xml_schema::type (),
      name_ (std::move (name), this),
      type_ (std::move (type), this)
    {
    }

    property::
    property (const property& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this)
    {
    }

    property::
    property (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void property::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // type
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "type",
              "",
              &::xsd::cxx::tree::factory_impl< type_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!type_.present ())
            {
              ::std::unique_ptr< type_type > r (
                dynamic_cast< type_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->type_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "type",
          "");
      }
    }

    property* property::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class property (*this, f, c);
    }

    property& property::
    operator= (const property& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->type_ = x.type_;
      }

      return *this;
    }

    property::
    ~property ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, property >
    _xsd_property_type_factory_init (
      "property",
      "com:ara:pfc:training:1");

    // property_value_list
    //

    property_value_list::
    property_value_list ()
    : ::xml_schema::type (),
      value_ (this)
    {
    }

    property_value_list::
    property_value_list (const property_value_list& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    property_value_list::
    property_value_list (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void property_value_list::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // value
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "value",
              "",
              &::xsd::cxx::tree::factory_impl< value_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< value_type > r (
              dynamic_cast< value_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->value_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    property_value_list* property_value_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class property_value_list (*this, f, c);
    }

    property_value_list& property_value_list::
    operator= (const property_value_list& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->value_ = x.value_;
      }

      return *this;
    }

    property_value_list::
    ~property_value_list ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, property_value_list >
    _xsd_property_value_list_type_factory_init (
      "property-value-list",
      "com:ara:pfc:training:1");

    // property_value
    //

    property_value::
    property_value (const name_type& name,
                    const value_type& value)
    : ::xml_schema::type (),
      name_ (name, this),
      value_ (value, this)
    {
    }

    property_value::
    property_value (::std::unique_ptr< name_type > name,
                    ::std::unique_ptr< value_type > value)
    : ::xml_schema::type (),
      name_ (std::move (name), this),
      value_ (std::move (value), this)
    {
    }

    property_value::
    property_value (const property_value& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      value_ (x.value_, f, this)
    {
    }

    property_value::
    property_value (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void property_value::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // value
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "value",
              "",
              &::xsd::cxx::tree::factory_impl< value_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!value_.present ())
            {
              ::std::unique_ptr< value_type > r (
                dynamic_cast< value_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->value_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "value",
          "");
      }
    }

    property_value* property_value::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class property_value (*this, f, c);
    }

    property_value& property_value::
    operator= (const property_value& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->value_ = x.value_;
      }

      return *this;
    }

    property_value::
    ~property_value ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, property_value >
    _xsd_property_value_type_factory_init (
      "property-value",
      "com:ara:pfc:training:1");

    // relates_to
    //

    relates_to::
    relates_to (const treatment_plans_type& treatment_plans,
                const trauma_profiles_type& trauma_profiles)
    : ::xml_schema::type (),
      treatment_plans_ (treatment_plans, this),
      trauma_profiles_ (trauma_profiles, this)
    {
    }

    relates_to::
    relates_to (::std::unique_ptr< treatment_plans_type > treatment_plans,
                ::std::unique_ptr< trauma_profiles_type > trauma_profiles)
    : ::xml_schema::type (),
      treatment_plans_ (std::move (treatment_plans), this),
      trauma_profiles_ (std::move (trauma_profiles), this)
    {
    }

    relates_to::
    relates_to (const relates_to& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      treatment_plans_ (x.treatment_plans_, f, this),
      trauma_profiles_ (x.trauma_profiles_, f, this)
    {
    }

    relates_to::
    relates_to (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      treatment_plans_ (this),
      trauma_profiles_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void relates_to::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // treatment-plans
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "treatment-plans",
              "",
              &::xsd::cxx::tree::factory_impl< treatment_plans_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!treatment_plans_.present ())
            {
              ::std::unique_ptr< treatment_plans_type > r (
                dynamic_cast< treatment_plans_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->treatment_plans_.set (::std::move (r));
              continue;
            }
          }
        }

        // trauma-profiles
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "trauma-profiles",
              "",
              &::xsd::cxx::tree::factory_impl< trauma_profiles_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!trauma_profiles_.present ())
            {
              ::std::unique_ptr< trauma_profiles_type > r (
                dynamic_cast< trauma_profiles_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->trauma_profiles_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!treatment_plans_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "treatment-plans",
          "");
      }

      if (!trauma_profiles_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "trauma-profiles",
          "");
      }
    }

    relates_to* relates_to::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class relates_to (*this, f, c);
    }

    relates_to& relates_to::
    operator= (const relates_to& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->treatment_plans_ = x.treatment_plans_;
        this->trauma_profiles_ = x.trauma_profiles_;
      }

      return *this;
    }

    relates_to::
    ~relates_to ()
    {
    }
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace pfc
{
  namespace schema
  {
    ::std::ostream&
    operator<< (::std::ostream& o, const summary& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.title ())
        {
          o << ::std::endl << "title: ";
          om.insert (o, *i.title ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.description ())
        {
          o << ::std::endl << "description: ";
          om.insert (o, *i.description ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.version ())
        {
          o << ::std::endl << "version: ";
          om.insert (o, *i.version ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.classification ())
        {
          o << ::std::endl << "classification: ";
          om.insert (o, *i.classification ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.keywords ())
        {
          o << ::std::endl << "keywords: ";
          om.insert (o, *i.keywords ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.domain ())
        {
          o << ::std::endl << "domain: ";
          om.insert (o, *i.domain ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.limitations ())
        {
          o << ::std::endl << "limitations: ";
          om.insert (o, *i.limitations ());
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, summary >
    _xsd_summary_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const author& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.first_name ())
        {
          o << ::std::endl << "first_name: ";
          om.insert (o, *i.first_name ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.last_name ())
        {
          o << ::std::endl << "last_name: ";
          om.insert (o, *i.last_name ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.organization ())
        {
          o << ::std::endl << "organization: ";
          om.insert (o, *i.organization ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.phone_number ())
        {
          o << ::std::endl << "phone_number: ";
          om.insert (o, *i.phone_number ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.email ())
        {
          o << ::std::endl << "email: ";
          om.insert (o, *i.email ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.zip ())
        {
          o << ::std::endl << "zip: ";
          om.insert (o, *i.zip ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.state ())
        {
          o << ::std::endl << "state: ";
          om.insert (o, *i.state ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.country ())
        {
          o << ::std::endl << "country: ";
          om.insert (o, *i.country ());
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, author >
    _xsd_author_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const equipment_definition_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (equipment_definition_list::equipment_const_iterator
             b (i.equipment ().begin ()), e (i.equipment ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "equipment: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, equipment_definition_list >
    _xsd_equipment_definition_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const equipment& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      if (i.type ())
      {
        o << ::std::endl << "type: " << *i.type ();
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "citations: ";
        om.insert (o, i.citations ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.image ())
        {
          o << ::std::endl << "image: ";
          om.insert (o, *i.image ());
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, equipment >
    _xsd_equipment_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const trauma_definition_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (trauma_definition_list::trauma_const_iterator
             b (i.trauma ().begin ()), e (i.trauma ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "trauma: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, trauma_definition_list >
    _xsd_trauma_definition_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const trauma& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.common_name ())
        {
          o << ::std::endl << "common-name: ";
          om.insert (o, *i.common_name ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "medical-name: ";
        om.insert (o, i.medical_name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "citations: ";
        om.insert (o, i.citations ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "severity-range: ";
        om.insert (o, i.severity_range ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, trauma >
    _xsd_trauma_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const trauma_severity_range& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.numeric_range ())
        {
          o << ::std::endl << "numeric-range: ";
          om.insert (o, *i.numeric_range ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.token_range ())
        {
          o << ::std::endl << "token-range: ";
          om.insert (o, *i.token_range ());
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, trauma_severity_range >
    _xsd_trauma_severity_range_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const numeric_range& i)
    {
      o << ::std::endl << "lower_bound: " << i.lower_bound ();
      o << ::std::endl << "upper_bound: " << i.upper_bound ();
      if (i.median ())
      {
        o << ::std::endl << "median: " << *i.median ();
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.unit ())
        {
          o << ::std::endl << "unit: ";
          om.insert (o, *i.unit ());
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, numeric_range >
    _xsd_numeric_range_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const token_range& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (token_range::token_const_iterator
             b (i.token ().begin ()), e (i.token ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "token: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, token_range >
    _xsd_token_range_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const citation_ref_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (citation_ref_list::citation_ref_const_iterator
             b (i.citation_ref ().begin ()), e (i.citation_ref ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "citation-ref: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, citation_ref_list >
    _xsd_citation_ref_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const treatment_plan_definition_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (treatment_plan_definition_list::treatment_plan_const_iterator
             b (i.treatment_plan ().begin ()), e (i.treatment_plan ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "treatment-plan: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, treatment_plan_definition_list >
    _xsd_treatment_plan_definition_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const treatment_plan& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.common_name ())
        {
          o << ::std::endl << "common-name: ";
          om.insert (o, *i.common_name ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.medical_name ())
        {
          o << ::std::endl << "medical-name: ";
          om.insert (o, *i.medical_name ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "required-equipment: ";
        om.insert (o, i.required_equipment ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "references: ";
        om.insert (o, i.references ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, treatment_plan >
    _xsd_treatment_plan_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const equipment_ref_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (equipment_ref_list::equipment_refs_const_iterator
             b (i.equipment_refs ().begin ()), e (i.equipment_refs ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "equipment-refs: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, equipment_ref_list >
    _xsd_equipment_ref_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const medical_reference_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "citations: ";
        om.insert (o, i.citations ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "cpgs: ";
        om.insert (o, i.cpgs ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, medical_reference_list >
    _xsd_medical_reference_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const cpg_ref_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (cpg_ref_list::cpg_ref_const_iterator
             b (i.cpg_ref ().begin ()), e (i.cpg_ref ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "cpg-ref: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, cpg_ref_list >
    _xsd_cpg_ref_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const cpg_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (cpg_list::cpg_const_iterator
             b (i.cpg ().begin ()), e (i.cpg ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "cpg: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, cpg_list >
    _xsd_cpg_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const cpg& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "citation-ref: ";
        om.insert (o, i.citation_ref ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, cpg >
    _xsd_cpg_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const learning_objective_reference_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (learning_objective_reference_list::objective_const_iterator
             b (i.objective ().begin ()), e (i.objective ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "objective: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, learning_objective_reference_list >
    _xsd_learning_objective_reference_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const treatment_plan_ref_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (treatment_plan_ref_list::treatment_plan_const_iterator
             b (i.treatment_plan ().begin ()), e (i.treatment_plan ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "treatment-plan: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, treatment_plan_ref_list >
    _xsd_treatment_plan_ref_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const trauma_profile_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (trauma_profile_list::trauma_profile_const_iterator
             b (i.trauma_profile ().begin ()), e (i.trauma_profile ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "trauma-profile: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, trauma_profile_list >
    _xsd_trauma_profile_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const trauma_profile& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.physiology_state ())
        {
          o << ::std::endl << "physiology-state: ";
          om.insert (o, *i.physiology_state ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "injuries: ";
        om.insert (o, i.injuries ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "treatments: ";
        om.insert (o, i.treatments ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, trauma_profile >
    _xsd_trauma_profile_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const trauma_profile_ref_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (trauma_profile_ref_list::trauma_profile_const_iterator
             b (i.trauma_profile ().begin ()), e (i.trauma_profile ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "trauma-profile: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, trauma_profile_ref_list >
    _xsd_trauma_profile_ref_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const trauma_occurence_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (trauma_occurence_list::trauma_const_iterator
             b (i.trauma ().begin ()), e (i.trauma ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "trauma: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, trauma_occurence_list >
    _xsd_trauma_occurence_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const trauma_occurence& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "location: ";
        om.insert (o, i.location ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "severity: ";
        om.insert (o, i.severity ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, trauma_occurence >
    _xsd_trauma_occurence_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const medical_scenario_syllabus& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "learning-objectives: ";
        om.insert (o, i.learning_objectives ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "learning-assessments: ";
        om.insert (o, i.learning_assessments ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, medical_scenario_syllabus >
    _xsd_medical_scenario_syllabus_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const learning_objective_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (learning_objective_list::objective_const_iterator
             b (i.objective ().begin ()), e (i.objective ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "objective: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, learning_objective_list >
    _xsd_learning_objective_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const learning_objective& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "references: ";
        om.insert (o, i.references ());
      }

      o << ::std::endl << "relates-to: " << i.relates_to ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, learning_objective >
    _xsd_learning_objective_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const assessment_list& i)
    {
      o << ::std::endl << "total-points: " << i.total_points ();
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (assessment_list::assessment_const_iterator
             b (i.assessment ().begin ()), e (i.assessment ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "assessment: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, assessment_list >
    _xsd_assessment_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const assessment& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "objective-id: ";
        om.insert (o, i.objective_id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      o << ::std::endl << "points-avaiable: " << i.points_avaiable ();
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "criteria: ";
        om.insert (o, i.criteria ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, assessment >
    _xsd_assessment_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const medical_scenario& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "roles: ";
        om.insert (o, i.roles ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "training-script: ";
        om.insert (o, i.training_script ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, medical_scenario >
    _xsd_medical_scenario_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const role_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (role_list::role_const_iterator
             b (i.role ().begin ()), e (i.role ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "role: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, role_list >
    _xsd_role_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const role& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "short-name: ";
        om.insert (o, i.short_name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.trauma_profile_ref ())
        {
          o << ::std::endl << "trauma-profile-ref: ";
          om.insert (o, *i.trauma_profile_ref ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, role >
    _xsd_role_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const role_ref_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (role_ref_list::role_ref_const_iterator
             b (i.role_ref ().begin ()), e (i.role_ref ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "role-ref: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, role_ref_list >
    _xsd_role_ref_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const item_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (item_list::item_const_iterator
             b (i.item ().begin ()), e (i.item ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "item: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, item_list >
    _xsd_item_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const item& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "short-name: ";
        om.insert (o, i.short_name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "equipment-id: ";
        om.insert (o, i.equipment_id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "properties: ";
        om.insert (o, i.properties ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, item >
    _xsd_item_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const scene_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (scene_list::scene_const_iterator
             b (i.scene ().begin ()), e (i.scene ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "scene: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, scene_list >
    _xsd_scene_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const scene& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "location-id: ";
        om.insert (o, i.location_id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "time-of-day: ";
        om.insert (o, i.time_of_day ());
      }

      o << ::std::endl << "time-in-simulation: " << i.time_in_simulation ();
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "events: ";
        om.insert (o, i.events ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "items: ";
        om.insert (o, i.items ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "roles: ";
        om.insert (o, i.roles ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, scene >
    _xsd_scene_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const event_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (event_list::event_const_iterator
             b (i.event ().begin ()), e (i.event ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "event: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, event_list >
    _xsd_event_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const event& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "id: ";
        om.insert (o, i.id ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "category: ";
        om.insert (o, i.category ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "fidelity: ";
        om.insert (o, i.fidelity ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "actor_1: ";
        om.insert (o, i.actor_1 ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "actor_2: ";
        om.insert (o, i.actor_2 ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "equipment: ";
        om.insert (o, i.equipment ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "details: ";
        om.insert (o, i.details ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, event >
    _xsd_event_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, event_category_enum::value i)
    {
      return o << event_category_enum::_xsd_event_category_enum_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const event_category_enum& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, event_category_enum >
    _xsd_event_category_enum_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, event_fidelity_enum::value i)
    {
      return o << event_fidelity_enum::_xsd_event_fidelity_enum_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const event_fidelity_enum& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, event_fidelity_enum >
    _xsd_event_fidelity_enum_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const citation_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (citation_list::citation_const_iterator
             b (i.citation ().begin ()), e (i.citation ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "citation: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, citation_list >
    _xsd_citation_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const citation& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "uuid: ";
        om.insert (o, i.uuid ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.key ())
        {
          o << ::std::endl << "key: ";
          om.insert (o, *i.key ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (citation::authors_const_iterator
             b (i.authors ().begin ()), e (i.authors ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "authors: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "title: ";
        om.insert (o, i.title ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "date: ";
        om.insert (o, i.date ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.page ())
        {
          o << ::std::endl << "page: ";
          om.insert (o, *i.page ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.accessed ())
        {
          o << ::std::endl << "accessed: ";
          om.insert (o, *i.accessed ());
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, citation >
    _xsd_citation_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const properties_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (properties_list::property_const_iterator
             b (i.property ().begin ()), e (i.property ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "property: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, properties_list >
    _xsd_properties_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const property& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "type: ";
        om.insert (o, i.type ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, property >
    _xsd_property_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const property_value_list& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (property_value_list::value_const_iterator
             b (i.value ().begin ()), e (i.value ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "value: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, property_value_list >
    _xsd_property_value_list_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const property_value& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "value: ";
        om.insert (o, i.value ());
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, property_value >
    _xsd_property_value_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const relates_to& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "treatment-plans: ";
        om.insert (o, i.treatment_plans ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "trauma-profiles: ";
        om.insert (o, i.trauma_profiles ());
      }

      return o;
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace pfc
{
  namespace schema
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace pfc
{
  namespace schema
  {
    void
    operator<< (::xercesc::DOMElement& e, const summary& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // title
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.title ())
        {
          const summary::title_type& x (*i.title ());
          if (typeid (summary::title_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "title",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "title",
              "",
              false, false, e, x);
        }
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.description ())
        {
          const summary::description_type& x (*i.description ());
          if (typeid (summary::description_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "description",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "description",
              "",
              false, false, e, x);
        }
      }

      // version
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.version ())
        {
          const summary::version_type& x (*i.version ());
          if (typeid (summary::version_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "version",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "version",
              "",
              false, false, e, x);
        }
      }

      // classification
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.classification ())
        {
          const summary::classification_type& x (*i.classification ());
          if (typeid (summary::classification_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "classification",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "classification",
              "",
              false, false, e, x);
        }
      }

      // keywords
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.keywords ())
        {
          const summary::keywords_type& x (*i.keywords ());
          if (typeid (summary::keywords_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "keywords",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "keywords",
              "",
              false, false, e, x);
        }
      }

      // domain
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.domain ())
        {
          const summary::domain_type& x (*i.domain ());
          if (typeid (summary::domain_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "domain",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "domain",
              "",
              false, false, e, x);
        }
      }

      // limitations
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.limitations ())
        {
          const summary::limitations_type& x (*i.limitations ());
          if (typeid (summary::limitations_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "limitations",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "limitations",
              "",
              false, false, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, summary >
    _xsd_summary_type_serializer_init (
      "summary",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const author& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // first_name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.first_name ())
        {
          const author::first_name_type& x (*i.first_name ());
          if (typeid (author::first_name_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "first_name",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "first_name",
              "",
              false, false, e, x);
        }
      }

      // last_name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.last_name ())
        {
          const author::last_name_type& x (*i.last_name ());
          if (typeid (author::last_name_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "last_name",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "last_name",
              "",
              false, false, e, x);
        }
      }

      // organization
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.organization ())
        {
          const author::organization_type& x (*i.organization ());
          if (typeid (author::organization_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "organization",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "organization",
              "",
              false, false, e, x);
        }
      }

      // phone_number
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.phone_number ())
        {
          const author::phone_number_type& x (*i.phone_number ());
          if (typeid (author::phone_number_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "phone_number",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "phone_number",
              "",
              false, false, e, x);
        }
      }

      // email
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.email ())
        {
          const author::email_type& x (*i.email ());
          if (typeid (author::email_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "email",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "email",
              "",
              false, false, e, x);
        }
      }

      // zip
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.zip ())
        {
          const author::zip_type& x (*i.zip ());
          if (typeid (author::zip_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "zip",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "zip",
              "",
              false, false, e, x);
        }
      }

      // state
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.state ())
        {
          const author::state_type& x (*i.state ());
          if (typeid (author::state_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "state",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "state",
              "",
              false, false, e, x);
        }
      }

      // country
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.country ())
        {
          const author::country_type& x (*i.country ());
          if (typeid (author::country_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "country",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "country",
              "",
              false, false, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, author >
    _xsd_author_type_serializer_init (
      "author",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const equipment_definition_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // equipment
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (equipment_definition_list::equipment_const_iterator
             b (i.equipment ().begin ()), n (i.equipment ().end ());
             b != n; ++b)
        {
          if (typeid (equipment_definition_list::equipment_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "equipment",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "equipment",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, equipment_definition_list >
    _xsd_equipment_definition_list_type_serializer_init (
      "equipment-definition-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const equipment& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const equipment::id_type& x (i.id ());
        if (typeid (equipment::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const equipment::name_type& x (i.name ());
        if (typeid (equipment::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // type
      //
      if (i.type ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "type",
            e));

        s << *i.type ();
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const equipment::description_type& x (i.description ());
        if (typeid (equipment::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // citations
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const equipment::citations_type& x (i.citations ());
        if (typeid (equipment::citations_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "citations",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "citations",
            "",
            false, false, e, x);
      }

      // image
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.image ())
        {
          const equipment::image_type& x (*i.image ());
          if (typeid (equipment::image_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "image",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "image",
              "",
              false, false, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, equipment >
    _xsd_equipment_type_serializer_init (
      "equipment",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const trauma_definition_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // trauma
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (trauma_definition_list::trauma_const_iterator
             b (i.trauma ().begin ()), n (i.trauma ().end ());
             b != n; ++b)
        {
          if (typeid (trauma_definition_list::trauma_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "trauma",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "trauma",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, trauma_definition_list >
    _xsd_trauma_definition_list_type_serializer_init (
      "trauma-definition-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const trauma& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const trauma::id_type& x (i.id ());
        if (typeid (trauma::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // common-name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.common_name ())
        {
          const trauma::common_name_type& x (*i.common_name ());
          if (typeid (trauma::common_name_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "common-name",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "common-name",
              "",
              false, false, e, x);
        }
      }

      // medical-name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const trauma::medical_name_type& x (i.medical_name ());
        if (typeid (trauma::medical_name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "medical-name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "medical-name",
            "",
            false, false, e, x);
      }

      // citations
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const trauma::citations_type& x (i.citations ());
        if (typeid (trauma::citations_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "citations",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "citations",
            "",
            false, false, e, x);
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const trauma::description_type& x (i.description ());
        if (typeid (trauma::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // severity-range
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const trauma::severity_range_type& x (i.severity_range ());
        if (typeid (trauma::severity_range_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "severity-range",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "severity-range",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, trauma >
    _xsd_trauma_type_serializer_init (
      "trauma",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const trauma_severity_range& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // numeric-range
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.numeric_range ())
        {
          const trauma_severity_range::numeric_range_type& x (*i.numeric_range ());
          if (typeid (trauma_severity_range::numeric_range_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "numeric-range",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "numeric-range",
              "",
              false, false, e, x);
        }
      }

      // token-range
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.token_range ())
        {
          const trauma_severity_range::token_range_type& x (*i.token_range ());
          if (typeid (trauma_severity_range::token_range_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "token-range",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "token-range",
              "",
              false, false, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, trauma_severity_range >
    _xsd_trauma_severity_range_type_serializer_init (
      "trauma-severity-range",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const numeric_range& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // lower_bound
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "lower_bound",
            e));

        s << ::xml_schema::as_double(i.lower_bound ());
      }

      // upper_bound
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "upper_bound",
            e));

        s << ::xml_schema::as_double(i.upper_bound ());
      }

      // median
      //
      if (i.median ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "median",
            e));

        s << ::xml_schema::as_double(*i.median ());
      }

      // unit
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.unit ())
        {
          const numeric_range::unit_type& x (*i.unit ());
          if (typeid (numeric_range::unit_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "unit",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "unit",
              "",
              false, false, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, numeric_range >
    _xsd_numeric_range_type_serializer_init (
      "numeric-range",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const token_range& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // token
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (token_range::token_const_iterator
             b (i.token ().begin ()), n (i.token ().end ());
             b != n; ++b)
        {
          if (typeid (token_range::token_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "token",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "token",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, token_range >
    _xsd_token_range_type_serializer_init (
      "token-range",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const citation_ref_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // citation-ref
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (citation_ref_list::citation_ref_const_iterator
             b (i.citation_ref ().begin ()), n (i.citation_ref ().end ());
             b != n; ++b)
        {
          if (typeid (citation_ref_list::citation_ref_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "citation-ref",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "citation-ref",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, citation_ref_list >
    _xsd_citation_ref_list_type_serializer_init (
      "citation-ref-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const treatment_plan_definition_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // treatment-plan
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (treatment_plan_definition_list::treatment_plan_const_iterator
             b (i.treatment_plan ().begin ()), n (i.treatment_plan ().end ());
             b != n; ++b)
        {
          if (typeid (treatment_plan_definition_list::treatment_plan_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "treatment-plan",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "treatment-plan",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, treatment_plan_definition_list >
    _xsd_treatment_plan_definition_list_type_serializer_init (
      "treatment-plan-definition-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const treatment_plan& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const treatment_plan::id_type& x (i.id ());
        if (typeid (treatment_plan::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // common-name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.common_name ())
        {
          const treatment_plan::common_name_type& x (*i.common_name ());
          if (typeid (treatment_plan::common_name_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "common-name",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "common-name",
              "",
              false, false, e, x);
        }
      }

      // medical-name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.medical_name ())
        {
          const treatment_plan::medical_name_type& x (*i.medical_name ());
          if (typeid (treatment_plan::medical_name_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "medical-name",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "medical-name",
              "",
              false, false, e, x);
        }
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const treatment_plan::description_type& x (i.description ());
        if (typeid (treatment_plan::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // required-equipment
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const treatment_plan::required_equipment_type& x (i.required_equipment ());
        if (typeid (treatment_plan::required_equipment_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "required-equipment",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "required-equipment",
            "",
            false, false, e, x);
      }

      // references
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const treatment_plan::references_type& x (i.references ());
        if (typeid (treatment_plan::references_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "references",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "references",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, treatment_plan >
    _xsd_treatment_plan_type_serializer_init (
      "treatment-plan",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const equipment_ref_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // equipment-refs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (equipment_ref_list::equipment_refs_const_iterator
             b (i.equipment_refs ().begin ()), n (i.equipment_refs ().end ());
             b != n; ++b)
        {
          if (typeid (equipment_ref_list::equipment_refs_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "equipment-refs",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "equipment-refs",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, equipment_ref_list >
    _xsd_equipment_ref_list_type_serializer_init (
      "equipment-ref-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const medical_reference_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // citations
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_reference_list::citations_type& x (i.citations ());
        if (typeid (medical_reference_list::citations_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "citations",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "citations",
            "",
            false, false, e, x);
      }

      // cpgs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_reference_list::cpgs_type& x (i.cpgs ());
        if (typeid (medical_reference_list::cpgs_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "cpgs",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "cpgs",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, medical_reference_list >
    _xsd_medical_reference_list_type_serializer_init (
      "medical-reference-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const cpg_ref_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // cpg-ref
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (cpg_ref_list::cpg_ref_const_iterator
             b (i.cpg_ref ().begin ()), n (i.cpg_ref ().end ());
             b != n; ++b)
        {
          if (typeid (cpg_ref_list::cpg_ref_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "cpg-ref",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "cpg-ref",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, cpg_ref_list >
    _xsd_cpg_ref_list_type_serializer_init (
      "cpg-ref-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const cpg_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // cpg
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (cpg_list::cpg_const_iterator
             b (i.cpg ().begin ()), n (i.cpg ().end ());
             b != n; ++b)
        {
          if (typeid (cpg_list::cpg_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "cpg",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "cpg",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, cpg_list >
    _xsd_cpg_list_type_serializer_init (
      "cpg-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const cpg& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const cpg::name_type& x (i.name ());
        if (typeid (cpg::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const cpg::description_type& x (i.description ());
        if (typeid (cpg::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // citation-ref
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const cpg::citation_ref_type& x (i.citation_ref ());
        if (typeid (cpg::citation_ref_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "citation-ref",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "citation-ref",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, cpg >
    _xsd_cpg_type_serializer_init (
      "cpg",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const learning_objective_reference_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // objective
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (learning_objective_reference_list::objective_const_iterator
             b (i.objective ().begin ()), n (i.objective ().end ());
             b != n; ++b)
        {
          if (typeid (learning_objective_reference_list::objective_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "objective",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "objective",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, learning_objective_reference_list >
    _xsd_learning_objective_reference_list_type_serializer_init (
      "learning-objective-reference-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const treatment_plan_ref_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // treatment-plan
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (treatment_plan_ref_list::treatment_plan_const_iterator
             b (i.treatment_plan ().begin ()), n (i.treatment_plan ().end ());
             b != n; ++b)
        {
          if (typeid (treatment_plan_ref_list::treatment_plan_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "treatment-plan",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "treatment-plan",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, treatment_plan_ref_list >
    _xsd_treatment_plan_ref_list_type_serializer_init (
      "treatment-plan-ref-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const trauma_profile_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // trauma-profile
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (trauma_profile_list::trauma_profile_const_iterator
             b (i.trauma_profile ().begin ()), n (i.trauma_profile ().end ());
             b != n; ++b)
        {
          if (typeid (trauma_profile_list::trauma_profile_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "trauma-profile",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "trauma-profile",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, trauma_profile_list >
    _xsd_trauma_profile_list_type_serializer_init (
      "trauma-profile-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const trauma_profile& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const trauma_profile::id_type& x (i.id ());
        if (typeid (trauma_profile::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const trauma_profile::name_type& x (i.name ());
        if (typeid (trauma_profile::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // physiology-state
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.physiology_state ())
        {
          const trauma_profile::physiology_state_type& x (*i.physiology_state ());
          if (typeid (trauma_profile::physiology_state_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "physiology-state",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "physiology-state",
              "",
              false, false, e, x);
        }
      }

      // injuries
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const trauma_profile::injuries_type& x (i.injuries ());
        if (typeid (trauma_profile::injuries_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "injuries",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "injuries",
            "",
            false, false, e, x);
      }

      // treatments
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const trauma_profile::treatments_type& x (i.treatments ());
        if (typeid (trauma_profile::treatments_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "treatments",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "treatments",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, trauma_profile >
    _xsd_trauma_profile_type_serializer_init (
      "trauma-profile",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const trauma_profile_ref_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // trauma-profile
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (trauma_profile_ref_list::trauma_profile_const_iterator
             b (i.trauma_profile ().begin ()), n (i.trauma_profile ().end ());
             b != n; ++b)
        {
          if (typeid (trauma_profile_ref_list::trauma_profile_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "trauma-profile",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "trauma-profile",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, trauma_profile_ref_list >
    _xsd_trauma_profile_ref_list_type_serializer_init (
      "trauma-profile-ref-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const trauma_occurence_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // trauma
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (trauma_occurence_list::trauma_const_iterator
             b (i.trauma ().begin ()), n (i.trauma ().end ());
             b != n; ++b)
        {
          if (typeid (trauma_occurence_list::trauma_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "trauma",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "trauma",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, trauma_occurence_list >
    _xsd_trauma_occurence_list_type_serializer_init (
      "trauma-occurence-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const trauma_occurence& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const trauma_occurence::id_type& x (i.id ());
        if (typeid (trauma_occurence::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // location
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const trauma_occurence::location_type& x (i.location ());
        if (typeid (trauma_occurence::location_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "location",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "location",
            "",
            false, false, e, x);
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const trauma_occurence::description_type& x (i.description ());
        if (typeid (trauma_occurence::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // severity
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const trauma_occurence::severity_type& x (i.severity ());
        if (typeid (trauma_occurence::severity_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "severity",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "severity",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, trauma_occurence >
    _xsd_trauma_occurence_type_serializer_init (
      "trauma-occurence",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const medical_scenario_syllabus& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // learning-objectives
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_scenario_syllabus::learning_objectives_type& x (i.learning_objectives ());
        if (typeid (medical_scenario_syllabus::learning_objectives_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "learning-objectives",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "learning-objectives",
            "",
            false, false, e, x);
      }

      // learning-assessments
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_scenario_syllabus::learning_assessments_type& x (i.learning_assessments ());
        if (typeid (medical_scenario_syllabus::learning_assessments_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "learning-assessments",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "learning-assessments",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, medical_scenario_syllabus >
    _xsd_medical_scenario_syllabus_type_serializer_init (
      "medical-scenario-syllabus",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const learning_objective_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // objective
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (learning_objective_list::objective_const_iterator
             b (i.objective ().begin ()), n (i.objective ().end ());
             b != n; ++b)
        {
          if (typeid (learning_objective_list::objective_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "objective",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "objective",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, learning_objective_list >
    _xsd_learning_objective_list_type_serializer_init (
      "learning-objective-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const learning_objective& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const learning_objective::id_type& x (i.id ());
        if (typeid (learning_objective::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const learning_objective::name_type& x (i.name ());
        if (typeid (learning_objective::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const learning_objective::description_type& x (i.description ());
        if (typeid (learning_objective::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // references
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const learning_objective::references_type& x (i.references ());
        if (typeid (learning_objective::references_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "references",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "references",
            "",
            false, false, e, x);
      }

      // relates-to
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "relates-to",
            e));

        s << i.relates_to ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, learning_objective >
    _xsd_learning_objective_type_serializer_init (
      "learning-objective",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const assessment_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // total-points
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "total-points",
            e));

        s << i.total_points ();
      }

      // assessment
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (assessment_list::assessment_const_iterator
             b (i.assessment ().begin ()), n (i.assessment ().end ());
             b != n; ++b)
        {
          if (typeid (assessment_list::assessment_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "assessment",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "assessment",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, assessment_list >
    _xsd_assessment_list_type_serializer_init (
      "assessment-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const assessment& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const assessment::id_type& x (i.id ());
        if (typeid (assessment::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // objective-id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const assessment::objective_id_type& x (i.objective_id ());
        if (typeid (assessment::objective_id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "objective-id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "objective-id",
            "",
            false, false, e, x);
      }

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const assessment::name_type& x (i.name ());
        if (typeid (assessment::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const assessment::description_type& x (i.description ());
        if (typeid (assessment::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // points-avaiable
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "points-avaiable",
            e));

        s << i.points_avaiable ();
      }

      // criteria
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const assessment::criteria_type& x (i.criteria ());
        if (typeid (assessment::criteria_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "criteria",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "criteria",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, assessment >
    _xsd_assessment_type_serializer_init (
      "assessment",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const medical_scenario& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_scenario::id_type& x (i.id ());
        if (typeid (medical_scenario::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // roles
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_scenario::roles_type& x (i.roles ());
        if (typeid (medical_scenario::roles_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "roles",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "roles",
            "",
            false, false, e, x);
      }

      // training-script
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const medical_scenario::training_script_type& x (i.training_script ());
        if (typeid (medical_scenario::training_script_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "training-script",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "training-script",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, medical_scenario >
    _xsd_medical_scenario_type_serializer_init (
      "medical-scenario",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const role_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // role
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (role_list::role_const_iterator
             b (i.role ().begin ()), n (i.role ().end ());
             b != n; ++b)
        {
          if (typeid (role_list::role_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "role",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "role",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, role_list >
    _xsd_role_list_type_serializer_init (
      "role-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const role& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const role::id_type& x (i.id ());
        if (typeid (role::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const role::name_type& x (i.name ());
        if (typeid (role::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // short-name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const role::short_name_type& x (i.short_name ());
        if (typeid (role::short_name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "short-name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "short-name",
            "",
            false, false, e, x);
      }

      // trauma-profile-ref
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.trauma_profile_ref ())
        {
          const role::trauma_profile_ref_type& x (*i.trauma_profile_ref ());
          if (typeid (role::trauma_profile_ref_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "trauma-profile-ref",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "trauma-profile-ref",
              "",
              false, false, e, x);
        }
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const role::description_type& x (i.description ());
        if (typeid (role::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, role >
    _xsd_role_type_serializer_init (
      "role",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const role_ref_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // role-ref
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (role_ref_list::role_ref_const_iterator
             b (i.role_ref ().begin ()), n (i.role_ref ().end ());
             b != n; ++b)
        {
          if (typeid (role_ref_list::role_ref_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "role-ref",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "role-ref",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, role_ref_list >
    _xsd_role_ref_list_type_serializer_init (
      "role-ref-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const item_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // item
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (item_list::item_const_iterator
             b (i.item ().begin ()), n (i.item ().end ());
             b != n; ++b)
        {
          if (typeid (item_list::item_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "item",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "item",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, item_list >
    _xsd_item_list_type_serializer_init (
      "item-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const item& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // short-name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const item::short_name_type& x (i.short_name ());
        if (typeid (item::short_name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "short-name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "short-name",
            "",
            false, false, e, x);
      }

      // equipment-id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const item::equipment_id_type& x (i.equipment_id ());
        if (typeid (item::equipment_id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "equipment-id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "equipment-id",
            "",
            false, false, e, x);
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const item::description_type& x (i.description ());
        if (typeid (item::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // properties
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const item::properties_type& x (i.properties ());
        if (typeid (item::properties_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "properties",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "properties",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, item >
    _xsd_item_type_serializer_init (
      "item",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const scene_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // scene
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (scene_list::scene_const_iterator
             b (i.scene ().begin ()), n (i.scene ().end ());
             b != n; ++b)
        {
          if (typeid (scene_list::scene_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "scene",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "scene",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, scene_list >
    _xsd_scene_list_type_serializer_init (
      "scene-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const scene& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // location-id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const scene::location_id_type& x (i.location_id ());
        if (typeid (scene::location_id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "location-id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "location-id",
            "",
            false, false, e, x);
      }

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const scene::name_type& x (i.name ());
        if (typeid (scene::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const scene::description_type& x (i.description ());
        if (typeid (scene::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }

      // time-of-day
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const scene::time_of_day_type& x (i.time_of_day ());
        if (typeid (scene::time_of_day_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "time-of-day",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "time-of-day",
            "",
            false, false, e, x);
      }

      // time-in-simulation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "time-in-simulation",
            e));

        s << i.time_in_simulation ();
      }

      // events
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const scene::events_type& x (i.events ());
        if (typeid (scene::events_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "events",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "events",
            "",
            false, false, e, x);
      }

      // items
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const scene::items_type& x (i.items ());
        if (typeid (scene::items_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "items",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "items",
            "",
            false, false, e, x);
      }

      // roles
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const scene::roles_type& x (i.roles ());
        if (typeid (scene::roles_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "roles",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "roles",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, scene >
    _xsd_scene_type_serializer_init (
      "scene",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const event_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // event
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (event_list::event_const_iterator
             b (i.event ().begin ()), n (i.event ().end ());
             b != n; ++b)
        {
          if (typeid (event_list::event_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "event",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "event",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, event_list >
    _xsd_event_list_type_serializer_init (
      "event-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const event& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const event::id_type& x (i.id ());
        if (typeid (event::id_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "id",
            "",
            false, false, e, x);
      }

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const event::name_type& x (i.name ());
        if (typeid (event::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // category
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const event::category_type& x (i.category ());
        if (typeid (event::category_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "category",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "category",
            "",
            false, false, e, x);
      }

      // fidelity
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const event::fidelity_type& x (i.fidelity ());
        if (typeid (event::fidelity_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "fidelity",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "fidelity",
            "",
            false, false, e, x);
      }

      // actor_1
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const event::actor_1_type& x (i.actor_1 ());
        if (typeid (event::actor_1_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "actor_1",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "actor_1",
            "",
            false, false, e, x);
      }

      // actor_2
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const event::actor_2_type& x (i.actor_2 ());
        if (typeid (event::actor_2_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "actor_2",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "actor_2",
            "",
            false, false, e, x);
      }

      // equipment
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const event::equipment_type& x (i.equipment ());
        if (typeid (event::equipment_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "equipment",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "equipment",
            "",
            false, false, e, x);
      }

      // details
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const event::details_type& x (i.details ());
        if (typeid (event::details_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "details",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "details",
            "",
            false, false, e, x);
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const event::description_type& x (i.description ());
        if (typeid (event::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, event >
    _xsd_event_type_serializer_init (
      "event",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const event_category_enum& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const event_category_enum& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const event_category_enum& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, event_category_enum >
    _xsd_event_category_enum_type_serializer_init (
      "event-category-enum",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const event_fidelity_enum& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const event_fidelity_enum& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const event_fidelity_enum& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, event_fidelity_enum >
    _xsd_event_fidelity_enum_type_serializer_init (
      "event-fidelity-enum",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const citation_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // citation
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (citation_list::citation_const_iterator
             b (i.citation ().begin ()), n (i.citation ().end ());
             b != n; ++b)
        {
          if (typeid (citation_list::citation_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "citation",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "citation",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, citation_list >
    _xsd_citation_list_type_serializer_init (
      "citation-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const citation& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // uuid
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const citation::uuid_type& x (i.uuid ());
        if (typeid (citation::uuid_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "uuid",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "uuid",
            "",
            false, false, e, x);
      }

      // key
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.key ())
        {
          const citation::key_type& x (*i.key ());
          if (typeid (citation::key_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "key",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "key",
              "",
              false, false, e, x);
        }
      }

      // authors
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (citation::authors_const_iterator
             b (i.authors ().begin ()), n (i.authors ().end ());
             b != n; ++b)
        {
          if (typeid (citation::authors_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "authors",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "authors",
              "",
              false, false, e, *b);
        }
      }

      // title
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const citation::title_type& x (i.title ());
        if (typeid (citation::title_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "title",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "title",
            "",
            false, false, e, x);
      }

      // date
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const citation::date_type& x (i.date ());
        if (typeid (citation::date_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "date",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "date",
            "",
            false, false, e, x);
      }

      // page
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.page ())
        {
          const citation::page_type& x (*i.page ());
          if (typeid (citation::page_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "page",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "page",
              "",
              false, false, e, x);
        }
      }

      // accessed
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.accessed ())
        {
          const citation::accessed_type& x (*i.accessed ());
          if (typeid (citation::accessed_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "accessed",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "accessed",
              "",
              false, false, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, citation >
    _xsd_citation_type_serializer_init (
      "citation",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const properties_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // property
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (properties_list::property_const_iterator
             b (i.property ().begin ()), n (i.property ().end ());
             b != n; ++b)
        {
          if (typeid (properties_list::property_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "property",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "property",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, properties_list >
    _xsd_properties_list_type_serializer_init (
      "properties-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const property& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const property::name_type& x (i.name ());
        if (typeid (property::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // type
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const property::type_type& x (i.type ());
        if (typeid (property::type_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "type",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "type",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, property >
    _xsd_property_type_serializer_init (
      "property",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const property_value_list& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // value
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (property_value_list::value_const_iterator
             b (i.value ().begin ()), n (i.value ().end ());
             b != n; ++b)
        {
          if (typeid (property_value_list::value_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "value",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "value",
              "",
              false, false, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, property_value_list >
    _xsd_property_value_list_type_serializer_init (
      "property-value-list",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const property_value& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const property_value::name_type& x (i.name ());
        if (typeid (property_value::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "",
            false, false, e, x);
      }

      // value
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const property_value::value_type& x (i.value ());
        if (typeid (property_value::value_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "value",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "value",
            "",
            false, false, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, property_value >
    _xsd_property_value_type_serializer_init (
      "property-value",
      "com:ara:pfc:training:1");


    void
    operator<< (::xercesc::DOMElement& e, const relates_to& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // treatment-plans
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const relates_to::treatment_plans_type& x (i.treatment_plans ());
        if (typeid (relates_to::treatment_plans_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "treatment-plans",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "treatment-plans",
            "",
            false, false, e, x);
      }

      // trauma-profiles
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const relates_to::trauma_profiles_type& x (i.trauma_profiles ());
        if (typeid (relates_to::trauma_profiles_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "trauma-profiles",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "trauma-profiles",
            "",
            false, false, e, x);
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

