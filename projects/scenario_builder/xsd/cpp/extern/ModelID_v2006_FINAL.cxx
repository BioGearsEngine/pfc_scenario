// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ModelID_v2006_FINAL.hxx"

namespace schemas
{
  namespace modelID
  {
    // String
    // 

    const String::notes_optional& String::
    notes () const
    {
      return this->notes_;
    }

    String::notes_optional& String::
    notes ()
    {
      return this->notes_;
    }

    void String::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void String::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void String::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const String::idtag_optional& String::
    idtag () const
    {
      return this->idtag_;
    }

    String::idtag_optional& String::
    idtag ()
    {
      return this->idtag_;
    }

    void String::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void String::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void String::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }


    // IdentifierType
    // 

    const IdentifierType::notes_optional& IdentifierType::
    notes () const
    {
      return this->notes_;
    }

    IdentifierType::notes_optional& IdentifierType::
    notes ()
    {
      return this->notes_;
    }

    void IdentifierType::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void IdentifierType::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void IdentifierType::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const IdentifierType::idtag_optional& IdentifierType::
    idtag () const
    {
      return this->idtag_;
    }

    IdentifierType::idtag_optional& IdentifierType::
    idtag ()
    {
      return this->idtag_;
    }

    void IdentifierType::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void IdentifierType::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void IdentifierType::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }


    // nonEmptyString
    // 


    // NonEmptyString
    // 

    const NonEmptyString::notes_optional& NonEmptyString::
    notes () const
    {
      return this->notes_;
    }

    NonEmptyString::notes_optional& NonEmptyString::
    notes ()
    {
      return this->notes_;
    }

    void NonEmptyString::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void NonEmptyString::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void NonEmptyString::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const NonEmptyString::idtag_optional& NonEmptyString::
    idtag () const
    {
      return this->idtag_;
    }

    NonEmptyString::idtag_optional& NonEmptyString::
    idtag ()
    {
      return this->idtag_;
    }

    void NonEmptyString::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void NonEmptyString::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void NonEmptyString::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }


    // OMTypeEnumerations
    // 

    OMTypeEnumerations::
    OMTypeEnumerations (value v)
    : ::xml_schema::string (_xsd_OMTypeEnumerations_literals_[v])
    {
    }

    OMTypeEnumerations::
    OMTypeEnumerations (const char* v)
    : ::xml_schema::string (v)
    {
    }

    OMTypeEnumerations::
    OMTypeEnumerations (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    OMTypeEnumerations::
    OMTypeEnumerations (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    OMTypeEnumerations::
    OMTypeEnumerations (const OMTypeEnumerations& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    OMTypeEnumerations& OMTypeEnumerations::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_OMTypeEnumerations_literals_[v]);

      return *this;
    }


    // OMTypeUnion
    //

    OMTypeUnion::
    OMTypeUnion (const char* s)
    : ::xml_schema::string (s)
    {
    }

    OMTypeUnion::
    OMTypeUnion (const ::std::string& s)
    : ::xml_schema::string (s)
    {
    }

    OMTypeUnion::
    OMTypeUnion (const OMTypeUnion& o,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (o, f, c)
    {
    }

    // glyphTypeEnumerations
    // 

    glyphTypeEnumerations::
    glyphTypeEnumerations (value v)
    : ::xml_schema::string (_xsd_glyphTypeEnumerations_literals_[v])
    {
    }

    glyphTypeEnumerations::
    glyphTypeEnumerations (const char* v)
    : ::xml_schema::string (v)
    {
    }

    glyphTypeEnumerations::
    glyphTypeEnumerations (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    glyphTypeEnumerations::
    glyphTypeEnumerations (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    glyphTypeEnumerations::
    glyphTypeEnumerations (const glyphTypeEnumerations& v,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    glyphTypeEnumerations& glyphTypeEnumerations::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_glyphTypeEnumerations_literals_[v]);

      return *this;
    }


    // glyphTypeUnion
    //

    glyphTypeUnion::
    glyphTypeUnion (const char* s)
    : ::xml_schema::string (s)
    {
    }

    glyphTypeUnion::
    glyphTypeUnion (const ::std::string& s)
    : ::xml_schema::string (s)
    {
    }

    glyphTypeUnion::
    glyphTypeUnion (const glyphTypeUnion& o,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::string (o, f, c)
    {
    }

    // glyphType
    // 

    const glyphType::notes_optional& glyphType::
    notes () const
    {
      return this->notes_;
    }

    glyphType::notes_optional& glyphType::
    notes ()
    {
      return this->notes_;
    }

    void glyphType::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void glyphType::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void glyphType::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const glyphType::idtag_optional& glyphType::
    idtag () const
    {
      return this->idtag_;
    }

    glyphType::idtag_optional& glyphType::
    idtag ()
    {
      return this->idtag_;
    }

    void glyphType::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void glyphType::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void glyphType::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }

    const glyphType::type_type& glyphType::
    type () const
    {
      return this->type_.get ();
    }

    glyphType::type_type& glyphType::
    type ()
    {
      return this->type_.get ();
    }

    void glyphType::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void glyphType::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }

    const glyphType::height_optional& glyphType::
    height () const
    {
      return this->height_;
    }

    glyphType::height_optional& glyphType::
    height ()
    {
      return this->height_;
    }

    void glyphType::
    height (const height_type& x)
    {
      this->height_.set (x);
    }

    void glyphType::
    height (const height_optional& x)
    {
      this->height_ = x;
    }

    const glyphType::width_optional& glyphType::
    width () const
    {
      return this->width_;
    }

    glyphType::width_optional& glyphType::
    width ()
    {
      return this->width_;
    }

    void glyphType::
    width (const width_type& x)
    {
      this->width_.set (x);
    }

    void glyphType::
    width (const width_optional& x)
    {
      this->width_ = x;
    }

    const glyphType::alt_optional& glyphType::
    alt () const
    {
      return this->alt_;
    }

    glyphType::alt_optional& glyphType::
    alt ()
    {
      return this->alt_;
    }

    void glyphType::
    alt (const alt_type& x)
    {
      this->alt_.set (x);
    }

    void glyphType::
    alt (const alt_optional& x)
    {
      this->alt_ = x;
    }

    void glyphType::
    alt (::std::unique_ptr< alt_type > x)
    {
      this->alt_.set (std::move (x));
    }


    // pocType
    // 

    const pocType::pocType1_type& pocType::
    pocType1 () const
    {
      return this->pocType1_.get ();
    }

    pocType::pocType1_type& pocType::
    pocType1 ()
    {
      return this->pocType1_.get ();
    }

    void pocType::
    pocType1 (const pocType1_type& x)
    {
      this->pocType1_.set (x);
    }

    void pocType::
    pocType1 (::std::unique_ptr< pocType1_type > x)
    {
      this->pocType1_.set (std::move (x));
    }

    const pocType::pocName_optional& pocType::
    pocName () const
    {
      return this->pocName_;
    }

    pocType::pocName_optional& pocType::
    pocName ()
    {
      return this->pocName_;
    }

    void pocType::
    pocName (const pocName_type& x)
    {
      this->pocName_.set (x);
    }

    void pocType::
    pocName (const pocName_optional& x)
    {
      this->pocName_ = x;
    }

    void pocType::
    pocName (::std::unique_ptr< pocName_type > x)
    {
      this->pocName_.set (std::move (x));
    }

    const pocType::pocOrg_optional& pocType::
    pocOrg () const
    {
      return this->pocOrg_;
    }

    pocType::pocOrg_optional& pocType::
    pocOrg ()
    {
      return this->pocOrg_;
    }

    void pocType::
    pocOrg (const pocOrg_type& x)
    {
      this->pocOrg_.set (x);
    }

    void pocType::
    pocOrg (const pocOrg_optional& x)
    {
      this->pocOrg_ = x;
    }

    void pocType::
    pocOrg (::std::unique_ptr< pocOrg_type > x)
    {
      this->pocOrg_.set (std::move (x));
    }

    const pocType::pocTelephone_sequence& pocType::
    pocTelephone () const
    {
      return this->pocTelephone_;
    }

    pocType::pocTelephone_sequence& pocType::
    pocTelephone ()
    {
      return this->pocTelephone_;
    }

    void pocType::
    pocTelephone (const pocTelephone_sequence& s)
    {
      this->pocTelephone_ = s;
    }

    const pocType::pocEmail_sequence& pocType::
    pocEmail () const
    {
      return this->pocEmail_;
    }

    pocType::pocEmail_sequence& pocType::
    pocEmail ()
    {
      return this->pocEmail_;
    }

    void pocType::
    pocEmail (const pocEmail_sequence& s)
    {
      this->pocEmail_ = s;
    }


    // SecurityClassificationEnumeration
    // 

    SecurityClassificationEnumeration::
    SecurityClassificationEnumeration (value v)
    : ::xml_schema::string (_xsd_SecurityClassificationEnumeration_literals_[v])
    {
    }

    SecurityClassificationEnumeration::
    SecurityClassificationEnumeration (const char* v)
    : ::xml_schema::string (v)
    {
    }

    SecurityClassificationEnumeration::
    SecurityClassificationEnumeration (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    SecurityClassificationEnumeration::
    SecurityClassificationEnumeration (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    SecurityClassificationEnumeration::
    SecurityClassificationEnumeration (const SecurityClassificationEnumeration& v,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    SecurityClassificationEnumeration& SecurityClassificationEnumeration::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_SecurityClassificationEnumeration_literals_[v]);

      return *this;
    }


    // SecurityClassificationUnion
    //

    SecurityClassificationUnion::
    SecurityClassificationUnion (const char* s)
    : ::xml_schema::string (s)
    {
    }

    SecurityClassificationUnion::
    SecurityClassificationUnion (const ::std::string& s)
    : ::xml_schema::string (s)
    {
    }

    SecurityClassificationUnion::
    SecurityClassificationUnion (const SecurityClassificationUnion& o,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::string (o, f, c)
    {
    }

    // modelType
    // 

    const modelType::notes_optional& modelType::
    notes () const
    {
      return this->notes_;
    }

    modelType::notes_optional& modelType::
    notes ()
    {
      return this->notes_;
    }

    void modelType::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void modelType::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void modelType::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const modelType::idtag_optional& modelType::
    idtag () const
    {
      return this->idtag_;
    }

    modelType::idtag_optional& modelType::
    idtag ()
    {
      return this->idtag_;
    }

    void modelType::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void modelType::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void modelType::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }


    // securityClassificationType
    // 

    const securityClassificationType::notes_optional& securityClassificationType::
    notes () const
    {
      return this->notes_;
    }

    securityClassificationType::notes_optional& securityClassificationType::
    notes ()
    {
      return this->notes_;
    }

    void securityClassificationType::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void securityClassificationType::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void securityClassificationType::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const securityClassificationType::idtag_optional& securityClassificationType::
    idtag () const
    {
      return this->idtag_;
    }

    securityClassificationType::idtag_optional& securityClassificationType::
    idtag ()
    {
      return this->idtag_;
    }

    void securityClassificationType::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void securityClassificationType::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void securityClassificationType::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }


    // ApplicationDomainEnumerations
    // 

    ApplicationDomainEnumerations::
    ApplicationDomainEnumerations (value v)
    : ::xml_schema::string (_xsd_ApplicationDomainEnumerations_literals_[v])
    {
    }

    ApplicationDomainEnumerations::
    ApplicationDomainEnumerations (const char* v)
    : ::xml_schema::string (v)
    {
    }

    ApplicationDomainEnumerations::
    ApplicationDomainEnumerations (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    ApplicationDomainEnumerations::
    ApplicationDomainEnumerations (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    ApplicationDomainEnumerations::
    ApplicationDomainEnumerations (const ApplicationDomainEnumerations& v,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    ApplicationDomainEnumerations& ApplicationDomainEnumerations::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_ApplicationDomainEnumerations_literals_[v]);

      return *this;
    }


    // ApplicationDomainUnion
    //

    ApplicationDomainUnion::
    ApplicationDomainUnion (const char* s)
    : ::xml_schema::string (s)
    {
    }

    ApplicationDomainUnion::
    ApplicationDomainUnion (const ::std::string& s)
    : ::xml_schema::string (s)
    {
    }

    ApplicationDomainUnion::
    ApplicationDomainUnion (const ApplicationDomainUnion& o,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (o, f, c)
    {
    }

    // applicationDomainType
    // 

    const applicationDomainType::notes_optional& applicationDomainType::
    notes () const
    {
      return this->notes_;
    }

    applicationDomainType::notes_optional& applicationDomainType::
    notes ()
    {
      return this->notes_;
    }

    void applicationDomainType::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void applicationDomainType::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void applicationDomainType::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const applicationDomainType::idtag_optional& applicationDomainType::
    idtag () const
    {
      return this->idtag_;
    }

    applicationDomainType::idtag_optional& applicationDomainType::
    idtag ()
    {
      return this->idtag_;
    }

    void applicationDomainType::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void applicationDomainType::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void applicationDomainType::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }


    // POCTypeEnumeration
    // 

    POCTypeEnumeration::
    POCTypeEnumeration (value v)
    : ::xml_schema::string (_xsd_POCTypeEnumeration_literals_[v])
    {
    }

    POCTypeEnumeration::
    POCTypeEnumeration (const char* v)
    : ::xml_schema::string (v)
    {
    }

    POCTypeEnumeration::
    POCTypeEnumeration (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    POCTypeEnumeration::
    POCTypeEnumeration (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    POCTypeEnumeration::
    POCTypeEnumeration (const POCTypeEnumeration& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    POCTypeEnumeration& POCTypeEnumeration::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_POCTypeEnumeration_literals_[v]);

      return *this;
    }


    // POCTypeUnion
    //

    POCTypeUnion::
    POCTypeUnion (const char* s)
    : ::xml_schema::string (s)
    {
    }

    POCTypeUnion::
    POCTypeUnion (const ::std::string& s)
    : ::xml_schema::string (s)
    {
    }

    POCTypeUnion::
    POCTypeUnion (const POCTypeUnion& o,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (o, f, c)
    {
    }

    // pocTypeType
    // 

    const pocTypeType::notes_optional& pocTypeType::
    notes () const
    {
      return this->notes_;
    }

    pocTypeType::notes_optional& pocTypeType::
    notes ()
    {
      return this->notes_;
    }

    void pocTypeType::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void pocTypeType::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void pocTypeType::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const pocTypeType::idtag_optional& pocTypeType::
    idtag () const
    {
      return this->idtag_;
    }

    pocTypeType::idtag_optional& pocTypeType::
    idtag ()
    {
      return this->idtag_;
    }

    void pocTypeType::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void pocTypeType::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void pocTypeType::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }


    // referenceTypeEnumerations
    // 

    referenceTypeEnumerations::
    referenceTypeEnumerations (value v)
    : ::xml_schema::string (_xsd_referenceTypeEnumerations_literals_[v])
    {
    }

    referenceTypeEnumerations::
    referenceTypeEnumerations (const char* v)
    : ::xml_schema::string (v)
    {
    }

    referenceTypeEnumerations::
    referenceTypeEnumerations (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    referenceTypeEnumerations::
    referenceTypeEnumerations (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    referenceTypeEnumerations::
    referenceTypeEnumerations (const referenceTypeEnumerations& v,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    referenceTypeEnumerations& referenceTypeEnumerations::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_referenceTypeEnumerations_literals_[v]);

      return *this;
    }


    // referenceTypeUnion
    //

    referenceTypeUnion::
    referenceTypeUnion (const char* s)
    : ::xml_schema::string (s)
    {
    }

    referenceTypeUnion::
    referenceTypeUnion (const ::std::string& s)
    : ::xml_schema::string (s)
    {
    }

    referenceTypeUnion::
    referenceTypeUnion (const referenceTypeUnion& o,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (o, f, c)
    {
    }

    // referenceType
    // 

    const referenceType::type_type& referenceType::
    type () const
    {
      return this->type_.get ();
    }

    referenceType::type_type& referenceType::
    type ()
    {
      return this->type_.get ();
    }

    void referenceType::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void referenceType::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }

    const referenceType::identification_type& referenceType::
    identification () const
    {
      return this->identification_.get ();
    }

    referenceType::identification_type& referenceType::
    identification ()
    {
      return this->identification_.get ();
    }

    void referenceType::
    identification (const identification_type& x)
    {
      this->identification_.set (x);
    }

    void referenceType::
    identification (::std::unique_ptr< identification_type > x)
    {
      this->identification_.set (std::move (x));
    }

    const referenceType::notes_optional& referenceType::
    notes () const
    {
      return this->notes_;
    }

    referenceType::notes_optional& referenceType::
    notes ()
    {
      return this->notes_;
    }

    void referenceType::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void referenceType::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void referenceType::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const referenceType::idtag_optional& referenceType::
    idtag () const
    {
      return this->idtag_;
    }

    referenceType::idtag_optional& referenceType::
    idtag ()
    {
      return this->idtag_;
    }

    void referenceType::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void referenceType::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void referenceType::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }


    // keywordType
    // 

    const keywordType::taxonomy_optional& keywordType::
    taxonomy () const
    {
      return this->taxonomy_;
    }

    keywordType::taxonomy_optional& keywordType::
    taxonomy ()
    {
      return this->taxonomy_;
    }

    void keywordType::
    taxonomy (const taxonomy_type& x)
    {
      this->taxonomy_.set (x);
    }

    void keywordType::
    taxonomy (const taxonomy_optional& x)
    {
      this->taxonomy_ = x;
    }

    void keywordType::
    taxonomy (::std::unique_ptr< taxonomy_type > x)
    {
      this->taxonomy_.set (std::move (x));
    }

    const keywordType::keywordValue_type& keywordType::
    keywordValue () const
    {
      return this->keywordValue_.get ();
    }

    keywordType::keywordValue_type& keywordType::
    keywordValue ()
    {
      return this->keywordValue_.get ();
    }

    void keywordType::
    keywordValue (const keywordValue_type& x)
    {
      this->keywordValue_.set (x);
    }

    void keywordType::
    keywordValue (::std::unique_ptr< keywordValue_type > x)
    {
      this->keywordValue_.set (std::move (x));
    }

    const keywordType::notes_optional& keywordType::
    notes () const
    {
      return this->notes_;
    }

    keywordType::notes_optional& keywordType::
    notes ()
    {
      return this->notes_;
    }

    void keywordType::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void keywordType::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void keywordType::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const keywordType::idtag_optional& keywordType::
    idtag () const
    {
      return this->idtag_;
    }

    keywordType::idtag_optional& keywordType::
    idtag ()
    {
      return this->idtag_;
    }

    void keywordType::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void keywordType::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void keywordType::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }


    // modelIdentificationType
    // 

    const modelIdentificationType::name_type& modelIdentificationType::
    name () const
    {
      return this->name_.get ();
    }

    modelIdentificationType::name_type& modelIdentificationType::
    name ()
    {
      return this->name_.get ();
    }

    void modelIdentificationType::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void modelIdentificationType::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const modelIdentificationType::type_type& modelIdentificationType::
    type () const
    {
      return this->type_.get ();
    }

    modelIdentificationType::type_type& modelIdentificationType::
    type ()
    {
      return this->type_.get ();
    }

    void modelIdentificationType::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void modelIdentificationType::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }

    const modelIdentificationType::version_type& modelIdentificationType::
    version () const
    {
      return this->version_.get ();
    }

    modelIdentificationType::version_type& modelIdentificationType::
    version ()
    {
      return this->version_.get ();
    }

    void modelIdentificationType::
    version (const version_type& x)
    {
      this->version_.set (x);
    }

    void modelIdentificationType::
    version (::std::unique_ptr< version_type > x)
    {
      this->version_.set (std::move (x));
    }

    const modelIdentificationType::modificationDate_type& modelIdentificationType::
    modificationDate () const
    {
      return this->modificationDate_.get ();
    }

    modelIdentificationType::modificationDate_type& modelIdentificationType::
    modificationDate ()
    {
      return this->modificationDate_.get ();
    }

    void modelIdentificationType::
    modificationDate (const modificationDate_type& x)
    {
      this->modificationDate_.set (x);
    }

    void modelIdentificationType::
    modificationDate (::std::unique_ptr< modificationDate_type > x)
    {
      this->modificationDate_.set (std::move (x));
    }

    const modelIdentificationType::securityClassification_type& modelIdentificationType::
    securityClassification () const
    {
      return this->securityClassification_.get ();
    }

    modelIdentificationType::securityClassification_type& modelIdentificationType::
    securityClassification ()
    {
      return this->securityClassification_.get ();
    }

    void modelIdentificationType::
    securityClassification (const securityClassification_type& x)
    {
      this->securityClassification_.set (x);
    }

    void modelIdentificationType::
    securityClassification (::std::unique_ptr< securityClassification_type > x)
    {
      this->securityClassification_.set (std::move (x));
    }

    const modelIdentificationType::releaseRestriction_sequence& modelIdentificationType::
    releaseRestriction () const
    {
      return this->releaseRestriction_;
    }

    modelIdentificationType::releaseRestriction_sequence& modelIdentificationType::
    releaseRestriction ()
    {
      return this->releaseRestriction_;
    }

    void modelIdentificationType::
    releaseRestriction (const releaseRestriction_sequence& s)
    {
      this->releaseRestriction_ = s;
    }

    const modelIdentificationType::purpose_optional& modelIdentificationType::
    purpose () const
    {
      return this->purpose_;
    }

    modelIdentificationType::purpose_optional& modelIdentificationType::
    purpose ()
    {
      return this->purpose_;
    }

    void modelIdentificationType::
    purpose (const purpose_type& x)
    {
      this->purpose_.set (x);
    }

    void modelIdentificationType::
    purpose (const purpose_optional& x)
    {
      this->purpose_ = x;
    }

    void modelIdentificationType::
    purpose (::std::unique_ptr< purpose_type > x)
    {
      this->purpose_.set (std::move (x));
    }

    const modelIdentificationType::applicationDomain_optional& modelIdentificationType::
    applicationDomain () const
    {
      return this->applicationDomain_;
    }

    modelIdentificationType::applicationDomain_optional& modelIdentificationType::
    applicationDomain ()
    {
      return this->applicationDomain_;
    }

    void modelIdentificationType::
    applicationDomain (const applicationDomain_type& x)
    {
      this->applicationDomain_.set (x);
    }

    void modelIdentificationType::
    applicationDomain (const applicationDomain_optional& x)
    {
      this->applicationDomain_ = x;
    }

    void modelIdentificationType::
    applicationDomain (::std::unique_ptr< applicationDomain_type > x)
    {
      this->applicationDomain_.set (std::move (x));
    }

    const modelIdentificationType::description_type& modelIdentificationType::
    description () const
    {
      return this->description_.get ();
    }

    modelIdentificationType::description_type& modelIdentificationType::
    description ()
    {
      return this->description_.get ();
    }

    void modelIdentificationType::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void modelIdentificationType::
    description (::std::unique_ptr< description_type > x)
    {
      this->description_.set (std::move (x));
    }

    const modelIdentificationType::useLimitation_optional& modelIdentificationType::
    useLimitation () const
    {
      return this->useLimitation_;
    }

    modelIdentificationType::useLimitation_optional& modelIdentificationType::
    useLimitation ()
    {
      return this->useLimitation_;
    }

    void modelIdentificationType::
    useLimitation (const useLimitation_type& x)
    {
      this->useLimitation_.set (x);
    }

    void modelIdentificationType::
    useLimitation (const useLimitation_optional& x)
    {
      this->useLimitation_ = x;
    }

    void modelIdentificationType::
    useLimitation (::std::unique_ptr< useLimitation_type > x)
    {
      this->useLimitation_.set (std::move (x));
    }

    const modelIdentificationType::useHistory_sequence& modelIdentificationType::
    useHistory () const
    {
      return this->useHistory_;
    }

    modelIdentificationType::useHistory_sequence& modelIdentificationType::
    useHistory ()
    {
      return this->useHistory_;
    }

    void modelIdentificationType::
    useHistory (const useHistory_sequence& s)
    {
      this->useHistory_ = s;
    }

    const modelIdentificationType::keyword_sequence& modelIdentificationType::
    keyword () const
    {
      return this->keyword_;
    }

    modelIdentificationType::keyword_sequence& modelIdentificationType::
    keyword ()
    {
      return this->keyword_;
    }

    void modelIdentificationType::
    keyword (const keyword_sequence& s)
    {
      this->keyword_ = s;
    }

    const modelIdentificationType::poc_sequence& modelIdentificationType::
    poc () const
    {
      return this->poc_;
    }

    modelIdentificationType::poc_sequence& modelIdentificationType::
    poc ()
    {
      return this->poc_;
    }

    void modelIdentificationType::
    poc (const poc_sequence& s)
    {
      this->poc_ = s;
    }

    const modelIdentificationType::reference_sequence& modelIdentificationType::
    reference () const
    {
      return this->reference_;
    }

    modelIdentificationType::reference_sequence& modelIdentificationType::
    reference ()
    {
      return this->reference_;
    }

    void modelIdentificationType::
    reference (const reference_sequence& s)
    {
      this->reference_ = s;
    }

    const modelIdentificationType::other_optional& modelIdentificationType::
    other () const
    {
      return this->other_;
    }

    modelIdentificationType::other_optional& modelIdentificationType::
    other ()
    {
      return this->other_;
    }

    void modelIdentificationType::
    other (const other_type& x)
    {
      this->other_.set (x);
    }

    void modelIdentificationType::
    other (const other_optional& x)
    {
      this->other_ = x;
    }

    void modelIdentificationType::
    other (::std::unique_ptr< other_type > x)
    {
      this->other_.set (std::move (x));
    }

    const modelIdentificationType::glyph_optional& modelIdentificationType::
    glyph () const
    {
      return this->glyph_;
    }

    modelIdentificationType::glyph_optional& modelIdentificationType::
    glyph ()
    {
      return this->glyph_;
    }

    void modelIdentificationType::
    glyph (const glyph_type& x)
    {
      this->glyph_.set (x);
    }

    void modelIdentificationType::
    glyph (const glyph_optional& x)
    {
      this->glyph_ = x;
    }

    void modelIdentificationType::
    glyph (::std::unique_ptr< glyph_type > x)
    {
      this->glyph_.set (std::move (x));
    }

    const modelIdentificationType::notes_optional& modelIdentificationType::
    notes () const
    {
      return this->notes_;
    }

    modelIdentificationType::notes_optional& modelIdentificationType::
    notes ()
    {
      return this->notes_;
    }

    void modelIdentificationType::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void modelIdentificationType::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void modelIdentificationType::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const modelIdentificationType::idtag_optional& modelIdentificationType::
    idtag () const
    {
      return this->idtag_;
    }

    modelIdentificationType::idtag_optional& modelIdentificationType::
    idtag ()
    {
      return this->idtag_;
    }

    void modelIdentificationType::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void modelIdentificationType::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void modelIdentificationType::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }


    // type
    // 

    const type::notes_optional& type::
    notes () const
    {
      return this->notes_;
    }

    type::notes_optional& type::
    notes ()
    {
      return this->notes_;
    }

    void type::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void type::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void type::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const type::idtag_optional& type::
    idtag () const
    {
      return this->idtag_;
    }

    type::idtag_optional& type::
    idtag ()
    {
      return this->idtag_;
    }

    void type::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void type::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void type::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }


    // identification
    // 

    const identification::notes_optional& identification::
    notes () const
    {
      return this->notes_;
    }

    identification::notes_optional& identification::
    notes ()
    {
      return this->notes_;
    }

    void identification::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void identification::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void identification::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const identification::idtag_optional& identification::
    idtag () const
    {
      return this->idtag_;
    }

    identification::idtag_optional& identification::
    idtag ()
    {
      return this->idtag_;
    }

    void identification::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void identification::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void identification::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }


    // modificationDate
    // 

    const modificationDate::notes_optional& modificationDate::
    notes () const
    {
      return this->notes_;
    }

    modificationDate::notes_optional& modificationDate::
    notes ()
    {
      return this->notes_;
    }

    void modificationDate::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void modificationDate::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void modificationDate::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const modificationDate::idtag_optional& modificationDate::
    idtag () const
    {
      return this->idtag_;
    }

    modificationDate::idtag_optional& modificationDate::
    idtag ()
    {
      return this->idtag_;
    }

    void modificationDate::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void modificationDate::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void modificationDate::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }


    // poc
    // 

    const poc::notes_optional& poc::
    notes () const
    {
      return this->notes_;
    }

    poc::notes_optional& poc::
    notes ()
    {
      return this->notes_;
    }

    void poc::
    notes (const notes_type& x)
    {
      this->notes_.set (x);
    }

    void poc::
    notes (const notes_optional& x)
    {
      this->notes_ = x;
    }

    void poc::
    notes (::std::unique_ptr< notes_type > x)
    {
      this->notes_.set (std::move (x));
    }

    const poc::idtag_optional& poc::
    idtag () const
    {
      return this->idtag_;
    }

    poc::idtag_optional& poc::
    idtag ()
    {
      return this->idtag_;
    }

    void poc::
    idtag (const idtag_type& x)
    {
      this->idtag_.set (x);
    }

    void poc::
    idtag (const idtag_optional& x)
    {
      this->idtag_ = x;
    }

    void poc::
    idtag (::std::unique_ptr< idtag_type > x)
    {
      this->idtag_.set (std::move (x));
    }


    // glyph
    // 
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace schemas
{
  namespace modelID
  {
    // String
    //

    String::
    String ()
    : ::xml_schema::string (),
      notes_ (this),
      idtag_ (this)
    {
    }

    String::
    String (const char* _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    String::
    String (const ::std::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    String::
    String (const ::xml_schema::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    String::
    String (const String& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this)
    {
    }

    String::
    String (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      notes_ (this),
      idtag_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void String::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }
      }
    }

    String* String::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class String (*this, f, c);
    }

    String& String::
    operator= (const String& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::string& > (*this) = x;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
      }

      return *this;
    }

    String::
    ~String ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, String >
    _xsd_String_type_factory_init (
      "String",
      "http://www.sisostds.org/schemas/modelID");

    // IdentifierType
    //

    IdentifierType::
    IdentifierType (const char* _xsd_ncname_base)
    : ::xml_schema::ncname (_xsd_ncname_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    IdentifierType::
    IdentifierType (const ::std::string& _xsd_ncname_base)
    : ::xml_schema::ncname (_xsd_ncname_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    IdentifierType::
    IdentifierType (const ::xml_schema::ncname& _xsd_ncname_base)
    : ::xml_schema::ncname (_xsd_ncname_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    IdentifierType::
    IdentifierType (const IdentifierType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::ncname (x, f, c),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this)
    {
    }

    IdentifierType::
    IdentifierType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::ncname (e, f | ::xml_schema::flags::base, c),
      notes_ (this),
      idtag_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void IdentifierType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }
      }
    }

    IdentifierType* IdentifierType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IdentifierType (*this, f, c);
    }

    IdentifierType& IdentifierType::
    operator= (const IdentifierType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::ncname& > (*this) = x;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
      }

      return *this;
    }

    IdentifierType::
    ~IdentifierType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IdentifierType >
    _xsd_IdentifierType_type_factory_init (
      "IdentifierType",
      "http://www.sisostds.org/schemas/modelID");

    // nonEmptyString
    //

    nonEmptyString::
    nonEmptyString ()
    : ::xml_schema::string ()
    {
    }

    nonEmptyString::
    nonEmptyString (const char* _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    nonEmptyString::
    nonEmptyString (const ::std::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    nonEmptyString::
    nonEmptyString (const ::xml_schema::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base)
    {
    }

    nonEmptyString::
    nonEmptyString (const nonEmptyString& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    nonEmptyString::
    nonEmptyString (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    nonEmptyString::
    nonEmptyString (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    nonEmptyString::
    nonEmptyString (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    nonEmptyString* nonEmptyString::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class nonEmptyString (*this, f, c);
    }

    nonEmptyString::
    ~nonEmptyString ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, nonEmptyString >
    _xsd_nonEmptyString_type_factory_init (
      "nonEmptyString",
      "http://www.sisostds.org/schemas/modelID");

    // NonEmptyString
    //

    NonEmptyString::
    NonEmptyString ()
    : ::schemas::modelID::nonEmptyString (),
      notes_ (this),
      idtag_ (this)
    {
    }

    NonEmptyString::
    NonEmptyString (const char* _xsd_string_base)
    : ::schemas::modelID::nonEmptyString (_xsd_string_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    NonEmptyString::
    NonEmptyString (const ::std::string& _xsd_string_base)
    : ::schemas::modelID::nonEmptyString (_xsd_string_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    NonEmptyString::
    NonEmptyString (const ::xml_schema::string& _xsd_string_base)
    : ::schemas::modelID::nonEmptyString (_xsd_string_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    NonEmptyString::
    NonEmptyString (const NonEmptyString& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::schemas::modelID::nonEmptyString (x, f, c),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this)
    {
    }

    NonEmptyString::
    NonEmptyString (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::schemas::modelID::nonEmptyString (e, f | ::xml_schema::flags::base, c),
      notes_ (this),
      idtag_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void NonEmptyString::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }
      }
    }

    NonEmptyString* NonEmptyString::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NonEmptyString (*this, f, c);
    }

    NonEmptyString& NonEmptyString::
    operator= (const NonEmptyString& x)
    {
      if (this != &x)
      {
        static_cast< ::schemas::modelID::nonEmptyString& > (*this) = x;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
      }

      return *this;
    }

    NonEmptyString::
    ~NonEmptyString ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, NonEmptyString >
    _xsd_NonEmptyString_type_factory_init (
      "NonEmptyString",
      "http://www.sisostds.org/schemas/modelID");

    // OMTypeEnumerations
    //

    OMTypeEnumerations::
    OMTypeEnumerations (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_OMTypeEnumerations_convert ();
    }

    OMTypeEnumerations::
    OMTypeEnumerations (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_OMTypeEnumerations_convert ();
    }

    OMTypeEnumerations::
    OMTypeEnumerations (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_OMTypeEnumerations_convert ();
    }

    OMTypeEnumerations* OMTypeEnumerations::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OMTypeEnumerations (*this, f, c);
    }

    OMTypeEnumerations::value OMTypeEnumerations::
    _xsd_OMTypeEnumerations_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_OMTypeEnumerations_literals_);
      const value* i (::std::lower_bound (
                        _xsd_OMTypeEnumerations_indexes_,
                        _xsd_OMTypeEnumerations_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_OMTypeEnumerations_indexes_ + 3 || _xsd_OMTypeEnumerations_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const OMTypeEnumerations::
    _xsd_OMTypeEnumerations_literals_[3] =
    {
      "FOM",
      "SOM",
      "BOM"
    };

    const OMTypeEnumerations::value OMTypeEnumerations::
    _xsd_OMTypeEnumerations_indexes_[3] =
    {
      ::schemas::modelID::OMTypeEnumerations::BOM,
      ::schemas::modelID::OMTypeEnumerations::FOM,
      ::schemas::modelID::OMTypeEnumerations::SOM
    };

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OMTypeEnumerations >
    _xsd_OMTypeEnumerations_type_factory_init (
      "OMTypeEnumerations",
      "http://www.sisostds.org/schemas/modelID");

    // OMTypeUnion
    //

    OMTypeUnion::
    OMTypeUnion (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    OMTypeUnion::
    OMTypeUnion (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    OMTypeUnion::
    OMTypeUnion (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    OMTypeUnion* OMTypeUnion::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OMTypeUnion (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OMTypeUnion >
    _xsd_OMTypeUnion_type_factory_init (
      "OMTypeUnion",
      "http://www.sisostds.org/schemas/modelID");

    // glyphTypeEnumerations
    //

    glyphTypeEnumerations::
    glyphTypeEnumerations (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_glyphTypeEnumerations_convert ();
    }

    glyphTypeEnumerations::
    glyphTypeEnumerations (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_glyphTypeEnumerations_convert ();
    }

    glyphTypeEnumerations::
    glyphTypeEnumerations (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_glyphTypeEnumerations_convert ();
    }

    glyphTypeEnumerations* glyphTypeEnumerations::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class glyphTypeEnumerations (*this, f, c);
    }

    glyphTypeEnumerations::value glyphTypeEnumerations::
    _xsd_glyphTypeEnumerations_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_glyphTypeEnumerations_literals_);
      const value* i (::std::lower_bound (
                        _xsd_glyphTypeEnumerations_indexes_,
                        _xsd_glyphTypeEnumerations_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_glyphTypeEnumerations_indexes_ + 5 || _xsd_glyphTypeEnumerations_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const glyphTypeEnumerations::
    _xsd_glyphTypeEnumerations_literals_[5] =
    {
      "BITMAP",
      "JPG",
      "GIF",
      "PNG",
      "TIFF"
    };

    const glyphTypeEnumerations::value glyphTypeEnumerations::
    _xsd_glyphTypeEnumerations_indexes_[5] =
    {
      ::schemas::modelID::glyphTypeEnumerations::BITMAP,
      ::schemas::modelID::glyphTypeEnumerations::GIF,
      ::schemas::modelID::glyphTypeEnumerations::JPG,
      ::schemas::modelID::glyphTypeEnumerations::PNG,
      ::schemas::modelID::glyphTypeEnumerations::TIFF
    };

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, glyphTypeEnumerations >
    _xsd_glyphTypeEnumerations_type_factory_init (
      "glyphTypeEnumerations",
      "http://www.sisostds.org/schemas/modelID");

    // glyphTypeUnion
    //

    glyphTypeUnion::
    glyphTypeUnion (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    glyphTypeUnion::
    glyphTypeUnion (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    glyphTypeUnion::
    glyphTypeUnion (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    glyphTypeUnion* glyphTypeUnion::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class glyphTypeUnion (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, glyphTypeUnion >
    _xsd_glyphTypeUnion_type_factory_init (
      "glyphTypeUnion",
      "http://www.sisostds.org/schemas/modelID");

    // glyphType
    //

    glyphType::
    glyphType (const type_type& type)
    : ::xml_schema::base64_binary (),
      notes_ (this),
      idtag_ (this),
      type_ (type, this),
      height_ (this),
      width_ (this),
      alt_ (this)
    {
    }

    glyphType::
    glyphType (const ::xml_schema::base64_binary& _xsd_base64_binary_base,
               const type_type& type)
    : ::xml_schema::base64_binary (_xsd_base64_binary_base),
      notes_ (this),
      idtag_ (this),
      type_ (type, this),
      height_ (this),
      width_ (this),
      alt_ (this)
    {
    }

    glyphType::
    glyphType (const glyphType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::base64_binary (x, f, c),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this),
      type_ (x.type_, f, this),
      height_ (x.height_, f, this),
      width_ (x.width_, f, this),
      alt_ (x.alt_, f, this)
    {
    }

    glyphType::
    glyphType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::base64_binary (e, f | ::xml_schema::flags::base, c),
      notes_ (this),
      idtag_ (this),
      type_ (this),
      height_ (this),
      width_ (this),
      alt_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void glyphType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "height" && n.namespace_ ().empty ())
        {
          this->height_.set (height_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "width" && n.namespace_ ().empty ())
        {
          this->width_.set (width_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "alt" && n.namespace_ ().empty ())
        {
          this->alt_.set (alt_traits::create (i, f, this));
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    glyphType* glyphType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class glyphType (*this, f, c);
    }

    glyphType& glyphType::
    operator= (const glyphType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::base64_binary& > (*this) = x;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
        this->type_ = x.type_;
        this->height_ = x.height_;
        this->width_ = x.width_;
        this->alt_ = x.alt_;
      }

      return *this;
    }

    glyphType::
    ~glyphType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, glyphType >
    _xsd_glyphType_type_factory_init (
      "glyphType",
      "http://www.sisostds.org/schemas/modelID");

    // pocType
    //

    pocType::
    pocType (const pocType1_type& pocType1)
    : ::xml_schema::type (),
      pocType1_ (pocType1, this),
      pocName_ (this),
      pocOrg_ (this),
      pocTelephone_ (this),
      pocEmail_ (this)
    {
    }

    pocType::
    pocType (::std::unique_ptr< pocType1_type > pocType1)
    : ::xml_schema::type (),
      pocType1_ (std::move (pocType1), this),
      pocName_ (this),
      pocOrg_ (this),
      pocTelephone_ (this),
      pocEmail_ (this)
    {
    }

    pocType::
    pocType (const pocType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      pocType1_ (x.pocType1_, f, this),
      pocName_ (x.pocName_, f, this),
      pocOrg_ (x.pocOrg_, f, this),
      pocTelephone_ (x.pocTelephone_, f, this),
      pocEmail_ (x.pocEmail_, f, this)
    {
    }

    pocType::
    pocType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      pocType1_ (this),
      pocName_ (this),
      pocOrg_ (this),
      pocTelephone_ (this),
      pocEmail_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void pocType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // pocType
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "pocType",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< pocType1_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!pocType1_.present ())
            {
              ::std::unique_ptr< pocType1_type > r (
                dynamic_cast< pocType1_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->pocType1_.set (::std::move (r));
              continue;
            }
          }
        }

        // pocName
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "pocName",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< pocName_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->pocName_)
            {
              ::std::unique_ptr< pocName_type > r (
                dynamic_cast< pocName_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->pocName_.set (::std::move (r));
              continue;
            }
          }
        }

        // pocOrg
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "pocOrg",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< pocOrg_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->pocOrg_)
            {
              ::std::unique_ptr< pocOrg_type > r (
                dynamic_cast< pocOrg_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->pocOrg_.set (::std::move (r));
              continue;
            }
          }
        }

        // pocTelephone
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "pocTelephone",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< pocTelephone_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< pocTelephone_type > r (
              dynamic_cast< pocTelephone_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->pocTelephone_.push_back (::std::move (r));
            continue;
          }
        }

        // pocEmail
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "pocEmail",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< pocEmail_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< pocEmail_type > r (
              dynamic_cast< pocEmail_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->pocEmail_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!pocType1_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "pocType",
          "http://www.sisostds.org/schemas/modelID");
      }
    }

    pocType* pocType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class pocType (*this, f, c);
    }

    pocType& pocType::
    operator= (const pocType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->pocType1_ = x.pocType1_;
        this->pocName_ = x.pocName_;
        this->pocOrg_ = x.pocOrg_;
        this->pocTelephone_ = x.pocTelephone_;
        this->pocEmail_ = x.pocEmail_;
      }

      return *this;
    }

    pocType::
    ~pocType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, pocType >
    _xsd_pocType_type_factory_init (
      "pocType",
      "http://www.sisostds.org/schemas/modelID");

    // SecurityClassificationEnumeration
    //

    SecurityClassificationEnumeration::
    SecurityClassificationEnumeration (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_SecurityClassificationEnumeration_convert ();
    }

    SecurityClassificationEnumeration::
    SecurityClassificationEnumeration (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_SecurityClassificationEnumeration_convert ();
    }

    SecurityClassificationEnumeration::
    SecurityClassificationEnumeration (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_SecurityClassificationEnumeration_convert ();
    }

    SecurityClassificationEnumeration* SecurityClassificationEnumeration::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SecurityClassificationEnumeration (*this, f, c);
    }

    SecurityClassificationEnumeration::value SecurityClassificationEnumeration::
    _xsd_SecurityClassificationEnumeration_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SecurityClassificationEnumeration_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SecurityClassificationEnumeration_indexes_,
                        _xsd_SecurityClassificationEnumeration_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_SecurityClassificationEnumeration_indexes_ + 4 || _xsd_SecurityClassificationEnumeration_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const SecurityClassificationEnumeration::
    _xsd_SecurityClassificationEnumeration_literals_[4] =
    {
      "Unclassified",
      "Confidential",
      "Secret",
      "Top Secret"
    };

    const SecurityClassificationEnumeration::value SecurityClassificationEnumeration::
    _xsd_SecurityClassificationEnumeration_indexes_[4] =
    {
      ::schemas::modelID::SecurityClassificationEnumeration::Confidential,
      ::schemas::modelID::SecurityClassificationEnumeration::Secret,
      ::schemas::modelID::SecurityClassificationEnumeration::Top_Secret,
      ::schemas::modelID::SecurityClassificationEnumeration::Unclassified
    };

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SecurityClassificationEnumeration >
    _xsd_SecurityClassificationEnumeration_type_factory_init (
      "SecurityClassificationEnumeration",
      "http://www.sisostds.org/schemas/modelID");

    // SecurityClassificationUnion
    //

    SecurityClassificationUnion::
    SecurityClassificationUnion (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    SecurityClassificationUnion::
    SecurityClassificationUnion (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    SecurityClassificationUnion::
    SecurityClassificationUnion (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    SecurityClassificationUnion* SecurityClassificationUnion::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SecurityClassificationUnion (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SecurityClassificationUnion >
    _xsd_SecurityClassificationUnion_type_factory_init (
      "SecurityClassificationUnion",
      "http://www.sisostds.org/schemas/modelID");

    // modelType
    //

    modelType::
    modelType (const char* _xsd_OMTypeUnion_base)
    : ::schemas::modelID::OMTypeUnion (_xsd_OMTypeUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    modelType::
    modelType (const ::std::string& _xsd_OMTypeUnion_base)
    : ::schemas::modelID::OMTypeUnion (_xsd_OMTypeUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    modelType::
    modelType (const ::schemas::modelID::OMTypeUnion& _xsd_OMTypeUnion_base)
    : ::schemas::modelID::OMTypeUnion (_xsd_OMTypeUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    modelType::
    modelType (const modelType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::schemas::modelID::OMTypeUnion (x, f, c),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this)
    {
    }

    modelType::
    modelType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::schemas::modelID::OMTypeUnion (e, f | ::xml_schema::flags::base, c),
      notes_ (this),
      idtag_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void modelType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }
      }
    }

    modelType* modelType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class modelType (*this, f, c);
    }

    modelType& modelType::
    operator= (const modelType& x)
    {
      if (this != &x)
      {
        static_cast< ::schemas::modelID::OMTypeUnion& > (*this) = x;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
      }

      return *this;
    }

    modelType::
    ~modelType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, modelType >
    _xsd_modelType_type_factory_init (
      "modelType",
      "http://www.sisostds.org/schemas/modelID");

    // securityClassificationType
    //

    securityClassificationType::
    securityClassificationType (const char* _xsd_SecurityClassificationUnion_base)
    : ::schemas::modelID::SecurityClassificationUnion (_xsd_SecurityClassificationUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    securityClassificationType::
    securityClassificationType (const ::std::string& _xsd_SecurityClassificationUnion_base)
    : ::schemas::modelID::SecurityClassificationUnion (_xsd_SecurityClassificationUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    securityClassificationType::
    securityClassificationType (const ::schemas::modelID::SecurityClassificationUnion& _xsd_SecurityClassificationUnion_base)
    : ::schemas::modelID::SecurityClassificationUnion (_xsd_SecurityClassificationUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    securityClassificationType::
    securityClassificationType (const securityClassificationType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::schemas::modelID::SecurityClassificationUnion (x, f, c),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this)
    {
    }

    securityClassificationType::
    securityClassificationType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::schemas::modelID::SecurityClassificationUnion (e, f | ::xml_schema::flags::base, c),
      notes_ (this),
      idtag_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void securityClassificationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }
      }
    }

    securityClassificationType* securityClassificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class securityClassificationType (*this, f, c);
    }

    securityClassificationType& securityClassificationType::
    operator= (const securityClassificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::schemas::modelID::SecurityClassificationUnion& > (*this) = x;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
      }

      return *this;
    }

    securityClassificationType::
    ~securityClassificationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, securityClassificationType >
    _xsd_securityClassificationType_type_factory_init (
      "securityClassificationType",
      "http://www.sisostds.org/schemas/modelID");

    // ApplicationDomainEnumerations
    //

    ApplicationDomainEnumerations::
    ApplicationDomainEnumerations (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_ApplicationDomainEnumerations_convert ();
    }

    ApplicationDomainEnumerations::
    ApplicationDomainEnumerations (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_ApplicationDomainEnumerations_convert ();
    }

    ApplicationDomainEnumerations::
    ApplicationDomainEnumerations (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_ApplicationDomainEnumerations_convert ();
    }

    ApplicationDomainEnumerations* ApplicationDomainEnumerations::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ApplicationDomainEnumerations (*this, f, c);
    }

    ApplicationDomainEnumerations::value ApplicationDomainEnumerations::
    _xsd_ApplicationDomainEnumerations_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ApplicationDomainEnumerations_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ApplicationDomainEnumerations_indexes_,
                        _xsd_ApplicationDomainEnumerations_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_ApplicationDomainEnumerations_indexes_ + 5 || _xsd_ApplicationDomainEnumerations_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ApplicationDomainEnumerations::
    _xsd_ApplicationDomainEnumerations_literals_[5] =
    {
      "Analysis",
      "Training",
      "Test and Evaluation",
      "Engineering",
      "Acquisition"
    };

    const ApplicationDomainEnumerations::value ApplicationDomainEnumerations::
    _xsd_ApplicationDomainEnumerations_indexes_[5] =
    {
      ::schemas::modelID::ApplicationDomainEnumerations::Acquisition,
      ::schemas::modelID::ApplicationDomainEnumerations::Analysis,
      ::schemas::modelID::ApplicationDomainEnumerations::Engineering,
      ::schemas::modelID::ApplicationDomainEnumerations::Test_and_Evaluation,
      ::schemas::modelID::ApplicationDomainEnumerations::Training
    };

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ApplicationDomainEnumerations >
    _xsd_ApplicationDomainEnumerations_type_factory_init (
      "ApplicationDomainEnumerations",
      "http://www.sisostds.org/schemas/modelID");

    // ApplicationDomainUnion
    //

    ApplicationDomainUnion::
    ApplicationDomainUnion (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    ApplicationDomainUnion::
    ApplicationDomainUnion (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    ApplicationDomainUnion::
    ApplicationDomainUnion (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    ApplicationDomainUnion* ApplicationDomainUnion::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ApplicationDomainUnion (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ApplicationDomainUnion >
    _xsd_ApplicationDomainUnion_type_factory_init (
      "ApplicationDomainUnion",
      "http://www.sisostds.org/schemas/modelID");

    // applicationDomainType
    //

    applicationDomainType::
    applicationDomainType (const char* _xsd_ApplicationDomainUnion_base)
    : ::schemas::modelID::ApplicationDomainUnion (_xsd_ApplicationDomainUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    applicationDomainType::
    applicationDomainType (const ::std::string& _xsd_ApplicationDomainUnion_base)
    : ::schemas::modelID::ApplicationDomainUnion (_xsd_ApplicationDomainUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    applicationDomainType::
    applicationDomainType (const ::schemas::modelID::ApplicationDomainUnion& _xsd_ApplicationDomainUnion_base)
    : ::schemas::modelID::ApplicationDomainUnion (_xsd_ApplicationDomainUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    applicationDomainType::
    applicationDomainType (const applicationDomainType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::schemas::modelID::ApplicationDomainUnion (x, f, c),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this)
    {
    }

    applicationDomainType::
    applicationDomainType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::schemas::modelID::ApplicationDomainUnion (e, f | ::xml_schema::flags::base, c),
      notes_ (this),
      idtag_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void applicationDomainType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }
      }
    }

    applicationDomainType* applicationDomainType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class applicationDomainType (*this, f, c);
    }

    applicationDomainType& applicationDomainType::
    operator= (const applicationDomainType& x)
    {
      if (this != &x)
      {
        static_cast< ::schemas::modelID::ApplicationDomainUnion& > (*this) = x;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
      }

      return *this;
    }

    applicationDomainType::
    ~applicationDomainType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, applicationDomainType >
    _xsd_applicationDomainType_type_factory_init (
      "applicationDomainType",
      "http://www.sisostds.org/schemas/modelID");

    // POCTypeEnumeration
    //

    POCTypeEnumeration::
    POCTypeEnumeration (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_POCTypeEnumeration_convert ();
    }

    POCTypeEnumeration::
    POCTypeEnumeration (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_POCTypeEnumeration_convert ();
    }

    POCTypeEnumeration::
    POCTypeEnumeration (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_POCTypeEnumeration_convert ();
    }

    POCTypeEnumeration* POCTypeEnumeration::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class POCTypeEnumeration (*this, f, c);
    }

    POCTypeEnumeration::value POCTypeEnumeration::
    _xsd_POCTypeEnumeration_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_POCTypeEnumeration_literals_);
      const value* i (::std::lower_bound (
                        _xsd_POCTypeEnumeration_indexes_,
                        _xsd_POCTypeEnumeration_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_POCTypeEnumeration_indexes_ + 6 || _xsd_POCTypeEnumeration_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const POCTypeEnumeration::
    _xsd_POCTypeEnumeration_literals_[6] =
    {
      "Primary author",
      "Contributor",
      "Proponent",
      "Sponsor",
      "Release authority",
      "Technical POC"
    };

    const POCTypeEnumeration::value POCTypeEnumeration::
    _xsd_POCTypeEnumeration_indexes_[6] =
    {
      ::schemas::modelID::POCTypeEnumeration::Contributor,
      ::schemas::modelID::POCTypeEnumeration::Primary_author,
      ::schemas::modelID::POCTypeEnumeration::Proponent,
      ::schemas::modelID::POCTypeEnumeration::Release_authority,
      ::schemas::modelID::POCTypeEnumeration::Sponsor,
      ::schemas::modelID::POCTypeEnumeration::Technical_POC
    };

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, POCTypeEnumeration >
    _xsd_POCTypeEnumeration_type_factory_init (
      "POCTypeEnumeration",
      "http://www.sisostds.org/schemas/modelID");

    // POCTypeUnion
    //

    POCTypeUnion::
    POCTypeUnion (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    POCTypeUnion::
    POCTypeUnion (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    POCTypeUnion::
    POCTypeUnion (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    POCTypeUnion* POCTypeUnion::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class POCTypeUnion (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, POCTypeUnion >
    _xsd_POCTypeUnion_type_factory_init (
      "POCTypeUnion",
      "http://www.sisostds.org/schemas/modelID");

    // pocTypeType
    //

    pocTypeType::
    pocTypeType (const char* _xsd_POCTypeUnion_base)
    : ::schemas::modelID::POCTypeUnion (_xsd_POCTypeUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    pocTypeType::
    pocTypeType (const ::std::string& _xsd_POCTypeUnion_base)
    : ::schemas::modelID::POCTypeUnion (_xsd_POCTypeUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    pocTypeType::
    pocTypeType (const ::schemas::modelID::POCTypeUnion& _xsd_POCTypeUnion_base)
    : ::schemas::modelID::POCTypeUnion (_xsd_POCTypeUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    pocTypeType::
    pocTypeType (const pocTypeType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::schemas::modelID::POCTypeUnion (x, f, c),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this)
    {
    }

    pocTypeType::
    pocTypeType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::schemas::modelID::POCTypeUnion (e, f | ::xml_schema::flags::base, c),
      notes_ (this),
      idtag_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void pocTypeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }
      }
    }

    pocTypeType* pocTypeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class pocTypeType (*this, f, c);
    }

    pocTypeType& pocTypeType::
    operator= (const pocTypeType& x)
    {
      if (this != &x)
      {
        static_cast< ::schemas::modelID::POCTypeUnion& > (*this) = x;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
      }

      return *this;
    }

    pocTypeType::
    ~pocTypeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, pocTypeType >
    _xsd_pocTypeType_type_factory_init (
      "pocTypeType",
      "http://www.sisostds.org/schemas/modelID");

    // referenceTypeEnumerations
    //

    referenceTypeEnumerations::
    referenceTypeEnumerations (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_referenceTypeEnumerations_convert ();
    }

    referenceTypeEnumerations::
    referenceTypeEnumerations (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_referenceTypeEnumerations_convert ();
    }

    referenceTypeEnumerations::
    referenceTypeEnumerations (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_referenceTypeEnumerations_convert ();
    }

    referenceTypeEnumerations* referenceTypeEnumerations::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class referenceTypeEnumerations (*this, f, c);
    }

    referenceTypeEnumerations::value referenceTypeEnumerations::
    _xsd_referenceTypeEnumerations_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_referenceTypeEnumerations_literals_);
      const value* i (::std::lower_bound (
                        _xsd_referenceTypeEnumerations_indexes_,
                        _xsd_referenceTypeEnumerations_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_referenceTypeEnumerations_indexes_ + 3 || _xsd_referenceTypeEnumerations_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const referenceTypeEnumerations::
    _xsd_referenceTypeEnumerations_literals_[3] =
    {
      "Source Material",
      "Conceptual Model",
      "Related BOM"
    };

    const referenceTypeEnumerations::value referenceTypeEnumerations::
    _xsd_referenceTypeEnumerations_indexes_[3] =
    {
      ::schemas::modelID::referenceTypeEnumerations::Conceptual_Model,
      ::schemas::modelID::referenceTypeEnumerations::Related_BOM,
      ::schemas::modelID::referenceTypeEnumerations::Source_Material
    };

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, referenceTypeEnumerations >
    _xsd_referenceTypeEnumerations_type_factory_init (
      "referenceTypeEnumerations",
      "http://www.sisostds.org/schemas/modelID");

    // referenceTypeUnion
    //

    referenceTypeUnion::
    referenceTypeUnion (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    referenceTypeUnion::
    referenceTypeUnion (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    referenceTypeUnion::
    referenceTypeUnion (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    referenceTypeUnion* referenceTypeUnion::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class referenceTypeUnion (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, referenceTypeUnion >
    _xsd_referenceTypeUnion_type_factory_init (
      "referenceTypeUnion",
      "http://www.sisostds.org/schemas/modelID");

    // referenceType
    //

    referenceType::
    referenceType (const type_type& type,
                   const identification_type& identification)
    : ::xml_schema::type (),
      type_ (type, this),
      identification_ (identification, this),
      notes_ (this),
      idtag_ (this)
    {
    }

    referenceType::
    referenceType (::std::unique_ptr< type_type > type,
                   ::std::unique_ptr< identification_type > identification)
    : ::xml_schema::type (),
      type_ (std::move (type), this),
      identification_ (std::move (identification), this),
      notes_ (this),
      idtag_ (this)
    {
    }

    referenceType::
    referenceType (const referenceType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      type_ (x.type_, f, this),
      identification_ (x.identification_, f, this),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this)
    {
    }

    referenceType::
    referenceType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      type_ (this),
      identification_ (this),
      notes_ (this),
      idtag_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void referenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // type
        //
        if (n.name () == "type" && n.namespace_ () == "http://www.sisostds.org/schemas/modelID")
        {
          ::std::unique_ptr< type_type > r (
            type_traits::create (i, f, this));

          if (!type_.present ())
          {
            this->type_.set (::std::move (r));
            continue;
          }
        }

        // identification
        //
        if (n.name () == "identification" && n.namespace_ () == "http://www.sisostds.org/schemas/modelID")
        {
          ::std::unique_ptr< identification_type > r (
            identification_traits::create (i, f, this));

          if (!identification_.present ())
          {
            this->identification_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "type",
          "http://www.sisostds.org/schemas/modelID");
      }

      if (!identification_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "identification",
          "http://www.sisostds.org/schemas/modelID");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }
      }
    }

    referenceType* referenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class referenceType (*this, f, c);
    }

    referenceType& referenceType::
    operator= (const referenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->type_ = x.type_;
        this->identification_ = x.identification_;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
      }

      return *this;
    }

    referenceType::
    ~referenceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, referenceType >
    _xsd_referenceType_type_factory_init (
      "referenceType",
      "http://www.sisostds.org/schemas/modelID");

    // keywordType
    //

    keywordType::
    keywordType (const keywordValue_type& keywordValue)
    : ::xml_schema::type (),
      taxonomy_ (this),
      keywordValue_ (keywordValue, this),
      notes_ (this),
      idtag_ (this)
    {
    }

    keywordType::
    keywordType (::std::unique_ptr< keywordValue_type > keywordValue)
    : ::xml_schema::type (),
      taxonomy_ (this),
      keywordValue_ (std::move (keywordValue), this),
      notes_ (this),
      idtag_ (this)
    {
    }

    keywordType::
    keywordType (const keywordType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      taxonomy_ (x.taxonomy_, f, this),
      keywordValue_ (x.keywordValue_, f, this),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this)
    {
    }

    keywordType::
    keywordType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      taxonomy_ (this),
      keywordValue_ (this),
      notes_ (this),
      idtag_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void keywordType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // taxonomy
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "taxonomy",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< taxonomy_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->taxonomy_)
            {
              ::std::unique_ptr< taxonomy_type > r (
                dynamic_cast< taxonomy_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->taxonomy_.set (::std::move (r));
              continue;
            }
          }
        }

        // keywordValue
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "keywordValue",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< keywordValue_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!keywordValue_.present ())
            {
              ::std::unique_ptr< keywordValue_type > r (
                dynamic_cast< keywordValue_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->keywordValue_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!keywordValue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "keywordValue",
          "http://www.sisostds.org/schemas/modelID");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }
      }
    }

    keywordType* keywordType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class keywordType (*this, f, c);
    }

    keywordType& keywordType::
    operator= (const keywordType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->taxonomy_ = x.taxonomy_;
        this->keywordValue_ = x.keywordValue_;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
      }

      return *this;
    }

    keywordType::
    ~keywordType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, keywordType >
    _xsd_keywordType_type_factory_init (
      "keywordType",
      "http://www.sisostds.org/schemas/modelID");

    // modelIdentificationType
    //

    modelIdentificationType::
    modelIdentificationType (const name_type& name,
                             const type_type& type,
                             const version_type& version,
                             const modificationDate_type& modificationDate,
                             const securityClassification_type& securityClassification,
                             const description_type& description)
    : ::xml_schema::type (),
      name_ (name, this),
      type_ (type, this),
      version_ (version, this),
      modificationDate_ (modificationDate, this),
      securityClassification_ (securityClassification, this),
      releaseRestriction_ (this),
      purpose_ (this),
      applicationDomain_ (this),
      description_ (description, this),
      useLimitation_ (this),
      useHistory_ (this),
      keyword_ (this),
      poc_ (this),
      reference_ (this),
      other_ (this),
      glyph_ (this),
      notes_ (this),
      idtag_ (this)
    {
    }

    modelIdentificationType::
    modelIdentificationType (::std::unique_ptr< name_type > name,
                             ::std::unique_ptr< type_type > type,
                             ::std::unique_ptr< version_type > version,
                             ::std::unique_ptr< modificationDate_type > modificationDate,
                             ::std::unique_ptr< securityClassification_type > securityClassification,
                             ::std::unique_ptr< description_type > description)
    : ::xml_schema::type (),
      name_ (std::move (name), this),
      type_ (std::move (type), this),
      version_ (std::move (version), this),
      modificationDate_ (std::move (modificationDate), this),
      securityClassification_ (std::move (securityClassification), this),
      releaseRestriction_ (this),
      purpose_ (this),
      applicationDomain_ (this),
      description_ (std::move (description), this),
      useLimitation_ (this),
      useHistory_ (this),
      keyword_ (this),
      poc_ (this),
      reference_ (this),
      other_ (this),
      glyph_ (this),
      notes_ (this),
      idtag_ (this)
    {
    }

    modelIdentificationType::
    modelIdentificationType (const modelIdentificationType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this),
      version_ (x.version_, f, this),
      modificationDate_ (x.modificationDate_, f, this),
      securityClassification_ (x.securityClassification_, f, this),
      releaseRestriction_ (x.releaseRestriction_, f, this),
      purpose_ (x.purpose_, f, this),
      applicationDomain_ (x.applicationDomain_, f, this),
      description_ (x.description_, f, this),
      useLimitation_ (x.useLimitation_, f, this),
      useHistory_ (x.useHistory_, f, this),
      keyword_ (x.keyword_, f, this),
      poc_ (x.poc_, f, this),
      reference_ (x.reference_, f, this),
      other_ (x.other_, f, this),
      glyph_ (x.glyph_, f, this),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this)
    {
    }

    modelIdentificationType::
    modelIdentificationType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      type_ (this),
      version_ (this),
      modificationDate_ (this),
      securityClassification_ (this),
      releaseRestriction_ (this),
      purpose_ (this),
      applicationDomain_ (this),
      description_ (this),
      useLimitation_ (this),
      useHistory_ (this),
      keyword_ (this),
      poc_ (this),
      reference_ (this),
      other_ (this),
      glyph_ (this),
      notes_ (this),
      idtag_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void modelIdentificationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "name",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< name_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!name_.present ())
            {
              ::std::unique_ptr< name_type > r (
                dynamic_cast< name_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->name_.set (::std::move (r));
              continue;
            }
          }
        }

        // type
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "type",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< type_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!type_.present ())
            {
              ::std::unique_ptr< type_type > r (
                dynamic_cast< type_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->type_.set (::std::move (r));
              continue;
            }
          }
        }

        // version
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "version",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< version_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!version_.present ())
            {
              ::std::unique_ptr< version_type > r (
                dynamic_cast< version_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->version_.set (::std::move (r));
              continue;
            }
          }
        }

        // modificationDate
        //
        if (n.name () == "modificationDate" && n.namespace_ () == "http://www.sisostds.org/schemas/modelID")
        {
          ::std::unique_ptr< modificationDate_type > r (
            modificationDate_traits::create (i, f, this));

          if (!modificationDate_.present ())
          {
            this->modificationDate_.set (::std::move (r));
            continue;
          }
        }

        // securityClassification
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "securityClassification",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< securityClassification_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!securityClassification_.present ())
            {
              ::std::unique_ptr< securityClassification_type > r (
                dynamic_cast< securityClassification_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->securityClassification_.set (::std::move (r));
              continue;
            }
          }
        }

        // releaseRestriction
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "releaseRestriction",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< releaseRestriction_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< releaseRestriction_type > r (
              dynamic_cast< releaseRestriction_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->releaseRestriction_.push_back (::std::move (r));
            continue;
          }
        }

        // purpose
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "purpose",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< purpose_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->purpose_)
            {
              ::std::unique_ptr< purpose_type > r (
                dynamic_cast< purpose_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->purpose_.set (::std::move (r));
              continue;
            }
          }
        }

        // applicationDomain
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "applicationDomain",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< applicationDomain_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->applicationDomain_)
            {
              ::std::unique_ptr< applicationDomain_type > r (
                dynamic_cast< applicationDomain_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->applicationDomain_.set (::std::move (r));
              continue;
            }
          }
        }

        // description
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "description",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< description_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!description_.present ())
            {
              ::std::unique_ptr< description_type > r (
                dynamic_cast< description_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->description_.set (::std::move (r));
              continue;
            }
          }
        }

        // useLimitation
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "useLimitation",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< useLimitation_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->useLimitation_)
            {
              ::std::unique_ptr< useLimitation_type > r (
                dynamic_cast< useLimitation_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->useLimitation_.set (::std::move (r));
              continue;
            }
          }
        }

        // useHistory
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "useHistory",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< useHistory_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< useHistory_type > r (
              dynamic_cast< useHistory_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->useHistory_.push_back (::std::move (r));
            continue;
          }
        }

        // keyword
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "keyword",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< keyword_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< keyword_type > r (
              dynamic_cast< keyword_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->keyword_.push_back (::std::move (r));
            continue;
          }
        }

        // poc
        //
        if (n.name () == "poc" && n.namespace_ () == "http://www.sisostds.org/schemas/modelID")
        {
          ::std::unique_ptr< poc_type > r (
            poc_traits::create (i, f, this));

          this->poc_.push_back (::std::move (r));
          continue;
        }

        // reference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "reference",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< reference_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< reference_type > r (
              dynamic_cast< reference_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->reference_.push_back (::std::move (r));
            continue;
          }
        }

        // other
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "other",
              "http://www.sisostds.org/schemas/modelID",
              &::xsd::cxx::tree::factory_impl< other_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->other_)
            {
              ::std::unique_ptr< other_type > r (
                dynamic_cast< other_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->other_.set (::std::move (r));
              continue;
            }
          }
        }

        // glyph
        //
        if (n.name () == "glyph" && n.namespace_ () == "http://www.sisostds.org/schemas/modelID")
        {
          ::std::unique_ptr< glyph_type > r (
            glyph_traits::create (i, f, this));

          if (!this->glyph_)
          {
            this->glyph_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "http://www.sisostds.org/schemas/modelID");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "type",
          "http://www.sisostds.org/schemas/modelID");
      }

      if (!version_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "version",
          "http://www.sisostds.org/schemas/modelID");
      }

      if (!modificationDate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "modificationDate",
          "http://www.sisostds.org/schemas/modelID");
      }

      if (!securityClassification_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "securityClassification",
          "http://www.sisostds.org/schemas/modelID");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "http://www.sisostds.org/schemas/modelID");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }
      }
    }

    modelIdentificationType* modelIdentificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class modelIdentificationType (*this, f, c);
    }

    modelIdentificationType& modelIdentificationType::
    operator= (const modelIdentificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->type_ = x.type_;
        this->version_ = x.version_;
        this->modificationDate_ = x.modificationDate_;
        this->securityClassification_ = x.securityClassification_;
        this->releaseRestriction_ = x.releaseRestriction_;
        this->purpose_ = x.purpose_;
        this->applicationDomain_ = x.applicationDomain_;
        this->description_ = x.description_;
        this->useLimitation_ = x.useLimitation_;
        this->useHistory_ = x.useHistory_;
        this->keyword_ = x.keyword_;
        this->poc_ = x.poc_;
        this->reference_ = x.reference_;
        this->other_ = x.other_;
        this->glyph_ = x.glyph_;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
      }

      return *this;
    }

    modelIdentificationType::
    ~modelIdentificationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, modelIdentificationType >
    _xsd_modelIdentificationType_type_factory_init (
      "modelIdentificationType",
      "http://www.sisostds.org/schemas/modelID");

    // type
    //

    type::
    type (const char* _xsd_referenceTypeUnion_base)
    : ::schemas::modelID::referenceTypeUnion (_xsd_referenceTypeUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    type::
    type (const ::std::string& _xsd_referenceTypeUnion_base)
    : ::schemas::modelID::referenceTypeUnion (_xsd_referenceTypeUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    type::
    type (const ::schemas::modelID::referenceTypeUnion& _xsd_referenceTypeUnion_base)
    : ::schemas::modelID::referenceTypeUnion (_xsd_referenceTypeUnion_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    type::
    type (const type& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::schemas::modelID::referenceTypeUnion (x, f, c),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this)
    {
    }

    type::
    type (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::schemas::modelID::referenceTypeUnion (e, f | ::xml_schema::flags::base, c),
      notes_ (this),
      idtag_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }
      }
    }

    type* type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class type (*this, f, c);
    }

    type& type::
    operator= (const type& x)
    {
      if (this != &x)
      {
        static_cast< ::schemas::modelID::referenceTypeUnion& > (*this) = x;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
      }

      return *this;
    }

    type::
    ~type ()
    {
    }

    // identification
    //

    identification::
    identification (const ::xml_schema::uri& _xsd_uri_base)
    : ::xml_schema::uri (_xsd_uri_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    identification::
    identification (const identification& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::uri (x, f, c),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this)
    {
    }

    identification::
    identification (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::uri (e, f | ::xml_schema::flags::base, c),
      notes_ (this),
      idtag_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void identification::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }
      }
    }

    identification* identification::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class identification (*this, f, c);
    }

    identification& identification::
    operator= (const identification& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::uri& > (*this) = x;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
      }

      return *this;
    }

    identification::
    ~identification ()
    {
    }

    // modificationDate
    //

    modificationDate::
    modificationDate (const ::xml_schema::date& _xsd_date_base)
    : ::xml_schema::date (_xsd_date_base),
      notes_ (this),
      idtag_ (this)
    {
    }

    modificationDate::
    modificationDate (const modificationDate& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::date (x, f, c),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this)
    {
    }

    modificationDate::
    modificationDate (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::date (e, f | ::xml_schema::flags::base, c),
      notes_ (this),
      idtag_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void modificationDate::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }
      }
    }

    modificationDate* modificationDate::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class modificationDate (*this, f, c);
    }

    modificationDate& modificationDate::
    operator= (const modificationDate& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::date& > (*this) = x;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
      }

      return *this;
    }

    modificationDate::
    ~modificationDate ()
    {
    }

    // poc
    //

    poc::
    poc (const pocType1_type& pocType1)
    : ::schemas::modelID::pocType (pocType1),
      notes_ (this),
      idtag_ (this)
    {
    }

    poc::
    poc (::std::unique_ptr< pocType1_type > pocType1)
    : ::schemas::modelID::pocType (std::move (pocType1)),
      notes_ (this),
      idtag_ (this)
    {
    }

    poc::
    poc (const poc& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::schemas::modelID::pocType (x, f, c),
      notes_ (x.notes_, f, this),
      idtag_ (x.idtag_, f, this)
    {
    }

    poc::
    poc (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::schemas::modelID::pocType (e, f | ::xml_schema::flags::base, c),
      notes_ (this),
      idtag_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void poc::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::schemas::modelID::pocType::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "notes" && n.namespace_ ().empty ())
        {
          this->notes_.set (notes_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "idtag" && n.namespace_ ().empty ())
        {
          this->idtag_.set (idtag_traits::create (i, f, this));
          continue;
        }
      }
    }

    poc* poc::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class poc (*this, f, c);
    }

    poc& poc::
    operator= (const poc& x)
    {
      if (this != &x)
      {
        static_cast< ::schemas::modelID::pocType& > (*this) = x;
        this->notes_ = x.notes_;
        this->idtag_ = x.idtag_;
      }

      return *this;
    }

    poc::
    ~poc ()
    {
    }

    // glyph
    //

    glyph::
    glyph (const type_type& type)
    : ::schemas::modelID::glyphType (type)
    {
    }

    glyph::
    glyph (const ::xml_schema::base64_binary& _xsd_base64_binary_base,
           const type_type& type)
    : ::schemas::modelID::glyphType (_xsd_base64_binary_base,
                                     type)
    {
    }

    glyph::
    glyph (const glyph& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::schemas::modelID::glyphType (x, f, c)
    {
    }

    glyph::
    glyph (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::schemas::modelID::glyphType (e, f, c)
    {
    }

    glyph* glyph::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class glyph (*this, f, c);
    }

    glyph::
    ~glyph ()
    {
    }
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace schemas
{
  namespace modelID
  {
    ::std::ostream&
    operator<< (::std::ostream& o, const String& i)
    {
      o << static_cast< const ::xml_schema::string& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, String >
    _xsd_String_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const IdentifierType& i)
    {
      o << static_cast< const ::xml_schema::ncname& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, IdentifierType >
    _xsd_IdentifierType_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const nonEmptyString& i)
    {
      o << static_cast< const ::xml_schema::string& > (i);

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, nonEmptyString >
    _xsd_nonEmptyString_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const NonEmptyString& i)
    {
      o << static_cast< const ::schemas::modelID::nonEmptyString& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, NonEmptyString >
    _xsd_NonEmptyString_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, OMTypeEnumerations::value i)
    {
      return o << OMTypeEnumerations::_xsd_OMTypeEnumerations_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const OMTypeEnumerations& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, OMTypeEnumerations >
    _xsd_OMTypeEnumerations_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const OMTypeUnion& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, OMTypeUnion >
    _xsd_OMTypeUnion_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, glyphTypeEnumerations::value i)
    {
      return o << glyphTypeEnumerations::_xsd_glyphTypeEnumerations_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const glyphTypeEnumerations& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, glyphTypeEnumerations >
    _xsd_glyphTypeEnumerations_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const glyphTypeUnion& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, glyphTypeUnion >
    _xsd_glyphTypeUnion_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const glyphType& i)
    {
      o << static_cast< const ::xml_schema::base64_binary& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      o << ::std::endl << "type: " << i.type ();
      if (i.height ())
      {
        o << ::std::endl << "height: " << *i.height ();
      }

      if (i.width ())
      {
        o << ::std::endl << "width: " << *i.width ();
      }

      if (i.alt ())
      {
        o << ::std::endl << "alt: " << *i.alt ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, glyphType >
    _xsd_glyphType_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const pocType& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "pocType: ";
        om.insert (o, i.pocType1 ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.pocName ())
        {
          o << ::std::endl << "pocName: ";
          om.insert (o, *i.pocName ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.pocOrg ())
        {
          o << ::std::endl << "pocOrg: ";
          om.insert (o, *i.pocOrg ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (pocType::pocTelephone_const_iterator
             b (i.pocTelephone ().begin ()), e (i.pocTelephone ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "pocTelephone: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (pocType::pocEmail_const_iterator
             b (i.pocEmail ().begin ()), e (i.pocEmail ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "pocEmail: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, pocType >
    _xsd_pocType_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, SecurityClassificationEnumeration::value i)
    {
      return o << SecurityClassificationEnumeration::_xsd_SecurityClassificationEnumeration_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SecurityClassificationEnumeration& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SecurityClassificationEnumeration >
    _xsd_SecurityClassificationEnumeration_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const SecurityClassificationUnion& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SecurityClassificationUnion >
    _xsd_SecurityClassificationUnion_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const modelType& i)
    {
      o << static_cast< const ::schemas::modelID::OMTypeUnion& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, modelType >
    _xsd_modelType_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const securityClassificationType& i)
    {
      o << static_cast< const ::schemas::modelID::SecurityClassificationUnion& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, securityClassificationType >
    _xsd_securityClassificationType_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, ApplicationDomainEnumerations::value i)
    {
      return o << ApplicationDomainEnumerations::_xsd_ApplicationDomainEnumerations_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ApplicationDomainEnumerations& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ApplicationDomainEnumerations >
    _xsd_ApplicationDomainEnumerations_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const ApplicationDomainUnion& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ApplicationDomainUnion >
    _xsd_ApplicationDomainUnion_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const applicationDomainType& i)
    {
      o << static_cast< const ::schemas::modelID::ApplicationDomainUnion& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, applicationDomainType >
    _xsd_applicationDomainType_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, POCTypeEnumeration::value i)
    {
      return o << POCTypeEnumeration::_xsd_POCTypeEnumeration_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const POCTypeEnumeration& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, POCTypeEnumeration >
    _xsd_POCTypeEnumeration_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const POCTypeUnion& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, POCTypeUnion >
    _xsd_POCTypeUnion_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const pocTypeType& i)
    {
      o << static_cast< const ::schemas::modelID::POCTypeUnion& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, pocTypeType >
    _xsd_pocTypeType_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, referenceTypeEnumerations::value i)
    {
      return o << referenceTypeEnumerations::_xsd_referenceTypeEnumerations_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const referenceTypeEnumerations& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, referenceTypeEnumerations >
    _xsd_referenceTypeEnumerations_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const referenceTypeUnion& i)
    {
      return o << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, referenceTypeUnion >
    _xsd_referenceTypeUnion_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const referenceType& i)
    {
      o << ::std::endl << "type: " << i.type ();
      o << ::std::endl << "identification: " << i.identification ();
      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, referenceType >
    _xsd_referenceType_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const keywordType& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.taxonomy ())
        {
          o << ::std::endl << "taxonomy: ";
          om.insert (o, *i.taxonomy ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "keywordValue: ";
        om.insert (o, i.keywordValue ());
      }

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, keywordType >
    _xsd_keywordType_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const modelIdentificationType& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "name: ";
        om.insert (o, i.name ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "type: ";
        om.insert (o, i.type ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "version: ";
        om.insert (o, i.version ());
      }

      o << ::std::endl << "modificationDate: " << i.modificationDate ();
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "securityClassification: ";
        om.insert (o, i.securityClassification ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (modelIdentificationType::releaseRestriction_const_iterator
             b (i.releaseRestriction ().begin ()), e (i.releaseRestriction ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "releaseRestriction: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.purpose ())
        {
          o << ::std::endl << "purpose: ";
          om.insert (o, *i.purpose ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.applicationDomain ())
        {
          o << ::std::endl << "applicationDomain: ";
          om.insert (o, *i.applicationDomain ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "description: ";
        om.insert (o, i.description ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.useLimitation ())
        {
          o << ::std::endl << "useLimitation: ";
          om.insert (o, *i.useLimitation ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (modelIdentificationType::useHistory_const_iterator
             b (i.useHistory ().begin ()), e (i.useHistory ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "useHistory: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (modelIdentificationType::keyword_const_iterator
             b (i.keyword ().begin ()), e (i.keyword ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "keyword: ";
          om.insert (o, *b);
        }
      }

      for (modelIdentificationType::poc_const_iterator
           b (i.poc ().begin ()), e (i.poc ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "poc: " << *b;
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (modelIdentificationType::reference_const_iterator
             b (i.reference ().begin ()), e (i.reference ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "reference: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.other ())
        {
          o << ::std::endl << "other: ";
          om.insert (o, *i.other ());
        }
      }

      if (i.glyph ())
      {
        o << ::std::endl << "glyph: " << *i.glyph ();
      }

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, modelIdentificationType >
    _xsd_modelIdentificationType_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const type& i)
    {
      o << static_cast< const ::schemas::modelID::referenceTypeUnion& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const identification& i)
    {
      o << static_cast< const ::xml_schema::uri& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const modificationDate& i)
    {
      o << static_cast< const ::xml_schema::date& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const poc& i)
    {
      o << static_cast< const ::schemas::modelID::pocType& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.idtag ())
      {
        o << ::std::endl << "idtag: " << *i.idtag ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const glyph& i)
    {
      o << static_cast< const ::schemas::modelID::glyphType& > (i);

      return o;
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace schemas
{
  namespace modelID
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace schemas
{
  namespace modelID
  {
    void
    operator<< (::xercesc::DOMElement& e, const String& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, String >
    _xsd_String_type_serializer_init (
      "String",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const IdentifierType& i)
    {
      e << static_cast< const ::xml_schema::ncname& > (i);

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IdentifierType >
    _xsd_IdentifierType_type_serializer_init (
      "IdentifierType",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const nonEmptyString& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const nonEmptyString& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const nonEmptyString& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, nonEmptyString >
    _xsd_nonEmptyString_type_serializer_init (
      "nonEmptyString",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const NonEmptyString& i)
    {
      e << static_cast< const ::schemas::modelID::nonEmptyString& > (i);

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NonEmptyString >
    _xsd_NonEmptyString_type_serializer_init (
      "NonEmptyString",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const OMTypeEnumerations& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const OMTypeEnumerations& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const OMTypeEnumerations& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OMTypeEnumerations >
    _xsd_OMTypeEnumerations_type_serializer_init (
      "OMTypeEnumerations",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const OMTypeUnion& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const OMTypeUnion& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const OMTypeUnion& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OMTypeUnion >
    _xsd_OMTypeUnion_type_serializer_init (
      "OMTypeUnion",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const glyphTypeEnumerations& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const glyphTypeEnumerations& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const glyphTypeEnumerations& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, glyphTypeEnumerations >
    _xsd_glyphTypeEnumerations_type_serializer_init (
      "glyphTypeEnumerations",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const glyphTypeUnion& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const glyphTypeUnion& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const glyphTypeUnion& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, glyphTypeUnion >
    _xsd_glyphTypeUnion_type_serializer_init (
      "glyphTypeUnion",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const glyphType& i)
    {
      e << static_cast< const ::xml_schema::base64_binary& > (i);

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }

      // height
      //
      if (i.height ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "height",
            e));

        a << *i.height ();
      }

      // width
      //
      if (i.width ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "width",
            e));

        a << *i.width ();
      }

      // alt
      //
      if (i.alt ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "alt",
            e));

        a << *i.alt ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, glyphType >
    _xsd_glyphType_type_serializer_init (
      "glyphType",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const pocType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // pocType
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const pocType::pocType1_type& x (i.pocType1 ());
        if (typeid (pocType::pocType1_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "pocType",
              "http://www.sisostds.org/schemas/modelID",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "pocType",
            "http://www.sisostds.org/schemas/modelID",
            false, true, e, x);
      }

      // pocName
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.pocName ())
        {
          const pocType::pocName_type& x (*i.pocName ());
          if (typeid (pocType::pocName_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "pocName",
                "http://www.sisostds.org/schemas/modelID",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "pocName",
              "http://www.sisostds.org/schemas/modelID",
              false, true, e, x);
        }
      }

      // pocOrg
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.pocOrg ())
        {
          const pocType::pocOrg_type& x (*i.pocOrg ());
          if (typeid (pocType::pocOrg_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "pocOrg",
                "http://www.sisostds.org/schemas/modelID",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "pocOrg",
              "http://www.sisostds.org/schemas/modelID",
              false, true, e, x);
        }
      }

      // pocTelephone
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (pocType::pocTelephone_const_iterator
             b (i.pocTelephone ().begin ()), n (i.pocTelephone ().end ());
             b != n; ++b)
        {
          if (typeid (pocType::pocTelephone_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "pocTelephone",
                "http://www.sisostds.org/schemas/modelID",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "pocTelephone",
              "http://www.sisostds.org/schemas/modelID",
              false, true, e, *b);
        }
      }

      // pocEmail
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (pocType::pocEmail_const_iterator
             b (i.pocEmail ().begin ()), n (i.pocEmail ().end ());
             b != n; ++b)
        {
          if (typeid (pocType::pocEmail_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "pocEmail",
                "http://www.sisostds.org/schemas/modelID",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "pocEmail",
              "http://www.sisostds.org/schemas/modelID",
              false, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, pocType >
    _xsd_pocType_type_serializer_init (
      "pocType",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const SecurityClassificationEnumeration& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const SecurityClassificationEnumeration& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SecurityClassificationEnumeration& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SecurityClassificationEnumeration >
    _xsd_SecurityClassificationEnumeration_type_serializer_init (
      "SecurityClassificationEnumeration",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const SecurityClassificationUnion& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const SecurityClassificationUnion& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SecurityClassificationUnion& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SecurityClassificationUnion >
    _xsd_SecurityClassificationUnion_type_serializer_init (
      "SecurityClassificationUnion",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const modelType& i)
    {
      e << static_cast< const ::schemas::modelID::OMTypeUnion& > (i);

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, modelType >
    _xsd_modelType_type_serializer_init (
      "modelType",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const securityClassificationType& i)
    {
      e << static_cast< const ::schemas::modelID::SecurityClassificationUnion& > (i);

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, securityClassificationType >
    _xsd_securityClassificationType_type_serializer_init (
      "securityClassificationType",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const ApplicationDomainEnumerations& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ApplicationDomainEnumerations& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ApplicationDomainEnumerations& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ApplicationDomainEnumerations >
    _xsd_ApplicationDomainEnumerations_type_serializer_init (
      "ApplicationDomainEnumerations",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const ApplicationDomainUnion& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ApplicationDomainUnion& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ApplicationDomainUnion& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ApplicationDomainUnion >
    _xsd_ApplicationDomainUnion_type_serializer_init (
      "ApplicationDomainUnion",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const applicationDomainType& i)
    {
      e << static_cast< const ::schemas::modelID::ApplicationDomainUnion& > (i);

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, applicationDomainType >
    _xsd_applicationDomainType_type_serializer_init (
      "applicationDomainType",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const POCTypeEnumeration& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const POCTypeEnumeration& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const POCTypeEnumeration& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, POCTypeEnumeration >
    _xsd_POCTypeEnumeration_type_serializer_init (
      "POCTypeEnumeration",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const POCTypeUnion& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const POCTypeUnion& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const POCTypeUnion& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, POCTypeUnion >
    _xsd_POCTypeUnion_type_serializer_init (
      "POCTypeUnion",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const pocTypeType& i)
    {
      e << static_cast< const ::schemas::modelID::POCTypeUnion& > (i);

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, pocTypeType >
    _xsd_pocTypeType_type_serializer_init (
      "pocTypeType",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const referenceTypeEnumerations& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const referenceTypeEnumerations& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const referenceTypeEnumerations& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, referenceTypeEnumerations >
    _xsd_referenceTypeEnumerations_type_serializer_init (
      "referenceTypeEnumerations",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const referenceTypeUnion& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const referenceTypeUnion& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const referenceTypeUnion& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, referenceTypeUnion >
    _xsd_referenceTypeUnion_type_serializer_init (
      "referenceTypeUnion",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const referenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // type
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "type",
            "http://www.sisostds.org/schemas/modelID",
            e));

        s << i.type ();
      }

      // identification
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "identification",
            "http://www.sisostds.org/schemas/modelID",
            e));

        s << i.identification ();
      }

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, referenceType >
    _xsd_referenceType_type_serializer_init (
      "referenceType",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const keywordType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // taxonomy
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.taxonomy ())
        {
          const keywordType::taxonomy_type& x (*i.taxonomy ());
          if (typeid (keywordType::taxonomy_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "taxonomy",
                "http://www.sisostds.org/schemas/modelID",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "taxonomy",
              "http://www.sisostds.org/schemas/modelID",
              false, true, e, x);
        }
      }

      // keywordValue
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const keywordType::keywordValue_type& x (i.keywordValue ());
        if (typeid (keywordType::keywordValue_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "keywordValue",
              "http://www.sisostds.org/schemas/modelID",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "keywordValue",
            "http://www.sisostds.org/schemas/modelID",
            false, true, e, x);
      }

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, keywordType >
    _xsd_keywordType_type_serializer_init (
      "keywordType",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const modelIdentificationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // name
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const modelIdentificationType::name_type& x (i.name ());
        if (typeid (modelIdentificationType::name_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              "http://www.sisostds.org/schemas/modelID",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "name",
            "http://www.sisostds.org/schemas/modelID",
            false, true, e, x);
      }

      // type
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const modelIdentificationType::type_type& x (i.type ());
        if (typeid (modelIdentificationType::type_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "type",
              "http://www.sisostds.org/schemas/modelID",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "type",
            "http://www.sisostds.org/schemas/modelID",
            false, true, e, x);
      }

      // version
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const modelIdentificationType::version_type& x (i.version ());
        if (typeid (modelIdentificationType::version_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "version",
              "http://www.sisostds.org/schemas/modelID",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "version",
            "http://www.sisostds.org/schemas/modelID",
            false, true, e, x);
      }

      // modificationDate
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "modificationDate",
            "http://www.sisostds.org/schemas/modelID",
            e));

        s << i.modificationDate ();
      }

      // securityClassification
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const modelIdentificationType::securityClassification_type& x (i.securityClassification ());
        if (typeid (modelIdentificationType::securityClassification_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "securityClassification",
              "http://www.sisostds.org/schemas/modelID",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "securityClassification",
            "http://www.sisostds.org/schemas/modelID",
            false, true, e, x);
      }

      // releaseRestriction
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (modelIdentificationType::releaseRestriction_const_iterator
             b (i.releaseRestriction ().begin ()), n (i.releaseRestriction ().end ());
             b != n; ++b)
        {
          if (typeid (modelIdentificationType::releaseRestriction_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "releaseRestriction",
                "http://www.sisostds.org/schemas/modelID",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "releaseRestriction",
              "http://www.sisostds.org/schemas/modelID",
              false, true, e, *b);
        }
      }

      // purpose
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.purpose ())
        {
          const modelIdentificationType::purpose_type& x (*i.purpose ());
          if (typeid (modelIdentificationType::purpose_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "purpose",
                "http://www.sisostds.org/schemas/modelID",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "purpose",
              "http://www.sisostds.org/schemas/modelID",
              false, true, e, x);
        }
      }

      // applicationDomain
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.applicationDomain ())
        {
          const modelIdentificationType::applicationDomain_type& x (*i.applicationDomain ());
          if (typeid (modelIdentificationType::applicationDomain_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "applicationDomain",
                "http://www.sisostds.org/schemas/modelID",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "applicationDomain",
              "http://www.sisostds.org/schemas/modelID",
              false, true, e, x);
        }
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const modelIdentificationType::description_type& x (i.description ());
        if (typeid (modelIdentificationType::description_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "description",
              "http://www.sisostds.org/schemas/modelID",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "description",
            "http://www.sisostds.org/schemas/modelID",
            false, true, e, x);
      }

      // useLimitation
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.useLimitation ())
        {
          const modelIdentificationType::useLimitation_type& x (*i.useLimitation ());
          if (typeid (modelIdentificationType::useLimitation_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "useLimitation",
                "http://www.sisostds.org/schemas/modelID",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "useLimitation",
              "http://www.sisostds.org/schemas/modelID",
              false, true, e, x);
        }
      }

      // useHistory
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (modelIdentificationType::useHistory_const_iterator
             b (i.useHistory ().begin ()), n (i.useHistory ().end ());
             b != n; ++b)
        {
          if (typeid (modelIdentificationType::useHistory_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "useHistory",
                "http://www.sisostds.org/schemas/modelID",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "useHistory",
              "http://www.sisostds.org/schemas/modelID",
              false, true, e, *b);
        }
      }

      // keyword
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (modelIdentificationType::keyword_const_iterator
             b (i.keyword ().begin ()), n (i.keyword ().end ());
             b != n; ++b)
        {
          if (typeid (modelIdentificationType::keyword_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "keyword",
                "http://www.sisostds.org/schemas/modelID",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "keyword",
              "http://www.sisostds.org/schemas/modelID",
              false, true, e, *b);
        }
      }

      // poc
      //
      for (modelIdentificationType::poc_const_iterator
           b (i.poc ().begin ()), n (i.poc ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "poc",
            "http://www.sisostds.org/schemas/modelID",
            e));

        s << *b;
      }

      // reference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (modelIdentificationType::reference_const_iterator
             b (i.reference ().begin ()), n (i.reference ().end ());
             b != n; ++b)
        {
          if (typeid (modelIdentificationType::reference_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "reference",
                "http://www.sisostds.org/schemas/modelID",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "reference",
              "http://www.sisostds.org/schemas/modelID",
              false, true, e, *b);
        }
      }

      // other
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.other ())
        {
          const modelIdentificationType::other_type& x (*i.other ());
          if (typeid (modelIdentificationType::other_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "other",
                "http://www.sisostds.org/schemas/modelID",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "other",
              "http://www.sisostds.org/schemas/modelID",
              false, true, e, x);
        }
      }

      // glyph
      //
      if (i.glyph ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "glyph",
            "http://www.sisostds.org/schemas/modelID",
            e));

        s << *i.glyph ();
      }

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, modelIdentificationType >
    _xsd_modelIdentificationType_type_serializer_init (
      "modelIdentificationType",
      "http://www.sisostds.org/schemas/modelID");


    void
    operator<< (::xercesc::DOMElement& e, const type& i)
    {
      e << static_cast< const ::schemas::modelID::referenceTypeUnion& > (i);

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const identification& i)
    {
      e << static_cast< const ::xml_schema::uri& > (i);

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const modificationDate& i)
    {
      e << static_cast< const ::xml_schema::date& > (i);

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const poc& i)
    {
      e << static_cast< const ::schemas::modelID::pocType& > (i);

      // notes
      //
      if (i.notes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "notes",
            e));

        a << *i.notes ();
      }

      // idtag
      //
      if (i.idtag ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idtag",
            e));

        a << *i.idtag ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const glyph& i)
    {
      e << static_cast< const ::schemas::modelID::glyphType& > (i);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

