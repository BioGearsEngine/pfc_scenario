// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "JC3IEDMMeteorological.hxx"

namespace oo_2_0
{
  // AngleOptionalTypeRangeAngle7_4
  // 


  // DatetimeOptionalTypeFix18
  // 


  // DimensionOptionalType12_3
  // 


  // DimensionMandatoryType12_3
  // 


  // QuantityOptionalType8_4
  // 


  // RateOptionalType4_1
  // 


  // RateOptionalType8_4
  // 


  // RatioOptionalTypeRangeRatio6_5
  // 


  // RatioOptionalTypeRangeRatio7_6
  // 


  // TemperatureTypeRangeTemperature5_1
  // 


  // Atmosphere
  // 

  const Atmosphere::HumidityRatio_optional& Atmosphere::
  HumidityRatio () const
  {
    return this->HumidityRatio_;
  }

  Atmosphere::HumidityRatio_optional& Atmosphere::
  HumidityRatio ()
  {
    return this->HumidityRatio_;
  }

  void Atmosphere::
  HumidityRatio (const HumidityRatio_type& x)
  {
    this->HumidityRatio_.set (x);
  }

  void Atmosphere::
  HumidityRatio (const HumidityRatio_optional& x)
  {
    this->HumidityRatio_ = x;
  }

  void Atmosphere::
  HumidityRatio (::std::auto_ptr< HumidityRatio_type > x)
  {
    this->HumidityRatio_.set (x);
  }

  const Atmosphere::InversionLayerCode_optional& Atmosphere::
  InversionLayerCode () const
  {
    return this->InversionLayerCode_;
  }

  Atmosphere::InversionLayerCode_optional& Atmosphere::
  InversionLayerCode ()
  {
    return this->InversionLayerCode_;
  }

  void Atmosphere::
  InversionLayerCode (const InversionLayerCode_type& x)
  {
    this->InversionLayerCode_.set (x);
  }

  void Atmosphere::
  InversionLayerCode (const InversionLayerCode_optional& x)
  {
    this->InversionLayerCode_ = x;
  }

  void Atmosphere::
  InversionLayerCode (::std::auto_ptr< InversionLayerCode_type > x)
  {
    this->InversionLayerCode_.set (x);
  }

  const Atmosphere::PressureQuantity_optional& Atmosphere::
  PressureQuantity () const
  {
    return this->PressureQuantity_;
  }

  Atmosphere::PressureQuantity_optional& Atmosphere::
  PressureQuantity ()
  {
    return this->PressureQuantity_;
  }

  void Atmosphere::
  PressureQuantity (const PressureQuantity_type& x)
  {
    this->PressureQuantity_.set (x);
  }

  void Atmosphere::
  PressureQuantity (const PressureQuantity_optional& x)
  {
    this->PressureQuantity_ = x;
  }

  void Atmosphere::
  PressureQuantity (::std::auto_ptr< PressureQuantity_type > x)
  {
    this->PressureQuantity_.set (x);
  }

  const Atmosphere::Temperature_optional& Atmosphere::
  Temperature () const
  {
    return this->Temperature_;
  }

  Atmosphere::Temperature_optional& Atmosphere::
  Temperature ()
  {
    return this->Temperature_;
  }

  void Atmosphere::
  Temperature (const Temperature_type& x)
  {
    this->Temperature_.set (x);
  }

  void Atmosphere::
  Temperature (const Temperature_optional& x)
  {
    this->Temperature_ = x;
  }

  void Atmosphere::
  Temperature (::std::auto_ptr< Temperature_type > x)
  {
    this->Temperature_.set (x);
  }

  const Atmosphere::TemperatureGradientCode_optional& Atmosphere::
  TemperatureGradientCode () const
  {
    return this->TemperatureGradientCode_;
  }

  Atmosphere::TemperatureGradientCode_optional& Atmosphere::
  TemperatureGradientCode ()
  {
    return this->TemperatureGradientCode_;
  }

  void Atmosphere::
  TemperatureGradientCode (const TemperatureGradientCode_type& x)
  {
    this->TemperatureGradientCode_.set (x);
  }

  void Atmosphere::
  TemperatureGradientCode (const TemperatureGradientCode_optional& x)
  {
    this->TemperatureGradientCode_ = x;
  }

  void Atmosphere::
  TemperatureGradientCode (::std::auto_ptr< TemperatureGradientCode_type > x)
  {
    this->TemperatureGradientCode_.set (x);
  }


  // CloudCover
  // 

  const CloudCover::CategoryCode_type& CloudCover::
  CategoryCode () const
  {
    return this->CategoryCode_.get ();
  }

  CloudCover::CategoryCode_type& CloudCover::
  CategoryCode ()
  {
    return this->CategoryCode_.get ();
  }

  void CloudCover::
  CategoryCode (const CategoryCode_type& x)
  {
    this->CategoryCode_.set (x);
  }

  void CloudCover::
  CategoryCode (::std::auto_ptr< CategoryCode_type > x)
  {
    this->CategoryCode_.set (x);
  }

  const CloudCover::BaseDimension_optional& CloudCover::
  BaseDimension () const
  {
    return this->BaseDimension_;
  }

  CloudCover::BaseDimension_optional& CloudCover::
  BaseDimension ()
  {
    return this->BaseDimension_;
  }

  void CloudCover::
  BaseDimension (const BaseDimension_type& x)
  {
    this->BaseDimension_.set (x);
  }

  void CloudCover::
  BaseDimension (const BaseDimension_optional& x)
  {
    this->BaseDimension_ = x;
  }

  void CloudCover::
  BaseDimension (::std::auto_ptr< BaseDimension_type > x)
  {
    this->BaseDimension_.set (x);
  }

  const CloudCover::TopDimension_optional& CloudCover::
  TopDimension () const
  {
    return this->TopDimension_;
  }

  CloudCover::TopDimension_optional& CloudCover::
  TopDimension ()
  {
    return this->TopDimension_;
  }

  void CloudCover::
  TopDimension (const TopDimension_type& x)
  {
    this->TopDimension_.set (x);
  }

  void CloudCover::
  TopDimension (const TopDimension_optional& x)
  {
    this->TopDimension_ = x;
  }

  void CloudCover::
  TopDimension (::std::auto_ptr< TopDimension_type > x)
  {
    this->TopDimension_.set (x);
  }

  const CloudCover::AverageCoverageCode_optional& CloudCover::
  AverageCoverageCode () const
  {
    return this->AverageCoverageCode_;
  }

  CloudCover::AverageCoverageCode_optional& CloudCover::
  AverageCoverageCode ()
  {
    return this->AverageCoverageCode_;
  }

  void CloudCover::
  AverageCoverageCode (const AverageCoverageCode_type& x)
  {
    this->AverageCoverageCode_.set (x);
  }

  void CloudCover::
  AverageCoverageCode (const AverageCoverageCode_optional& x)
  {
    this->AverageCoverageCode_ = x;
  }

  void CloudCover::
  AverageCoverageCode (::std::auto_ptr< AverageCoverageCode_type > x)
  {
    this->AverageCoverageCode_.set (x);
  }

  const CloudCover::LightRefractionRatio_optional& CloudCover::
  LightRefractionRatio () const
  {
    return this->LightRefractionRatio_;
  }

  CloudCover::LightRefractionRatio_optional& CloudCover::
  LightRefractionRatio ()
  {
    return this->LightRefractionRatio_;
  }

  void CloudCover::
  LightRefractionRatio (const LightRefractionRatio_type& x)
  {
    this->LightRefractionRatio_.set (x);
  }

  void CloudCover::
  LightRefractionRatio (const LightRefractionRatio_optional& x)
  {
    this->LightRefractionRatio_ = x;
  }

  void CloudCover::
  LightRefractionRatio (::std::auto_ptr< LightRefractionRatio_type > x)
  {
    this->LightRefractionRatio_.set (x);
  }


  // Icing
  // 

  const Icing::CategoryCode_optional& Icing::
  CategoryCode () const
  {
    return this->CategoryCode_;
  }

  Icing::CategoryCode_optional& Icing::
  CategoryCode ()
  {
    return this->CategoryCode_;
  }

  void Icing::
  CategoryCode (const CategoryCode_type& x)
  {
    this->CategoryCode_.set (x);
  }

  void Icing::
  CategoryCode (const CategoryCode_optional& x)
  {
    this->CategoryCode_ = x;
  }

  void Icing::
  CategoryCode (::std::auto_ptr< CategoryCode_type > x)
  {
    this->CategoryCode_.set (x);
  }

  const Icing::SeverityQualifierCode_optional& Icing::
  SeverityQualifierCode () const
  {
    return this->SeverityQualifierCode_;
  }

  Icing::SeverityQualifierCode_optional& Icing::
  SeverityQualifierCode ()
  {
    return this->SeverityQualifierCode_;
  }

  void Icing::
  SeverityQualifierCode (const SeverityQualifierCode_type& x)
  {
    this->SeverityQualifierCode_.set (x);
  }

  void Icing::
  SeverityQualifierCode (const SeverityQualifierCode_optional& x)
  {
    this->SeverityQualifierCode_ = x;
  }

  void Icing::
  SeverityQualifierCode (::std::auto_ptr< SeverityQualifierCode_type > x)
  {
    this->SeverityQualifierCode_.set (x);
  }


  // Light
  // 

  const Light::CategoryCode_optional& Light::
  CategoryCode () const
  {
    return this->CategoryCode_;
  }

  Light::CategoryCode_optional& Light::
  CategoryCode ()
  {
    return this->CategoryCode_;
  }

  void Light::
  CategoryCode (const CategoryCode_type& x)
  {
    this->CategoryCode_.set (x);
  }

  void Light::
  CategoryCode (const CategoryCode_optional& x)
  {
    this->CategoryCode_ = x;
  }

  void Light::
  CategoryCode (::std::auto_ptr< CategoryCode_type > x)
  {
    this->CategoryCode_.set (x);
  }

  const Light::UpDatetime_optional& Light::
  UpDatetime () const
  {
    return this->UpDatetime_;
  }

  Light::UpDatetime_optional& Light::
  UpDatetime ()
  {
    return this->UpDatetime_;
  }

  void Light::
  UpDatetime (const UpDatetime_type& x)
  {
    this->UpDatetime_.set (x);
  }

  void Light::
  UpDatetime (const UpDatetime_optional& x)
  {
    this->UpDatetime_ = x;
  }

  void Light::
  UpDatetime (::std::auto_ptr< UpDatetime_type > x)
  {
    this->UpDatetime_.set (x);
  }

  const Light::DownDatetime_optional& Light::
  DownDatetime () const
  {
    return this->DownDatetime_;
  }

  Light::DownDatetime_optional& Light::
  DownDatetime ()
  {
    return this->DownDatetime_;
  }

  void Light::
  DownDatetime (const DownDatetime_type& x)
  {
    this->DownDatetime_.set (x);
  }

  void Light::
  DownDatetime (const DownDatetime_optional& x)
  {
    this->DownDatetime_ = x;
  }

  void Light::
  DownDatetime (::std::auto_ptr< DownDatetime_type > x)
  {
    this->DownDatetime_.set (x);
  }

  const Light::MoonPhaseCode_optional& Light::
  MoonPhaseCode () const
  {
    return this->MoonPhaseCode_;
  }

  Light::MoonPhaseCode_optional& Light::
  MoonPhaseCode ()
  {
    return this->MoonPhaseCode_;
  }

  void Light::
  MoonPhaseCode (const MoonPhaseCode_type& x)
  {
    this->MoonPhaseCode_.set (x);
  }

  void Light::
  MoonPhaseCode (const MoonPhaseCode_optional& x)
  {
    this->MoonPhaseCode_ = x;
  }

  void Light::
  MoonPhaseCode (::std::auto_ptr< MoonPhaseCode_type > x)
  {
    this->MoonPhaseCode_.set (x);
  }


  // Precipitation
  // 

  const Precipitation::CategoryCode_type& Precipitation::
  CategoryCode () const
  {
    return this->CategoryCode_.get ();
  }

  Precipitation::CategoryCode_type& Precipitation::
  CategoryCode ()
  {
    return this->CategoryCode_.get ();
  }

  void Precipitation::
  CategoryCode (const CategoryCode_type& x)
  {
    this->CategoryCode_.set (x);
  }

  void Precipitation::
  CategoryCode (::std::auto_ptr< CategoryCode_type > x)
  {
    this->CategoryCode_.set (x);
  }

  const Precipitation::Rate_optional& Precipitation::
  Rate () const
  {
    return this->Rate_;
  }

  Precipitation::Rate_optional& Precipitation::
  Rate ()
  {
    return this->Rate_;
  }

  void Precipitation::
  Rate (const Rate_type& x)
  {
    this->Rate_.set (x);
  }

  void Precipitation::
  Rate (const Rate_optional& x)
  {
    this->Rate_ = x;
  }

  void Precipitation::
  Rate (::std::auto_ptr< Rate_type > x)
  {
    this->Rate_.set (x);
  }


  // Visibility
  // 

  const Visibility::CategoryCode_optional& Visibility::
  CategoryCode () const
  {
    return this->CategoryCode_;
  }

  Visibility::CategoryCode_optional& Visibility::
  CategoryCode ()
  {
    return this->CategoryCode_;
  }

  void Visibility::
  CategoryCode (const CategoryCode_type& x)
  {
    this->CategoryCode_.set (x);
  }

  void Visibility::
  CategoryCode (const CategoryCode_optional& x)
  {
    this->CategoryCode_ = x;
  }

  void Visibility::
  CategoryCode (::std::auto_ptr< CategoryCode_type > x)
  {
    this->CategoryCode_.set (x);
  }

  const Visibility::RangeDimension_type& Visibility::
  RangeDimension () const
  {
    return this->RangeDimension_.get ();
  }

  Visibility::RangeDimension_type& Visibility::
  RangeDimension ()
  {
    return this->RangeDimension_.get ();
  }

  void Visibility::
  RangeDimension (const RangeDimension_type& x)
  {
    this->RangeDimension_.set (x);
  }

  void Visibility::
  RangeDimension (::std::auto_ptr< RangeDimension_type > x)
  {
    this->RangeDimension_.set (x);
  }


  // Wind
  // 

  const Wind::CategoryCode_optional& Wind::
  CategoryCode () const
  {
    return this->CategoryCode_;
  }

  Wind::CategoryCode_optional& Wind::
  CategoryCode ()
  {
    return this->CategoryCode_;
  }

  void Wind::
  CategoryCode (const CategoryCode_type& x)
  {
    this->CategoryCode_.set (x);
  }

  void Wind::
  CategoryCode (const CategoryCode_optional& x)
  {
    this->CategoryCode_ = x;
  }

  void Wind::
  CategoryCode (::std::auto_ptr< CategoryCode_type > x)
  {
    this->CategoryCode_.set (x);
  }

  const Wind::AirStabilityCategoryCode_optional& Wind::
  AirStabilityCategoryCode () const
  {
    return this->AirStabilityCategoryCode_;
  }

  Wind::AirStabilityCategoryCode_optional& Wind::
  AirStabilityCategoryCode ()
  {
    return this->AirStabilityCategoryCode_;
  }

  void Wind::
  AirStabilityCategoryCode (const AirStabilityCategoryCode_type& x)
  {
    this->AirStabilityCategoryCode_.set (x);
  }

  void Wind::
  AirStabilityCategoryCode (const AirStabilityCategoryCode_optional& x)
  {
    this->AirStabilityCategoryCode_ = x;
  }

  void Wind::
  AirStabilityCategoryCode (::std::auto_ptr< AirStabilityCategoryCode_type > x)
  {
    this->AirStabilityCategoryCode_.set (x);
  }

  const Wind::AltitudeLayerCode_optional& Wind::
  AltitudeLayerCode () const
  {
    return this->AltitudeLayerCode_;
  }

  Wind::AltitudeLayerCode_optional& Wind::
  AltitudeLayerCode ()
  {
    return this->AltitudeLayerCode_;
  }

  void Wind::
  AltitudeLayerCode (const AltitudeLayerCode_type& x)
  {
    this->AltitudeLayerCode_.set (x);
  }

  void Wind::
  AltitudeLayerCode (const AltitudeLayerCode_optional& x)
  {
    this->AltitudeLayerCode_ = x;
  }

  void Wind::
  AltitudeLayerCode (::std::auto_ptr< AltitudeLayerCode_type > x)
  {
    this->AltitudeLayerCode_.set (x);
  }

  const Wind::DirectionAngle_optional& Wind::
  DirectionAngle () const
  {
    return this->DirectionAngle_;
  }

  Wind::DirectionAngle_optional& Wind::
  DirectionAngle ()
  {
    return this->DirectionAngle_;
  }

  void Wind::
  DirectionAngle (const DirectionAngle_type& x)
  {
    this->DirectionAngle_.set (x);
  }

  void Wind::
  DirectionAngle (const DirectionAngle_optional& x)
  {
    this->DirectionAngle_ = x;
  }

  void Wind::
  DirectionAngle (::std::auto_ptr< DirectionAngle_type > x)
  {
    this->DirectionAngle_.set (x);
  }

  const Wind::EffectiveDownwindDirectionAngle_optional& Wind::
  EffectiveDownwindDirectionAngle () const
  {
    return this->EffectiveDownwindDirectionAngle_;
  }

  Wind::EffectiveDownwindDirectionAngle_optional& Wind::
  EffectiveDownwindDirectionAngle ()
  {
    return this->EffectiveDownwindDirectionAngle_;
  }

  void Wind::
  EffectiveDownwindDirectionAngle (const EffectiveDownwindDirectionAngle_type& x)
  {
    this->EffectiveDownwindDirectionAngle_.set (x);
  }

  void Wind::
  EffectiveDownwindDirectionAngle (const EffectiveDownwindDirectionAngle_optional& x)
  {
    this->EffectiveDownwindDirectionAngle_ = x;
  }

  void Wind::
  EffectiveDownwindDirectionAngle (::std::auto_ptr< EffectiveDownwindDirectionAngle_type > x)
  {
    this->EffectiveDownwindDirectionAngle_.set (x);
  }

  const Wind::SpeedRate_optional& Wind::
  SpeedRate () const
  {
    return this->SpeedRate_;
  }

  Wind::SpeedRate_optional& Wind::
  SpeedRate ()
  {
    return this->SpeedRate_;
  }

  void Wind::
  SpeedRate (const SpeedRate_type& x)
  {
    this->SpeedRate_.set (x);
  }

  void Wind::
  SpeedRate (const SpeedRate_optional& x)
  {
    this->SpeedRate_ = x;
  }

  void Wind::
  SpeedRate (::std::auto_ptr< SpeedRate_type > x)
  {
    this->SpeedRate_.set (x);
  }

  const Wind::NuclearYieldQualifierCode_optional& Wind::
  NuclearYieldQualifierCode () const
  {
    return this->NuclearYieldQualifierCode_;
  }

  Wind::NuclearYieldQualifierCode_optional& Wind::
  NuclearYieldQualifierCode ()
  {
    return this->NuclearYieldQualifierCode_;
  }

  void Wind::
  NuclearYieldQualifierCode (const NuclearYieldQualifierCode_type& x)
  {
    this->NuclearYieldQualifierCode_.set (x);
  }

  void Wind::
  NuclearYieldQualifierCode (const NuclearYieldQualifierCode_optional& x)
  {
    this->NuclearYieldQualifierCode_ = x;
  }

  void Wind::
  NuclearYieldQualifierCode (::std::auto_ptr< NuclearYieldQualifierCode_type > x)
  {
    this->NuclearYieldQualifierCode_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

#include <xsd/cxx/tree/comparison-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;

  static
  const ::xsd::cxx::tree::comparison_plate< 0, char >
  comparison_plate_init;
}

namespace oo_2_0
{
  // AngleOptionalTypeRangeAngle7_4
  //

  static const ::xsd::cxx::tree::facet _xsd_AngleOptionalTypeRangeAngle7_4_facet_table[] = 
  {
    {
      ::xsd::cxx::tree::facet::fraction_digits, 4UL
    },

    {
      ::xsd::cxx::tree::facet::total_digits, 7UL
    },

    {
      ::xsd::cxx::tree::facet::none, 0UL
    }
  };

  AngleOptionalTypeRangeAngle7_4::
  AngleOptionalTypeRangeAngle7_4 (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
    this->_facet_table (_xsd_AngleOptionalTypeRangeAngle7_4_facet_table);
  }

  AngleOptionalTypeRangeAngle7_4::
  AngleOptionalTypeRangeAngle7_4 (const AngleOptionalTypeRangeAngle7_4& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
    this->_facet_table (_xsd_AngleOptionalTypeRangeAngle7_4_facet_table);
  }

  AngleOptionalTypeRangeAngle7_4::
  AngleOptionalTypeRangeAngle7_4 (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
    this->_facet_table (_xsd_AngleOptionalTypeRangeAngle7_4_facet_table);
  }

  AngleOptionalTypeRangeAngle7_4::
  AngleOptionalTypeRangeAngle7_4 (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
    this->_facet_table (_xsd_AngleOptionalTypeRangeAngle7_4_facet_table);
  }

  AngleOptionalTypeRangeAngle7_4::
  AngleOptionalTypeRangeAngle7_4 (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
    this->_facet_table (_xsd_AngleOptionalTypeRangeAngle7_4_facet_table);
  }

  AngleOptionalTypeRangeAngle7_4* AngleOptionalTypeRangeAngle7_4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AngleOptionalTypeRangeAngle7_4 (*this, f, c);
  }

  AngleOptionalTypeRangeAngle7_4::
  ~AngleOptionalTypeRangeAngle7_4 ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AngleOptionalTypeRangeAngle7_4 >
  _xsd_AngleOptionalTypeRangeAngle7_4_type_factory_init (
    "AngleOptionalTypeRangeAngle7_4",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, AngleOptionalTypeRangeAngle7_4 >
  _xsd_AngleOptionalTypeRangeAngle7_4_comparison_init;

  // DatetimeOptionalTypeFix18
  //

  DatetimeOptionalTypeFix18::
  DatetimeOptionalTypeFix18 ()
  : ::xml_schema::string ()
  {
  }

  DatetimeOptionalTypeFix18::
  DatetimeOptionalTypeFix18 (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  DatetimeOptionalTypeFix18::
  DatetimeOptionalTypeFix18 (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  DatetimeOptionalTypeFix18::
  DatetimeOptionalTypeFix18 (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  DatetimeOptionalTypeFix18::
  DatetimeOptionalTypeFix18 (const DatetimeOptionalTypeFix18& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  DatetimeOptionalTypeFix18::
  DatetimeOptionalTypeFix18 (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  DatetimeOptionalTypeFix18::
  DatetimeOptionalTypeFix18 (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  DatetimeOptionalTypeFix18::
  DatetimeOptionalTypeFix18 (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  DatetimeOptionalTypeFix18* DatetimeOptionalTypeFix18::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DatetimeOptionalTypeFix18 (*this, f, c);
  }

  DatetimeOptionalTypeFix18::
  ~DatetimeOptionalTypeFix18 ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DatetimeOptionalTypeFix18 >
  _xsd_DatetimeOptionalTypeFix18_type_factory_init (
    "DatetimeOptionalTypeFix18",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, DatetimeOptionalTypeFix18 >
  _xsd_DatetimeOptionalTypeFix18_comparison_init;

  // DimensionOptionalType12_3
  //

  static const ::xsd::cxx::tree::facet _xsd_DimensionOptionalType12_3_facet_table[] = 
  {
    {
      ::xsd::cxx::tree::facet::fraction_digits, 3UL
    },

    {
      ::xsd::cxx::tree::facet::total_digits, 12UL
    },

    {
      ::xsd::cxx::tree::facet::none, 0UL
    }
  };

  DimensionOptionalType12_3::
  DimensionOptionalType12_3 (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
    this->_facet_table (_xsd_DimensionOptionalType12_3_facet_table);
  }

  DimensionOptionalType12_3::
  DimensionOptionalType12_3 (const DimensionOptionalType12_3& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
    this->_facet_table (_xsd_DimensionOptionalType12_3_facet_table);
  }

  DimensionOptionalType12_3::
  DimensionOptionalType12_3 (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
    this->_facet_table (_xsd_DimensionOptionalType12_3_facet_table);
  }

  DimensionOptionalType12_3::
  DimensionOptionalType12_3 (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
    this->_facet_table (_xsd_DimensionOptionalType12_3_facet_table);
  }

  DimensionOptionalType12_3::
  DimensionOptionalType12_3 (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
    this->_facet_table (_xsd_DimensionOptionalType12_3_facet_table);
  }

  DimensionOptionalType12_3* DimensionOptionalType12_3::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionOptionalType12_3 (*this, f, c);
  }

  DimensionOptionalType12_3::
  ~DimensionOptionalType12_3 ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DimensionOptionalType12_3 >
  _xsd_DimensionOptionalType12_3_type_factory_init (
    "DimensionOptionalType12_3",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, DimensionOptionalType12_3 >
  _xsd_DimensionOptionalType12_3_comparison_init;

  // DimensionMandatoryType12_3
  //

  static const ::xsd::cxx::tree::facet _xsd_DimensionMandatoryType12_3_facet_table[] = 
  {
    {
      ::xsd::cxx::tree::facet::fraction_digits, 3UL
    },

    {
      ::xsd::cxx::tree::facet::total_digits, 12UL
    },

    {
      ::xsd::cxx::tree::facet::none, 0UL
    }
  };

  DimensionMandatoryType12_3::
  DimensionMandatoryType12_3 (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
    this->_facet_table (_xsd_DimensionMandatoryType12_3_facet_table);
  }

  DimensionMandatoryType12_3::
  DimensionMandatoryType12_3 (const DimensionMandatoryType12_3& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
    this->_facet_table (_xsd_DimensionMandatoryType12_3_facet_table);
  }

  DimensionMandatoryType12_3::
  DimensionMandatoryType12_3 (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
    this->_facet_table (_xsd_DimensionMandatoryType12_3_facet_table);
  }

  DimensionMandatoryType12_3::
  DimensionMandatoryType12_3 (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
    this->_facet_table (_xsd_DimensionMandatoryType12_3_facet_table);
  }

  DimensionMandatoryType12_3::
  DimensionMandatoryType12_3 (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
    this->_facet_table (_xsd_DimensionMandatoryType12_3_facet_table);
  }

  DimensionMandatoryType12_3* DimensionMandatoryType12_3::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionMandatoryType12_3 (*this, f, c);
  }

  DimensionMandatoryType12_3::
  ~DimensionMandatoryType12_3 ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DimensionMandatoryType12_3 >
  _xsd_DimensionMandatoryType12_3_type_factory_init (
    "DimensionMandatoryType12_3",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, DimensionMandatoryType12_3 >
  _xsd_DimensionMandatoryType12_3_comparison_init;

  // QuantityOptionalType8_4
  //

  static const ::xsd::cxx::tree::facet _xsd_QuantityOptionalType8_4_facet_table[] = 
  {
    {
      ::xsd::cxx::tree::facet::fraction_digits, 4UL
    },

    {
      ::xsd::cxx::tree::facet::total_digits, 8UL
    },

    {
      ::xsd::cxx::tree::facet::none, 0UL
    }
  };

  QuantityOptionalType8_4::
  QuantityOptionalType8_4 (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
    this->_facet_table (_xsd_QuantityOptionalType8_4_facet_table);
  }

  QuantityOptionalType8_4::
  QuantityOptionalType8_4 (const QuantityOptionalType8_4& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
    this->_facet_table (_xsd_QuantityOptionalType8_4_facet_table);
  }

  QuantityOptionalType8_4::
  QuantityOptionalType8_4 (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
    this->_facet_table (_xsd_QuantityOptionalType8_4_facet_table);
  }

  QuantityOptionalType8_4::
  QuantityOptionalType8_4 (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
    this->_facet_table (_xsd_QuantityOptionalType8_4_facet_table);
  }

  QuantityOptionalType8_4::
  QuantityOptionalType8_4 (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
    this->_facet_table (_xsd_QuantityOptionalType8_4_facet_table);
  }

  QuantityOptionalType8_4* QuantityOptionalType8_4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class QuantityOptionalType8_4 (*this, f, c);
  }

  QuantityOptionalType8_4::
  ~QuantityOptionalType8_4 ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, QuantityOptionalType8_4 >
  _xsd_QuantityOptionalType8_4_type_factory_init (
    "QuantityOptionalType8_4",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, QuantityOptionalType8_4 >
  _xsd_QuantityOptionalType8_4_comparison_init;

  // RateOptionalType4_1
  //

  static const ::xsd::cxx::tree::facet _xsd_RateOptionalType4_1_facet_table[] = 
  {
    {
      ::xsd::cxx::tree::facet::fraction_digits, 1UL
    },

    {
      ::xsd::cxx::tree::facet::total_digits, 4UL
    },

    {
      ::xsd::cxx::tree::facet::none, 0UL
    }
  };

  RateOptionalType4_1::
  RateOptionalType4_1 (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
    this->_facet_table (_xsd_RateOptionalType4_1_facet_table);
  }

  RateOptionalType4_1::
  RateOptionalType4_1 (const RateOptionalType4_1& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
    this->_facet_table (_xsd_RateOptionalType4_1_facet_table);
  }

  RateOptionalType4_1::
  RateOptionalType4_1 (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
    this->_facet_table (_xsd_RateOptionalType4_1_facet_table);
  }

  RateOptionalType4_1::
  RateOptionalType4_1 (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
    this->_facet_table (_xsd_RateOptionalType4_1_facet_table);
  }

  RateOptionalType4_1::
  RateOptionalType4_1 (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
    this->_facet_table (_xsd_RateOptionalType4_1_facet_table);
  }

  RateOptionalType4_1* RateOptionalType4_1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RateOptionalType4_1 (*this, f, c);
  }

  RateOptionalType4_1::
  ~RateOptionalType4_1 ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RateOptionalType4_1 >
  _xsd_RateOptionalType4_1_type_factory_init (
    "RateOptionalType4_1",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, RateOptionalType4_1 >
  _xsd_RateOptionalType4_1_comparison_init;

  // RateOptionalType8_4
  //

  static const ::xsd::cxx::tree::facet _xsd_RateOptionalType8_4_facet_table[] = 
  {
    {
      ::xsd::cxx::tree::facet::fraction_digits, 4UL
    },

    {
      ::xsd::cxx::tree::facet::total_digits, 8UL
    },

    {
      ::xsd::cxx::tree::facet::none, 0UL
    }
  };

  RateOptionalType8_4::
  RateOptionalType8_4 (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
    this->_facet_table (_xsd_RateOptionalType8_4_facet_table);
  }

  RateOptionalType8_4::
  RateOptionalType8_4 (const RateOptionalType8_4& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
    this->_facet_table (_xsd_RateOptionalType8_4_facet_table);
  }

  RateOptionalType8_4::
  RateOptionalType8_4 (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
    this->_facet_table (_xsd_RateOptionalType8_4_facet_table);
  }

  RateOptionalType8_4::
  RateOptionalType8_4 (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
    this->_facet_table (_xsd_RateOptionalType8_4_facet_table);
  }

  RateOptionalType8_4::
  RateOptionalType8_4 (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
    this->_facet_table (_xsd_RateOptionalType8_4_facet_table);
  }

  RateOptionalType8_4* RateOptionalType8_4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RateOptionalType8_4 (*this, f, c);
  }

  RateOptionalType8_4::
  ~RateOptionalType8_4 ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RateOptionalType8_4 >
  _xsd_RateOptionalType8_4_type_factory_init (
    "RateOptionalType8_4",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, RateOptionalType8_4 >
  _xsd_RateOptionalType8_4_comparison_init;

  // RatioOptionalTypeRangeRatio6_5
  //

  static const ::xsd::cxx::tree::facet _xsd_RatioOptionalTypeRangeRatio6_5_facet_table[] = 
  {
    {
      ::xsd::cxx::tree::facet::fraction_digits, 5UL
    },

    {
      ::xsd::cxx::tree::facet::total_digits, 6UL
    },

    {
      ::xsd::cxx::tree::facet::none, 0UL
    }
  };

  RatioOptionalTypeRangeRatio6_5::
  RatioOptionalTypeRangeRatio6_5 (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
    this->_facet_table (_xsd_RatioOptionalTypeRangeRatio6_5_facet_table);
  }

  RatioOptionalTypeRangeRatio6_5::
  RatioOptionalTypeRangeRatio6_5 (const RatioOptionalTypeRangeRatio6_5& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
    this->_facet_table (_xsd_RatioOptionalTypeRangeRatio6_5_facet_table);
  }

  RatioOptionalTypeRangeRatio6_5::
  RatioOptionalTypeRangeRatio6_5 (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
    this->_facet_table (_xsd_RatioOptionalTypeRangeRatio6_5_facet_table);
  }

  RatioOptionalTypeRangeRatio6_5::
  RatioOptionalTypeRangeRatio6_5 (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
    this->_facet_table (_xsd_RatioOptionalTypeRangeRatio6_5_facet_table);
  }

  RatioOptionalTypeRangeRatio6_5::
  RatioOptionalTypeRangeRatio6_5 (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
    this->_facet_table (_xsd_RatioOptionalTypeRangeRatio6_5_facet_table);
  }

  RatioOptionalTypeRangeRatio6_5* RatioOptionalTypeRangeRatio6_5::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RatioOptionalTypeRangeRatio6_5 (*this, f, c);
  }

  RatioOptionalTypeRangeRatio6_5::
  ~RatioOptionalTypeRangeRatio6_5 ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RatioOptionalTypeRangeRatio6_5 >
  _xsd_RatioOptionalTypeRangeRatio6_5_type_factory_init (
    "RatioOptionalTypeRangeRatio6_5",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, RatioOptionalTypeRangeRatio6_5 >
  _xsd_RatioOptionalTypeRangeRatio6_5_comparison_init;

  // RatioOptionalTypeRangeRatio7_6
  //

  static const ::xsd::cxx::tree::facet _xsd_RatioOptionalTypeRangeRatio7_6_facet_table[] = 
  {
    {
      ::xsd::cxx::tree::facet::fraction_digits, 6UL
    },

    {
      ::xsd::cxx::tree::facet::total_digits, 7UL
    },

    {
      ::xsd::cxx::tree::facet::none, 0UL
    }
  };

  RatioOptionalTypeRangeRatio7_6::
  RatioOptionalTypeRangeRatio7_6 (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
    this->_facet_table (_xsd_RatioOptionalTypeRangeRatio7_6_facet_table);
  }

  RatioOptionalTypeRangeRatio7_6::
  RatioOptionalTypeRangeRatio7_6 (const RatioOptionalTypeRangeRatio7_6& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
    this->_facet_table (_xsd_RatioOptionalTypeRangeRatio7_6_facet_table);
  }

  RatioOptionalTypeRangeRatio7_6::
  RatioOptionalTypeRangeRatio7_6 (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
    this->_facet_table (_xsd_RatioOptionalTypeRangeRatio7_6_facet_table);
  }

  RatioOptionalTypeRangeRatio7_6::
  RatioOptionalTypeRangeRatio7_6 (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
    this->_facet_table (_xsd_RatioOptionalTypeRangeRatio7_6_facet_table);
  }

  RatioOptionalTypeRangeRatio7_6::
  RatioOptionalTypeRangeRatio7_6 (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
    this->_facet_table (_xsd_RatioOptionalTypeRangeRatio7_6_facet_table);
  }

  RatioOptionalTypeRangeRatio7_6* RatioOptionalTypeRangeRatio7_6::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RatioOptionalTypeRangeRatio7_6 (*this, f, c);
  }

  RatioOptionalTypeRangeRatio7_6::
  ~RatioOptionalTypeRangeRatio7_6 ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RatioOptionalTypeRangeRatio7_6 >
  _xsd_RatioOptionalTypeRangeRatio7_6_type_factory_init (
    "RatioOptionalTypeRangeRatio7_6",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, RatioOptionalTypeRangeRatio7_6 >
  _xsd_RatioOptionalTypeRangeRatio7_6_comparison_init;

  // TemperatureTypeRangeTemperature5_1
  //

  static const ::xsd::cxx::tree::facet _xsd_TemperatureTypeRangeTemperature5_1_facet_table[] = 
  {
    {
      ::xsd::cxx::tree::facet::fraction_digits, 1UL
    },

    {
      ::xsd::cxx::tree::facet::total_digits, 5UL
    },

    {
      ::xsd::cxx::tree::facet::none, 0UL
    }
  };

  TemperatureTypeRangeTemperature5_1::
  TemperatureTypeRangeTemperature5_1 (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
    this->_facet_table (_xsd_TemperatureTypeRangeTemperature5_1_facet_table);
  }

  TemperatureTypeRangeTemperature5_1::
  TemperatureTypeRangeTemperature5_1 (const TemperatureTypeRangeTemperature5_1& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
    this->_facet_table (_xsd_TemperatureTypeRangeTemperature5_1_facet_table);
  }

  TemperatureTypeRangeTemperature5_1::
  TemperatureTypeRangeTemperature5_1 (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
    this->_facet_table (_xsd_TemperatureTypeRangeTemperature5_1_facet_table);
  }

  TemperatureTypeRangeTemperature5_1::
  TemperatureTypeRangeTemperature5_1 (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
    this->_facet_table (_xsd_TemperatureTypeRangeTemperature5_1_facet_table);
  }

  TemperatureTypeRangeTemperature5_1::
  TemperatureTypeRangeTemperature5_1 (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
    this->_facet_table (_xsd_TemperatureTypeRangeTemperature5_1_facet_table);
  }

  TemperatureTypeRangeTemperature5_1* TemperatureTypeRangeTemperature5_1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TemperatureTypeRangeTemperature5_1 (*this, f, c);
  }

  TemperatureTypeRangeTemperature5_1::
  ~TemperatureTypeRangeTemperature5_1 ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TemperatureTypeRangeTemperature5_1 >
  _xsd_TemperatureTypeRangeTemperature5_1_type_factory_init (
    "TemperatureTypeRangeTemperature5_1",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, TemperatureTypeRangeTemperature5_1 >
  _xsd_TemperatureTypeRangeTemperature5_1_comparison_init;

  // Atmosphere
  //

  Atmosphere::
  Atmosphere ()
  : ::xml_schema::type (),
    HumidityRatio_ (this),
    InversionLayerCode_ (this),
    PressureQuantity_ (this),
    Temperature_ (this),
    TemperatureGradientCode_ (this)
  {
  }

  Atmosphere::
  Atmosphere (const Atmosphere& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    HumidityRatio_ (x.HumidityRatio_, f, this),
    InversionLayerCode_ (x.InversionLayerCode_, f, this),
    PressureQuantity_ (x.PressureQuantity_, f, this),
    Temperature_ (x.Temperature_, f, this),
    TemperatureGradientCode_ (x.TemperatureGradientCode_, f, this)
  {
  }

  Atmosphere::
  Atmosphere (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    HumidityRatio_ (this),
    InversionLayerCode_ (this),
    PressureQuantity_ (this),
    Temperature_ (this),
    TemperatureGradientCode_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Atmosphere::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HumidityRatio
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HumidityRatio",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< HumidityRatio_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->HumidityRatio_)
          {
            ::std::auto_ptr< HumidityRatio_type > r (
              dynamic_cast< HumidityRatio_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->HumidityRatio_.set (r);
            continue;
          }
        }
      }

      // InversionLayerCode
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "InversionLayerCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< InversionLayerCode_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->InversionLayerCode_)
          {
            ::std::auto_ptr< InversionLayerCode_type > r (
              dynamic_cast< InversionLayerCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->InversionLayerCode_.set (r);
            continue;
          }
        }
      }

      // PressureQuantity
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PressureQuantity",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< PressureQuantity_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->PressureQuantity_)
          {
            ::std::auto_ptr< PressureQuantity_type > r (
              dynamic_cast< PressureQuantity_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->PressureQuantity_.set (r);
            continue;
          }
        }
      }

      // Temperature
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Temperature",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< Temperature_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Temperature_)
          {
            ::std::auto_ptr< Temperature_type > r (
              dynamic_cast< Temperature_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Temperature_.set (r);
            continue;
          }
        }
      }

      // TemperatureGradientCode
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TemperatureGradientCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< TemperatureGradientCode_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->TemperatureGradientCode_)
          {
            ::std::auto_ptr< TemperatureGradientCode_type > r (
              dynamic_cast< TemperatureGradientCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->TemperatureGradientCode_.set (r);
            continue;
          }
        }
      }

      break;
    }
  }

  Atmosphere* Atmosphere::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Atmosphere (*this, f, c);
  }

  Atmosphere& Atmosphere::
  operator= (const Atmosphere& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->HumidityRatio_ = x.HumidityRatio_;
      this->InversionLayerCode_ = x.InversionLayerCode_;
      this->PressureQuantity_ = x.PressureQuantity_;
      this->Temperature_ = x.Temperature_;
      this->TemperatureGradientCode_ = x.TemperatureGradientCode_;
    }

    return *this;
  }

  Atmosphere::
  ~Atmosphere ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Atmosphere >
  _xsd_Atmosphere_type_factory_init (
    "Atmosphere",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, Atmosphere >
  _xsd_Atmosphere_comparison_init;

  bool
  operator== (const Atmosphere& x, const Atmosphere& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Atmosphere::HumidityRatio_optional a (x.HumidityRatio ()), b (y.HumidityRatio ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Atmosphere::InversionLayerCode_optional a (x.InversionLayerCode ()), b (y.InversionLayerCode ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Atmosphere::PressureQuantity_optional a (x.PressureQuantity ()), b (y.PressureQuantity ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Atmosphere::Temperature_optional a (x.Temperature ()), b (y.Temperature ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Atmosphere::TemperatureGradientCode_optional a (x.TemperatureGradientCode ()), b (y.TemperatureGradientCode ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const Atmosphere& x, const Atmosphere& y)
  {
    return !(x == y);
  }

  // CloudCover
  //

  CloudCover::
  CloudCover (const CategoryCode_type& CategoryCode)
  : ::xml_schema::type (),
    CategoryCode_ (CategoryCode, this),
    BaseDimension_ (this),
    TopDimension_ (this),
    AverageCoverageCode_ (this),
    LightRefractionRatio_ (this)
  {
  }

  CloudCover::
  CloudCover (::std::auto_ptr< CategoryCode_type > CategoryCode)
  : ::xml_schema::type (),
    CategoryCode_ (CategoryCode, this),
    BaseDimension_ (this),
    TopDimension_ (this),
    AverageCoverageCode_ (this),
    LightRefractionRatio_ (this)
  {
  }

  CloudCover::
  CloudCover (const CloudCover& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CategoryCode_ (x.CategoryCode_, f, this),
    BaseDimension_ (x.BaseDimension_, f, this),
    TopDimension_ (x.TopDimension_, f, this),
    AverageCoverageCode_ (x.AverageCoverageCode_, f, this),
    LightRefractionRatio_ (x.LightRefractionRatio_, f, this)
  {
  }

  CloudCover::
  CloudCover (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CategoryCode_ (this),
    BaseDimension_ (this),
    TopDimension_ (this),
    AverageCoverageCode_ (this),
    LightRefractionRatio_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CloudCover::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CategoryCode
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CategoryCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< CategoryCode_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!CategoryCode_.present ())
          {
            ::std::auto_ptr< CategoryCode_type > r (
              dynamic_cast< CategoryCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CategoryCode_.set (r);
            continue;
          }
        }
      }

      // BaseDimension
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "BaseDimension",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< BaseDimension_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->BaseDimension_)
          {
            ::std::auto_ptr< BaseDimension_type > r (
              dynamic_cast< BaseDimension_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->BaseDimension_.set (r);
            continue;
          }
        }
      }

      // TopDimension
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TopDimension",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< TopDimension_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->TopDimension_)
          {
            ::std::auto_ptr< TopDimension_type > r (
              dynamic_cast< TopDimension_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->TopDimension_.set (r);
            continue;
          }
        }
      }

      // AverageCoverageCode
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AverageCoverageCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< AverageCoverageCode_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AverageCoverageCode_)
          {
            ::std::auto_ptr< AverageCoverageCode_type > r (
              dynamic_cast< AverageCoverageCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AverageCoverageCode_.set (r);
            continue;
          }
        }
      }

      // LightRefractionRatio
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "LightRefractionRatio",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< LightRefractionRatio_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->LightRefractionRatio_)
          {
            ::std::auto_ptr< LightRefractionRatio_type > r (
              dynamic_cast< LightRefractionRatio_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->LightRefractionRatio_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!CategoryCode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CategoryCode",
        "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");
    }
  }

  CloudCover* CloudCover::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CloudCover (*this, f, c);
  }

  CloudCover& CloudCover::
  operator= (const CloudCover& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CategoryCode_ = x.CategoryCode_;
      this->BaseDimension_ = x.BaseDimension_;
      this->TopDimension_ = x.TopDimension_;
      this->AverageCoverageCode_ = x.AverageCoverageCode_;
      this->LightRefractionRatio_ = x.LightRefractionRatio_;
    }

    return *this;
  }

  CloudCover::
  ~CloudCover ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CloudCover >
  _xsd_CloudCover_type_factory_init (
    "CloudCover",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, CloudCover >
  _xsd_CloudCover_comparison_init;

  bool
  operator== (const CloudCover& x, const CloudCover& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.CategoryCode (), y.CategoryCode ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      CloudCover::BaseDimension_optional a (x.BaseDimension ()), b (y.BaseDimension ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      CloudCover::TopDimension_optional a (x.TopDimension ()), b (y.TopDimension ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      CloudCover::AverageCoverageCode_optional a (x.AverageCoverageCode ()), b (y.AverageCoverageCode ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      CloudCover::LightRefractionRatio_optional a (x.LightRefractionRatio ()), b (y.LightRefractionRatio ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const CloudCover& x, const CloudCover& y)
  {
    return !(x == y);
  }

  // Icing
  //

  Icing::
  Icing ()
  : ::xml_schema::type (),
    CategoryCode_ (this),
    SeverityQualifierCode_ (this)
  {
  }

  Icing::
  Icing (const Icing& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CategoryCode_ (x.CategoryCode_, f, this),
    SeverityQualifierCode_ (x.SeverityQualifierCode_, f, this)
  {
  }

  Icing::
  Icing (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CategoryCode_ (this),
    SeverityQualifierCode_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Icing::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CategoryCode
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CategoryCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< CategoryCode_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CategoryCode_)
          {
            ::std::auto_ptr< CategoryCode_type > r (
              dynamic_cast< CategoryCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CategoryCode_.set (r);
            continue;
          }
        }
      }

      // SeverityQualifierCode
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SeverityQualifierCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< SeverityQualifierCode_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SeverityQualifierCode_)
          {
            ::std::auto_ptr< SeverityQualifierCode_type > r (
              dynamic_cast< SeverityQualifierCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SeverityQualifierCode_.set (r);
            continue;
          }
        }
      }

      break;
    }
  }

  Icing* Icing::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Icing (*this, f, c);
  }

  Icing& Icing::
  operator= (const Icing& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CategoryCode_ = x.CategoryCode_;
      this->SeverityQualifierCode_ = x.SeverityQualifierCode_;
    }

    return *this;
  }

  Icing::
  ~Icing ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Icing >
  _xsd_Icing_type_factory_init (
    "Icing",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, Icing >
  _xsd_Icing_comparison_init;

  bool
  operator== (const Icing& x, const Icing& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Icing::CategoryCode_optional a (x.CategoryCode ()), b (y.CategoryCode ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Icing::SeverityQualifierCode_optional a (x.SeverityQualifierCode ()), b (y.SeverityQualifierCode ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const Icing& x, const Icing& y)
  {
    return !(x == y);
  }

  // Light
  //

  Light::
  Light ()
  : ::xml_schema::type (),
    CategoryCode_ (this),
    UpDatetime_ (this),
    DownDatetime_ (this),
    MoonPhaseCode_ (this)
  {
  }

  Light::
  Light (const Light& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CategoryCode_ (x.CategoryCode_, f, this),
    UpDatetime_ (x.UpDatetime_, f, this),
    DownDatetime_ (x.DownDatetime_, f, this),
    MoonPhaseCode_ (x.MoonPhaseCode_, f, this)
  {
  }

  Light::
  Light (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CategoryCode_ (this),
    UpDatetime_ (this),
    DownDatetime_ (this),
    MoonPhaseCode_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Light::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CategoryCode
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CategoryCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< CategoryCode_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CategoryCode_)
          {
            ::std::auto_ptr< CategoryCode_type > r (
              dynamic_cast< CategoryCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CategoryCode_.set (r);
            continue;
          }
        }
      }

      // UpDatetime
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UpDatetime",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< UpDatetime_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->UpDatetime_)
          {
            ::std::auto_ptr< UpDatetime_type > r (
              dynamic_cast< UpDatetime_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UpDatetime_.set (r);
            continue;
          }
        }
      }

      // DownDatetime
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DownDatetime",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< DownDatetime_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DownDatetime_)
          {
            ::std::auto_ptr< DownDatetime_type > r (
              dynamic_cast< DownDatetime_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DownDatetime_.set (r);
            continue;
          }
        }
      }

      // MoonPhaseCode
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MoonPhaseCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< MoonPhaseCode_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MoonPhaseCode_)
          {
            ::std::auto_ptr< MoonPhaseCode_type > r (
              dynamic_cast< MoonPhaseCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MoonPhaseCode_.set (r);
            continue;
          }
        }
      }

      break;
    }
  }

  Light* Light::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Light (*this, f, c);
  }

  Light& Light::
  operator= (const Light& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CategoryCode_ = x.CategoryCode_;
      this->UpDatetime_ = x.UpDatetime_;
      this->DownDatetime_ = x.DownDatetime_;
      this->MoonPhaseCode_ = x.MoonPhaseCode_;
    }

    return *this;
  }

  Light::
  ~Light ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Light >
  _xsd_Light_type_factory_init (
    "Light",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, Light >
  _xsd_Light_comparison_init;

  bool
  operator== (const Light& x, const Light& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Light::CategoryCode_optional a (x.CategoryCode ()), b (y.CategoryCode ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Light::UpDatetime_optional a (x.UpDatetime ()), b (y.UpDatetime ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Light::DownDatetime_optional a (x.DownDatetime ()), b (y.DownDatetime ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Light::MoonPhaseCode_optional a (x.MoonPhaseCode ()), b (y.MoonPhaseCode ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const Light& x, const Light& y)
  {
    return !(x == y);
  }

  // Precipitation
  //

  Precipitation::
  Precipitation (const CategoryCode_type& CategoryCode)
  : ::xml_schema::type (),
    CategoryCode_ (CategoryCode, this),
    Rate_ (this)
  {
  }

  Precipitation::
  Precipitation (::std::auto_ptr< CategoryCode_type > CategoryCode)
  : ::xml_schema::type (),
    CategoryCode_ (CategoryCode, this),
    Rate_ (this)
  {
  }

  Precipitation::
  Precipitation (const Precipitation& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CategoryCode_ (x.CategoryCode_, f, this),
    Rate_ (x.Rate_, f, this)
  {
  }

  Precipitation::
  Precipitation (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CategoryCode_ (this),
    Rate_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Precipitation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CategoryCode
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CategoryCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< CategoryCode_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!CategoryCode_.present ())
          {
            ::std::auto_ptr< CategoryCode_type > r (
              dynamic_cast< CategoryCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CategoryCode_.set (r);
            continue;
          }
        }
      }

      // Rate
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Rate",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< Rate_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Rate_)
          {
            ::std::auto_ptr< Rate_type > r (
              dynamic_cast< Rate_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Rate_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!CategoryCode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CategoryCode",
        "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");
    }
  }

  Precipitation* Precipitation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Precipitation (*this, f, c);
  }

  Precipitation& Precipitation::
  operator= (const Precipitation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CategoryCode_ = x.CategoryCode_;
      this->Rate_ = x.Rate_;
    }

    return *this;
  }

  Precipitation::
  ~Precipitation ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Precipitation >
  _xsd_Precipitation_type_factory_init (
    "Precipitation",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, Precipitation >
  _xsd_Precipitation_comparison_init;

  bool
  operator== (const Precipitation& x, const Precipitation& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.CategoryCode (), y.CategoryCode ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Precipitation::Rate_optional a (x.Rate ()), b (y.Rate ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const Precipitation& x, const Precipitation& y)
  {
    return !(x == y);
  }

  // Visibility
  //

  Visibility::
  Visibility (const RangeDimension_type& RangeDimension)
  : ::xml_schema::type (),
    CategoryCode_ (this),
    RangeDimension_ (RangeDimension, this)
  {
  }

  Visibility::
  Visibility (::std::auto_ptr< RangeDimension_type > RangeDimension)
  : ::xml_schema::type (),
    CategoryCode_ (this),
    RangeDimension_ (RangeDimension, this)
  {
  }

  Visibility::
  Visibility (const Visibility& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CategoryCode_ (x.CategoryCode_, f, this),
    RangeDimension_ (x.RangeDimension_, f, this)
  {
  }

  Visibility::
  Visibility (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CategoryCode_ (this),
    RangeDimension_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Visibility::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CategoryCode
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CategoryCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< CategoryCode_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CategoryCode_)
          {
            ::std::auto_ptr< CategoryCode_type > r (
              dynamic_cast< CategoryCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CategoryCode_.set (r);
            continue;
          }
        }
      }

      // RangeDimension
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "RangeDimension",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< RangeDimension_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!RangeDimension_.present ())
          {
            ::std::auto_ptr< RangeDimension_type > r (
              dynamic_cast< RangeDimension_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->RangeDimension_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!RangeDimension_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "RangeDimension",
        "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");
    }
  }

  Visibility* Visibility::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Visibility (*this, f, c);
  }

  Visibility& Visibility::
  operator= (const Visibility& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CategoryCode_ = x.CategoryCode_;
      this->RangeDimension_ = x.RangeDimension_;
    }

    return *this;
  }

  Visibility::
  ~Visibility ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Visibility >
  _xsd_Visibility_type_factory_init (
    "Visibility",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, Visibility >
  _xsd_Visibility_comparison_init;

  bool
  operator== (const Visibility& x, const Visibility& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Visibility::CategoryCode_optional a (x.CategoryCode ()), b (y.CategoryCode ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.RangeDimension (), y.RangeDimension ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const Visibility& x, const Visibility& y)
  {
    return !(x == y);
  }

  // Wind
  //

  Wind::
  Wind ()
  : ::xml_schema::type (),
    CategoryCode_ (this),
    AirStabilityCategoryCode_ (this),
    AltitudeLayerCode_ (this),
    DirectionAngle_ (this),
    EffectiveDownwindDirectionAngle_ (this),
    SpeedRate_ (this),
    NuclearYieldQualifierCode_ (this)
  {
  }

  Wind::
  Wind (const Wind& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CategoryCode_ (x.CategoryCode_, f, this),
    AirStabilityCategoryCode_ (x.AirStabilityCategoryCode_, f, this),
    AltitudeLayerCode_ (x.AltitudeLayerCode_, f, this),
    DirectionAngle_ (x.DirectionAngle_, f, this),
    EffectiveDownwindDirectionAngle_ (x.EffectiveDownwindDirectionAngle_, f, this),
    SpeedRate_ (x.SpeedRate_, f, this),
    NuclearYieldQualifierCode_ (x.NuclearYieldQualifierCode_, f, this)
  {
  }

  Wind::
  Wind (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CategoryCode_ (this),
    AirStabilityCategoryCode_ (this),
    AltitudeLayerCode_ (this),
    DirectionAngle_ (this),
    EffectiveDownwindDirectionAngle_ (this),
    SpeedRate_ (this),
    NuclearYieldQualifierCode_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Wind::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CategoryCode
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CategoryCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< CategoryCode_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CategoryCode_)
          {
            ::std::auto_ptr< CategoryCode_type > r (
              dynamic_cast< CategoryCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CategoryCode_.set (r);
            continue;
          }
        }
      }

      // AirStabilityCategoryCode
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AirStabilityCategoryCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< AirStabilityCategoryCode_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AirStabilityCategoryCode_)
          {
            ::std::auto_ptr< AirStabilityCategoryCode_type > r (
              dynamic_cast< AirStabilityCategoryCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AirStabilityCategoryCode_.set (r);
            continue;
          }
        }
      }

      // AltitudeLayerCode
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AltitudeLayerCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< AltitudeLayerCode_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AltitudeLayerCode_)
          {
            ::std::auto_ptr< AltitudeLayerCode_type > r (
              dynamic_cast< AltitudeLayerCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AltitudeLayerCode_.set (r);
            continue;
          }
        }
      }

      // DirectionAngle
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DirectionAngle",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< DirectionAngle_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DirectionAngle_)
          {
            ::std::auto_ptr< DirectionAngle_type > r (
              dynamic_cast< DirectionAngle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DirectionAngle_.set (r);
            continue;
          }
        }
      }

      // EffectiveDownwindDirectionAngle
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "EffectiveDownwindDirectionAngle",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< EffectiveDownwindDirectionAngle_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->EffectiveDownwindDirectionAngle_)
          {
            ::std::auto_ptr< EffectiveDownwindDirectionAngle_type > r (
              dynamic_cast< EffectiveDownwindDirectionAngle_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->EffectiveDownwindDirectionAngle_.set (r);
            continue;
          }
        }
      }

      // SpeedRate
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SpeedRate",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< SpeedRate_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SpeedRate_)
          {
            ::std::auto_ptr< SpeedRate_type > r (
              dynamic_cast< SpeedRate_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SpeedRate_.set (r);
            continue;
          }
        }
      }

      // NuclearYieldQualifierCode
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "NuclearYieldQualifierCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            &::xsd::cxx::tree::factory_impl< NuclearYieldQualifierCode_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->NuclearYieldQualifierCode_)
          {
            ::std::auto_ptr< NuclearYieldQualifierCode_type > r (
              dynamic_cast< NuclearYieldQualifierCode_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->NuclearYieldQualifierCode_.set (r);
            continue;
          }
        }
      }

      break;
    }
  }

  Wind* Wind::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Wind (*this, f, c);
  }

  Wind& Wind::
  operator= (const Wind& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CategoryCode_ = x.CategoryCode_;
      this->AirStabilityCategoryCode_ = x.AirStabilityCategoryCode_;
      this->AltitudeLayerCode_ = x.AltitudeLayerCode_;
      this->DirectionAngle_ = x.DirectionAngle_;
      this->EffectiveDownwindDirectionAngle_ = x.EffectiveDownwindDirectionAngle_;
      this->SpeedRate_ = x.SpeedRate_;
      this->NuclearYieldQualifierCode_ = x.NuclearYieldQualifierCode_;
    }

    return *this;
  }

  Wind::
  ~Wind ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Wind >
  _xsd_Wind_type_factory_init (
    "Wind",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, Wind >
  _xsd_Wind_comparison_init;

  bool
  operator== (const Wind& x, const Wind& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Wind::CategoryCode_optional a (x.CategoryCode ()), b (y.CategoryCode ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Wind::AirStabilityCategoryCode_optional a (x.AirStabilityCategoryCode ()), b (y.AirStabilityCategoryCode ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Wind::AltitudeLayerCode_optional a (x.AltitudeLayerCode ()), b (y.AltitudeLayerCode ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Wind::DirectionAngle_optional a (x.DirectionAngle ()), b (y.DirectionAngle ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Wind::EffectiveDownwindDirectionAngle_optional a (x.EffectiveDownwindDirectionAngle ()), b (y.EffectiveDownwindDirectionAngle ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Wind::SpeedRate_optional a (x.SpeedRate ()), b (y.SpeedRate ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      Wind::NuclearYieldQualifierCode_optional a (x.NuclearYieldQualifierCode ()), b (y.NuclearYieldQualifierCode ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const Wind& x, const Wind& y)
  {
    return !(x == y);
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace oo_2_0
{
  ::std::ostream&
  operator<< (::std::ostream& o, const AngleOptionalTypeRangeAngle7_4& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, AngleOptionalTypeRangeAngle7_4 >
  _xsd_AngleOptionalTypeRangeAngle7_4_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const DatetimeOptionalTypeFix18& i)
  {
    o << static_cast< const ::xml_schema::string& > (i);

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, DatetimeOptionalTypeFix18 >
  _xsd_DatetimeOptionalTypeFix18_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const DimensionOptionalType12_3& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, DimensionOptionalType12_3 >
  _xsd_DimensionOptionalType12_3_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const DimensionMandatoryType12_3& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, DimensionMandatoryType12_3 >
  _xsd_DimensionMandatoryType12_3_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const QuantityOptionalType8_4& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, QuantityOptionalType8_4 >
  _xsd_QuantityOptionalType8_4_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const RateOptionalType4_1& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, RateOptionalType4_1 >
  _xsd_RateOptionalType4_1_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const RateOptionalType8_4& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, RateOptionalType8_4 >
  _xsd_RateOptionalType8_4_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const RatioOptionalTypeRangeRatio6_5& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, RatioOptionalTypeRangeRatio6_5 >
  _xsd_RatioOptionalTypeRangeRatio6_5_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const RatioOptionalTypeRangeRatio7_6& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, RatioOptionalTypeRangeRatio7_6 >
  _xsd_RatioOptionalTypeRangeRatio7_6_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const TemperatureTypeRangeTemperature5_1& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, TemperatureTypeRangeTemperature5_1 >
  _xsd_TemperatureTypeRangeTemperature5_1_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const Atmosphere& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.HumidityRatio ())
      {
        o << ::std::endl << "HumidityRatio: ";
        om.insert (o, *i.HumidityRatio ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.InversionLayerCode ())
      {
        o << ::std::endl << "InversionLayerCode: ";
        om.insert (o, *i.InversionLayerCode ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.PressureQuantity ())
      {
        o << ::std::endl << "PressureQuantity: ";
        om.insert (o, *i.PressureQuantity ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Temperature ())
      {
        o << ::std::endl << "Temperature: ";
        om.insert (o, *i.Temperature ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.TemperatureGradientCode ())
      {
        o << ::std::endl << "TemperatureGradientCode: ";
        om.insert (o, *i.TemperatureGradientCode ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, Atmosphere >
  _xsd_Atmosphere_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const CloudCover& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "CategoryCode: ";
      om.insert (o, i.CategoryCode ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.BaseDimension ())
      {
        o << ::std::endl << "BaseDimension: ";
        om.insert (o, *i.BaseDimension ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.TopDimension ())
      {
        o << ::std::endl << "TopDimension: ";
        om.insert (o, *i.TopDimension ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AverageCoverageCode ())
      {
        o << ::std::endl << "AverageCoverageCode: ";
        om.insert (o, *i.AverageCoverageCode ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.LightRefractionRatio ())
      {
        o << ::std::endl << "LightRefractionRatio: ";
        om.insert (o, *i.LightRefractionRatio ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CloudCover >
  _xsd_CloudCover_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const Icing& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.CategoryCode ())
      {
        o << ::std::endl << "CategoryCode: ";
        om.insert (o, *i.CategoryCode ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.SeverityQualifierCode ())
      {
        o << ::std::endl << "SeverityQualifierCode: ";
        om.insert (o, *i.SeverityQualifierCode ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, Icing >
  _xsd_Icing_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const Light& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.CategoryCode ())
      {
        o << ::std::endl << "CategoryCode: ";
        om.insert (o, *i.CategoryCode ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.UpDatetime ())
      {
        o << ::std::endl << "UpDatetime: ";
        om.insert (o, *i.UpDatetime ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DownDatetime ())
      {
        o << ::std::endl << "DownDatetime: ";
        om.insert (o, *i.DownDatetime ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.MoonPhaseCode ())
      {
        o << ::std::endl << "MoonPhaseCode: ";
        om.insert (o, *i.MoonPhaseCode ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, Light >
  _xsd_Light_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const Precipitation& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "CategoryCode: ";
      om.insert (o, i.CategoryCode ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.Rate ())
      {
        o << ::std::endl << "Rate: ";
        om.insert (o, *i.Rate ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, Precipitation >
  _xsd_Precipitation_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const Visibility& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.CategoryCode ())
      {
        o << ::std::endl << "CategoryCode: ";
        om.insert (o, *i.CategoryCode ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "RangeDimension: ";
      om.insert (o, i.RangeDimension ());
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, Visibility >
  _xsd_Visibility_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const Wind& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.CategoryCode ())
      {
        o << ::std::endl << "CategoryCode: ";
        om.insert (o, *i.CategoryCode ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AirStabilityCategoryCode ())
      {
        o << ::std::endl << "AirStabilityCategoryCode: ";
        om.insert (o, *i.AirStabilityCategoryCode ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.AltitudeLayerCode ())
      {
        o << ::std::endl << "AltitudeLayerCode: ";
        om.insert (o, *i.AltitudeLayerCode ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.DirectionAngle ())
      {
        o << ::std::endl << "DirectionAngle: ";
        om.insert (o, *i.DirectionAngle ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.EffectiveDownwindDirectionAngle ())
      {
        o << ::std::endl << "EffectiveDownwindDirectionAngle: ";
        om.insert (o, *i.EffectiveDownwindDirectionAngle ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.SpeedRate ())
      {
        o << ::std::endl << "SpeedRate: ";
        om.insert (o, *i.SpeedRate ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.NuclearYieldQualifierCode ())
      {
        o << ::std::endl << "NuclearYieldQualifierCode: ";
        om.insert (o, *i.NuclearYieldQualifierCode ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, Wind >
  _xsd_Wind_std_ostream_init;
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace oo_2_0
{
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace oo_2_0
{
  void
  operator<< (::xercesc::DOMElement& e, const AngleOptionalTypeRangeAngle7_4& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AngleOptionalTypeRangeAngle7_4& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const AngleOptionalTypeRangeAngle7_4& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AngleOptionalTypeRangeAngle7_4 >
  _xsd_AngleOptionalTypeRangeAngle7_4_type_serializer_init (
    "AngleOptionalTypeRangeAngle7_4",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const DatetimeOptionalTypeFix18& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DatetimeOptionalTypeFix18& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const DatetimeOptionalTypeFix18& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DatetimeOptionalTypeFix18 >
  _xsd_DatetimeOptionalTypeFix18_type_serializer_init (
    "DatetimeOptionalTypeFix18",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const DimensionOptionalType12_3& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DimensionOptionalType12_3& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const DimensionOptionalType12_3& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DimensionOptionalType12_3 >
  _xsd_DimensionOptionalType12_3_type_serializer_init (
    "DimensionOptionalType12_3",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const DimensionMandatoryType12_3& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DimensionMandatoryType12_3& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const DimensionMandatoryType12_3& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DimensionMandatoryType12_3 >
  _xsd_DimensionMandatoryType12_3_type_serializer_init (
    "DimensionMandatoryType12_3",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const QuantityOptionalType8_4& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const QuantityOptionalType8_4& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const QuantityOptionalType8_4& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, QuantityOptionalType8_4 >
  _xsd_QuantityOptionalType8_4_type_serializer_init (
    "QuantityOptionalType8_4",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const RateOptionalType4_1& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const RateOptionalType4_1& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const RateOptionalType4_1& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RateOptionalType4_1 >
  _xsd_RateOptionalType4_1_type_serializer_init (
    "RateOptionalType4_1",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const RateOptionalType8_4& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const RateOptionalType8_4& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const RateOptionalType8_4& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RateOptionalType8_4 >
  _xsd_RateOptionalType8_4_type_serializer_init (
    "RateOptionalType8_4",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const RatioOptionalTypeRangeRatio6_5& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const RatioOptionalTypeRangeRatio6_5& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const RatioOptionalTypeRangeRatio6_5& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RatioOptionalTypeRangeRatio6_5 >
  _xsd_RatioOptionalTypeRangeRatio6_5_type_serializer_init (
    "RatioOptionalTypeRangeRatio6_5",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const RatioOptionalTypeRangeRatio7_6& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const RatioOptionalTypeRangeRatio7_6& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const RatioOptionalTypeRangeRatio7_6& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RatioOptionalTypeRangeRatio7_6 >
  _xsd_RatioOptionalTypeRangeRatio7_6_type_serializer_init (
    "RatioOptionalTypeRangeRatio7_6",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const TemperatureTypeRangeTemperature5_1& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TemperatureTypeRangeTemperature5_1& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const TemperatureTypeRangeTemperature5_1& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TemperatureTypeRangeTemperature5_1 >
  _xsd_TemperatureTypeRangeTemperature5_1_type_serializer_init (
    "TemperatureTypeRangeTemperature5_1",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const Atmosphere& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // HumidityRatio
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.HumidityRatio ())
      {
        const Atmosphere::HumidityRatio_type& x (*i.HumidityRatio ());
        if (typeid (Atmosphere::HumidityRatio_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "HumidityRatio",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "HumidityRatio",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // InversionLayerCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.InversionLayerCode ())
      {
        const Atmosphere::InversionLayerCode_type& x (*i.InversionLayerCode ());
        if (typeid (Atmosphere::InversionLayerCode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "InversionLayerCode",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "InversionLayerCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // PressureQuantity
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.PressureQuantity ())
      {
        const Atmosphere::PressureQuantity_type& x (*i.PressureQuantity ());
        if (typeid (Atmosphere::PressureQuantity_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PressureQuantity",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "PressureQuantity",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // Temperature
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Temperature ())
      {
        const Atmosphere::Temperature_type& x (*i.Temperature ());
        if (typeid (Atmosphere::Temperature_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Temperature",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Temperature",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // TemperatureGradientCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.TemperatureGradientCode ())
      {
        const Atmosphere::TemperatureGradientCode_type& x (*i.TemperatureGradientCode ());
        if (typeid (Atmosphere::TemperatureGradientCode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TemperatureGradientCode",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "TemperatureGradientCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Atmosphere >
  _xsd_Atmosphere_type_serializer_init (
    "Atmosphere",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const CloudCover& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CategoryCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const CloudCover::CategoryCode_type& x (i.CategoryCode ());
      if (typeid (CloudCover::CategoryCode_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CategoryCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "CategoryCode",
          "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
          false, true, e, x);
    }

    // BaseDimension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.BaseDimension ())
      {
        const CloudCover::BaseDimension_type& x (*i.BaseDimension ());
        if (typeid (CloudCover::BaseDimension_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "BaseDimension",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "BaseDimension",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // TopDimension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.TopDimension ())
      {
        const CloudCover::TopDimension_type& x (*i.TopDimension ());
        if (typeid (CloudCover::TopDimension_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TopDimension",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "TopDimension",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // AverageCoverageCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AverageCoverageCode ())
      {
        const CloudCover::AverageCoverageCode_type& x (*i.AverageCoverageCode ());
        if (typeid (CloudCover::AverageCoverageCode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AverageCoverageCode",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AverageCoverageCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // LightRefractionRatio
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.LightRefractionRatio ())
      {
        const CloudCover::LightRefractionRatio_type& x (*i.LightRefractionRatio ());
        if (typeid (CloudCover::LightRefractionRatio_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "LightRefractionRatio",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "LightRefractionRatio",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CloudCover >
  _xsd_CloudCover_type_serializer_init (
    "CloudCover",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const Icing& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CategoryCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CategoryCode ())
      {
        const Icing::CategoryCode_type& x (*i.CategoryCode ());
        if (typeid (Icing::CategoryCode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CategoryCode",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CategoryCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // SeverityQualifierCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.SeverityQualifierCode ())
      {
        const Icing::SeverityQualifierCode_type& x (*i.SeverityQualifierCode ());
        if (typeid (Icing::SeverityQualifierCode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SeverityQualifierCode",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SeverityQualifierCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Icing >
  _xsd_Icing_type_serializer_init (
    "Icing",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const Light& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CategoryCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CategoryCode ())
      {
        const Light::CategoryCode_type& x (*i.CategoryCode ());
        if (typeid (Light::CategoryCode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CategoryCode",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CategoryCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // UpDatetime
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.UpDatetime ())
      {
        const Light::UpDatetime_type& x (*i.UpDatetime ());
        if (typeid (Light::UpDatetime_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UpDatetime",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "UpDatetime",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // DownDatetime
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DownDatetime ())
      {
        const Light::DownDatetime_type& x (*i.DownDatetime ());
        if (typeid (Light::DownDatetime_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DownDatetime",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DownDatetime",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // MoonPhaseCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MoonPhaseCode ())
      {
        const Light::MoonPhaseCode_type& x (*i.MoonPhaseCode ());
        if (typeid (Light::MoonPhaseCode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MoonPhaseCode",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MoonPhaseCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Light >
  _xsd_Light_type_serializer_init (
    "Light",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const Precipitation& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CategoryCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Precipitation::CategoryCode_type& x (i.CategoryCode ());
      if (typeid (Precipitation::CategoryCode_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CategoryCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "CategoryCode",
          "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
          false, true, e, x);
    }

    // Rate
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Rate ())
      {
        const Precipitation::Rate_type& x (*i.Rate ());
        if (typeid (Precipitation::Rate_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Rate",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Rate",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Precipitation >
  _xsd_Precipitation_type_serializer_init (
    "Precipitation",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const Visibility& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CategoryCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CategoryCode ())
      {
        const Visibility::CategoryCode_type& x (*i.CategoryCode ());
        if (typeid (Visibility::CategoryCode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CategoryCode",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CategoryCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // RangeDimension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Visibility::RangeDimension_type& x (i.RangeDimension ());
      if (typeid (Visibility::RangeDimension_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RangeDimension",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RangeDimension",
          "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
          false, true, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Visibility >
  _xsd_Visibility_type_serializer_init (
    "Visibility",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");


  void
  operator<< (::xercesc::DOMElement& e, const Wind& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CategoryCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CategoryCode ())
      {
        const Wind::CategoryCode_type& x (*i.CategoryCode ());
        if (typeid (Wind::CategoryCode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CategoryCode",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CategoryCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // AirStabilityCategoryCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AirStabilityCategoryCode ())
      {
        const Wind::AirStabilityCategoryCode_type& x (*i.AirStabilityCategoryCode ());
        if (typeid (Wind::AirStabilityCategoryCode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AirStabilityCategoryCode",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AirStabilityCategoryCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // AltitudeLayerCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AltitudeLayerCode ())
      {
        const Wind::AltitudeLayerCode_type& x (*i.AltitudeLayerCode ());
        if (typeid (Wind::AltitudeLayerCode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AltitudeLayerCode",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AltitudeLayerCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // DirectionAngle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DirectionAngle ())
      {
        const Wind::DirectionAngle_type& x (*i.DirectionAngle ());
        if (typeid (Wind::DirectionAngle_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DirectionAngle",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DirectionAngle",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // EffectiveDownwindDirectionAngle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.EffectiveDownwindDirectionAngle ())
      {
        const Wind::EffectiveDownwindDirectionAngle_type& x (*i.EffectiveDownwindDirectionAngle ());
        if (typeid (Wind::EffectiveDownwindDirectionAngle_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EffectiveDownwindDirectionAngle",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EffectiveDownwindDirectionAngle",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // SpeedRate
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.SpeedRate ())
      {
        const Wind::SpeedRate_type& x (*i.SpeedRate ());
        if (typeid (Wind::SpeedRate_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SpeedRate",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SpeedRate",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }

    // NuclearYieldQualifierCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.NuclearYieldQualifierCode ())
      {
        const Wind::NuclearYieldQualifierCode_type& x (*i.NuclearYieldQualifierCode ());
        if (typeid (Wind::NuclearYieldQualifierCode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "NuclearYieldQualifierCode",
              "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "NuclearYieldQualifierCode",
            "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Wind >
  _xsd_Wind_type_serializer_init (
    "Wind",
    "urn:int:nato:standard:mip:jc3iedm:3.1:oo:2.0");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

