// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef EXTERN_JC3IEDM_3_1_CODES_20061208_HXX
#define EXTERN_JC3IEDM_3_1_CODES_20061208_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace oo_2_0
{
  class AbsolutePointCategoryCode;
  class ActionAircraftEmploymentApproachOffsetCode;
  class ActionAircraftEmploymentCrewCompositionCode;
  class ActionAircraftEmploymentDeplanementMethodCode;
  class ActionAircraftEmploymentGeneralRoleCode;
  class ActionAircraftEmploymentInflightReportRequirementIndicatorCode;
  class ActionCategoryCode;
  class ActionContextCategoryCode;
  class ActionEffectCategoryCode;
  class ActionEffectDescriptionCode;
  class ActionEffectSeverityCode;
  class ActionElectronicWarfareEmploymentCategoryCode;
  class ActionEventCategoryCode;
  class ActionEventDetailClassificationCode;
  class ActionEventDetailCrimeIndicatorCode;
  class ActionFunctionalAssociationCategoryCode;
  class ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode;
  class ActionMaritimeEmploymentVesselTransitInstructionCode;
  class ActionObjectiveCategoryCode;
  class ActionObjectiveItemCategoryCode;
  class ActionObjectiveItemMarkingMethodCode;
  class ActionObjectiveItemMarkingPanelShapeCode;
  class ActionObjectiveItemMarkingRecognitionSignalColourCode;
  class ActionObjectiveItemPrimacyCode;
  class ActionObjectiveQualifierCode;
  class ActionObjectiveTypeCategoryCode;
  class ActionObjectiveTypeImageryProductImageTypeCode;
  class ActionReconnaissanceEmploymentImageCoverageModeCode;
  class ActionReconnaissanceEmploymentImageViewQualifierCode;
  class ActionReconnaissanceEmploymentTypeOfCoverageCode;
  class ActionReferenceAssociationCategoryCode;
  class ActionResourceCategoryCode;
  class ActionResourceCriticalityIndicatorCode;
  class ActionResourceEmploymentCategoryCode;
  class ActionResourceEmploymentMethodOfControlCode;
  class ActionResourceEmploymentTrajectoryFireCode;
  class ActionResourceQualifierCode;
  class ActionTaskActivityCode;
  class ActionTaskCategoryCode;
  class ActionTaskEndQualifierCode;
  class ActionTaskEntailedSafetyDegreeCode;
  class ActionTaskMeteorologicalImpactCode;
  class ActionTaskOperationalLevelCode;
  class ActionTaskOvertCovertCode;
  class ActionTaskPriorityCode;
  class ActionTaskStartQualifierCode;
  class ActionTaskStatusAmendTimingCode;
  class ActionTaskStatusApprovalIndicatorCode;
  class ActionTaskStatusCategoryCode;
  class ActionTaskStatusPlanningIndicatorCode;
  class ActionTaskStatusProgressCode;
  class ActionTaskTimingDayCode;
  class ActionTaskTimingHourCode;
  class ActionTemporalAssociationCategoryCode;
  class AddressCategoryCode;
  class AffiliationCategoryCode;
  class AffiliationEthnicGroupCode;
  class AffiliationFunctionalGroupCode;
  class AffiliationGeopoliticalCode;
  class AffiliationReligionCode;
  class AirRouteSegmentCivilMilitaryCode;
  class AirRouteSegmentInternationalRouteCode;
  class AirRouteSegmentRequiredNavigationPerformanceCode;
  class AircraftTypeAirframeDesignCode;
  class AircraftTypeCategoryCode;
  class AircraftTypeDesignRangeCode;
  class AircraftTypeDesignRoleCode;
  class AircraftTypeLoadCategoryCode;
  class AircraftTypeMainPurposeCode;
  class AircraftTypeManningCode;
  class AircraftTypeMilitaryCivilianCode;
  class AircraftTypeModelCode;
  class AircraftTypeTakeoffAndLandingCode;
  class AircraftTypeTrainingCategoryCode;
  class AircraftTypeWeatherQualifierCode;
  class AirfieldAirTrafficControlPresenceIndicatorCode;
  class AirfieldInstrumentLandingSystemPresenceIndicatorCode;
  class AirfieldStatusDayOperationsCode;
  class AirfieldStatusEvaluationIndicatorCode;
  class AirfieldStatusFlightSupportCategoryCode;
  class AirfieldTypeUseCategoryCode;
  class AirfieldVisualNavigationalAidIndicatorCode;
  class AmmunitionTypeCategoryCode;
  class AmmunitionTypeExerciseMineFlareColourCode;
  class AmmunitionTypeMineMaritimeFiringCode;
  class AnchorageBottomTypeCode;
  class AnchorageMooringsTypeCode;
  class AnglePrecisionCode;
  class ApproachDirectionCategoryCode;
  class AssociationStatusCategoryCode;
  class AtmosphereInversionLayerCode;
  class AtmospherePressureSystemCategoryCode;
  class AtmosphereTemperatureGradientCode;
  class BerthMajorVesselClassCode;
  class BerthRailAvailabilityIndicatorCode;
  class BerthRollOnRollOffIndicatorCode;
  class BiologicalMaterielTypeCategoryCode;
  class BiologicalMaterielTypeSubcategoryCode;
  class BridgeTypeDesignTypeCode;
  class BridgeUsageCode;
  class CandidateTargetDetailAssociationCategoryCode;
  class CandidateTargetDetailAuthorisationApprovalCode;
  class CandidateTargetDetailCategoryCode;
  class CandidateTargetDetailFocusTypeCode;
  class CandidateTargetDetailSchemeCode;
  class CandidateTargetListAssociationCategoryCode;
  class CandidateTargetListAuthorisationIndicatorCode;
  class CapabilityCategoryCode;
  class CapabilityDayNightCode;
  class CapabilityReferenceAssociationCategoryCode;
  class CapabilityUnitOfMeasureCode;
  class CargoCategoryCode;
  class CasualtyGroupCode;
  class CbrnEquipmentTypeCategoryCode;
  class CbrnEventAlarmResultIndicatorCode;
  class CbrnEventCategoryCode;
  class CbrnEventConfirmationTestIndicatorCode;
  class CbrnEventMaterielContainerTypeCode;
  class CbrnEventSubcategoryCode;
  class ChemicalBiologicalEventCategoryCode;
  class ChemicalBiologicalEventSpillSizeCode;
  class ChemicalMaterielTypeCategoryCode;
  class ChemicalMaterielTypeSubcategoryCode;
  class CivilianPostTypeCategoryCode;
  class CloudCoverAverageCoverageCode;
  class CloudCoverCategoryCode;
  class ConsumableMaterielTypeCategoryCode;
  class ConsumableMaterielTypeHazardCode;
  class ConsumableMaterielTypeIssuingElementCode;
  class ConsumableMaterielTypeIssuingUnitOfMeasureCode;
  class ConsumableMaterielTypePerishabilityIndicatorCode;
  class ConsumableMaterielTypeSubcategoryCode;
  class ConsumableMaterielTypeUnitedNationsNumberCode;
  class ContextAssessmentLimitingFactorsCode;
  class ContextAssociationCategoryCode;
  class ContextCategoryCode;
  class ContextElementStatusCategoryCode;
  class ContextObjectItemAssociationCategoryCode;
  class ContextReportingDataAssociationCategoryCode;
  class ControlFeatureCategoryCode;
  class ControlFeatureStatusCbrnThreatLevelCode;
  class ControlFeatureStatusInvestigationStatusCode;
  class ControlFeatureStatusSecurityStatusCode;
  class ControlFeatureTypeCategoryCode;
  class DemolitionStatusCode;
  class DirectionCode;
  class DistancePrecisionCode;
  class DryDockMarineRailwaySizeCode;
  class ElectronicEquipmentTypeCategoryCode;
  class ElectronicEquipmentTypeSubcategoryCode;
  class EngineeringCapabilityCategoryCode;
  class EngineeringCapabilityDescriptorCode;
  class EngineeringEquipmentTypeCategoryCode;
  class EquipmentTypeCategoryCode;
  class EvacuationDestinationCode;
  class ExecutiveMilitaryOrganisationTypeCategoryCode;
  class FacilityCategoryCode;
  class FacilityPrimaryConstructionMaterialCode;
  class FacilityStatusCategoryCode;
  class FacilityStatusEnemyActivityConditionCode;
  class FacilityStatusOccupationProgramIndicatorCode;
  class FacilityStatusOperationalStatusCode;
  class FacilityStatusOperationalStatusQualifierCode;
  class FacilityStatusReserveIndicatorCode;
  class FacilityStatusSecurityStatusCode;
  class FacilityTypeCategoryCode;
  class FeatureCategoryCode;
  class FeatureTypeCategoryCode;
  class FeintIndicatorCode;
  class FireCapabilityCategoryCode;
  class FireCapabilityDescriptorCode;
  class FireCapabilityWeaponTypeCode;
  class GenderCode;
  class GeographicFeatureBottomHardnessCode;
  class GeographicFeatureSolidSurfaceCompositionCode;
  class GeographicFeatureStatusCategoryCode;
  class GeographicFeatureStatusSurfaceRecirculationIndicatorCode;
  class GeographicFeatureSurfaceCategoryCode;
  class GeographicFeatureTerrainCode;
  class GeographicFeatureTypeCategoryCode;
  class GeographicFeatureTypeSubcategoryCode;
  class GeometricVolumeCategoryCode;
  class GovernmentOrganisationTypeCategoryCode;
  class GroupCharacteristicAgeGroupCode;
  class GroupCharacteristicMaladyCode;
  class GroupCharacteristicMaladyTransmissibilityIndicatorCode;
  class GroupCharacteristicTriageCode;
  class GroupOrganisationTypeCategoryCode;
  class HandlingCapabilityActionCode;
  class HandlingCapabilityDescriptorCode;
  class HarbourAirportNearIndicatorCode;
  class HarbourBiologicallySecureAvailabilityIndicatorCode;
  class HarbourConvoyMarshallingIndicatorCode;
  class HarbourDegaussingIndicatorCode;
  class HarbourDirtyBallastIndicatorCode;
  class HarbourEntranceRestrictionsIceIndicatorCode;
  class HarbourEntranceRestrictionsSwellIndicatorCode;
  class HarbourEstimatedTimeOfArrivalIndicatorCode;
  class HarbourFireFightingCapabilityCode;
  class HarbourFireFightingIndicatorCode;
  class HarbourFirstPortOfEntryIndicatorCode;
  class HarbourFreshWaterAvailabilityIndicatorCode;
  class HarbourLashIndicatorCode;
  class HarbourLighterageAvailabilityIndicatorCode;
  class HarbourOverheadLimitsIndicatorCode;
  class HarbourPassengerHandlingIndicatorCode;
  class HarbourPersistenceCode;
  class HarbourPilotageAvailabilityIndicatorCode;
  class HarbourPilotageRequirementIndicatorCode;
  class HarbourRefuellingAvailabilityIndicatorCode;
  class HarbourRefuellingTypeCode;
  class HarbourShelterQualityCode;
  class HarbourTankerFacilitiesIndicatorCode;
  class HarbourTransitAccommodationIndicatorCode;
  class HarbourTugAvailabilityIndicatorCode;
  class HarbourTurningAreaIndicatorCode;
  class HarbourTypeCategoryCode;
  class HarbourVehicleHandlingTypeCode;
  class HoldingRequiredCalculationMethodCode;
  class HoldingTransferReasonCode;
  class IcingCategoryCode;
  class IcingSeverityQualifierCode;
  class JettyRailServedIndicatorCode;
  class LanguageCategoryCode;
  class LanguageSkillProficiencyCode;
  class LightCategoryCode;
  class LightMoonPhaseCode;
  class LiquidSurfaceStatusSeaStateCode;
  class LiquidSurfaceStatusSurfaceConditionCode;
  class LocationCategoryCode;
  class MainActivityCode;
  class MaintenanceCapabilityCategoryCode;
  class MaintenanceCapabilityLevelCode;
  class MaritimeEquipmentTypeCategoryCode;
  class MaritimeEquipmentTypeSubcategoryCode;
  class MaterielCategoryCode;
  class MaterielStatusBodyColourCode;
  class MaterielStatusBuoyMalfunctionCode;
  class MaterielStatusCategoryCode;
  class MaterielStatusImoCompliantIndicatorCode;
  class MaterielStatusMarkingCode;
  class MaterielStatusMarkingColourCode;
  class MaterielStatusOperationalStatusCode;
  class MaterielStatusOperationalStatusModeCode;
  class MaterielStatusOperationalStatusQualifierCode;
  class MaterielStatusReserveIndicatorCode;
  class MaterielStatusSafetyStatusCode;
  class MaterielTypeCategoryCode;
  class MaterielTypeSupplyClassCode;
  class MedicalFacilityStatusIntervalCasualtyTypeCode;
  class MedicalFacilityStatusPendingSurgeryTriageCode;
  class MeteorologicFeatureCategoryCode;
  class MeteorologicFeatureInterpretationCode;
  class MeteorologicFeatureSourceCode;
  class MilitaryObstacleCategoryCode;
  class MilitaryObstacleTypeCategoryCode;
  class MilitaryObstacleTypeSubcategoryCode;
  class MilitaryOrganisationTypeCategoryCode;
  class MilitaryOrganisationTypeServiceCode;
  class MilitaryPostTypeCategoryCode;
  class MilitaryPostTypeRankCode;
  class MinePresenceCode;
  class MineStatusAirDropEffectCode;
  class MineStatusCode;
  class MineStatusMaritimeMineQualifierCode;
  class MinefieldCategoryCode;
  class MinefieldLandDepthPlacementCode;
  class MinefieldLandFunctionCode;
  class MinefieldLandPatternCode;
  class MinefieldLandPersistenceCode;
  class MinefieldLandStoppingPowerCode;
  class MinefieldMaritimeBottomNaturalCamouflageCode;
  class MinefieldMaritimeDepthPlacementCode;
  class MinefieldMaritimeFunctionCode;
  class MinefieldMaritimeStatusCode;
  class MinefieldMaritimeStatusColourCode;
  class MinefieldMaritimeStatusExpectedLevelMcmCode;
  class MinefieldMaritimeStatusMineDetectionCode;
  class MinefieldMaritimeStatusMineZoneRiskCode;
  class MinefieldMaritimeStatusSeedingCode;
  class MinefieldMaritimeSubfunctionCode;
  class MiscellaneousEquipmentTypeCategoryCode;
  class MiscellaneousEquipmentTypeSubcategoryCode;
  class MissionPrimacyCode;
  class MobilityCapabilityCategoryCode;
  class MobilityCapabilityDescriptorCode;
  class MobilityCapabilityTerrainTypeCode;
  class MobilityCode;
  class ModeOfTransportationCode;
  class NetworkArchitectureCode;
  class NetworkCapacityBandwidthCode;
  class NetworkCapacityProtocolCode;
  class NetworkCategoryCode;
  class NetworkFrequencyBandCode;
  class NetworkFrequencyModulationCode;
  class NetworkMeansCode;
  class NetworkServiceCategoryCode;
  class NetworkServiceCryptographicIndicatorCode;
  class NetworkServiceStatusIndicatorCode;
  class NetworkServiceSubcategoryCode;
  class NetworkSubcategoryCode;
  class NuclearEventCategoryCode;
  class NuclearWeaponEventCraterPresenceCode;
  class NuclearYieldGroupCode;
  class ObjectItemAddressAuthorisationIndicatorCode;
  class ObjectItemAddressPrimacyCode;
  class ObjectItemAddressTransmitReceiveCode;
  class ObjectItemAliasCategoryCode;
  class ObjectItemAssociationCategoryCode;
  class ObjectItemAssociationSubcategoryCode;
  class ObjectItemCategoryCode;
  class ObjectItemGroupAccountDetailQualifierCode;
  class ObjectItemHostilityStatusCode;
  class ObjectItemLocationMeaningCode;
  class ObjectItemLocationRelativeSpeedCode;
  class ObjectItemReferenceAssociationCategoryCode;
  class ObjectItemStatusBoobyTrapPresenceCode;
  class ObjectItemStatusCategoryCode;
  class ObjectItemStatusEmissionControlCode;
  class ObjectTypeCategoryCode;
  class ObjectTypeDecoyIndicatorCode;
  class ObjectTypeEstablishmentCategoryCode;
  class ObjectTypeEstablishmentEnvironmentConditionCode;
  class ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode;
  class ObjectTypeEstablishmentOperationalModeCode;
  class ObjectTypeReferenceAssociationCategoryCode;
  class OperationalCapabilityCategoryCode;
  class OperationalCapabilityLevelCode;
  class OperationalCapabilityQualifierCode;
  class OperationalInformationGroupCategoryCode;
  class OperationalInformationGroupOrganisationAssociationCategoryCode;
  class OrbitAreaAlignmentCode;
  class OrderCategoryCode;
  class OrderStatusExecutionStateCode;
  class OrganisationActionAssociationCategoryCode;
  class OrganisationActionTaskRuleOfEngagementStatusCategoryCode;
  class OrganisationCategoryCode;
  class OrganisationMaterielTypeAssociationReportableTypeCode;
  class OrganisationPlanOrderAssociationCategoryCode;
  class OrganisationReferenceAssociationCategoryCode;
  class OrganisationStatusAvailabilityCode;
  class OrganisationStatusCbrnDressStateCode;
  class OrganisationStatusCommandAndControlRoleCode;
  class OrganisationStatusCommitmentStatusCode;
  class OrganisationStatusFireModeCode;
  class OrganisationStatusOperationalStatusCode;
  class OrganisationStatusOperationalStatusQualifierCode;
  class OrganisationStatusReadinessCode;
  class OrganisationStatusReinforcementCode;
  class OrganisationStatusReserveIndicatorCode;
  class OrganisationStatusTrainingCode;
  class OrganisationStatusUsageStatusCode;
  class OrganisationTypeCategoryCode;
  class OrganisationTypeCommandAndControlCategoryCode;
  class OrganisationTypeCommandFunctionIndicatorCode;
  class PersistencyCode;
  class PersonBloodTypeCode;
  class PersonIdentificationDocumentCode;
  class PersonLanguageSkillGeneralProficiencyCode;
  class PersonProfessingIndicatorCode;
  class PersonStatusDutyStatusCode;
  class PersonStatusPhysicalStatusCode;
  class PersonStatusPhysicalStatusQualifierCode;
  class PersonStatusReserveIndicatorCode;
  class PersonTypeCategoryCode;
  class PersonTypeRankCode;
  class PersonTypeSubcategoryCode;
  class PhysicalAddressCategoryCode;
  class PlanCategoryCode;
  class PlanOrderAssociationCategoryCode;
  class PlanOrderCategoryCode;
  class PlanOrderComponentContentReferenceCategoryCode;
  class PlanOrderComponentStructureCategoryCode;
  class PlanOrderDistributionAcknowledgementCode;
  class PlanOrderDistributionCategoryCode;
  class PlanOrderHeaderContentTimeZoneCode;
  class PlanStatusDevelopmentStatusCode;
  class PlanStatusStateCode;
  class PointCategoryCode;
  class PrecipitationCategoryCode;
  class PrivateSectorOrganisationTypeCategoryCode;
  class QuayContainerHandlingTypeCode;
  class QuayCraneOffloadingTypeCode;
  class QuayRailServedIndicatorCode;
  class QuayStorageCode;
  class RadioactiveEventCategoryCode;
  class RadioactiveEventDoseRateTrendCode;
  class RadioactiveEventRelativeDecayRateCode;
  class RadioactiveMaterielTypeCategoryCode;
  class RadioactiveMaterielTypePrimaryRadiationCode;
  class RailcarTypeCategoryCode;
  class RailcarTypeSubcategoryCode;
  class RailwaySignalSystemCode;
  class RailwaySignalSystemEfficiencyCode;
  class RailwayTrackGaugeCode;
  class RailwayTractionSystemCode;
  class ReferenceAssociationCategoryCode;
  class ReferenceContentCategoryCode;
  class ReferenceLifecycleCode;
  class ReferenceMediumTypeCode;
  class ReferenceTransmittalTypeCode;
  class ReferenceVerificationCode;
  class RelativeCoordinateSystemReferenceCategoryCode;
  class ReleaseCategoryCode;
  class ReportingDataAccuracyCode;
  class ReportingDataCategoryCode;
  class ReportingDataCountingIndicatorCode;
  class ReportingDataCredibilityCode;
  class ReportingDataEntityCategoryCode;
  class ReportingDataRealDataExerciseUseOnlyCode;
  class ReportingDataReliabilityCode;
  class ReportingDataSourceTypeCode;
  class ReportingDataTimingCategoryCode;
  class RequestAnswerCategoryCode;
  class RequestCategoryCode;
  class RequestImmediateInterestIndicatorCode;
  class RoadCategoryCode;
  class RoadQualityCode;
  class RoadShoulderWidthCode;
  class RoadWeatherConditionCategoryCode;
  class RouteDirectionUsageCode;
  class RouteSegmentCategoryCode;
  class RouteTypeCategoryCode;
  class RunwayLightingPresenceIndicatorCode;
  class RunwayPavementEvaluationMethodCode;
  class RunwayPavementMaximumTyrePressureCode;
  class RunwayPavementSubgradeCategoryCode;
  class RunwayPavementTypeCode;
  class SecurityClassificationLevelCode;
  class SolidSurfaceStatusCode;
  class SolidSurfaceStatusSurfaceConditionCode;
  class SolidSurfaceStatusSurfaceFirmnessCode;
  class SpeedPrecisionCode;
  class StorageCapabilityConditionCode;
  class StorageCapabilityDescriptorCode;
  class SubsurfaceVesselTypeCategoryCode;
  class SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode;
  class SupportCapabilityCategoryCode;
  class SupportCapabilityDescriptorCode;
  class SurfaceCategoryCode;
  class SurfaceVesselTypeCategoryCode;
  class SurveillanceCapabilityCategoryCode;
  class SurveillanceCapabilityDescriptorCode;
  class TargetEngagementAuthorityCode;
  class TargetPersonnelProtectionCategoryCode;
  class TaskFormationTypeCategoryCode;
  class TransmissionCapabilityCategoryCode;
  class TransmissionCapabilityDescriptorCode;
  class UnitTypeArmCategoryCode;
  class UnitTypeArmSpecialisationCode;
  class UnitTypeCategoryCode;
  class UnitTypeGeneralMobilityCode;
  class UnitTypeQualifierCode;
  class UnitTypeSizeCode;
  class UnitTypeSupplementarySpecialisationCode;
  class UsageStatusCode;
  class UxoStatusExposureCode;
  class UxoStatusQualifierCode;
  class VegetationCategoryCode;
  class VegetationSubcategoryCode;
  class VehicleTypeCategoryCode;
  class VerticalDistanceReferenceCode;
  class VesselTypeCategoryCode;
  class VesselTypePropulsionTypeCode;
  class VisibilityCategoryCode;
  class WeaponTypeCategoryCode;
  class WeaponTypeFireGuidanceIndicatorCode;
  class WeaponTypeSubcategoryCode;
  class WindAirStabilityCategoryCode;
  class WindAltitudeLayerCode;
  class WindCategoryCode;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace oo_2_0
{
  class AbsolutePointCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CARTPT,
      GEOGPT
    };

    AbsolutePointCategoryCode (value v);

    AbsolutePointCategoryCode (const char* v);

    AbsolutePointCategoryCode (const ::std::string& v);

    AbsolutePointCategoryCode (const ::xml_schema::token& v);

    AbsolutePointCategoryCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    AbsolutePointCategoryCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    AbsolutePointCategoryCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    AbsolutePointCategoryCode (const AbsolutePointCategoryCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual AbsolutePointCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AbsolutePointCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AbsolutePointCategoryCode_convert ();
    }

    protected:
    value
    _xsd_AbsolutePointCategoryCode_convert () const;

    public:
    static const char* const _xsd_AbsolutePointCategoryCode_literals_[2];
    static const value _xsd_AbsolutePointCategoryCode_indexes_[2];
  };

  class ActionAircraftEmploymentApproachOffsetCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      LEFT,
      RIGHT,
      RL
    };

    ActionAircraftEmploymentApproachOffsetCode (value v);

    ActionAircraftEmploymentApproachOffsetCode (const char* v);

    ActionAircraftEmploymentApproachOffsetCode (const ::std::string& v);

    ActionAircraftEmploymentApproachOffsetCode (const ::xml_schema::token& v);

    ActionAircraftEmploymentApproachOffsetCode (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ActionAircraftEmploymentApproachOffsetCode (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ActionAircraftEmploymentApproachOffsetCode (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ActionAircraftEmploymentApproachOffsetCode (const ActionAircraftEmploymentApproachOffsetCode& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual ActionAircraftEmploymentApproachOffsetCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionAircraftEmploymentApproachOffsetCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionAircraftEmploymentApproachOffsetCode_convert ();
    }

    protected:
    value
    _xsd_ActionAircraftEmploymentApproachOffsetCode_convert () const;

    public:
    static const char* const _xsd_ActionAircraftEmploymentApproachOffsetCode_literals_[3];
    static const value _xsd_ActionAircraftEmploymentApproachOffsetCode_indexes_[3];
  };

  class ActionAircraftEmploymentCrewCompositionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AUGMNT,
      BASIC,
      COMRCL
    };

    ActionAircraftEmploymentCrewCompositionCode (value v);

    ActionAircraftEmploymentCrewCompositionCode (const char* v);

    ActionAircraftEmploymentCrewCompositionCode (const ::std::string& v);

    ActionAircraftEmploymentCrewCompositionCode (const ::xml_schema::token& v);

    ActionAircraftEmploymentCrewCompositionCode (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ActionAircraftEmploymentCrewCompositionCode (const ::xercesc::DOMAttr& a,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ActionAircraftEmploymentCrewCompositionCode (const ::std::string& s,
                                                 const ::xercesc::DOMElement* e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ActionAircraftEmploymentCrewCompositionCode (const ActionAircraftEmploymentCrewCompositionCode& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual ActionAircraftEmploymentCrewCompositionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionAircraftEmploymentCrewCompositionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionAircraftEmploymentCrewCompositionCode_convert ();
    }

    protected:
    value
    _xsd_ActionAircraftEmploymentCrewCompositionCode_convert () const;

    public:
    static const char* const _xsd_ActionAircraftEmploymentCrewCompositionCode_literals_[3];
    static const value _xsd_ActionAircraftEmploymentCrewCompositionCode_indexes_[3];
  };

  class ActionAircraftEmploymentDeplanementMethodCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ABSEIL,
      GRAVTY,
      HOVER,
      LAND,
      PARAUT,
      PARCHT,
      PAREXT,
      PARGLD,
      PARLAE,
      PARMAN,
      ROPE,
      WEDGE,
      WINCH
    };

    ActionAircraftEmploymentDeplanementMethodCode (value v);

    ActionAircraftEmploymentDeplanementMethodCode (const char* v);

    ActionAircraftEmploymentDeplanementMethodCode (const ::std::string& v);

    ActionAircraftEmploymentDeplanementMethodCode (const ::xml_schema::token& v);

    ActionAircraftEmploymentDeplanementMethodCode (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    ActionAircraftEmploymentDeplanementMethodCode (const ::xercesc::DOMAttr& a,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    ActionAircraftEmploymentDeplanementMethodCode (const ::std::string& s,
                                                   const ::xercesc::DOMElement* e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    ActionAircraftEmploymentDeplanementMethodCode (const ActionAircraftEmploymentDeplanementMethodCode& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    virtual ActionAircraftEmploymentDeplanementMethodCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionAircraftEmploymentDeplanementMethodCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionAircraftEmploymentDeplanementMethodCode_convert ();
    }

    protected:
    value
    _xsd_ActionAircraftEmploymentDeplanementMethodCode_convert () const;

    public:
    static const char* const _xsd_ActionAircraftEmploymentDeplanementMethodCode_literals_[13];
    static const value _xsd_ActionAircraftEmploymentDeplanementMethodCode_indexes_[13];
  };

  class ActionAircraftEmploymentGeneralRoleCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DEF,
      NKN,
      NOS,
      OFF,
      SUPPRT,
      SWING
    };

    ActionAircraftEmploymentGeneralRoleCode (value v);

    ActionAircraftEmploymentGeneralRoleCode (const char* v);

    ActionAircraftEmploymentGeneralRoleCode (const ::std::string& v);

    ActionAircraftEmploymentGeneralRoleCode (const ::xml_schema::token& v);

    ActionAircraftEmploymentGeneralRoleCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    ActionAircraftEmploymentGeneralRoleCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    ActionAircraftEmploymentGeneralRoleCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    ActionAircraftEmploymentGeneralRoleCode (const ActionAircraftEmploymentGeneralRoleCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual ActionAircraftEmploymentGeneralRoleCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionAircraftEmploymentGeneralRoleCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionAircraftEmploymentGeneralRoleCode_convert ();
    }

    protected:
    value
    _xsd_ActionAircraftEmploymentGeneralRoleCode_convert () const;

    public:
    static const char* const _xsd_ActionAircraftEmploymentGeneralRoleCode_literals_[6];
    static const value _xsd_ActionAircraftEmploymentGeneralRoleCode_indexes_[6];
  };

  class ActionAircraftEmploymentInflightReportRequirementIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    ActionAircraftEmploymentInflightReportRequirementIndicatorCode (value v);

    ActionAircraftEmploymentInflightReportRequirementIndicatorCode (const char* v);

    ActionAircraftEmploymentInflightReportRequirementIndicatorCode (const ::std::string& v);

    ActionAircraftEmploymentInflightReportRequirementIndicatorCode (const ::xml_schema::token& v);

    ActionAircraftEmploymentInflightReportRequirementIndicatorCode (const ::xercesc::DOMElement& e,
                                                                    ::xml_schema::flags f = 0,
                                                                    ::xml_schema::container* c = 0);

    ActionAircraftEmploymentInflightReportRequirementIndicatorCode (const ::xercesc::DOMAttr& a,
                                                                    ::xml_schema::flags f = 0,
                                                                    ::xml_schema::container* c = 0);

    ActionAircraftEmploymentInflightReportRequirementIndicatorCode (const ::std::string& s,
                                                                    const ::xercesc::DOMElement* e,
                                                                    ::xml_schema::flags f = 0,
                                                                    ::xml_schema::container* c = 0);

    ActionAircraftEmploymentInflightReportRequirementIndicatorCode (const ActionAircraftEmploymentInflightReportRequirementIndicatorCode& x,
                                                                    ::xml_schema::flags f = 0,
                                                                    ::xml_schema::container* c = 0);

    virtual ActionAircraftEmploymentInflightReportRequirementIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionAircraftEmploymentInflightReportRequirementIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionAircraftEmploymentInflightReportRequirementIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_ActionAircraftEmploymentInflightReportRequirementIndicatorCode_convert () const;

    public:
    static const char* const _xsd_ActionAircraftEmploymentInflightReportRequirementIndicatorCode_literals_[2];
    static const value _xsd_ActionAircraftEmploymentInflightReportRequirementIndicatorCode_indexes_[2];
  };

  class ActionCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ACTEV,
      ACTTA
    };

    ActionCategoryCode (value v);

    ActionCategoryCode (const char* v);

    ActionCategoryCode (const ::std::string& v);

    ActionCategoryCode (const ::xml_schema::token& v);

    ActionCategoryCode (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    ActionCategoryCode (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    ActionCategoryCode (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    ActionCategoryCode (const ActionCategoryCode& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual ActionCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionCategoryCode_literals_[2];
    static const value _xsd_ActionCategoryCode_indexes_[2];
  };

  class ActionContextCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DES,
      FINACT,
      FINPLA,
      INIACT,
      INIPLA,
      INTACT,
      INTPLA,
      ISINCL,
      MAX,
      MIN
    };

    ActionContextCategoryCode (value v);

    ActionContextCategoryCode (const char* v);

    ActionContextCategoryCode (const ::std::string& v);

    ActionContextCategoryCode (const ::xml_schema::token& v);

    ActionContextCategoryCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ActionContextCategoryCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ActionContextCategoryCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ActionContextCategoryCode (const ActionContextCategoryCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual ActionContextCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionContextCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionContextCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionContextCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionContextCategoryCode_literals_[10];
    static const value _xsd_ActionContextCategoryCode_indexes_[10];
  };

  class ActionEffectCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AEITEM,
      AETYPE
    };

    ActionEffectCategoryCode (value v);

    ActionEffectCategoryCode (const char* v);

    ActionEffectCategoryCode (const ::std::string& v);

    ActionEffectCategoryCode (const ::xml_schema::token& v);

    ActionEffectCategoryCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ActionEffectCategoryCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ActionEffectCategoryCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ActionEffectCategoryCode (const ActionEffectCategoryCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual ActionEffectCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionEffectCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionEffectCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionEffectCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionEffectCategoryCode_literals_[2];
    static const value _xsd_ActionEffectCategoryCode_indexes_[2];
  };

  class ActionEffectDescriptionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BURN,
      CAPTRD,
      CONS,
      DSTRYK,
      FKIL,
      FLIG,
      IDNT,
      ILLUMN,
      INTREC,
      KILL,
      LDAM,
      LGTRST,
      LOST,
      MKIL,
      MODDAM,
      NBCAS,
      NKN,
      NORSTN,
      NOS,
      NUTRLD,
      SDAM,
      SUPRSD,
      VLNRST,
      VRBPRT,
      WNDD
    };

    ActionEffectDescriptionCode (value v);

    ActionEffectDescriptionCode (const char* v);

    ActionEffectDescriptionCode (const ::std::string& v);

    ActionEffectDescriptionCode (const ::xml_schema::token& v);

    ActionEffectDescriptionCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ActionEffectDescriptionCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ActionEffectDescriptionCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ActionEffectDescriptionCode (const ActionEffectDescriptionCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual ActionEffectDescriptionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionEffectDescriptionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionEffectDescriptionCode_convert ();
    }

    protected:
    value
    _xsd_ActionEffectDescriptionCode_convert () const;

    public:
    static const char* const _xsd_ActionEffectDescriptionCode_literals_[25];
    static const value _xsd_ActionEffectDescriptionCode_indexes_[25];
  };

  class ActionEffectSeverityCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MINDSR,
      NKN,
      NODSRP,
      SEVDSR,
      TOTDSR
    };

    ActionEffectSeverityCode (value v);

    ActionEffectSeverityCode (const char* v);

    ActionEffectSeverityCode (const ::std::string& v);

    ActionEffectSeverityCode (const ::xml_schema::token& v);

    ActionEffectSeverityCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ActionEffectSeverityCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ActionEffectSeverityCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ActionEffectSeverityCode (const ActionEffectSeverityCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual ActionEffectSeverityCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionEffectSeverityCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionEffectSeverityCode_convert ();
    }

    protected:
    value
    _xsd_ActionEffectSeverityCode_convert () const;

    public:
    static const char* const _xsd_ActionEffectSeverityCode_literals_[5];
    static const value _xsd_ActionEffectSeverityCode_indexes_[5];
  };

  class ActionElectronicWarfareEmploymentCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ACOUST,
      CHAFBL,
      CHAFBU,
      CHAFCO,
      CHAFSE,
      CONCEL,
      CONTRL,
      CRYPTO,
      DCFLAC,
      DCFLPK,
      DCFLTA,
      DCFLTR,
      DCMLFL,
      ELECCO,
      EWSELF,
      INVGNM,
      JAMBAR,
      JAMCOM,
      JAMDEC,
      JAMREP,
      JAMSPT,
      JAMSWL,
      JAMSWP,
      JAMTRS,
      NUISNC,
      PADDNG,
      PILL,
      PLNMSG,
      RANGGT,
      RFLCCR,
      RLLCGL,
      ROUTNG,
      SCANRT,
      SIMAMP,
      SIMFRC,
      SIMRIV,
      SIMTAC,
      SIMUNT
    };

    ActionElectronicWarfareEmploymentCategoryCode (value v);

    ActionElectronicWarfareEmploymentCategoryCode (const char* v);

    ActionElectronicWarfareEmploymentCategoryCode (const ::std::string& v);

    ActionElectronicWarfareEmploymentCategoryCode (const ::xml_schema::token& v);

    ActionElectronicWarfareEmploymentCategoryCode (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    ActionElectronicWarfareEmploymentCategoryCode (const ::xercesc::DOMAttr& a,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    ActionElectronicWarfareEmploymentCategoryCode (const ::std::string& s,
                                                   const ::xercesc::DOMElement* e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    ActionElectronicWarfareEmploymentCategoryCode (const ActionElectronicWarfareEmploymentCategoryCode& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    virtual ActionElectronicWarfareEmploymentCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionElectronicWarfareEmploymentCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionElectronicWarfareEmploymentCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionElectronicWarfareEmploymentCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionElectronicWarfareEmploymentCategoryCode_literals_[38];
    static const value _xsd_ActionElectronicWarfareEmploymentCategoryCode_indexes_[38];
  };

  class ActionEventCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ABDICA,
      ACCAIR,
      ACCDNT,
      ACCMNE,
      ACCTRF,
      ACCWPN,
      ACCWRK,
      ACRLOS,
      ADVANC,
      AERENG,
      AERSHO,
      AIRCRS,
      AIRLAU,
      AIRLND,
      AIRVIO,
      ALRCAN,
      AMBUSH,
      AMPH,
      ARASLT,
      ARBNAS,
      ARMPRD,
      ARMTRD,
      ARRLGL,
      ARROBS,
      ARSON,
      ARTFIR,
      ASSMBL,
      ASSNTN,
      ASTCRM,
      ATMPOL,
      ATMRDR,
      ATRAPE,
      ATRBRY,
      ATSCDE,
      ATTACK,
      ATTDVR,
      ATTEL,
      ATTMN,
      ATTSPT,
      AVOIDN,
      BBYTRD,
      BCESC,
      BCFRCD,
      BCILGL,
      BCNTPL,
      BCPLND,
      BCSRVL,
      BLDUP,
      BLOCKN,
      BLYLND,
      BMBACC,
      BMBDLB,
      BOMBNG,
      BORINC,
      BORRAI,
      BREACH,
      BRNOBJ,
      BYPASS,
      CANLSE,
      CAPTUR,
      CARLNC,
      CARREC,
      CBRN,
      CDWDEX,
      CEREMN,
      CIVDIS,
      CIVDMI,
      CIVDML,
      CIVUNR,
      CIVWAR,
      CLRAIR,
      CLRLND,
      CLROBS,
      CLRRAD,
      CNDCNF,
      CNDMED,
      CNDRCR,
      CNDSCL,
      CNDSPT,
      CNFSTN,
      CNFWPS,
      CNPRFR,
      CNRDSV,
      CNRWPS,
      CNSLDT,
      COLMID,
      COLOBS,
      COMACT,
      COMDEA,
      COMDIS,
      COMINT,
      COMOUT,
      COMRES,
      CONSTN,
      CONTAN,
      COOPER,
      COUPDE,
      COVERN,
      CRIMIN,
      CRMHMN,
      CROSSN,
      CTRATK,
      CTRBYF,
      CTRFIR,
      DAZZLE,
      DCPTEL,
      DCPTIN,
      DEACST,
      DEASPL,
      DEFEAT,
      DEFEND,
      DEFLCT,
      DELAYN,
      DEMO,
      DENYNG,
      DEPLOY,
      DEPORT,
      DISEAS,
      DISENG,
      DIVRSN,
      DLBATK,
      DMNSTR,
      DRGCNS,
      DRGDST,
      DRGMNF,
      DRGOPR,
      DRGSTR,
      DRGTRN,
      DROUGH,
      DRVSHT,
      DSRPTN,
      DSTRBT,
      DSTRYN,
      DTHNAT,
      EARTHQ,
      EARWAR,
      ELCEMS,
      ELCVIO,
      ELCWAR,
      ENGAGE,
      ENMCON,
      ENVLPN,
      EPEDEM,
      EQPFAI,
      ESCPNG,
      ESCRTN,
      EVACTN,
      EXECTN,
      EXPLOS,
      EXPLTN,
      FAMINE,
      FIRE,
      FIX,
      FIXACO,
      FIXELM,
      FIXELO,
      FLOOD,
      FOLASS,
      FOLSPT,
      FRCLND,
      FRFGTN,
      FRNDFR,
      GENCHS,
      GENOCD,
      GOVCOL,
      GUARDN,
      GUNATA,
      HARASS,
      HASTY,
      HIDING,
      HIJACK,
      HJCKBT,
      HJCKLV,
      HJCKPL,
      HLDDEF,
      HLDOFF,
      HOLIDY,
      HRVIOL,
      HSTTKN,
      HUNTNG,
      IDENT,
      ILLUMN,
      INDESP,
      INDFIR,
      INDSHO,
      INFLTN,
      INTCPN,
      INTDCT,
      INTMDN,
      INVASI,
      ISOLTN,
      ISSMDA,
      ISSMDD,
      ISSPRS,
      JAMMNG,
      KIDNAP,
      LABSTR,
      LEAGR,
      LOCELC,
      LOCTNG,
      LOOTNG,
      LTRBME,
      LTRBMI,
      MAINTN,
      MARKNG,
      MARLAW,
      MASFOR,
      MEDEVC,
      MILMOB,
      MINLAY,
      MISSIG,
      MISSTG,
      MOVING,
      MRTFIR,
      MURDER,
      MUTASS,
      NATDIS,
      NATELC,
      NATEMG,
      NAVGUN,
      NAVPLF,
      NETSEI,
      NOS,
      NTRCHM,
      NTRCOM,
      NTREXP,
      OBSCUR,
      OBSRNG,
      OCCPNG,
      OFFCOF,
      ORGCRM,
      PCKTNG,
      PEAAGR,
      PEACON,
      PENTRT,
      PETSPL,
      POISON,
      POLDEM,
      POLEXE,
      POWEXC,
      POWRET,
      PROCUR,
      PROTEL,
      PRVACC,
      PRVAGR,
      PRVBDD,
      PRVCMP,
      PRVCNS,
      PRVDCN,
      PRVEDU,
      PRVHLT,
      PRVHSN,
      PRVINF,
      PRVLND,
      PRVRPR,
      PRVSCY,
      PRVSHL,
      PRVSTG,
      PRVTRS,
      PRXBMB,
      PSTLNC,
      PSYOP,
      PTRLNG,
      PUBMDA,
      PUBMDD,
      PUBPRS,
      PURSNG,
      RACIAL,
      RAPE,
      RECCE,
      RECCEF,
      RECNSN,
      RECPRN,
      RECVRN,
      REDPLN,
      REFMVM,
      REINFN,
      RELDEM,
      RELVIO,
      RELWAR,
      REORGN,
      REPAIR,
      RESPLN,
      RESTNG,
      RETAIN,
      RETIRE,
      REVOLU,
      RIOT,
      RKTFIR,
      RLFPLC,
      RNDZVS,
      ROBERY,
      SABOTG,
      SCRNNG,
      SECCMP,
      SECCOU,
      SECRNG,
      SECVIO,
      SEIZNG,
      SHOTNG,
      SINKIN,
      SNPATK,
      SPACAC,
      SPYING,
      SRVADV,
      SRVBRD,
      SRVBRK,
      SRVFLK,
      SRVINP,
      SRVMNB,
      SRVRGD,
      SRVRSF,
      STAWAR,
      STNGUP,
      STRFAR,
      STRIKE,
      SUICDE,
      SUPRSN,
      SUPRTN,
      SURREN,
      SURVEL,
      SUSHOS,
      TERR,
      THREAT,
      TORTUR,
      TRBAGT,
      TRBBLL,
      TRBHAR,
      TRBHLG,
      TRBINC,
      TRBINT,
      TREVIO,
      TRNSPN,
      TRVRSN,
      TURNNG,
      UXODSC,
      VANDAL,
      VERFYN,
      VOLCAN,
      WARALE,
      WARCON,
      WARCRM,
      WATPOL,
      WDRPRS,
      WITDRL,
      WITNSN,
      WPNFIR
    };

    ActionEventCategoryCode (value v);

    ActionEventCategoryCode (const char* v);

    ActionEventCategoryCode (const ::std::string& v);

    ActionEventCategoryCode (const ::xml_schema::token& v);

    ActionEventCategoryCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    ActionEventCategoryCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    ActionEventCategoryCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    ActionEventCategoryCode (const ActionEventCategoryCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual ActionEventCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionEventCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionEventCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionEventCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionEventCategoryCode_literals_[347];
    static const value _xsd_ActionEventCategoryCode_indexes_[347];
  };

  class ActionEventDetailClassificationCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DISAST,
      ECONMC,
      ENVIRN,
      ETHNIC,
      HSTRCL,
      LABOUR,
      MILTRY,
      POLTCL,
      RELIGS,
      SOCIAL
    };

    ActionEventDetailClassificationCode (value v);

    ActionEventDetailClassificationCode (const char* v);

    ActionEventDetailClassificationCode (const ::std::string& v);

    ActionEventDetailClassificationCode (const ::xml_schema::token& v);

    ActionEventDetailClassificationCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ActionEventDetailClassificationCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ActionEventDetailClassificationCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ActionEventDetailClassificationCode (const ActionEventDetailClassificationCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual ActionEventDetailClassificationCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionEventDetailClassificationCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionEventDetailClassificationCode_convert ();
    }

    protected:
    value
    _xsd_ActionEventDetailClassificationCode_convert () const;

    public:
    static const char* const _xsd_ActionEventDetailClassificationCode_literals_[10];
    static const value _xsd_ActionEventDetailClassificationCode_indexes_[10];
  };

  class ActionEventDetailCrimeIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    ActionEventDetailCrimeIndicatorCode (value v);

    ActionEventDetailCrimeIndicatorCode (const char* v);

    ActionEventDetailCrimeIndicatorCode (const ::std::string& v);

    ActionEventDetailCrimeIndicatorCode (const ::xml_schema::token& v);

    ActionEventDetailCrimeIndicatorCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ActionEventDetailCrimeIndicatorCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ActionEventDetailCrimeIndicatorCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ActionEventDetailCrimeIndicatorCode (const ActionEventDetailCrimeIndicatorCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual ActionEventDetailCrimeIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionEventDetailCrimeIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionEventDetailCrimeIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_ActionEventDetailCrimeIndicatorCode_convert () const;

    public:
    static const char* const _xsd_ActionEventDetailCrimeIndicatorCode_literals_[2];
    static const value _xsd_ActionEventDetailCrimeIndicatorCode_indexes_[2];
  };

  class ActionFunctionalAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ALT,
      HASPRV,
      HASSEC,
      HSA,
      IMO,
      INRSTO,
      IOT,
      ISAPRQ,
      ISCAUS,
      TPL,
      UAR
    };

    ActionFunctionalAssociationCategoryCode (value v);

    ActionFunctionalAssociationCategoryCode (const char* v);

    ActionFunctionalAssociationCategoryCode (const ::std::string& v);

    ActionFunctionalAssociationCategoryCode (const ::xml_schema::token& v);

    ActionFunctionalAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    ActionFunctionalAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    ActionFunctionalAssociationCategoryCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    ActionFunctionalAssociationCategoryCode (const ActionFunctionalAssociationCategoryCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual ActionFunctionalAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionFunctionalAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionFunctionalAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionFunctionalAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionFunctionalAssociationCategoryCode_literals_[11];
    static const value _xsd_ActionFunctionalAssociationCategoryCode_indexes_[11];
  };

  class ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CASP1,
      CASP2,
      CASP3,
      CASP4
    };

    ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode (value v);

    ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode (const char* v);

    ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode (const ::std::string& v);

    ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode (const ::xml_schema::token& v);

    ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

    ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode (const ::xercesc::DOMAttr& a,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

    ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode (const ::std::string& s,
                                                            const ::xercesc::DOMElement* e,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

    ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode (const ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode& x,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

    virtual ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode_convert ();
    }

    protected:
    value
    _xsd_ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode_convert () const;

    public:
    static const char* const _xsd_ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode_literals_[4];
    static const value _xsd_ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode_indexes_[4];
  };

  class ActionMaritimeEmploymentVesselTransitInstructionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      INFORM,
      LEAD,
      STOP
    };

    ActionMaritimeEmploymentVesselTransitInstructionCode (value v);

    ActionMaritimeEmploymentVesselTransitInstructionCode (const char* v);

    ActionMaritimeEmploymentVesselTransitInstructionCode (const ::std::string& v);

    ActionMaritimeEmploymentVesselTransitInstructionCode (const ::xml_schema::token& v);

    ActionMaritimeEmploymentVesselTransitInstructionCode (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    ActionMaritimeEmploymentVesselTransitInstructionCode (const ::xercesc::DOMAttr& a,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    ActionMaritimeEmploymentVesselTransitInstructionCode (const ::std::string& s,
                                                          const ::xercesc::DOMElement* e,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    ActionMaritimeEmploymentVesselTransitInstructionCode (const ActionMaritimeEmploymentVesselTransitInstructionCode& x,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    virtual ActionMaritimeEmploymentVesselTransitInstructionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionMaritimeEmploymentVesselTransitInstructionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionMaritimeEmploymentVesselTransitInstructionCode_convert ();
    }

    protected:
    value
    _xsd_ActionMaritimeEmploymentVesselTransitInstructionCode_convert () const;

    public:
    static const char* const _xsd_ActionMaritimeEmploymentVesselTransitInstructionCode_literals_[3];
    static const value _xsd_ActionMaritimeEmploymentVesselTransitInstructionCode_indexes_[3];
  };

  class ActionObjectiveCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      OI,
      OT,
      OTASK
    };

    ActionObjectiveCategoryCode (value v);

    ActionObjectiveCategoryCode (const char* v);

    ActionObjectiveCategoryCode (const ::std::string& v);

    ActionObjectiveCategoryCode (const ::xml_schema::token& v);

    ActionObjectiveCategoryCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ActionObjectiveCategoryCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ActionObjectiveCategoryCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ActionObjectiveCategoryCode (const ActionObjectiveCategoryCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual ActionObjectiveCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionObjectiveCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionObjectiveCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionObjectiveCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionObjectiveCategoryCode_literals_[3];
    static const value _xsd_ActionObjectiveCategoryCode_indexes_[3];
  };

  class ActionObjectiveItemCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NOS,
      TARGET
    };

    ActionObjectiveItemCategoryCode (value v);

    ActionObjectiveItemCategoryCode (const char* v);

    ActionObjectiveItemCategoryCode (const ::std::string& v);

    ActionObjectiveItemCategoryCode (const ::xml_schema::token& v);

    ActionObjectiveItemCategoryCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ActionObjectiveItemCategoryCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ActionObjectiveItemCategoryCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ActionObjectiveItemCategoryCode (const ActionObjectiveItemCategoryCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual ActionObjectiveItemCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionObjectiveItemCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionObjectiveItemCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionObjectiveItemCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionObjectiveItemCategoryCode_literals_[2];
    static const value _xsd_ActionObjectiveItemCategoryCode_indexes_[2];
  };

  class ActionObjectiveItemMarkingMethodCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FLR,
      ILLUMN,
      LAS,
      LIGHT,
      MPL,
      NKN,
      NOS,
      RBE,
      SMOKE,
      STRBBN,
      STRBLT,
      STRCLS,
      TORCH,
      VHCLLT
    };

    ActionObjectiveItemMarkingMethodCode (value v);

    ActionObjectiveItemMarkingMethodCode (const char* v);

    ActionObjectiveItemMarkingMethodCode (const ::std::string& v);

    ActionObjectiveItemMarkingMethodCode (const ::xml_schema::token& v);

    ActionObjectiveItemMarkingMethodCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ActionObjectiveItemMarkingMethodCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ActionObjectiveItemMarkingMethodCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ActionObjectiveItemMarkingMethodCode (const ActionObjectiveItemMarkingMethodCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual ActionObjectiveItemMarkingMethodCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionObjectiveItemMarkingMethodCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionObjectiveItemMarkingMethodCode_convert ();
    }

    protected:
    value
    _xsd_ActionObjectiveItemMarkingMethodCode_convert () const;

    public:
    static const char* const _xsd_ActionObjectiveItemMarkingMethodCode_literals_[14];
    static const value _xsd_ActionObjectiveItemMarkingMethodCode_indexes_[14];
  };

  class ActionObjectiveItemMarkingPanelShapeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HSHAPE,
      ISHAPE,
      NKN,
      NOS,
      TSHAPE,
      XSHAPE
    };

    ActionObjectiveItemMarkingPanelShapeCode (value v);

    ActionObjectiveItemMarkingPanelShapeCode (const char* v);

    ActionObjectiveItemMarkingPanelShapeCode (const ::std::string& v);

    ActionObjectiveItemMarkingPanelShapeCode (const ::xml_schema::token& v);

    ActionObjectiveItemMarkingPanelShapeCode (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ActionObjectiveItemMarkingPanelShapeCode (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ActionObjectiveItemMarkingPanelShapeCode (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ActionObjectiveItemMarkingPanelShapeCode (const ActionObjectiveItemMarkingPanelShapeCode& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual ActionObjectiveItemMarkingPanelShapeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionObjectiveItemMarkingPanelShapeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionObjectiveItemMarkingPanelShapeCode_convert ();
    }

    protected:
    value
    _xsd_ActionObjectiveItemMarkingPanelShapeCode_convert () const;

    public:
    static const char* const _xsd_ActionObjectiveItemMarkingPanelShapeCode_literals_[6];
    static const value _xsd_ActionObjectiveItemMarkingPanelShapeCode_indexes_[6];
  };

  class ActionObjectiveItemMarkingRecognitionSignalColourCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BLUE,
      GREEN,
      NKN,
      NOS,
      ORANGE,
      PURPLE,
      RED,
      WHITE,
      YELLOW
    };

    ActionObjectiveItemMarkingRecognitionSignalColourCode (value v);

    ActionObjectiveItemMarkingRecognitionSignalColourCode (const char* v);

    ActionObjectiveItemMarkingRecognitionSignalColourCode (const ::std::string& v);

    ActionObjectiveItemMarkingRecognitionSignalColourCode (const ::xml_schema::token& v);

    ActionObjectiveItemMarkingRecognitionSignalColourCode (const ::xercesc::DOMElement& e,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

    ActionObjectiveItemMarkingRecognitionSignalColourCode (const ::xercesc::DOMAttr& a,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

    ActionObjectiveItemMarkingRecognitionSignalColourCode (const ::std::string& s,
                                                           const ::xercesc::DOMElement* e,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

    ActionObjectiveItemMarkingRecognitionSignalColourCode (const ActionObjectiveItemMarkingRecognitionSignalColourCode& x,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

    virtual ActionObjectiveItemMarkingRecognitionSignalColourCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionObjectiveItemMarkingRecognitionSignalColourCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionObjectiveItemMarkingRecognitionSignalColourCode_convert ();
    }

    protected:
    value
    _xsd_ActionObjectiveItemMarkingRecognitionSignalColourCode_convert () const;

    public:
    static const char* const _xsd_ActionObjectiveItemMarkingRecognitionSignalColourCode_literals_[9];
    static const value _xsd_ActionObjectiveItemMarkingRecognitionSignalColourCode_indexes_[9];
  };

  class ActionObjectiveItemPrimacyCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ALTERN,
      PRIME,
      SECOND
    };

    ActionObjectiveItemPrimacyCode (value v);

    ActionObjectiveItemPrimacyCode (const char* v);

    ActionObjectiveItemPrimacyCode (const ::std::string& v);

    ActionObjectiveItemPrimacyCode (const ::xml_schema::token& v);

    ActionObjectiveItemPrimacyCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ActionObjectiveItemPrimacyCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ActionObjectiveItemPrimacyCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ActionObjectiveItemPrimacyCode (const ActionObjectiveItemPrimacyCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual ActionObjectiveItemPrimacyCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionObjectiveItemPrimacyCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionObjectiveItemPrimacyCode_convert ();
    }

    protected:
    value
    _xsd_ActionObjectiveItemPrimacyCode_convert () const;

    public:
    static const char* const _xsd_ActionObjectiveItemPrimacyCode_literals_[3];
    static const value _xsd_ActionObjectiveItemPrimacyCode_indexes_[3];
  };

  class ActionObjectiveQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AUTH,
      DONTAT,
      NEEL,
      NENL,
      NESL,
      NEWL,
      NOTA,
      STAYAB,
      STAYBL,
      STAYIN,
      STAYOT
    };

    ActionObjectiveQualifierCode (value v);

    ActionObjectiveQualifierCode (const char* v);

    ActionObjectiveQualifierCode (const ::std::string& v);

    ActionObjectiveQualifierCode (const ::xml_schema::token& v);

    ActionObjectiveQualifierCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ActionObjectiveQualifierCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ActionObjectiveQualifierCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ActionObjectiveQualifierCode (const ActionObjectiveQualifierCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual ActionObjectiveQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionObjectiveQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionObjectiveQualifierCode_convert ();
    }

    protected:
    value
    _xsd_ActionObjectiveQualifierCode_convert () const;

    public:
    static const char* const _xsd_ActionObjectiveQualifierCode_literals_[11];
    static const value _xsd_ActionObjectiveQualifierCode_indexes_[11];
  };

  class ActionObjectiveTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AOTIMG,
      NOS
    };

    ActionObjectiveTypeCategoryCode (value v);

    ActionObjectiveTypeCategoryCode (const char* v);

    ActionObjectiveTypeCategoryCode (const ::std::string& v);

    ActionObjectiveTypeCategoryCode (const ::xml_schema::token& v);

    ActionObjectiveTypeCategoryCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ActionObjectiveTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ActionObjectiveTypeCategoryCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ActionObjectiveTypeCategoryCode (const ActionObjectiveTypeCategoryCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual ActionObjectiveTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionObjectiveTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionObjectiveTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionObjectiveTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionObjectiveTypeCategoryCode_literals_[2];
    static const value _xsd_ActionObjectiveTypeCategoryCode_indexes_[2];
  };

  class ActionObjectiveTypeImageryProductImageTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_10PRNT,
      cxx_12PRNT,
      cxx_8PRNT,
      ANPRNT,
      CDROM,
      CNPRNT,
      DUPFLE,
      DUPNEG,
      DUPPOS,
      DUPTAP,
      DVD,
      MAXENL,
      MOSAIC,
      PLNGRP,
      SONNE,
      TGTGRP
    };

    ActionObjectiveTypeImageryProductImageTypeCode (value v);

    ActionObjectiveTypeImageryProductImageTypeCode (const char* v);

    ActionObjectiveTypeImageryProductImageTypeCode (const ::std::string& v);

    ActionObjectiveTypeImageryProductImageTypeCode (const ::xml_schema::token& v);

    ActionObjectiveTypeImageryProductImageTypeCode (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    ActionObjectiveTypeImageryProductImageTypeCode (const ::xercesc::DOMAttr& a,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    ActionObjectiveTypeImageryProductImageTypeCode (const ::std::string& s,
                                                    const ::xercesc::DOMElement* e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    ActionObjectiveTypeImageryProductImageTypeCode (const ActionObjectiveTypeImageryProductImageTypeCode& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    virtual ActionObjectiveTypeImageryProductImageTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionObjectiveTypeImageryProductImageTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionObjectiveTypeImageryProductImageTypeCode_convert ();
    }

    protected:
    value
    _xsd_ActionObjectiveTypeImageryProductImageTypeCode_convert () const;

    public:
    static const char* const _xsd_ActionObjectiveTypeImageryProductImageTypeCode_literals_[16];
    static const value _xsd_ActionObjectiveTypeImageryProductImageTypeCode_indexes_[16];
  };

  class ActionReconnaissanceEmploymentImageCoverageModeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MONOCC,
      MONOPC,
      PSMCC,
      PSMPC,
      STMCC,
      STMPC
    };

    ActionReconnaissanceEmploymentImageCoverageModeCode (value v);

    ActionReconnaissanceEmploymentImageCoverageModeCode (const char* v);

    ActionReconnaissanceEmploymentImageCoverageModeCode (const ::std::string& v);

    ActionReconnaissanceEmploymentImageCoverageModeCode (const ::xml_schema::token& v);

    ActionReconnaissanceEmploymentImageCoverageModeCode (const ::xercesc::DOMElement& e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    ActionReconnaissanceEmploymentImageCoverageModeCode (const ::xercesc::DOMAttr& a,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    ActionReconnaissanceEmploymentImageCoverageModeCode (const ::std::string& s,
                                                         const ::xercesc::DOMElement* e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    ActionReconnaissanceEmploymentImageCoverageModeCode (const ActionReconnaissanceEmploymentImageCoverageModeCode& x,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    virtual ActionReconnaissanceEmploymentImageCoverageModeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionReconnaissanceEmploymentImageCoverageModeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionReconnaissanceEmploymentImageCoverageModeCode_convert ();
    }

    protected:
    value
    _xsd_ActionReconnaissanceEmploymentImageCoverageModeCode_convert () const;

    public:
    static const char* const _xsd_ActionReconnaissanceEmploymentImageCoverageModeCode_literals_[6];
    static const value _xsd_ActionReconnaissanceEmploymentImageCoverageModeCode_indexes_[6];
  };

  class ActionReconnaissanceEmploymentImageViewQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DBEOIR,
      DBMIEO,
      ELCOPT,
      MIDINF,
      NSELEN,
      THRINF,
      VIDSFT
    };

    ActionReconnaissanceEmploymentImageViewQualifierCode (value v);

    ActionReconnaissanceEmploymentImageViewQualifierCode (const char* v);

    ActionReconnaissanceEmploymentImageViewQualifierCode (const ::std::string& v);

    ActionReconnaissanceEmploymentImageViewQualifierCode (const ::xml_schema::token& v);

    ActionReconnaissanceEmploymentImageViewQualifierCode (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    ActionReconnaissanceEmploymentImageViewQualifierCode (const ::xercesc::DOMAttr& a,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    ActionReconnaissanceEmploymentImageViewQualifierCode (const ::std::string& s,
                                                          const ::xercesc::DOMElement* e,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    ActionReconnaissanceEmploymentImageViewQualifierCode (const ActionReconnaissanceEmploymentImageViewQualifierCode& x,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    virtual ActionReconnaissanceEmploymentImageViewQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionReconnaissanceEmploymentImageViewQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionReconnaissanceEmploymentImageViewQualifierCode_convert ();
    }

    protected:
    value
    _xsd_ActionReconnaissanceEmploymentImageViewQualifierCode_convert () const;

    public:
    static const char* const _xsd_ActionReconnaissanceEmploymentImageViewQualifierCode_literals_[7];
    static const value _xsd_ActionReconnaissanceEmploymentImageViewQualifierCode_indexes_[7];
  };

  class ActionReconnaissanceEmploymentTypeOfCoverageCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AFLOA,
      AFLOAO,
      AFLOAV,
      AREAC,
      AREACO,
      AREACV,
      AREAS,
      AREASO,
      AREASV,
      BP,
      BPO,
      BPV,
      LINESE,
      PINPT,
      PINPTO,
      PINPTV,
      ROUTE,
      ROUTEO,
      ROUTEV,
      SPECS,
      SPECSO,
      SPECSV,
      STRIP,
      STRIPO,
      STRIPV
    };

    ActionReconnaissanceEmploymentTypeOfCoverageCode (value v);

    ActionReconnaissanceEmploymentTypeOfCoverageCode (const char* v);

    ActionReconnaissanceEmploymentTypeOfCoverageCode (const ::std::string& v);

    ActionReconnaissanceEmploymentTypeOfCoverageCode (const ::xml_schema::token& v);

    ActionReconnaissanceEmploymentTypeOfCoverageCode (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    ActionReconnaissanceEmploymentTypeOfCoverageCode (const ::xercesc::DOMAttr& a,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    ActionReconnaissanceEmploymentTypeOfCoverageCode (const ::std::string& s,
                                                      const ::xercesc::DOMElement* e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    ActionReconnaissanceEmploymentTypeOfCoverageCode (const ActionReconnaissanceEmploymentTypeOfCoverageCode& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    virtual ActionReconnaissanceEmploymentTypeOfCoverageCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionReconnaissanceEmploymentTypeOfCoverageCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionReconnaissanceEmploymentTypeOfCoverageCode_convert ();
    }

    protected:
    value
    _xsd_ActionReconnaissanceEmploymentTypeOfCoverageCode_convert () const;

    public:
    static const char* const _xsd_ActionReconnaissanceEmploymentTypeOfCoverageCode_literals_[25];
    static const value _xsd_ActionReconnaissanceEmploymentTypeOfCoverageCode_indexes_[25];
  };

  class ActionReferenceAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ISAMPL,
      ISCHNG,
      ISCNCL,
      ISDFND,
      ISDRCT,
      ISDSCR,
      ISPRBK,
      ISRFRN,
      ISRPTD
    };

    ActionReferenceAssociationCategoryCode (value v);

    ActionReferenceAssociationCategoryCode (const char* v);

    ActionReferenceAssociationCategoryCode (const ::std::string& v);

    ActionReferenceAssociationCategoryCode (const ::xml_schema::token& v);

    ActionReferenceAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    ActionReferenceAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    ActionReferenceAssociationCategoryCode (const ::std::string& s,
                                            const ::xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    ActionReferenceAssociationCategoryCode (const ActionReferenceAssociationCategoryCode& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual ActionReferenceAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionReferenceAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionReferenceAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionReferenceAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionReferenceAssociationCategoryCode_literals_[9];
    static const value _xsd_ActionReferenceAssociationCategoryCode_indexes_[9];
  };

  class ActionResourceCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      RI,
      RT
    };

    ActionResourceCategoryCode (value v);

    ActionResourceCategoryCode (const char* v);

    ActionResourceCategoryCode (const ::std::string& v);

    ActionResourceCategoryCode (const ::xml_schema::token& v);

    ActionResourceCategoryCode (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    ActionResourceCategoryCode (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    ActionResourceCategoryCode (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    ActionResourceCategoryCode (const ActionResourceCategoryCode& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual ActionResourceCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionResourceCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionResourceCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionResourceCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionResourceCategoryCode_literals_[2];
    static const value _xsd_ActionResourceCategoryCode_indexes_[2];
  };

  class ActionResourceCriticalityIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    ActionResourceCriticalityIndicatorCode (value v);

    ActionResourceCriticalityIndicatorCode (const char* v);

    ActionResourceCriticalityIndicatorCode (const ::std::string& v);

    ActionResourceCriticalityIndicatorCode (const ::xml_schema::token& v);

    ActionResourceCriticalityIndicatorCode (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    ActionResourceCriticalityIndicatorCode (const ::xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    ActionResourceCriticalityIndicatorCode (const ::std::string& s,
                                            const ::xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    ActionResourceCriticalityIndicatorCode (const ActionResourceCriticalityIndicatorCode& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual ActionResourceCriticalityIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionResourceCriticalityIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionResourceCriticalityIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_ActionResourceCriticalityIndicatorCode_convert () const;

    public:
    static const char* const _xsd_ActionResourceCriticalityIndicatorCode_literals_[2];
    static const value _xsd_ActionResourceCriticalityIndicatorCode_indexes_[2];
  };

  class ActionResourceEmploymentCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIREMP,
      ELCEMP,
      MAREMP,
      NOS,
      RECEMP
    };

    ActionResourceEmploymentCategoryCode (value v);

    ActionResourceEmploymentCategoryCode (const char* v);

    ActionResourceEmploymentCategoryCode (const ::std::string& v);

    ActionResourceEmploymentCategoryCode (const ::xml_schema::token& v);

    ActionResourceEmploymentCategoryCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ActionResourceEmploymentCategoryCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ActionResourceEmploymentCategoryCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ActionResourceEmploymentCategoryCode (const ActionResourceEmploymentCategoryCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual ActionResourceEmploymentCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionResourceEmploymentCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionResourceEmploymentCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionResourceEmploymentCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionResourceEmploymentCategoryCode_literals_[5];
    static const value _xsd_ActionResourceEmploymentCategoryCode_indexes_[5];
  };

  class ActionResourceEmploymentMethodOfControlCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ASORD,
      ONORD
    };

    ActionResourceEmploymentMethodOfControlCode (value v);

    ActionResourceEmploymentMethodOfControlCode (const char* v);

    ActionResourceEmploymentMethodOfControlCode (const ::std::string& v);

    ActionResourceEmploymentMethodOfControlCode (const ::xml_schema::token& v);

    ActionResourceEmploymentMethodOfControlCode (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ActionResourceEmploymentMethodOfControlCode (const ::xercesc::DOMAttr& a,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ActionResourceEmploymentMethodOfControlCode (const ::std::string& s,
                                                 const ::xercesc::DOMElement* e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ActionResourceEmploymentMethodOfControlCode (const ActionResourceEmploymentMethodOfControlCode& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual ActionResourceEmploymentMethodOfControlCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionResourceEmploymentMethodOfControlCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionResourceEmploymentMethodOfControlCode_convert ();
    }

    protected:
    value
    _xsd_ActionResourceEmploymentMethodOfControlCode_convert () const;

    public:
    static const char* const _xsd_ActionResourceEmploymentMethodOfControlCode_literals_[2];
    static const value _xsd_ActionResourceEmploymentMethodOfControlCode_indexes_[2];
  };

  class ActionResourceEmploymentTrajectoryFireCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HIGH,
      LOW
    };

    ActionResourceEmploymentTrajectoryFireCode (value v);

    ActionResourceEmploymentTrajectoryFireCode (const char* v);

    ActionResourceEmploymentTrajectoryFireCode (const ::std::string& v);

    ActionResourceEmploymentTrajectoryFireCode (const ::xml_schema::token& v);

    ActionResourceEmploymentTrajectoryFireCode (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ActionResourceEmploymentTrajectoryFireCode (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ActionResourceEmploymentTrajectoryFireCode (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ActionResourceEmploymentTrajectoryFireCode (const ActionResourceEmploymentTrajectoryFireCode& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual ActionResourceEmploymentTrajectoryFireCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionResourceEmploymentTrajectoryFireCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionResourceEmploymentTrajectoryFireCode_convert ();
    }

    protected:
    value
    _xsd_ActionResourceEmploymentTrajectoryFireCode_convert () const;

    public:
    static const char* const _xsd_ActionResourceEmploymentTrajectoryFireCode_literals_[2];
    static const value _xsd_ActionResourceEmploymentTrajectoryFireCode_indexes_[2];
  };

  class ActionResourceQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AUTH,
      MAXU,
      MINU,
      NEEL,
      NENL,
      NESL,
      NEWL,
      NOTA,
      STAYAB,
      STAYBL,
      STAYIN,
      STAYOT
    };

    ActionResourceQualifierCode (value v);

    ActionResourceQualifierCode (const char* v);

    ActionResourceQualifierCode (const ::std::string& v);

    ActionResourceQualifierCode (const ::xml_schema::token& v);

    ActionResourceQualifierCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ActionResourceQualifierCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ActionResourceQualifierCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ActionResourceQualifierCode (const ActionResourceQualifierCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual ActionResourceQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionResourceQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionResourceQualifierCode_convert ();
    }

    protected:
    value
    _xsd_ActionResourceQualifierCode_convert () const;

    public:
    static const char* const _xsd_ActionResourceQualifierCode_literals_[12];
    static const value _xsd_ActionResourceQualifierCode_indexes_[12];
  };

  class ActionTaskActivityCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ACQUIR,
      ADVANC,
      AEREVA,
      AERRFL,
      AEW,
      AEWCON,
      AIRDEF,
      AIRLND,
      AIRSUP,
      AIRSWP,
      AMBUSH,
      AMPH,
      AMPHWF,
      ANALYS,
      ANARWF,
      ANSBWF,
      ANSFWF,
      ANTARM,
      ARASLT,
      ARBNAS,
      ARCCTL,
      ARDREQ,
      ARDROP,
      ARINTR,
      ARLFSA,
      ARLFTR,
      ARMAS,
      ARRLGL,
      ARROBS,
      ARTCTL,
      ASSMBL,
      ATTACK,
      ATTDVR,
      ATTEL,
      ATTMN,
      ATTRIT,
      ATTSPT,
      AVOID,
      AWACS,
      BIOSMP,
      BLDUP,
      BLOCK,
      BRAKUP,
      BREACH,
      BYPASS,
      CADVGD,
      CANDC,
      CANLSE,
      CAPBAR,
      CAPNGR,
      CAPPRT,
      CAPRES,
      CAPSRF,
      CAPTUR,
      CARLNC,
      CARREC,
      CBRHDF,
      CBRKOF,
      CDWDAC,
      CFLKGD,
      CHAFF,
      CHMSMP,
      CINPLF,
      CLARSP,
      CLOSE,
      CLRAIR,
      CLRLND,
      CLROBS,
      CLRRAD,
      CMAINB,
      CNFPSL,
      CNFSTE,
      CNRPSL,
      CNRSVC,
      CNSLDT,
      COARPL,
      COMC3I,
      COMINC,
      COMREL,
      CONSTR,
      CONTAN,
      COOPER,
      COURER,
      COVER,
      CRESRV,
      CROSS,
      CRRGD,
      CTRATK,
      CTRBYF,
      CTRFIR,
      DAZZLE,
      DCPTEL,
      DEBARK,
      DECEIV,
      DECSVC,
      DEFCNT,
      DEFDST,
      DEFEAT,
      DEFEND,
      DEFLCT,
      DEFSUP,
      DELAY,
      DEMFRP,
      DEMGRD,
      DEMO,
      DENY,
      DEPLOY,
      DESCRB,
      DESTRY,
      DETECT,
      DISENG,
      DISRPT,
      DIVE,
      DIVERT,
      DLBATK,
      DRONL,
      DSTRBT,
      DUMPNG,
      ELCCNM,
      ELCWAR,
      ELCWRS,
      EMBARK,
      ENGAGE,
      ENVLP,
      ESCRT,
      EVACT,
      EXFLTR,
      EXPLT,
      FIX,
      FIXACO,
      FIXELM,
      FIXELO,
      FNCHFL,
      FOLASS,
      FOLSPT,
      FRWDAC,
      GENCHS,
      GUARD,
      HARASS,
      HASTY,
      HIDE,
      HLDDEF,
      HLDOFF,
      HONASP,
      IDENT,
      IDENTP,
      ILLUMN,
      IMINGT,
      INFILT,
      INFOOP,
      INTCEP,
      INTCOL,
      INTDCT,
      ISOLAT,
      ISSMDA,
      ISSMDD,
      ISSPRS,
      JAM,
      LAY,
      LEAGR,
      LIFT,
      LIFTAD,
      LOCATE,
      MAINTN,
      MAP,
      MARK,
      MASSFR,
      MCM11,
      MCM12,
      MCM13,
      MCM14,
      MCM31,
      MCM32,
      MCM33,
      MCM34,
      MCM35,
      MCM36,
      MCM37,
      MCM38,
      MCM39,
      MCM41,
      MCM42,
      MCM43,
      MCM44,
      MCM45,
      MCM46,
      MCM47,
      MCM48,
      MCM50,
      MCM51,
      MCM52,
      MCM53,
      MCM54,
      MCM55,
      MCM56,
      MCM57,
      MCM58A,
      MCM58B,
      MCM58C,
      MCM59,
      MCM61,
      MCM62,
      MCM63,
      MCM71,
      MCM72,
      MCM73,
      MCM74,
      MCM75,
      MCM81,
      MCM82,
      MCM83,
      MCM84,
      MCM85,
      MCM86,
      MCM87,
      MCM88,
      MCM89,
      MCM91,
      MCM92,
      MCM93,
      MCMATT,
      MCMCHK,
      MCMEXP,
      MCMLDT,
      MCMLMC,
      MCMPRE,
      MCMSA,
      MCMSAA,
      MCMSAC,
      MCMSAD,
      MCMSAG,
      MCMSAH,
      MCMSAM,
      MCMSAZ,
      MCMSB,
      MCMSBZ,
      MCMSC,
      MCMSCA,
      MCMSCC,
      MCMSCD,
      MCMSCG,
      MCMSCH,
      MCMSCM,
      MCMSCZ,
      MCMSE,
      MCMSEA,
      MCMSEC,
      MCMSED,
      MCMSEG,
      MCMSEH,
      MCMSEM,
      MCMSEZ,
      MCMSL,
      MCMSLA,
      MCMSLH,
      MCMSLM,
      MCMSLZ,
      MCMSP,
      MCMSPA,
      MCMSPC,
      MCMSPG,
      MCMSPH,
      MCMSPM,
      MCMSPZ,
      MCMSR,
      MCMSRD,
      MCMSRH,
      MCMSRV,
      MCMSS,
      MCMSSA,
      MCMSSC,
      MCMSSD,
      MCMSSG,
      MCMSSH,
      MCMSSM,
      MCMSSZ,
      MCMSU,
      MCMSUH,
      MCMSUZ,
      MCMSV,
      MCMSVA,
      MCMSVC,
      MCMSVD,
      MCMSVG,
      MCMSVH,
      MCMSVM,
      MCMSVZ,
      MCMSW,
      MCMSWZ,
      MCMSZZ,
      MCMTML,
      MEDEVC,
      METBAL,
      MINCM,
      MINEWF,
      MINLAY,
      MINSWP,
      MISSTG,
      MNHUNT,
      MNSWMA,
      MNTAIR,
      MNTGRD,
      MOPUP,
      MOVE,
      MPA,
      MRITOP,
      NACLSP,
      NTRCHM,
      NTRCOM,
      NTREXP,
      NUCSMP,
      NVLPLF,
      OBSCUR,
      OBSRV,
      OCCUPY,
      OFFAIR,
      OFFCNA,
      ORGCNF,
      ORGMED,
      ORGRCR,
      ORGSCL,
      ORGSPT,
      PATROL,
      PENTRT,
      PHOTO,
      PLAN,
      PREFIR,
      PREPR,
      PROCUR,
      PROTEL,
      PRVACC,
      PRVAGR,
      PRVBDD,
      PRVCMP,
      PRVCNS,
      PRVEDU,
      PRVHLT,
      PRVINF,
      PRVLND,
      PRVRPR,
      PRVSCY,
      PRVSHL,
      PRVSTG,
      PRVTRS,
      PSYCHW,
      PUBMDA,
      PUBMDD,
      PUBPRS,
      PURSUE,
      RCALIB,
      RECARM,
      RECCE,
      RECCEF,
      RECCEL,
      RECCES,
      RECECM,
      RECONS,
      RECOVR,
      RECPHO,
      RECRAD,
      RECTGT,
      RECUPR,
      RECVIS,
      REDEPL,
      REFILL,
      REFORM,
      REFUEL,
      REINF,
      REORG,
      REPAIR,
      RESCUE,
      REST,
      RESUPL,
      RETAIN,
      RETIRE,
      RLFPLC,
      RNDZVA,
      RNDZVB,
      RNDZVC,
      RNDZVD,
      RNDZVE,
      RNDZVF,
      RNDZVG,
      RNDZVS,
      SAR,
      SARCME,
      SARCMI,
      SARPLG,
      SCOUT,
      SCREEN,
      SCRMBL,
      SECURE,
      SECURT,
      SEIZE,
      SENSIM,
      SERASE,
      SERATE,
      SERCH,
      SERFLO,
      SERFOE,
      SERFRE,
      SERFTE,
      SERFUE,
      SERREE,
      SERRSE,
      SERSEA,
      SERSOE,
      SERSPE,
      SERSTE,
      SERSTR,
      SERTHR,
      SETUP,
      SINGA,
      SPCOPS,
      SPREAD,
      SPTCON,
      SPTELC,
      SRCHFR,
      SRCRES,
      STRCON,
      STRWAF,
      SUBWAF,
      SUPPRS,
      SUPPRT,
      SURVEL,
      SURVLE,
      SUSOAA,
      SWEEP,
      TCARRC,
      TGTDLT,
      THREAT,
      TOWTGT,
      TRAIN,
      TRANOP,
      TRANS,
      TRNSAA,
      TRVRS,
      TURN,
      UNCONW,
      UTILTY,
      VERIFY,
      WDRPRS,
      WITHDR,
      WITNES,
      WLDWSL
    };

    ActionTaskActivityCode (value v);

    ActionTaskActivityCode (const char* v);

    ActionTaskActivityCode (const ::std::string& v);

    ActionTaskActivityCode (const ::xml_schema::token& v);

    ActionTaskActivityCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ActionTaskActivityCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ActionTaskActivityCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ActionTaskActivityCode (const ActionTaskActivityCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual ActionTaskActivityCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskActivityCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskActivityCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskActivityCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskActivityCode_literals_[445];
    static const value _xsd_ActionTaskActivityCode_indexes_[445];
  };

  class ActionTaskCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ORD,
      PLAN,
      RQT,
      TEM
    };

    ActionTaskCategoryCode (value v);

    ActionTaskCategoryCode (const char* v);

    ActionTaskCategoryCode (const ::std::string& v);

    ActionTaskCategoryCode (const ::xml_schema::token& v);

    ActionTaskCategoryCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ActionTaskCategoryCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ActionTaskCategoryCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ActionTaskCategoryCode (const ActionTaskCategoryCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual ActionTaskCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskCategoryCode_literals_[4];
    static const value _xsd_ActionTaskCategoryCode_indexes_[4];
  };

  class ActionTaskEndQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AFT,
      ASAP,
      ASAPAF,
      ASAPNL,
      AT,
      BEF,
      INDEF,
      NLT,
      NOB,
      TBD,
      UNK,
      UNTFRN
    };

    ActionTaskEndQualifierCode (value v);

    ActionTaskEndQualifierCode (const char* v);

    ActionTaskEndQualifierCode (const ::std::string& v);

    ActionTaskEndQualifierCode (const ::xml_schema::token& v);

    ActionTaskEndQualifierCode (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    ActionTaskEndQualifierCode (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    ActionTaskEndQualifierCode (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    ActionTaskEndQualifierCode (const ActionTaskEndQualifierCode& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual ActionTaskEndQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskEndQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskEndQualifierCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskEndQualifierCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskEndQualifierCode_literals_[12];
    static const value _xsd_ActionTaskEndQualifierCode_indexes_[12];
  };

  class ActionTaskEntailedSafetyDegreeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ALPHA,
      BRAVO,
      CHARLE
    };

    ActionTaskEntailedSafetyDegreeCode (value v);

    ActionTaskEntailedSafetyDegreeCode (const char* v);

    ActionTaskEntailedSafetyDegreeCode (const ::std::string& v);

    ActionTaskEntailedSafetyDegreeCode (const ::xml_schema::token& v);

    ActionTaskEntailedSafetyDegreeCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    ActionTaskEntailedSafetyDegreeCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    ActionTaskEntailedSafetyDegreeCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    ActionTaskEntailedSafetyDegreeCode (const ActionTaskEntailedSafetyDegreeCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual ActionTaskEntailedSafetyDegreeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskEntailedSafetyDegreeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskEntailedSafetyDegreeCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskEntailedSafetyDegreeCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskEntailedSafetyDegreeCode_literals_[3];
    static const value _xsd_ActionTaskEntailedSafetyDegreeCode_indexes_[3];
  };

  class ActionTaskMeteorologicalImpactCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ACCPTB,
      MARGNL,
      UNACC
    };

    ActionTaskMeteorologicalImpactCode (value v);

    ActionTaskMeteorologicalImpactCode (const char* v);

    ActionTaskMeteorologicalImpactCode (const ::std::string& v);

    ActionTaskMeteorologicalImpactCode (const ::xml_schema::token& v);

    ActionTaskMeteorologicalImpactCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    ActionTaskMeteorologicalImpactCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    ActionTaskMeteorologicalImpactCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    ActionTaskMeteorologicalImpactCode (const ActionTaskMeteorologicalImpactCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual ActionTaskMeteorologicalImpactCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskMeteorologicalImpactCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskMeteorologicalImpactCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskMeteorologicalImpactCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskMeteorologicalImpactCode_literals_[3];
    static const value _xsd_ActionTaskMeteorologicalImpactCode_indexes_[3];
  };

  class ActionTaskOperationalLevelCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      STRTGC,
      TACTCL
    };

    ActionTaskOperationalLevelCode (value v);

    ActionTaskOperationalLevelCode (const char* v);

    ActionTaskOperationalLevelCode (const ::std::string& v);

    ActionTaskOperationalLevelCode (const ::xml_schema::token& v);

    ActionTaskOperationalLevelCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ActionTaskOperationalLevelCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ActionTaskOperationalLevelCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ActionTaskOperationalLevelCode (const ActionTaskOperationalLevelCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual ActionTaskOperationalLevelCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskOperationalLevelCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskOperationalLevelCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskOperationalLevelCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskOperationalLevelCode_literals_[2];
    static const value _xsd_ActionTaskOperationalLevelCode_indexes_[2];
  };

  class ActionTaskOvertCovertCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      COVERT,
      OVERT
    };

    ActionTaskOvertCovertCode (value v);

    ActionTaskOvertCovertCode (const char* v);

    ActionTaskOvertCovertCode (const ::std::string& v);

    ActionTaskOvertCovertCode (const ::xml_schema::token& v);

    ActionTaskOvertCovertCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ActionTaskOvertCovertCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ActionTaskOvertCovertCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ActionTaskOvertCovertCode (const ActionTaskOvertCovertCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual ActionTaskOvertCovertCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskOvertCovertCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskOvertCovertCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskOvertCovertCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskOvertCovertCode_literals_[2];
    static const value _xsd_ActionTaskOvertCovertCode_indexes_[2];
  };

  class ActionTaskPriorityCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_1,
      cxx_1A1,
      cxx_1A2,
      cxx_1A3,
      cxx_1A4,
      cxx_1B1,
      cxx_1B2,
      cxx_1B3,
      cxx_2,
      cxx_2A1,
      cxx_2A2,
      cxx_2B1,
      cxx_2B2,
      cxx_3,
      cxx_3A1,
      cxx_3A2,
      cxx_3A3,
      cxx_3B1,
      cxx_3B2,
      cxx_3B3,
      cxx_3B4,
      cxx_4,
      cxx_4A1,
      cxx_4A2,
      cxx_4B2,
      cxx_4B3,
      cxx_5
    };

    ActionTaskPriorityCode (value v);

    ActionTaskPriorityCode (const char* v);

    ActionTaskPriorityCode (const ::std::string& v);

    ActionTaskPriorityCode (const ::xml_schema::token& v);

    ActionTaskPriorityCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ActionTaskPriorityCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ActionTaskPriorityCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ActionTaskPriorityCode (const ActionTaskPriorityCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual ActionTaskPriorityCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskPriorityCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskPriorityCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskPriorityCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskPriorityCode_literals_[27];
    static const value _xsd_ActionTaskPriorityCode_indexes_[27];
  };

  class ActionTaskStartQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AFT,
      ASAP,
      ASAPAF,
      ASAPNL,
      AT,
      BEF,
      NLT,
      NOB,
      ONCALL,
      ONCDWD,
      TBD,
      UNK
    };

    ActionTaskStartQualifierCode (value v);

    ActionTaskStartQualifierCode (const char* v);

    ActionTaskStartQualifierCode (const ::std::string& v);

    ActionTaskStartQualifierCode (const ::xml_schema::token& v);

    ActionTaskStartQualifierCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ActionTaskStartQualifierCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ActionTaskStartQualifierCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ActionTaskStartQualifierCode (const ActionTaskStartQualifierCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual ActionTaskStartQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskStartQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskStartQualifierCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskStartQualifierCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskStartQualifierCode_literals_[12];
    static const value _xsd_ActionTaskStartQualifierCode_indexes_[12];
  };

  class ActionTaskStatusAmendTimingCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      RQEEAT,
      RQESAT,
      RQSEAT,
      RQSSAT
    };

    ActionTaskStatusAmendTimingCode (value v);

    ActionTaskStatusAmendTimingCode (const char* v);

    ActionTaskStatusAmendTimingCode (const ::std::string& v);

    ActionTaskStatusAmendTimingCode (const ::xml_schema::token& v);

    ActionTaskStatusAmendTimingCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ActionTaskStatusAmendTimingCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ActionTaskStatusAmendTimingCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ActionTaskStatusAmendTimingCode (const ActionTaskStatusAmendTimingCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual ActionTaskStatusAmendTimingCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskStatusAmendTimingCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskStatusAmendTimingCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskStatusAmendTimingCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskStatusAmendTimingCode_literals_[4];
    static const value _xsd_ActionTaskStatusAmendTimingCode_indexes_[4];
  };

  class ActionTaskStatusApprovalIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    ActionTaskStatusApprovalIndicatorCode (value v);

    ActionTaskStatusApprovalIndicatorCode (const char* v);

    ActionTaskStatusApprovalIndicatorCode (const ::std::string& v);

    ActionTaskStatusApprovalIndicatorCode (const ::xml_schema::token& v);

    ActionTaskStatusApprovalIndicatorCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ActionTaskStatusApprovalIndicatorCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ActionTaskStatusApprovalIndicatorCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ActionTaskStatusApprovalIndicatorCode (const ActionTaskStatusApprovalIndicatorCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual ActionTaskStatusApprovalIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskStatusApprovalIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskStatusApprovalIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskStatusApprovalIndicatorCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskStatusApprovalIndicatorCode_literals_[2];
    static const value _xsd_ActionTaskStatusApprovalIndicatorCode_indexes_[2];
  };

  class ActionTaskStatusCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ORD,
      PLAN
    };

    ActionTaskStatusCategoryCode (value v);

    ActionTaskStatusCategoryCode (const char* v);

    ActionTaskStatusCategoryCode (const ::std::string& v);

    ActionTaskStatusCategoryCode (const ::xml_schema::token& v);

    ActionTaskStatusCategoryCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ActionTaskStatusCategoryCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ActionTaskStatusCategoryCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ActionTaskStatusCategoryCode (const ActionTaskStatusCategoryCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual ActionTaskStatusCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskStatusCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskStatusCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskStatusCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskStatusCategoryCode_literals_[2];
    static const value _xsd_ActionTaskStatusCategoryCode_indexes_[2];
  };

  class ActionTaskStatusPlanningIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    ActionTaskStatusPlanningIndicatorCode (value v);

    ActionTaskStatusPlanningIndicatorCode (const char* v);

    ActionTaskStatusPlanningIndicatorCode (const ::std::string& v);

    ActionTaskStatusPlanningIndicatorCode (const ::xml_schema::token& v);

    ActionTaskStatusPlanningIndicatorCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ActionTaskStatusPlanningIndicatorCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ActionTaskStatusPlanningIndicatorCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ActionTaskStatusPlanningIndicatorCode (const ActionTaskStatusPlanningIndicatorCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual ActionTaskStatusPlanningIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskStatusPlanningIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskStatusPlanningIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskStatusPlanningIndicatorCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskStatusPlanningIndicatorCode_literals_[2];
    static const value _xsd_ActionTaskStatusPlanningIndicatorCode_indexes_[2];
  };

  class ActionTaskStatusProgressCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ABO,
      AIRBRN,
      CANCLD,
      COM,
      DELAY,
      DPLMMW,
      DWNTMW,
      IPR,
      NKN,
      NOOPER,
      NOS,
      NST,
      OFFTSK,
      PAU,
      PLAN,
      RECMMW,
      RETASK,
      SCRMBL,
      TASKED,
      TRNMMW
    };

    ActionTaskStatusProgressCode (value v);

    ActionTaskStatusProgressCode (const char* v);

    ActionTaskStatusProgressCode (const ::std::string& v);

    ActionTaskStatusProgressCode (const ::xml_schema::token& v);

    ActionTaskStatusProgressCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ActionTaskStatusProgressCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ActionTaskStatusProgressCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ActionTaskStatusProgressCode (const ActionTaskStatusProgressCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual ActionTaskStatusProgressCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskStatusProgressCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskStatusProgressCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskStatusProgressCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskStatusProgressCode_literals_[20];
    static const value _xsd_ActionTaskStatusProgressCode_indexes_[20];
  };

  class ActionTaskTimingDayCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      C,
      D,
      E,
      G,
      J,
      K,
      M,
      T
    };

    ActionTaskTimingDayCode (value v);

    ActionTaskTimingDayCode (const char* v);

    ActionTaskTimingDayCode (const ::std::string& v);

    ActionTaskTimingDayCode (const ::xml_schema::token& v);

    ActionTaskTimingDayCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    ActionTaskTimingDayCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    ActionTaskTimingDayCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    ActionTaskTimingDayCode (const ActionTaskTimingDayCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual ActionTaskTimingDayCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskTimingDayCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskTimingDayCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskTimingDayCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskTimingDayCode_literals_[8];
    static const value _xsd_ActionTaskTimingDayCode_indexes_[8];
  };

  class ActionTaskTimingHourCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      F,
      G,
      H,
      K,
      L,
      P,
      T,
      Y
    };

    ActionTaskTimingHourCode (value v);

    ActionTaskTimingHourCode (const char* v);

    ActionTaskTimingHourCode (const ::std::string& v);

    ActionTaskTimingHourCode (const ::xml_schema::token& v);

    ActionTaskTimingHourCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ActionTaskTimingHourCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ActionTaskTimingHourCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ActionTaskTimingHourCode (const ActionTaskTimingHourCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual ActionTaskTimingHourCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTaskTimingHourCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTaskTimingHourCode_convert ();
    }

    protected:
    value
    _xsd_ActionTaskTimingHourCode_convert () const;

    public:
    static const char* const _xsd_ActionTaskTimingHourCode_literals_[8];
    static const value _xsd_ActionTaskTimingHourCode_indexes_[8];
  };

  class ActionTemporalAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ENDEND,
      ENDENE,
      ENDENL,
      ENDSNE,
      ENDSNL,
      ENDSTR,
      SAEAST,
      SAENDO,
      SASTEA,
      SBEAST,
      SDUREA,
      SDUREB,
      STREND,
      STRENE,
      STRENL,
      STRSNE,
      STRSNL,
      STRSTR
    };

    ActionTemporalAssociationCategoryCode (value v);

    ActionTemporalAssociationCategoryCode (const char* v);

    ActionTemporalAssociationCategoryCode (const ::std::string& v);

    ActionTemporalAssociationCategoryCode (const ::xml_schema::token& v);

    ActionTemporalAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ActionTemporalAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ActionTemporalAssociationCategoryCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ActionTemporalAssociationCategoryCode (const ActionTemporalAssociationCategoryCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual ActionTemporalAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionTemporalAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionTemporalAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ActionTemporalAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_ActionTemporalAssociationCategoryCode_literals_[18];
    static const value _xsd_ActionTemporalAssociationCategoryCode_indexes_[18];
  };

  class AddressCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ELCADR,
      NOS,
      PHYADR
    };

    AddressCategoryCode (value v);

    AddressCategoryCode (const char* v);

    AddressCategoryCode (const ::std::string& v);

    AddressCategoryCode (const ::xml_schema::token& v);

    AddressCategoryCode (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    AddressCategoryCode (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    AddressCategoryCode (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    AddressCategoryCode (const AddressCategoryCode& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual AddressCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AddressCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AddressCategoryCode_convert ();
    }

    protected:
    value
    _xsd_AddressCategoryCode_convert () const;

    public:
    static const char* const _xsd_AddressCategoryCode_literals_[3];
    static const value _xsd_AddressCategoryCode_indexes_[3];
  };

  class AffiliationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AFLGEO,
      AFLETH,
      AFLFNC,
      AFLREL,
      NSP
    };

    AffiliationCategoryCode (value v);

    AffiliationCategoryCode (const char* v);

    AffiliationCategoryCode (const ::std::string& v);

    AffiliationCategoryCode (const ::xml_schema::token& v);

    AffiliationCategoryCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    AffiliationCategoryCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    AffiliationCategoryCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    AffiliationCategoryCode (const AffiliationCategoryCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual AffiliationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AffiliationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AffiliationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_AffiliationCategoryCode_convert () const;

    public:
    static const char* const _xsd_AffiliationCategoryCode_literals_[5];
    static const value _xsd_AffiliationCategoryCode_indexes_[5];
  };

  class AffiliationEthnicGroupCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ABKHAZ,
      ABORGN,
      ADMISL,
      AFAR,
      AFGHAN,
      AFRADJ,
      AFRAMR,
      AFRBAL,
      AFRBAR,
      AFRBAS,
      AFRBEL,
      AFRBUR,
      AFRFON,
      AFRFUL,
      AFRGBA,
      AFRGIO,
      AFRGOL,
      AFRGRE,
      AFRJOL,
      AFRKIS,
      AFRKPE,
      AFRKRA,
      AFRKRU,
      AFRLOM,
      AFRMAN,
      AFRMEN,
      AFRMND,
      AFRMNJ,
      AFRMNO,
      AFRNDE,
      AFRNFD,
      AFROAR,
      AFROAS,
      AFROCH,
      AFROEA,
      AFROEU,
      AFRPAP,
      AFRSER,
      AFRSHO,
      AFRTEM,
      AFRVAI,
      AFRWOL,
      AFRYOR,
      AGNI,
      AITISL,
      ALBANN,
      ALBNAN,
      ALEMAN,
      ALGRAN,
      AMERIC,
      AMERIN,
      AMERUS,
      AMHARA,
      ANDORR,
      ANGOLA,
      ANTASA,
      ARAB,
      ARABBE,
      ARGNTN,
      ARMNAN,
      ASNNFD,
      ASSYRN,
      ATUISL,
      AUSISL,
      AUSTRA,
      AUSTRL,
      AUSTRN,
      AYMARA,
      AZERBA,
      AZERI,
      BAHRAN,
      BAKONG,
      BALOCH,
      BANDA,
      BANGLS,
      BANTBA,
      BANTBT,
      BANTES,
      BANTFA,
      BANTKO,
      BANTLU,
      BANTMO,
      BANTU,
      BAOULE,
      BASARW,
      BASHKR,
      BASQUE,
      BATSWA,
      BAYA,
      BEJA,
      BELAU,
      BELGAN,
      BELORU,
      BENGLI,
      BERBER,
      BERIKA,
      BETE,
      BETSIM,
      BHOTE,
      BHOTIA,
      BIHARS,
      BIOKOB,
      BIOKOF,
      BISMAR,
      BLACK,
      BLACKA,
      BOBO,
      BOLIVN,
      BOSCRO,
      BOSMUS,
      BOSSER,
      BOUGNV,
      BRAZLN,
      BRETON,
      BRTNEC,
      BRTNFD,
      BULGRN,
      BURGHR,
      BURMAN,
      BURMSE,
      BUYI,
      BYLRSN,
      CAFRE,
      CAMERO,
      CANADN,
      CARIBN,
      CARISL,
      CAUCAS,
      CELTIC,
      CENAMR,
      CHAHAR,
      CHAM,
      CHAMOR,
      CHEWA,
      CHLEAN,
      CHNISL,
      CHNNEC,
      CHNNFD,
      CHRSTN,
      CHUVAS,
      CIRCAS,
      COASTA,
      COCOSM,
      COKNFD,
      COLMBN,
      COMORA,
      CORNSH,
      CORSCN,
      COSTRN,
      COTIER,
      CRELLA,
      CRELUS,
      CREOLE,
      CREOLM,
      CROATN,
      CYRNFD,
      CZECH,
      DAGHES,
      DALMTN,
      DANISH,
      DIOLA,
      DJERMA,
      DRAVID,
      DUTCH,
      EASISL,
      ECUDRN,
      EGYPTN,
      ENGLSH,
      EQUATO,
      ERIRIA,
      ESTONN,
      ETHNCN,
      ETHNCT,
      EURNEC,
      EURNFD,
      EUROAF,
      EUROIN,
      EUROPE,
      EWE,
      FAROES,
      FIJIAN,
      FIJNIN,
      FILPNO,
      FINNSH,
      FLEMSH,
      FLKISL,
      FORROS,
      FRANCO,
      FRENCH,
      FULA,
      FULANI,
      GAELIC,
      GAGAUZ,
      GARIFU,
      GEORGN,
      GERMAB,
      GERMAL,
      GERMAN,
      GERMAR,
      GILAKI,
      GMBISL,
      GOULAY,
      GOURMA,
      GREEK,
      GREEKT,
      GREENA,
      GREENC,
      GRNLND,
      GUADLN,
      GUATLN,
      GUJART,
      GUMISL,
      GURAGE,
      GURUNG,
      GURUNS,
      GUYANS,
      GYPSY,
      HAMTC,
      HAMTCM,
      HAN,
      HAUSA,
      HAWIAN,
      HAZARA,
      HINDUS,
      HISPAN,
      HKCHNS,
      HMONG,
      HONDRN,
      HUI,
      HUNGRN,
      HUTU,
      HUTUBA,
      IBOS,
      ICLNDR,
      IKRBAT,
      INDIGE,
      INDIGM,
      INDIGN,
      INDNEC,
      INDNFD,
      INDOAR,
      INDOCH,
      INDOMA,
      INDOSN,
      INUIT,
      IRAQI,
      IRISH,
      IRNPER,
      ISRJEW,
      ITALAN,
      ITALFR,
      ITALGE,
      ITALSL,
      JAMACN,
      JAPNES,
      JAVANE,
      JEWISH,
      JORDNN,
      KABYE,
      KALANG,
      KALENJ,
      KAMBA,
      KAMCHN,
      KANAKA,
      KARAKA,
      KAREN,
      KAZAKH,
      KAZAKQ,
      KENYAN,
      KGALAG,
      KHMER,
      KIKUYU,
      KIMBUN,
      KIRDI,
      KIRGHZ,
      KISII,
      KONGO,
      KOREAN,
      KUNAMA,
      KURD,
      KUWAIT,
      LADINO,
      LAOTAN,
      LAPP,
      LATIN,
      LATNEC,
      LATNFD,
      LATVAN,
      LEBNSE,
      LIBYAN,
      LIMBUS,
      LITHUN,
      LOBI,
      LOMWE,
      LUHYA,
      LUO,
      LUR,
      MACDNN,
      MADURE,
      MAGARS,
      MAKOA,
      MALAGA,
      MALATN,
      MALAY,
      MALAYA,
      MALAYI,
      MALAYM,
      MALCHN,
      MALINK,
      MALTSE,
      MALVAN,
      MAN,
      MANCHU,
      MANDE,
      MANDEB,
      MANDEM,
      MANDES,
      MANDJI,
      MANDNG,
      MANGIS,
      MANHIS,
      MANUIS,
      MANX,
      MAORI,
      MARISL,
      MARQIS,
      MARSIS,
      MASSA,
      MAUKIS,
      MAUR,
      MAURTN,
      MAYA,
      MAZAND,
      MBAKA,
      MBAYE,
      MBOCHI,
      MBOUM,
      MDENEC,
      MDENFD,
      MELANE,
      MEO,
      MERU,
      MESTZE,
      MESTZS,
      MEXCAN,
      MIAO,
      MICRON,
      MINA,
      MITISL,
      MIXED,
      MOLDOV,
      MON,
      MONEGA,
      MONGOL,
      MONTEN,
      MOOR,
      MORAVI,
      MOROCN,
      MOSSI,
      MOUND,
      MOUSSE,
      MUHAJR,
      MULATT,
      MUONG,
      MUSIMO,
      MUSLIM,
      MUSLMA,
      MUSLMB,
      MUSLMF,
      MUSLMH,
      MUSLMK,
      MUSLMM,
      MUSLMT,
      MUSLMU,
      MUSLMY,
      MUSLMZ,
      NAINDN,
      NATVEF,
      NATVEM,
      NAUISL,
      NEGRIT,
      NEPLSE,
      NEWARS,
      NEWBRT,
      NEWCAL,
      NEWGER,
      NEWIRL,
      NEWZEA,
      NEWZLE,
      NEWZLM,
      NGAMBY,
      NGONDE,
      NGONI,
      NICRGN,
      NIGRAN,
      NIUEAN,
      NKN,
      NORDIC,
      NORMAN,
      NORMFR,
      NORTAF,
      NORWGN,
      NOS,
      NYANJA,
      OAFNEC,
      OASNEC,
      OCNISL,
      OEUNFD,
      OIMATS,
      OMANI,
      OPANEC,
      OPANFD,
      ORIENT,
      ORKISL,
      OROMO,
      OSANEC,
      OSSET,
      OVIMBU,
      PACNFD,
      PAKSTN,
      PALAUA,
      PALMIS,
      PALSTN,
      PANMAN,
      PAPUAN,
      PARGYN,
      PASHTP,
      PASHTU,
      PENISL,
      PERSAN,
      PERUVN,
      PEUL,
      PHNISL,
      PHOUTH,
      PITISL,
      POLISH,
      POLYNE,
      POLYNS,
      POLYNT,
      PORTGS,
      PUERTR,
      PUKISL,
      PUNJAB,
      QUECHU,
      RAIS,
      RAKHIN,
      RAKISL,
      RARTGN,
      RIOMUN,
      ROMANN,
      ROMANS,
      ROMANY,
      ROTUMN,
      RUSSAN,
      RUTHEN,
      RWANDA,
      SAHO,
      SAKALA,
      SAMMAR,
      SAMOAN,
      SAMOAP,
      SANGHA,
      SANISL,
      SARA,
      SARDNN,
      SCANDN,
      SCOTSH,
      SENA,
      SENOUF,
      SENUFO,
      SERBAN,
      SERER,
      SERVIC,
      SEYISL,
      SHAN,
      SHERPA,
      SHTISL,
      SICLAN,
      SIDAMO,
      SIKH,
      SINCHN,
      SINDHI,
      SINHLS,
      SINOMA,
      SLAVIC,
      SLOVAK,
      SLOVNE,
      SLVNEC,
      SLVNFD,
      SOCISL,
      SOLISL,
      SOLVEN,
      SOMALI,
      SONGHA,
      SOTHO,
      SOUAFR,
      SOUAMR,
      SOUNFD,
      SOUSSO,
      SOUTHA,
      SPANSH,
      SRINEC,
      SRINFD,
      SRITML,
      SUNDAN,
      SWEDSH,
      SWISS,
      SYRANL,
      SYRIAN,
      SYROLE,
      TAHITN,
      TAICHN,
      TAJIK,
      TAMANG,
      TAMIL,
      TATAR,
      TEKE,
      TEUTON,
      THAI,
      TIBETN,
      TIGREA,
      TOKELN,
      TONGAN,
      TONGAS,
      TORISL,
      TOUBOU,
      TOUCOU,
      TSIMHE,
      TUAISL,
      TUAREG,
      TUMBUK,
      TUNISN,
      TURKME,
      TURKOM,
      TURKSH,
      TUTSI,
      TUVISL,
      TWA,
      UGANDN,
      UKRANN,
      URUGYN,
      UYGUR,
      UZBEK,
      VANUAT,
      VEDDA,
      VENEZN,
      VIETNM,
      VITCHN,
      VLACHS,
      VOLTAC,
      WAKISL,
      WALISL,
      WALLIS,
      WALLOO,
      WELSH,
      WHITE,
      WOLOF,
      WSTIND,
      YAO,
      YAPISL,
      YEMENI,
      YI,
      YORUBA,
      YUGOSL,
      ZAIRAN,
      ZANZIB,
      ZHUANG
    };

    AffiliationEthnicGroupCode (value v);

    AffiliationEthnicGroupCode (const char* v);

    AffiliationEthnicGroupCode (const ::std::string& v);

    AffiliationEthnicGroupCode (const ::xml_schema::token& v);

    AffiliationEthnicGroupCode (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    AffiliationEthnicGroupCode (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    AffiliationEthnicGroupCode (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    AffiliationEthnicGroupCode (const AffiliationEthnicGroupCode& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual AffiliationEthnicGroupCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AffiliationEthnicGroupCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AffiliationEthnicGroupCode_convert ();
    }

    protected:
    value
    _xsd_AffiliationEthnicGroupCode_convert () const;

    public:
    static const char* const _xsd_AffiliationEthnicGroupCode_literals_[567];
    static const value _xsd_AffiliationEthnicGroupCode_indexes_[567];
  };

  class AffiliationFunctionalGroupCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CRIMIN,
      EXER,
      MULTIN,
      NKN,
      NOS,
      TERRST
    };

    AffiliationFunctionalGroupCode (value v);

    AffiliationFunctionalGroupCode (const char* v);

    AffiliationFunctionalGroupCode (const ::std::string& v);

    AffiliationFunctionalGroupCode (const ::xml_schema::token& v);

    AffiliationFunctionalGroupCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    AffiliationFunctionalGroupCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    AffiliationFunctionalGroupCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    AffiliationFunctionalGroupCode (const AffiliationFunctionalGroupCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual AffiliationFunctionalGroupCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AffiliationFunctionalGroupCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AffiliationFunctionalGroupCode_convert ();
    }

    protected:
    value
    _xsd_AffiliationFunctionalGroupCode_convert () const;

    public:
    static const char* const _xsd_AffiliationFunctionalGroupCode_literals_[6];
    static const value _xsd_AffiliationFunctionalGroupCode_indexes_[6];
  };

  class AffiliationGeopoliticalCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ABW,
      AFG,
      AGO,
      AIA,
      ALB,
      AND,
      ANT,
      ARE,
      ARG,
      ARM,
      ASM,
      ATA,
      ATF,
      ATG,
      AUS,
      AUT,
      AZE,
      BDI,
      BEL,
      BEN,
      BFA,
      BGD,
      BGR,
      BHR,
      BHS,
      BIH,
      BLR,
      BLZ,
      BMU,
      BOL,
      BRA,
      BRB,
      BRN,
      BTN,
      BVT,
      BWA,
      CAF,
      CAN,
      CCK,
      CHE,
      CHL,
      CHN,
      CIV,
      CMR,
      COD,
      COG,
      COK,
      COL,
      COM,
      CPV,
      CRI,
      CSHH,
      CUB,
      CXR,
      CYM,
      CYP,
      CZE,
      DDDE,
      DEU,
      DJI,
      DMA,
      DNK,
      DOM,
      DZA,
      ECU,
      EGY,
      ERI,
      ESH,
      ESP,
      EST,
      ETH,
      FIN,
      FJI,
      FLK,
      FRA,
      FRO,
      FSM,
      FXX,
      GAB,
      GBR,
      GEO,
      GHA,
      GIB,
      GIN,
      GLP,
      GMB,
      GNB,
      GNQ,
      GRC,
      GRD,
      GRL,
      GTM,
      GUF,
      GUM,
      GUY,
      HKG,
      HMD,
      HND,
      HRV,
      HTI,
      HUN,
      IDN,
      IND,
      IOT,
      IRL,
      IRN,
      IRQ,
      ISL,
      ISR,
      ITA,
      JAM,
      JOR,
      JPN,
      KAZ,
      KEN,
      KGZ,
      KHM,
      KIR,
      KNA,
      KOR,
      KWT,
      LAO,
      LBN,
      LBR,
      LBY,
      LCA,
      LIE,
      LKA,
      LSO,
      LTU,
      LUX,
      LVA,
      MAC,
      MAR,
      MCO,
      MDA,
      MDG,
      MDV,
      MEX,
      MHL,
      MKD,
      MLI,
      MLT,
      MMR,
      MNG,
      MNP,
      MOZ,
      MRT,
      MSR,
      MTQ,
      MUS,
      MWI,
      MYS,
      MYT,
      NAM,
      NCL,
      NER,
      NFK,
      NGA,
      NIC,
      NIU,
      NLD,
      NOR,
      NOS,
      NPL,
      NRU,
      NZL,
      OMN,
      PAK,
      PAN,
      PCN,
      PER,
      PHL,
      PLW,
      PNG,
      POL,
      PRI,
      PRK,
      PRT,
      PRY,
      PSE,
      PYF,
      QAT,
      REU,
      ROU,
      RUS,
      RWA,
      SAU,
      SCG,
      SDN,
      SEN,
      SGP,
      SGS,
      SHN,
      SJM,
      SLB,
      SLE,
      SLV,
      SMR,
      SOM,
      SPM,
      STP,
      SUHH,
      SUR,
      SVK,
      SVN,
      SWE,
      SWZ,
      SYC,
      SYR,
      TCA,
      TCD,
      TGO,
      THA,
      TJK,
      TKL,
      TKM,
      TLS,
      TON,
      TTO,
      TUN,
      TUR,
      TUV,
      TWN,
      TZA,
      UGA,
      UKR,
      UMI,
      URY,
      USA,
      UZB,
      VAT,
      VCT,
      VEN,
      VGB,
      VIR,
      VNM,
      VUT,
      WLF,
      WSM,
      YEM,
      YUCS,
      ZAF,
      ZMB,
      ZWE
    };

    AffiliationGeopoliticalCode (value v);

    AffiliationGeopoliticalCode (const char* v);

    AffiliationGeopoliticalCode (const ::std::string& v);

    AffiliationGeopoliticalCode (const ::xml_schema::token& v);

    AffiliationGeopoliticalCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    AffiliationGeopoliticalCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    AffiliationGeopoliticalCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    AffiliationGeopoliticalCode (const AffiliationGeopoliticalCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual AffiliationGeopoliticalCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AffiliationGeopoliticalCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AffiliationGeopoliticalCode_convert ();
    }

    protected:
    value
    _xsd_AffiliationGeopoliticalCode_convert () const;

    public:
    static const char* const _xsd_AffiliationGeopoliticalCode_literals_[245];
    static const value _xsd_AffiliationGeopoliticalCode_indexes_[245];
  };

  class AffiliationReligionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AFRMTH,
      ANGLCN,
      ANIMSM,
      APSTLC,
      ARMNAN,
      ARMORT,
      ASMGOD,
      ATHEST,
      BABYLN,
      BAHAI,
      BAPTST,
      BEHAI,
      BLGORT,
      BUDHSM,
      CALVNS,
      CATHLC,
      CHNDGY,
      CHRENG,
      CHRFRW,
      CHRGOD,
      CHRSLB,
      CHRSTN,
      CHRTVL,
      CNFCNS,
      CNG,
      CNGCCH,
      CNGNCH,
      CPTCHR,
      DRUZE,
      EKLNIE,
      EPSCPL,
      ESTORT,
      ETHORT,
      EVNALL,
      EVNGCH,
      EVNLUT,
      GEOORT,
      GRGARM,
      GRKCTH,
      GRKORT,
      HINDU,
      IBDMUS,
      INDGNS,
      ISLAMA,
      ISLAMC,
      ISLAMI,
      ISLAMN,
      JAINS,
      JHVWTN,
      JUDASM,
      KIEVPT,
      KMBNGS,
      LAMBUD,
      LNDMSN,
      LTRSNT,
      LUTHRN,
      MANDEA,
      MARONT,
      MENNTE,
      METHDS,
      MODKNG,
      MORMON,
      MSCWPT,
      MUSLIM,
      MUSMLY,
      MUSSHF,
      MUSZYD,
      NIUNCH,
      NKN,
      NONE,
      NOS,
      ORTHDX,
      PARSI,
      PGNAFR,
      PNTCST,
      PRSBYT,
      PRT,
      PRTADV,
      PRTEVN,
      PRTMRV,
      RMNCTH,
      RMNCTU,
      ROMORT,
      RUSORT,
      SHIMUS,
      SHINTO,
      SHMNSM,
      SIKH,
      SLVMUS,
      SOCFRD,
      SPRCLT,
      SUNMUS,
      SVNADV,
      SYNCHN,
      TAOISM,
      TBTBUD,
      THRVBD,
      TRBREL,
      TRD,
      TRDMYN,
      UKRAUT,
      UKRCTH,
      UKRORT,
      UNCH,
      UNCHAU,
      UNCHCN,
      UNCHPR,
      UNDMTH,
      UNDPRB,
      UNFRCH,
      UNICTH,
      VOODOO,
      ZRSTRN
    };

    AffiliationReligionCode (value v);

    AffiliationReligionCode (const char* v);

    AffiliationReligionCode (const ::std::string& v);

    AffiliationReligionCode (const ::xml_schema::token& v);

    AffiliationReligionCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    AffiliationReligionCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    AffiliationReligionCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    AffiliationReligionCode (const AffiliationReligionCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual AffiliationReligionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AffiliationReligionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AffiliationReligionCode_convert ();
    }

    protected:
    value
    _xsd_AffiliationReligionCode_convert () const;

    public:
    static const char* const _xsd_AffiliationReligionCode_literals_[113];
    static const value _xsd_AffiliationReligionCode_indexes_[113];
  };

  class AirRouteSegmentCivilMilitaryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BOTH,
      CIVIL,
      MIL
    };

    AirRouteSegmentCivilMilitaryCode (value v);

    AirRouteSegmentCivilMilitaryCode (const char* v);

    AirRouteSegmentCivilMilitaryCode (const ::std::string& v);

    AirRouteSegmentCivilMilitaryCode (const ::xml_schema::token& v);

    AirRouteSegmentCivilMilitaryCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    AirRouteSegmentCivilMilitaryCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    AirRouteSegmentCivilMilitaryCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    AirRouteSegmentCivilMilitaryCode (const AirRouteSegmentCivilMilitaryCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual AirRouteSegmentCivilMilitaryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AirRouteSegmentCivilMilitaryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AirRouteSegmentCivilMilitaryCode_convert ();
    }

    protected:
    value
    _xsd_AirRouteSegmentCivilMilitaryCode_convert () const;

    public:
    static const char* const _xsd_AirRouteSegmentCivilMilitaryCode_literals_[3];
    static const value _xsd_AirRouteSegmentCivilMilitaryCode_indexes_[3];
  };

  class AirRouteSegmentInternationalRouteCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DOMSTC,
      INTERN
    };

    AirRouteSegmentInternationalRouteCode (value v);

    AirRouteSegmentInternationalRouteCode (const char* v);

    AirRouteSegmentInternationalRouteCode (const ::std::string& v);

    AirRouteSegmentInternationalRouteCode (const ::xml_schema::token& v);

    AirRouteSegmentInternationalRouteCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    AirRouteSegmentInternationalRouteCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    AirRouteSegmentInternationalRouteCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    AirRouteSegmentInternationalRouteCode (const AirRouteSegmentInternationalRouteCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual AirRouteSegmentInternationalRouteCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AirRouteSegmentInternationalRouteCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AirRouteSegmentInternationalRouteCode_convert ();
    }

    protected:
    value
    _xsd_AirRouteSegmentInternationalRouteCode_convert () const;

    public:
    static const char* const _xsd_AirRouteSegmentInternationalRouteCode_literals_[2];
    static const value _xsd_AirRouteSegmentInternationalRouteCode_indexes_[2];
  };

  class AirRouteSegmentRequiredNavigationPerformanceCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_125NM,
      cxx_1NM,
      cxx_20NM,
      cxx_4NM,
      cxx_5NM,
      cxx_6NM
    };

    AirRouteSegmentRequiredNavigationPerformanceCode (value v);

    AirRouteSegmentRequiredNavigationPerformanceCode (const char* v);

    AirRouteSegmentRequiredNavigationPerformanceCode (const ::std::string& v);

    AirRouteSegmentRequiredNavigationPerformanceCode (const ::xml_schema::token& v);

    AirRouteSegmentRequiredNavigationPerformanceCode (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    AirRouteSegmentRequiredNavigationPerformanceCode (const ::xercesc::DOMAttr& a,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    AirRouteSegmentRequiredNavigationPerformanceCode (const ::std::string& s,
                                                      const ::xercesc::DOMElement* e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    AirRouteSegmentRequiredNavigationPerformanceCode (const AirRouteSegmentRequiredNavigationPerformanceCode& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    virtual AirRouteSegmentRequiredNavigationPerformanceCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AirRouteSegmentRequiredNavigationPerformanceCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AirRouteSegmentRequiredNavigationPerformanceCode_convert ();
    }

    protected:
    value
    _xsd_AirRouteSegmentRequiredNavigationPerformanceCode_convert () const;

    public:
    static const char* const _xsd_AirRouteSegmentRequiredNavigationPerformanceCode_literals_[6];
    static const value _xsd_AirRouteSegmentRequiredNavigationPerformanceCode_indexes_[6];
  };

  class AircraftTypeAirframeDesignCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AUTOGY,
      BALOON,
      BOMBER,
      CARGO,
      DIRIG,
      FIGHTR,
      GLIDER,
      HELO,
      NKN,
      NOS,
      SATEL
    };

    AircraftTypeAirframeDesignCode (value v);

    AircraftTypeAirframeDesignCode (const char* v);

    AircraftTypeAirframeDesignCode (const ::std::string& v);

    AircraftTypeAirframeDesignCode (const ::xml_schema::token& v);

    AircraftTypeAirframeDesignCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    AircraftTypeAirframeDesignCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    AircraftTypeAirframeDesignCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    AircraftTypeAirframeDesignCode (const AircraftTypeAirframeDesignCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual AircraftTypeAirframeDesignCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AircraftTypeAirframeDesignCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AircraftTypeAirframeDesignCode_convert ();
    }

    protected:
    value
    _xsd_AircraftTypeAirframeDesignCode_convert () const;

    public:
    static const char* const _xsd_AircraftTypeAirframeDesignCode_literals_[11];
    static const value _xsd_AircraftTypeAirframeDesignCode_indexes_[11];
  };

  class AircraftTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIRRW,
      FIXWNG,
      LGTAIR,
      NKN,
      NOS,
      SPACEM
    };

    AircraftTypeCategoryCode (value v);

    AircraftTypeCategoryCode (const char* v);

    AircraftTypeCategoryCode (const ::std::string& v);

    AircraftTypeCategoryCode (const ::xml_schema::token& v);

    AircraftTypeCategoryCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    AircraftTypeCategoryCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    AircraftTypeCategoryCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    AircraftTypeCategoryCode (const AircraftTypeCategoryCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual AircraftTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AircraftTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AircraftTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_AircraftTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_AircraftTypeCategoryCode_literals_[6];
    static const value _xsd_AircraftTypeCategoryCode_indexes_[6];
  };

  class AircraftTypeDesignRangeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      LONG,
      MEDIUM,
      NKN,
      SHORT
    };

    AircraftTypeDesignRangeCode (value v);

    AircraftTypeDesignRangeCode (const char* v);

    AircraftTypeDesignRangeCode (const ::std::string& v);

    AircraftTypeDesignRangeCode (const ::xml_schema::token& v);

    AircraftTypeDesignRangeCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    AircraftTypeDesignRangeCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    AircraftTypeDesignRangeCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    AircraftTypeDesignRangeCode (const AircraftTypeDesignRangeCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual AircraftTypeDesignRangeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AircraftTypeDesignRangeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AircraftTypeDesignRangeCode_convert ();
    }

    protected:
    value
    _xsd_AircraftTypeDesignRangeCode_convert () const;

    public:
    static const char* const _xsd_AircraftTypeDesignRangeCode_literals_[4];
    static const value _xsd_AircraftTypeDesignRangeCode_indexes_[4];
  };

  class AircraftTypeDesignRoleCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DEF,
      MULTI,
      NKN,
      NOS,
      OFF,
      SUPPRT
    };

    AircraftTypeDesignRoleCode (value v);

    AircraftTypeDesignRoleCode (const char* v);

    AircraftTypeDesignRoleCode (const ::std::string& v);

    AircraftTypeDesignRoleCode (const ::xml_schema::token& v);

    AircraftTypeDesignRoleCode (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    AircraftTypeDesignRoleCode (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    AircraftTypeDesignRoleCode (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    AircraftTypeDesignRoleCode (const AircraftTypeDesignRoleCode& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual AircraftTypeDesignRoleCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AircraftTypeDesignRoleCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AircraftTypeDesignRoleCode_convert ();
    }

    protected:
    value
    _xsd_AircraftTypeDesignRoleCode_convert () const;

    public:
    static const char* const _xsd_AircraftTypeDesignRoleCode_literals_[6];
    static const value _xsd_AircraftTypeDesignRoleCode_indexes_[6];
  };

  class AircraftTypeLoadCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HEAVY,
      LIGHT,
      MEDIUM,
      NKN,
      NOS
    };

    AircraftTypeLoadCategoryCode (value v);

    AircraftTypeLoadCategoryCode (const char* v);

    AircraftTypeLoadCategoryCode (const ::std::string& v);

    AircraftTypeLoadCategoryCode (const ::xml_schema::token& v);

    AircraftTypeLoadCategoryCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    AircraftTypeLoadCategoryCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    AircraftTypeLoadCategoryCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    AircraftTypeLoadCategoryCode (const AircraftTypeLoadCategoryCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual AircraftTypeLoadCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AircraftTypeLoadCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AircraftTypeLoadCategoryCode_convert ();
    }

    protected:
    value
    _xsd_AircraftTypeLoadCategoryCode_convert () const;

    public:
    static const char* const _xsd_AircraftTypeLoadCategoryCode_literals_[5];
    static const value _xsd_AircraftTypeLoadCategoryCode_indexes_[5];
  };

  class AircraftTypeMainPurposeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AAR,
      ACP,
      AEW,
      AEWCON,
      AIRDEF,
      AIRSUP,
      ANTARM,
      ARELAY,
      ARMAS,
      ASCB,
      ASMPA,
      ASUW,
      ASW,
      ATKSTR,
      ATTACK,
      CARGO,
      CMDCTL,
      COM,
      CSAR,
      DRONL,
      ECMJAM,
      ELCCNM,
      EW,
      FIGBOM,
      FIGINT,
      GDATK,
      GDATKR,
      IMINGT,
      LIAIS,
      MAINT,
      MEDEVC,
      METBAL,
      MINCM,
      MINWAR,
      MPA,
      MPAREC,
      MULTIP,
      MULTIS,
      NAV,
      NAVATK,
      NKN,
      NOS,
      PATROL,
      PHOTO,
      PSG,
      RCALIB,
      RECCE,
      RECECM,
      RECPHO,
      RECRAD,
      RECVIS,
      SAR,
      SCOUT,
      SINGA,
      SOF,
      SPCPRP,
      STOR,
      TANKER,
      TGTREL,
      TOWTGT,
      UTILTY
    };

    AircraftTypeMainPurposeCode (value v);

    AircraftTypeMainPurposeCode (const char* v);

    AircraftTypeMainPurposeCode (const ::std::string& v);

    AircraftTypeMainPurposeCode (const ::xml_schema::token& v);

    AircraftTypeMainPurposeCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    AircraftTypeMainPurposeCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    AircraftTypeMainPurposeCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    AircraftTypeMainPurposeCode (const AircraftTypeMainPurposeCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual AircraftTypeMainPurposeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AircraftTypeMainPurposeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AircraftTypeMainPurposeCode_convert ();
    }

    protected:
    value
    _xsd_AircraftTypeMainPurposeCode_convert () const;

    public:
    static const char* const _xsd_AircraftTypeMainPurposeCode_literals_[61];
    static const value _xsd_AircraftTypeMainPurposeCode_indexes_[61];
  };

  class AircraftTypeManningCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MANNED,
      NKN,
      UNMANN,
      UNMNRP,
      UNMRP
    };

    AircraftTypeManningCode (value v);

    AircraftTypeManningCode (const char* v);

    AircraftTypeManningCode (const ::std::string& v);

    AircraftTypeManningCode (const ::xml_schema::token& v);

    AircraftTypeManningCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    AircraftTypeManningCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    AircraftTypeManningCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    AircraftTypeManningCode (const AircraftTypeManningCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual AircraftTypeManningCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AircraftTypeManningCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AircraftTypeManningCode_convert ();
    }

    protected:
    value
    _xsd_AircraftTypeManningCode_convert () const;

    public:
    static const char* const _xsd_AircraftTypeManningCode_literals_[5];
    static const value _xsd_AircraftTypeManningCode_indexes_[5];
  };

  class AircraftTypeMilitaryCivilianCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CIVIL,
      MIL,
      NKN
    };

    AircraftTypeMilitaryCivilianCode (value v);

    AircraftTypeMilitaryCivilianCode (const char* v);

    AircraftTypeMilitaryCivilianCode (const ::std::string& v);

    AircraftTypeMilitaryCivilianCode (const ::xml_schema::token& v);

    AircraftTypeMilitaryCivilianCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    AircraftTypeMilitaryCivilianCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    AircraftTypeMilitaryCivilianCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    AircraftTypeMilitaryCivilianCode (const AircraftTypeMilitaryCivilianCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual AircraftTypeMilitaryCivilianCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AircraftTypeMilitaryCivilianCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AircraftTypeMilitaryCivilianCode_convert ();
    }

    protected:
    value
    _xsd_AircraftTypeMilitaryCivilianCode_convert () const;

    public:
    static const char* const _xsd_AircraftTypeMilitaryCivilianCode_literals_[3];
    static const value _xsd_AircraftTypeMilitaryCivilianCode_indexes_[3];
  };

  class AircraftTypeModelCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_101156,
      cxx_1049,
      cxx_1124SS,
      cxx_1125SP,
      cxx_1150AT,
      cxx_1240,
      cxx_137T,
      cxx_200,
      cxx_201A,
      cxx_232C,
      cxx_269A,
      cxx_280L,
      cxx_28PBRE,
      cxx_28RBRD,
      cxx_28UBRD,
      cxx_28UBRE,
      cxx_300C,
      cxx_333DF,
      cxx_358GAV,
      cxx_35XD,
      cxx_369OHJ,
      cxx_414A,
      cxx_500MD,
      cxx_698V,
      cxx_8600,
      A1,
      A10,
      A100,
      A103,
      A109A,
      A109C,
      A109E,
      A109H0,
      A109HA,
      A109K,
      A109KM,
      A109KN,
      A109MA,
      A10A,
      A10AL,
      A10B,
      A119,
      A120LS,
      A122,
      A129,
      A12919,
      A132,
      A135,
      A139,
      A18,
      A1D,
      A1M,
      A20,
      A200,
      A200BS,
      A209,
      A211,
      A212,
      A212A,
      A21M,
      A22,
      A22J,
      A23,
      A25,
      A26,
      A27,
      A29,
      A2AVEN,
      A3,
      A300,
      A30060,
      A3006M,
      A3006S,
      A300B4,
      A300C4,
      A300MR,
      A300SB,
      A310,
      A31020,
      A31030,
      A310AE,
      A310CY,
      A310MR,
      A316,
      A317,
      A318,
      A319,
      A319CJ,
      A32,
      A320,
      A32020,
      A321,
      A32120,
      A32A,
      A330,
      A33020,
      A33030,
      A340,
      A34040,
      A34080,
      A360,
      A36H,
      A36TC,
      A37,
      A37A,
      A37B,
      A3A,
      A3B,
      A4,
      A4A,
      A4B,
      A4C,
      A4D,
      A4E,
      A4F,
      A4G,
      A4H,
      A4J,
      A4K,
      A4KU,
      A4L,
      A4M,
      A4N,
      A4P,
      A4Q,
      A4S,
      A4SU,
      A5,
      A501,
      A5M,
      A6,
      A60PLS,
      A6A,
      A6B,
      A6C,
      A6E,
      A6F,
      A6G,
      A7,
      A7A,
      A7B,
      A7C,
      A7D,
      A7E,
      A7G,
      A7H,
      A7K,
      A7P,
      AA1,
      AA1B,
      AA5,
      AB204,
      AB204A,
      AB204B,
      AB205,
      AB205A,
      AB205B,
      AB206,
      AB2063,
      AB2064,
      AB206A,
      AB206B,
      AB206L,
      AB209,
      AB212,
      AB212A,
      AB212C,
      AB212M,
      AB212O,
      AB214,
      AB214A,
      AB214B,
      AB214C,
      AB214S,
      AB222,
      AB260,
      AB406,
      AB412,
      AB47,
      AB47G,
      AB47J,
      AB47SX,
      ABE212,
      AC05,
      AC10,
      AC119,
      AC119K,
      AC12,
      AC130,
      AC130A,
      AC130H,
      AC130U,
      AC14,
      AC20,
      AC21,
      AC2A,
      AC2T,
      AC47,
      AC50,
      AC52,
      AC60,
      AC69,
      AC6T,
      AC72,
      AC90,
      ACMD,
      ACOCK,
      ACOCKA,
      ACOCKB,
      ADA,
      AE100,
      AE206,
      AE207,
      AE209,
      AE270,
      AE316,
      AE317,
      AER50,
      AEW2,
      AFM526,
      AFX,
      AG6,
      AGSYE1,
      AH1,
      AH12,
      AH12A,
      AH1E,
      AH1F,
      AH1G,
      AH1J,
      AH1LX,
      AH1P,
      AH1Q,
      AH1R,
      AH1RO,
      AH1S,
      AH1TSC,
      AH1W,
      AH1WSC,
      AH58D,
      AH6,
      AH64,
      AH64A,
      AH64C,
      AH64D,
      AH6C,
      AH6F,
      AH6G,
      AH6J,
      AH7,
      AH70,
      AHA,
      AHMK1,
      AHMK5,
      AHMK6,
      AHMK7,
      AHMK9,
      AIEP,
      AIRS,
      AJ37,
      AJS37,
      AL1,
      AL1A,
      AL60,
      AL60B,
      ALA100,
      ALA300,
      ALA40,
      ALA600,
      ALI,
      ALIZM,
      ALPHA,
      ALPHA1,
      ALPHA2,
      ALPHAT,
      AM3C,
      AMH,
      AMT100,
      AMT200,
      AN10,
      AN114,
      AN12,
      AN124,
      AN1241,
      AN1243,
      AN124M,
      AN14,
      AN140,
      AN180,
      AN2,
      AN22,
      AN225,
      AN22A,
      AN22B,
      AN24,
      AN26,
      AN26A,
      AN26B,
      AN26RT,
      AN28,
      AN28R1,
      AN28R2,
      AN28TD,
      AN30,
      AN32B,
      AN32P,
      AN38,
      AN3820,
      AN38K,
      AN4,
      AN40,
      AN70,
      AN7010,
      AN70T,
      AN70T1,
      AN70TK,
      AN71,
      AN72,
      AN72A,
      AN72P,
      AN72S,
      AN74,
      AN7420,
      AN74AB,
      AN74AC,
      AN74C,
      AN74K1,
      AN74K2,
      AN74MC,
      AN74SA,
      AN74SB,
      AN74T1,
      AN74T2,
      AN74TB,
      AN74TC,
      AN8,
      ANC1,
      ANC2,
      ANCC2,
      ANDCC2,
      ANDE3A,
      ANE3,
      ANSAT,
      AP1P,
      AP2S,
      AP3M,
      AP4S,
      AP68TP,
      APM20,
      AR11,
      AR15,
      AR58,
      ARA360,
      ARGOSY,
      ARL24,
      AS1052,
      AS2,
      AS202,
      AS2021,
      AS2023,
      AS300,
      AS32L1,
      AS32L2,
      AS332,
      AS332B,
      AS332C,
      AS332F,
      AS332L,
      AS332M,
      AS332N,
      AS332S,
      AS350,
      AS3502,
      AS3503,
      AS350B,
      AS350C,
      AS350D,
      AS350E,
      AS350F,
      AS350L,
      AS350M,
      AS355,
      AS3551,
      AS355B,
      AS355F,
      AS355M,
      AS365N,
      AS366G,
      AS532,
      AS5321,
      AS5322,
      AS532C,
      AS532H,
      AS550,
      AS555,
      AS555A,
      AS555U,
      AS565,
      AS565A,
      AS565B,
      AS565C,
      AS565M,
      AS565S,
      AS565U,
      AS61,
      AS61A,
      AS61N1,
      AS61R,
      AS61SK,
      AS61TS,
      AS6ISK,
      AS6ITS,
      AS80M2,
      AS90M2,
      ASTRA,
      AT1150,
      AT2000,
      AT26,
      AT28,
      AT33,
      AT37D,
      AT38B,
      AT401,
      AT402,
      AT502,
      AT503,
      AT50A2,
      AT6G,
      AT802,
      ATL2,
      ATLA,
      ATR42,
      ATR421,
      ATR422,
      ATR423,
      ATR424,
      ATR425,
      ATR42F,
      ATR42M,
      ATR42S,
      ATR52C,
      ATR72,
      ATR722,
      ATTA30,
      ATTC3,
      ATTC3C,
      AU23,
      AU23A,
      AU24,
      AU24A,
      AUH76,
      AUR,
      AV400A,
      AV52,
      AV8A,
      AV8AA,
      AV8B,
      AV8B2,
      AV8B2P,
      AV8BAH,
      AV8C,
      AV8S,
      AV8T4,
      AVIA89,
      AVIA90,
      AVIA96,
      AVIAA1,
      AW1,
      AW2,
      AY600,
      AY700,
      AYLLM2,
      AYLM20,
      AYS2RG,
      AZTEC,
      B0108,
      B1,
      B100,
      B105,
      B111,
      B1112,
      B1113,
      B1114,
      B11147,
      B1115,
      B1B,
      B2,
      B200TM,
      B214ST,
      B25,
      B26,
      B2A,
      B2SM,
      B350,
      B36TC,
      B3LA,
      B47,
      B5,
      B52,
      B52G,
      B52H,
      B57,
      B5BGL,
      B66,
      B707,
      B70713,
      B70732,
      B707AM,
      B707TT,
      B720,
      B720B,
      B720M,
      B720PH,
      B727,
      B72710,
      B72720,
      B737,
      B73710,
      B73712,
      B73720,
      B73730,
      B73740,
      B73750,
      B73760,
      B73770,
      B73780,
      B737AE,
      B737S,
      B747,
      B74710,
      B74720,
      B74730,
      B74740,
      B7474F,
      B747SP,
      B75,
      B757,
      B75720,
      B767,
      B76710,
      B76720,
      B76730,
      B7673T,
      B76740,
      B767AE,
      B767TC,
      B777,
      B77720,
      B77730,
      BA1257,
      BA1258,
      BA125S,
      BA14,
      BA146,
      BA1462,
      BA146Q,
      BA146S,
      BA15,
      BA2400,
      BA2500,
      BA748,
      BAC111,
      BAC145,
      BAC167,
      BAE125,
      BAE146,
      BAE748,
      BAETRI,
      BAEVIC,
      BATP,
      BC02,
      BC114B,
      BC17,
      BC18L,
      BC19,
      BC190D,
      BC200,
      BC2000,
      BC200A,
      BC200B,
      BC200C,
      BC200D,
      BC200E,
      BC200F,
      BC200G,
      BC200H,
      BC200K,
      BC200L,
      BC200M,
      BC200N,
      BC200P,
      BC200Q,
      BC200R,
      BC200S,
      BC200T,
      BC20BC,
      BC23,
      BC24,
      BC30,
      BC30LW,
      BC33,
      BC33FA,
      BC33FC,
      BC33L,
      BC35,
      BC350,
      BC35L,
      BC35V,
      BC36,
      BC36A,
      BC36AT,
      BC36L,
      BC36TC,
      BC400,
      BC400A,
      BC50,
      BC60,
      BC65,
      BC76,
      BC77,
      BC80,
      BC88,
      BC8S,
      BC90,
      BC90B,
      BC90C,
      BC90F,
      BC90SE,
      BC95,
      BCQU80,
      BCT42A,
      BCT42B,
      BCTWBE,
      BCV35B,
      BD10,
      BD12,
      BD700,
      BE12,
      BE205,
      BE205B,
      BE2063,
      BE2064,
      BE206A,
      BE206B,
      BE206G,
      BE206L,
      BE206T,
      BE209,
      BE209S,
      BE212T,
      BE230,
      BE30,
      BE300S,
      BE407,
      BE412,
      BE412C,
      BE42,
      BE427,
      BE430,
      BE442,
      BE45,
      BE58,
      BE6,
      BE609,
      BE620,
      BE901,
      BE99,
      BEKIO,
      BEKIOW,
      BELL,
      BEQU80,
      BER,
      BER103,
      BER200,
      BER32,
      BER32K,
      BER42,
      BERA,
      BERA45,
      BERA50,
      BERB,
      BERC,
      BERD,
      BERE,
      BERF,
      BERG,
      BERH,
      BERJ,
      BETA22,
      BGCMOD,
      BGL,
      BGR,
      BGRA,
      BGRB,
      BGRC,
      BGRCMO,
      BGRD,
      BGRE,
      BGRF,
      BGRG,
      BGRH,
      BGRJ,
      BGRK,
      BGRL,
      BH14,
      BH22,
      BHST,
      BJT400,
      BK117,
      BK117B,
      BK117C,
      BK117M,
      BK117P,
      BKF,
      BKFA,
      BKFB,
      BKFC,
      BL14,
      BL26,
      BL28,
      BL30,
      BL31,
      BLN,
      BLNA,
      BLNB,
      BLNC,
      BLNE,
      BN2,
      BN2A,
      BN2A3,
      BN2AB,
      BN2AEW,
      BN2ASW,
      BN2B,
      BN2BI,
      BN2BM,
      BN2T,
      BN2T1S,
      BN2T4R,
      BN2T4S,
      BN2TAL,
      BN2TED,
      BN2TI,
      BN2TIS,
      BN3,
      BN4000,
      BO105,
      BO105C,
      BO105D,
      BO105L,
      BO105M,
      BO105P,
      BO105T,
      BO106,
      BO108,
      BO115,
      BOE115,
      BOE18P,
      BOE18R,
      BOP,
      BOPAH,
      BR1050,
      BR1150,
      BR31,
      BRC707,
      BRE,
      BREA,
      BREB,
      BREC,
      BRED,
      BREE,
      BRFT,
      BRJ110,
      BRJ115,
      BRJ70,
      BRJ85,
      BRNG,
      BSN,
      BSNA,
      BSNB,
      BSNC,
      BT10,
      BT6S,
      BU20,
      BUC,
      BUCMK2,
      BULLAC,
      BULMK1,
      BULMK2,
      BV234,
      C020H,
      C022B,
      C0M500,
      C0M600,
      C101,
      C101BB,
      C101CC,
      C101DD,
      C101EB,
      C118,
      C118A,
      C118B,
      C119,
      C119A,
      C119G,
      C119J,
      C119JP,
      C119RQ,
      C12,
      C120,
      C121,
      C121G,
      C123,
      C123B,
      C123H,
      C123J,
      C123K,
      C123L,
      C123T,
      C124,
      C12A,
      C12F,
      C12FT,
      C12J,
      C130,
      C130A,
      C130B,
      C130C,
      C130D,
      C130E,
      C130F,
      C130G,
      C130H,
      C130H3,
      C130J,
      C130J3,
      C130K,
      C130M,
      C130MP,
      C130N,
      C130P,
      C130T,
      C131,
      C131CO,
      C131F,
      C131G,
      C131H,
      C133,
      C133A,
      C135,
      C135A,
      C135B,
      C135C,
      C135E,
      C135F,
      C135FR,
      C137B,
      C137C,
      C139A,
      C13OF,
      C14,
      C140,
      C140A,
      C141,
      C141B,
      C141C,
      C150,
      C152,
      C160,
      C160AL,
      C160AS,
      C160F,
      C160G,
      C160H,
      C160NG,
      C17,
      C170,
      C175,
      C177,
      C17A,
      C18,
      C180,
      C182,
      C188,
      C19,
      C190,
      C195,
      C19A,
      C1A,
      C1K,
      C1KAW,
      C1PR,
      C1S,
      C1T,
      C2,
      C20,
      C205,
      C206,
      C207,
      C207A,
      C208,
      C208CA,
      C20A,
      C20B,
      C20C,
      C20D,
      C20F,
      C20G,
      C20H,
      C20S,
      C21,
      C210,
      C212,
      C2121M,
      C2122M,
      C2123D,
      C2123E,
      C2123M,
      C2123P,
      C21240,
      C212A,
      C212C,
      C212M,
      C212P,
      C21A,
      C22,
      C223,
      C22J,
      C23,
      C233,
      C233FL,
      C235,
      C23A,
      C23ASU,
      C23SUN,
      C26,
      C26A,
      C26B,
      C27A,
      C27J,
      C295,
      C29A,
      C2A,
      C3,
      C303,
      C320,
      C32A,
      C335,
      C336,
      C337,
      C337G,
      C340,
      C3605,
      C37A,
      C38,
      C38A,
      C401,
      C402,
      C404,
      C411,
      C414,
      C42,
      C421,
      C425,
      C42R,
      C441,
      C45,
      C46,
      C461,
      C46A,
      C46FW,
      C47,
      C47A,
      C47DC3,
      C4M,
      C5,
      C500,
      C501,
      C501SP,
      C54,
      C54B,
      C54D,
      C550,
      C553,
      C560,
      C5A,
      C5B,
      C5C,
      C650,
      C7,
      C7A,
      C7DASH,
      C7KFIR,
      C8,
      C8A,
      C9,
      C91,
      C95,
      C95A,
      C95MAR,
      C97,
      C99,
      C9A,
      C9B,
      C9C,
      CA1,
      CA223A,
      CA223K,
      CA25,
      CA25E,
      CA25G,
      CA25I,
      CA25N,
      CA61MA,
      CA65,
      CA65A,
      CAL,
      CALA,
      CAM,
      CAN215,
      CANB2,
      CANBER,
      CANE13,
      CANPR7,
      CANPR9,
      CANT17,
      CANT1B,
      CANT4,
      CAP10,
      CAP10B,
      CAP231,
      CAP232,
      CASHA,
      CAT,
      CAYDEF,
      CAYU,
      CC108C,
      CC109,
      CC115,
      CC117,
      CC132D,
      CC138,
      CC142,
      CC144,
      CC3,
      CCH,
      CDR,
      CDRA,
      CE144A,
      CE206,
      CE208,
      CE310,
      CE337,
      CE414A,
      CE425,
      CE441,
      CE501,
      CE525,
      CE526,
      CE550,
      CE560,
      CE560E,
      CE650,
      CE660,
      CE670,
      CE750,
      CEAGH,
      CEAGT,
      CECON1,
      CECON2,
      CET41A,
      CET41B,
      CET41D,
      CET47A,
      CF00,
      CF101,
      CF104,
      CF18,
      CF18A,
      CF18B,
      CF5,
      CF5A,
      CF5D,
      CF5F,
      CG,
      CH10,
      CH113,
      CH113A,
      CH118,
      CH124,
      CH124B,
      CH135,
      CH135A,
      CH135I,
      CH136,
      CH136J,
      CH146,
      CH147,
      CH200,
      CH2000,
      CH250,
      CH3,
      CH34,
      CH34A,
      CH34D,
      CH34SP,
      CH37,
      CH3E,
      CH40,
      CH46,
      CH46A,
      CH46D,
      CH46E,
      CH46F,
      CH47,
      CH47A,
      CH47B,
      CH47C,
      CH47D,
      CH47J,
      CH47JA,
      CH5,
      CH50,
      CH53,
      CH53A,
      CH53B,
      CH53C,
      CH53D,
      CH53DG,
      CH53E,
      CH53ES,
      CH53G,
      CH54,
      CH54A,
      CH54B,
      CH54LS,
      CH54SC,
      CH55,
      CH601H,
      CH601S,
      CH7,
      CH701,
      CH8,
      CH9,
      CHALC,
      CHE22,
      CHE25,
      CHEROK,
      CHETA,
      CHEY,
      CHGZ11,
      CHGZ8,
      CHIEF,
      CHIII,
      CHIP,
      CHK91,
      CHKII,
      CHKIII,
      CHM1,
      CJ5,
      CJ6A,
      CKP,
      CL214,
      CL215,
      CL2156,
      CL215T,
      CL41,
      CL415,
      CL415M,
      CL41G,
      CL44,
      CL600,
      CL600C,
      CL601,
      CL601C,
      CL604,
      CL66,
      CLD,
      CLK,
      CLKA,
      CLN,
      CLNA,
      CLO,
      CLR,
      CLRA,
      CLRB,
      CLRC,
      CLT,
      CM170,
      CM175,
      CM48,
      CMAU,
      CMCLEO,
      CMK1,
      CMK3,
      CMMK1,
      CMMK2,
      CMMK2E,
      CMMK3,
      CMMK4,
      CMP,
      CN235,
      CN2351,
      CN2352,
      CN2353,
      CN235A,
      CN235M,
      CN245,
      CND,
      CNDA,
      CNDB,
      CO114B,
      CO681B,
      CO685,
      CO690,
      COC,
      COCH,
      COD,
      COK,
      COM500,
      COM560,
      COM600,
      COMAN,
      COMM1,
      COMM2A,
      COMM3,
      CON202,
      CON303,
      CON606,
      CONF27,
      CONTUR,
      CORA,
      COT,
      COTA,
      COTB,
      COUMK1,
      COUMK2,
      COURS7,
      CP121,
      CP140,
      CP140A,
      CR100,
      CR110,
      CRT,
      CRU,
      CS2FA,
      CSH,
      CSH2,
      CSHA,
      CT114,
      CT133,
      CT134,
      CT134A,
      CT142,
      CT33,
      CT39,
      CT39A,
      CT39E,
      CT39F,
      CT39G,
      CT4,
      CT43A,
      CT4A,
      CT50,
      CUB,
      CUBA,
      CUBB,
      CUBC,
      CUBD,
      CUF,
      CUR,
      CURB,
      CURLA,
      CV13,
      CV14,
      CV22,
      CV22A,
      CV24,
      CV34,
      CV440,
      CV580,
      CV60,
      CV64,
      CV880,
      CV99,
      CX3,
      CX3B,
      CX3C,
      CXX1,
      CXX2,
      D139,
      D139P1,
      D22811,
      D22821,
      D328,
      D32810,
      D32811,
      D32812,
      D32813,
      D32821,
      D32830,
      D32850,
      D32870,
      DA01,
      DA10,
      DA20,
      DA2000,
      DA20A1,
      DA20C1,
      DA2A,
      DA40,
      DA50,
      DALD4,
      DAUPH,
      DC10,
      DC1015,
      DC101C,
      DC1030,
      DC103C,
      DC103F,
      DC1040,
      DC10CF,
      DC114,
      DC130,
      DC130A,
      DC130H,
      DC3,
      DC4,
      DC6,
      DC6B,
      DC6C,
      DC7,
      DC7B,
      DC8,
      DC810,
      DC820,
      DC830,
      DC843,
      DC850,
      DC854,
      DC855,
      DC860,
      DC861,
      DC862,
      DC863,
      DC870,
      DC871,
      DC873,
      DC8F,
      DC8SAR,
      DC9,
      DC910,
      DC910M,
      DC920,
      DC930,
      DC932,
      DC940,
      DC950,
      DC951,
      DC9F30,
      DC9M,
      DEDE2,
      DELFIN,
      DG14,
      DH10,
      DH114A,
      DH114B,
      DH2T,
      DH60,
      DH62,
      DH64,
      DH80,
      DH82,
      DH83,
      DH87,
      DH89,
      DH98,
      DHC1,
      DHC1T1,
      DHC1T3,
      DHC2,
      DHC2A2,
      DHC2M3,
      DHC3,
      DHC3U1,
      DHC4,
      DHC4A,
      DHC5,
      DHC5D,
      DHC5E,
      DHC6,
      DHC610,
      DHC620,
      DHC630,
      DHC63M,
      DHC63R,
      DHC63S,
      DHC7,
      DHC7R,
      DHC8,
      DHC810,
      DHC820,
      DHC830,
      DHC840,
      DHC8M,
      DHC8TR,
      DHCAL2,
      DHCCSR,
      DHCT10,
      DHCT30,
      DINGO,
      DK10D,
      DO128,
      DO1282,
      DO1286,
      DO228,
      DO2281,
      DO228A,
      DO228B,
      DO228C,
      DO228D,
      DO228M,
      DO228P,
      DO27,
      DO28,
      DO28D,
      DO28D1,
      DO28DT,
      DO328,
      DO328J,
      DO528J,
      DOAJ,
      DOM,
      DOMIN,
      DP60,
      DP6000,
      DP800,
      DPN,
      DR400,
      DR4001,
      DR4006,
      DR4012,
      DR4016,
      DR4018,
      DR401R,
      DR4020,
      DR402R,
      DSH,
      DUB60,
      DUBNA2,
      DV20,
      DV40,
      E1S,
      E2,
      E25,
      E26,
      E2A,
      E2B,
      E2C,
      E2EST,
      E3,
      E3A,
      E3B,
      E3C,
      E3D,
      E3DMK1,
      E3F,
      E3INT,
      E3NTC,
      E4,
      E4A,
      E4AN,
      E4B,
      E4BN,
      E4TN,
      E6,
      E6A,
      E6B,
      E767,
      E8,
      E8A,
      E8B,
      E8C,
      E8D,
      E9A,
      EA1KF,
      EA3B,
      EA4F,
      EA4J,
      EA6,
      EA6A,
      EA6B,
      EA6I,
      EA7L,
      EA7OPT,
      EAV8B,
      EB57B,
      EB66,
      EC018D,
      EC1,
      EC120B,
      EC121,
      EC121K,
      EC130,
      EC130B,
      EC130C,
      EC130E,
      EC130G,
      EC130H,
      EC130J,
      EC130L,
      EC130Q,
      EC130V,
      EC135,
      EC135A,
      EC135C,
      EC135E,
      EC135G,
      EC135H,
      EC135J,
      EC135K,
      EC135L,
      EC135P,
      EC135Y,
      EC137D,
      EC145,
      EC165,
      EC18,
      EC18B,
      EC18C,
      EC18D,
      EC24A,
      EC35A,
      EC635,
      EC6CRI,
      EC95,
      ECSUP5,
      ECURE,
      EF111,
      EF111A,
      EF111G,
      EF18A,
      EF18B,
      EF4,
      EF4B,
      EF4G,
      EF4J,
      EFA,
      EH1,
      EH101,
      EH1011,
      EH1012,
      EH1013,
      EH1014,
      EH1015,
      EH1H,
      EH1X,
      EH60,
      EH60A,
      EH60B,
      EH60C,
      EH60QF,
      EH6DEF,
      EKA3B,
      ELITE,
      EM110C,
      EM111,
      EM111A,
      EM11P1,
      EM11P2,
      EM120,
      EM1211,
      EM121A,
      EM135,
      EM145,
      EM145R,
      EM145S,
      EM170,
      EM201,
      EM312,
      EM312F,
      EM312H,
      EM326G,
      EM710,
      EM711,
      EM720D,
      EM810,
      EM810C,
      EM810D,
      EMB100,
      EMB110,
      EMB111,
      EMB120,
      EMB121,
      EMB211,
      EMB212,
      EMB21A,
      EMB312,
      EMB326,
      EMBRAC,
      EMS312,
      ENS28,
      ENS28F,
      ENS28L,
      ENS480,
      ENTH28,
      EP2J,
      EP3,
      EP3A,
      EP3B,
      EP3E,
      EP3J,
      ERA3B,
      ES2D,
      ES3A,
      ESQ,
      ETE4MP,
      ETEN4,
      ETEN4M,
      ETEN4P,
      ETEND,
      ETENDH,
      ETENSU,
      EUROFA,
      EX200,
      EX300,
      EX400,
      EXC,
      EXEC90,
      F02,
      F10,
      F100,
      F100A,
      F100D,
      F100F,
      F101G,
      F102,
      F104,
      F104A,
      F104B,
      F104C,
      F104CF,
      F104D,
      F104DJ,
      F104F,
      F104G,
      F104J,
      F104S,
      F104SA,
      F105,
      F105G,
      F106,
      F106A,
      F10J10,
      F111,
      F111A,
      F111B,
      F111C,
      F111D,
      F111E,
      F111F,
      F111G,
      F111K,
      F117,
      F117A,
      F12,
      F1300N,
      F14,
      F14A,
      F14AP,
      F14B,
      F14D,
      F14MOD,
      F15,
      F15A,
      F15B,
      F15C,
      F15D,
      F15DJ,
      F15E,
      F15F,
      F15I,
      F15J,
      F15S,
      F16,
      F16A,
      F16B,
      F16C,
      F16CG,
      F16CJ,
      F16D,
      F16ES,
      F16N,
      F18,
      F18A,
      F18B,
      F18C,
      F18D,
      F18DRC,
      F18E,
      F18F,
      F1HNTR,
      F1MSI,
      F2,
      F21,
      F22,
      F220,
      F220AI,
      F222,
      F22A,
      F22B,
      F22PHO,
      F22PIN,
      F22R,
      F27,
      F27100,
      F27200,
      F27300,
      F27400,
      F27500,
      F27600,
      F27A,
      F27AV,
      F27KB,
      F27M,
      F27M4M,
      F27ME,
      F27SEN,
      F28,
      F28100,
      F2810C,
      F28200,
      F28300,
      F28400,
      F28F,
      F28FP,
      F28FX,
      F2A,
      F2LTNG,
      F3,
      F33,
      F337,
      F337F,
      F33A,
      F35,
      F4,
      F4062,
      F406CA,
      F42000,
      F45A,
      F45B,
      F4A,
      F4B,
      F4C,
      F4D,
      F4E,
      F4EJ,
      F4EJK,
      F4F,
      F4G,
      F4J,
      F4K,
      F4M,
      F4N,
      F4S,
      F4X20,
      F5,
      F50,
      F5A,
      F5B,
      F5C,
      F5D,
      F5E,
      F5F,
      F6,
      F6FARM,
      F7,
      F7A,
      F7B,
      F7BS,
      F7C,
      F7M,
      F7MG,
      F7P,
      F8,
      F82,
      F84,
      F86F,
      F86M32,
      F8A,
      F8CRUS,
      F8E,
      F8F,
      F8FB,
      F8FB2,
      F8FISH,
      F8H,
      F8LFAL,
      F9,
      F9A,
      F9CG,
      FA18,
      FA18A,
      FA18B,
      FA18C,
      FA18D,
      FA18L,
      FA2,
      FA20,
      FA2050,
      FA25,
      FA3,
      FA50,
      FA62,
      FA71,
      FAG,
      FAL10,
      FAL100,
      FAL10M,
      FAL20,
      FAL200,
      FAL205,
      FAL21,
      FAL21M,
      FAL2T,
      FAL50,
      FAL900,
      FAL90B,
      FAL90E,
      FALCN,
      FALCN1,
      FALCN2,
      FALCN5,
      FALMYS,
      FB111,
      FB111A,
      FB111G,
      FBA2E,
      FBD,
      FBDA,
      FBDB,
      FBDC,
      FBDD,
      FBDE,
      FBDF,
      FBDH,
      FBDJ,
      FBDK,
      FBDL,
      FBDN,
      FBR,
      FBRA,
      FBRB,
      FCM,
      FCMA,
      FCMB,
      FCMBAZ,
      FCMC,
      FCMD,
      FDL,
      FDLB,
      FDLC,
      FEN,
      FENA,
      FENB,
      FENC,
      FENCEF,
      FEND,
      FENE,
      FG1,
      FG1A,
      FGA5,
      FGA6,
      FGA7A,
      FGR2,
      FH1100,
      FH227,
      FHD,
      FICR,
      FIREB,
      FISHJX,
      FIT,
      FITA,
      FITB,
      FITC,
      FITD,
      FITE,
      FITF,
      FITG,
      FITH,
      FITJ,
      FITK,
      FK27,
      FLANKK,
      FLG,
      FLGA,
      FLGC,
      FLGD,
      FLGE,
      FLGF,
      FLGG,
      FLK,
      FLKA,
      FLKB,
      FLKC,
      FLO,
      FLOA,
      FLOB,
      FLOC,
      FLOD,
      FLOE,
      FLOF,
      FLOG,
      FLOGA,
      FLOGD,
      FLOGJ,
      FLOGJ2,
      FLOH,
      FLOJ,
      FLOK,
      FLT,
      FLTMAS,
      FMK2,
      FMK3,
      FMR,
      FMRA,
      FMRB,
      FMRC,
      FMRD,
      FMRE,
      FMRF,
      FNB,
      FOK13,
      FOK50,
      FOK50M,
      FOK60,
      FOK70,
      FOKER,
      FOR,
      FORA,
      FORB,
      FOX,
      FOXA,
      FOXB,
      FOXC,
      FOXD,
      FOXE,
      FOXF,
      FPT,
      FR74S,
      FRBI5,
      FRE,
      FREA,
      FREB,
      FREC,
      FRED,
      FREE,
      FREEFI,
      FREEST,
      FRELON,
      FRF,
      FRFA,
      FRFB,
      FS1000,
      FS3000,
      FS4000,
      FT337,
      FT7,
      FTB337,
      FU2495,
      FUJI,
      FUL,
      FXH,
      FXHA,
      FXHB,
      G115HE,
      G115TA,
      G164,
      G21,
      G22228,
      G222AL,
      G222EC,
      G222GE,
      G222R,
      G222RM,
      G222SA,
      G222T,
      G222VA,
      G222VS,
      G28,
      G2A,
      G44,
      G4SEAG,
      G4SG,
      G500,
      G520,
      G73,
      G91,
      G91R1,
      G91R3,
      G91R4,
      G91SM,
      G91T1,
      G91T3,
      G91Y,
      G91YEH,
      GA7,
      GA84,
      GABR,
      GAJ,
      GAK22,
      GARD2,
      GARD50,
      GAT,
      GAT23,
      GAT24A,
      GAT25,
      GAT28,
      GAT29,
      GAT35,
      GAT35A,
      GAT36,
      GAT54,
      GAT55,
      GATT1,
      GATT1D,
      GAV,
      GC1,
      GE6650,
      GEN,
      GF1,
      GF200,
      GF250,
      GF300,
      GF350,
      GH125,
      GHMC4,
      GHTMK2,
      GHTMK3,
      GJSA30,
      GLAS2S,
      GLAS3,
      GLASTA,
      GLB,
      GLOEX,
      GM01,
      GNAT,
      GNAT1,
      GNAT2,
      GOAIRT,
      GOM,
      GR1,
      GR1A,
      GR1J,
      GR3,
      GR4,
      GR4A,
      GR5,
      GR7,
      GRMK1,
      GUL2B,
      GUL4B,
      GUL4MP,
      GUL4SP,
      GUL5,
      GULI,
      GULII,
      GULIII,
      GULIV,
      H13,
      H16E,
      H16M1,
      H19,
      H23A,
      H2X,
      H3,
      H34,
      H36,
      H37,
      H5,
      H500,
      H500C,
      H500D,
      H500E,
      H500F,
      H500M,
      H500MD,
      H500ME,
      H53E,
      H57,
      H5BGL,
      H5HAR,
      H6,
      H7,
      H7482B,
      H74B,
      H76,
      H76N,
      H76SIK,
      HA1ESQ,
      HA200,
      HAB205,
      HAK100,
      HAK200,
      HAK50,
      HAK60,
      HAKT1A,
      HAKT1W,
      HAKTM1,
      HALSHA,
      HANSA2,
      HANSA3,
      HAR,
      HAR10,
      HARBH5,
      HARBZ5,
      HARGM3,
      HARGM4,
      HARII,
      HARIIP,
      HARKEB,
      HARTM6,
      HARV,
      HAS1,
      HAS2,
      HAS3,
      HAS31B,
      HAS3L,
      HAS4L,
      HASMK2,
      HASMK5,
      HASMK6,
      HASMK8,
      HAT21,
      HAW100,
      HAW400,
      HAW80,
      HAW80F,
      HAW80M,
      HAW80R,
      HAW80S,
      HAW80X,
      HAW8SM,
      HAZ,
      HAZA,
      HAZAPL,
      HAZB,
      HAZBT,
      HAZCPS,
      HB207,
      HB315B,
      HB315G,
      HB315L,
      HB350,
      HB350B,
      HB355F,
      HB35B1,
      HB42,
      HB43,
      HC1,
      HC130,
      HC130B,
      HC130E,
      HC130H,
      HC130N,
      HC130P,
      HC131A,
      HC2,
      HC7,
      HCC2,
      HCC412,
      HCM3,
      HCMK1,
      HCMK1K,
      HCMK3,
      HCMK4,
      HCMK5,
      HD21,
      HE1,
      HE4,
      HEB320,
      HEL,
      HERON,
      HF24,
      HF241T,
      HF24M1,
      HF24MT,
      HFB320,
      HGRM1,
      HGRM1A,
      HGRM3,
      HGRM5,
      HGRM7,
      HH1,
      HH1H,
      HH1K,
      HH1SAR,
      HH2,
      HH25A,
      HH2D,
      HH3APL,
      HH3ASR,
      HH3E,
      HH3SAR,
      HH4,
      HH42,
      HH42B,
      HH43F,
      HH46,
      HH46A,
      HH52,
      HH52A,
      HH52AS,
      HH52S,
      HH53,
      HH53A,
      HH53B,
      HH53C,
      HH53E,
      HH53H,
      HH60A,
      HH60D,
      HH60G,
      HH60H,
      HH60J,
      HH60JA,
      HH65,
      HH65II,
      HIINF,
      HIN,
      HINA,
      HINB,
      HINC,
      HIND,
      HINE,
      HINF,
      HING2,
      HINR,
      HINW,
      HIP,
      HIPA,
      HIPB,
      HIPC,
      HIPD,
      HIPE,
      HIPF,
      HIPG,
      HIPH,
      HIPJ,
      HIPJ1,
      HIPK,
      HIPK1,
      HIPK17,
      HJ5,
      HJT161,
      HJT162,
      HKM,
      HKMA,
      HKP10,
      HKP2,
      HKP2II,
      HKP3,
      HKP4,
      HKP5,
      HKP6,
      HKP7,
      HLX,
      HLXA,
      HLXB,
      HLXC,
      HLXD,
      HM1,
      HN32,
      HN433,
      HN600,
      HND,
      HNDA,
      HNDB,
      HNDC,
      HNDP,
      HOD,
      HODA,
      HODB,
      HOFH40,
      HOK,
      HOKA,
      HOKB,
      HOKC,
      HOM,
      HOP,
      HOR,
      HORA,
      HORB,
      HORC,
      HP,
      HP13,
      HPT32,
      HR55,
      HRK,
      HRKA,
      HRKB,
      HRKKB,
      HS1182,
      HS125,
      HS1254,
      HS1256,
      HS1257,
      HS1258,
      HS146,
      HS1462,
      HS25,
      HS650,
      HS748,
      HS7481,
      HS7482,
      HS7483,
      HS748A,
      HS748C,
      HS801M,
      HT17,
      HTM1,
      HTMK10,
      HTMK2,
      HTMK2A,
      HTMK4,
      HTMK4A,
      HTMK4N,
      HTT34,
      HU16,
      HU16B,
      HU16C,
      HU16E,
      HU25,
      HU25A,
      HU25B,
      HU25C,
      HU2PET,
      HU300C,
      HU5,
      HUG269,
      HUG300,
      HUG369,
      HUG500,
      HUNT8M,
      HUNTER,
      HUS1A,
      HVC,
      HVCA,
      HW5,
      HYDRO2,
      I1123,
      I1124,
      I1L,
      I22,
      I23,
      IA101,
      IA1123,
      IA1124,
      IA1125,
      IA202,
      IA316B,
      IA330,
      IA35,
      IA50,
      IA58,
      IA58A,
      IA58B,
      IA63,
      IA66,
      IAI,
      IAI201,
      IAIGAL,
      IAK52,
      IAR109,
      IAR28M,
      IAR316,
      IAR317,
      IAR330,
      IAR33L,
      IAR46,
      IAR705,
      IAR823,
      IAR825,
      IAR831,
      IAR93,
      IAR93O,
      IAR99,
      IL103,
      IL106,
      IL112,
      IL114,
      IL114C,
      IL114F,
      IL114M,
      IL114P,
      IL114T,
      IL12,
      IL14,
      IL14P,
      IL18,
      IL18A,
      IL18D,
      IL20,
      IL22,
      IL24N,
      IL28,
      IL28BB,
      IL28RB,
      IL28U,
      IL38,
      IL38P,
      IL62,
      IL62M,
      IL62MK,
      IL76,
      IL7697,
      IL76A5,
      IL76AE,
      IL76K,
      IL76LL,
      IL76M,
      IL76MD,
      IL76MF,
      IL76MK,
      IL76MP,
      IL76SK,
      IL76T,
      IL76TD,
      IL76TF,
      IL78,
      IL781,
      IL78M,
      IL78MI,
      IL82,
      IL86,
      IL87,
      IL9630,
      IL96M,
      IL96MK,
      IL96T,
      IMPM2,
      IMPMK2,
      IMPX,
      IP6201,
      IPE04,
      IR02,
      IR12,
      IRH5,
      IS2,
      ISK,
      ISST50,
      J1,
      J10,
      J1EJ,
      J1J,
      J2,
      J22,
      J32,
      J32B,
      J32D,
      J32E,
      J35,
      J35A,
      J35B,
      J35D,
      J35F,
      J35F1,
      J35F2,
      J35J,
      J35S,
      J35X,
      J35XD,
      J37,
      J37A,
      J39,
      J4,
      J5,
      J6,
      J7,
      J8,
      JABIRU,
      JAG,
      JAGA,
      JAGB,
      JAGE,
      JAGGR1,
      JAGINT,
      JAGM,
      JAGS,
      JAGSC,
      JAGT2,
      JAH1T,
      JAS39,
      JAS39A,
      JAS39B,
      JAS39C,
      JAS39D,
      JC130,
      JC130H,
      JCR450,
      JCR500,
      JCR650,
      JGRM1A,
      JGRMK1,
      JGRMK3,
      JH46E,
      JH7,
      JP1000,
      JP840,
      JP900,
      JP980,
      JS31,
      JS41,
      JS51,
      JS61,
      JSB,
      JSS31,
      JSTMK1,
      JTM2B,
      JTMK2,
      JTMK4,
      JU200,
      K107A,
      K107A2,
      K107A3,
      K107A4,
      K107AS,
      K1200,
      K18,
      K2,
      K250,
      K8,
      KA115,
      KA126B,
      KA15,
      KA226,
      KA25,
      KA25A,
      KA25B,
      KA25C,
      KA27PL,
      KA27PS,
      KA28,
      KA29A,
      KA29B,
      KA31,
      KA32,
      KA3211,
      KA3212,
      KA32A,
      KA32A1,
      KA32A2,
      KA32A3,
      KA32A7,
      KA3B,
      KA40,
      KA50,
      KA50N,
      KA52,
      KA6,
      KA62,
      KA62M,
      KA6A,
      KA6D,
      KA6H,
      KA7,
      KA840,
      KANIA,
      KANMI2,
      KATRAN,
      KAXX,
      KBMK2,
      KC10,
      KC10A,
      KC130,
      KC130F,
      KC130H,
      KC130Q,
      KC130R,
      KC130T,
      KC135,
      KC135A,
      KC135E,
      KC135F,
      KC135Q,
      KC135R,
      KC135T,
      KC137,
      KC13T3,
      KC707,
      KC747,
      KC8,
      KC97,
      KDC10,
      KE3A,
      KFIR,
      KFIRC2,
      KFIRC7,
      KFIRLC,
      KFIRR2,
      KFIRT2,
      KFIRT7,
      KH4,
      KIN44,
      KIOWA,
      KIRM1,
      KIRM1A,
      KIRM2,
      KIRMII,
      KMH,
      KORSHU,
      KORVET,
      KS3A,
      KTX1,
      KTX2,
      KUDU,
      KV07A5,
      KV107A,
      KV107S,
      KV107T,
      L100,
      L10020,
      L10030,
      L1003H,
      L100J,
      L1011,
      L10110,
      L10111,
      L10112,
      L10115,
      L1011A,
      L1011E,
      L1011F,
      L1011K,
      L1049,
      L11115,
      L159,
      L159T,
      L164,
      L18,
      L188,
      L188A,
      L188C,
      L19,
      L20,
      L21,
      L235BB,
      L29,
      L29A,
      L29CZ,
      L29DEL,
      L29R,
      L382G,
      L39,
      L39C,
      L39D,
      L39MS,
      L39V,
      L39Z,
      L39Z0,
      L39ZA,
      L410,
      L410A,
      L410U,
      L410UE,
      L420,
      L430,
      L450,
      L59E,
      L59T,
      L610G,
      L649,
      L70,
      L70VIN,
      L749,
      L90,
      LA25,
      LA250,
      LA270,
      LA4200,
      LADO0,
      LADO6,
      LAKX,
      LAN320,
      LAN360,
      LAN4,
      LAN4P,
      LANC,
      LANES,
      LANLC4,
      LANSES,
      LAR,
      LARK,
      LASEWO,
      LASTA1,
      LASTA2,
      LBAT,
      LC130,
      LC130F,
      LC130H,
      LC130R,
      LGTT5,
      LHASM2,
      LHASM3,
      LHASM4,
      LHM2,
      LHM53,
      LI2,
      LIGHT,
      LIM1,
      LIM6,
      LJ24,
      LJ24A,
      LJ25,
      LJ25A,
      LJ31,
      LJ31A,
      LJ35,
      LJ35A,
      LJ36A,
      LJ45,
      LJ55,
      LJ55B,
      LJ55C,
      LJ60,
      LR1,
      LR2,
      LX8,
      LYAH1G,
      LYAHM5,
      LYAHM7,
      LYAHM9,
      LYHAM3,
      LYHMM8,
      LYHS2F,
      LYHS4F,
      LYHSM2,
      LYM21A,
      LYM88A,
      LYMK21,
      LYMK23,
      LYMK25,
      LYMK27,
      LYMK28,
      LYMK80,
      LYMK81,
      LYMK86,
      LYMK88,
      LYMK89,
      LYMK90,
      LYMK95,
      LYMK99,
      LYS100,
      LYS200,
      LYS300,
      M101TG,
      M102,
      M102DS,
      M112,
      M15UTI,
      M17MYS,
      M18DRO,
      M2000,
      M20005,
      M2000B,
      M2000C,
      M2000D,
      M2000E,
      M2000I,
      M2000M,
      M2000N,
      M2000Y,
      M2009,
      M201SO,
      M202,
      M21B1,
      M21BIS,
      M21UM,
      M21US,
      M2600A,
      M2601L,
      M262,
      M26ISK,
      M28ST,
      M290TP,
      M4,
      M4000,
      M404,
      M50,
      M5000,
      M58MAS,
      M5F,
      MAA,
      MADCAP,
      MAI,
      MAR,
      MARMK,
      MARMK2,
      MART,
      MARUT,
      MARWND,
      MAS,
      MASCOT,
      MASH,
      MATAD,
      MAX,
      MAY,
      MB312,
      MB326,
      MB326A,
      MB326B,
      MB326D,
      MB326F,
      MB326G,
      MB326H,
      MB326K,
      MB326L,
      MB326M,
      MB326X,
      MB339,
      MB339A,
      MB339B,
      MB339C,
      MB339D,
      MB339E,
      MB339K,
      MB339M,
      MB339V,
      MB39CB,
      MBB223,
      MC130,
      MC130E,
      MC130H,
      MC130P,
      MCP,
      MD11,
      MD11C,
      MD11CF,
      MD11ER,
      MD11F,
      MD17,
      MD500,
      MD500B,
      MD500C,
      MD500D,
      MD500E,
      MD50M,
      MD50MD,
      MD50ME,
      MD50MG,
      MD520N,
      MD530,
      MD530F,
      MD600N,
      MD80,
      MD81,
      MD82,
      MD82T,
      MD83,
      MD87,
      MD88,
      MD90,
      MD900,
      MD903,
      MD903E,
      MD903T,
      MD920,
      MD95,
      MD953,
      MD955,
      MDG,
      MDN,
      MDS,
      ME29,
      MEM20,
      MER2,
      MER23,
      MER23E,
      MER2A,
      MER2B,
      MER3,
      MER3B,
      MER4,
      MERHC3,
      MERHM2,
      MET2,
      MET23,
      MET23C,
      MET23D,
      MET2A,
      MET3,
      MF1CR,
      MF1CR2,
      MF1CT,
      MF1EQ,
      MF1R,
      MFI15,
      MFI17,
      MFI18,
      MG21MF,
      MG21PA,
      MG21PF,
      MG21PS,
      MG21R,
      MG21RF,
      MG21SM,
      MG21U,
      MG21UM,
      MG21US,
      MG23MF,
      MG23ML,
      MG23MS,
      MG23SM,
      MG23UB,
      MG23UM,
      MG25BM,
      MG25RB,
      MG25RK,
      MG25RU,
      MG29ME,
      MG29NU,
      MG29SD,
      MG29SE,
      MG29SM,
      MG29UB,
      MG31BS,
      MGS6,
      MGS8,
      MH1521,
      MH47,
      MH47D,
      MH47E,
      MH53,
      MH53E,
      MH53ED,
      MH53EP,
      MH53ES,
      MH53H,
      MH53J,
      MH6,
      MH60,
      MH60A,
      MH60G,
      MH60K,
      MH60L,
      MH6B,
      MI1,
      MI10,
      MI10K,
      MI12,
      MI14,
      MI14BT,
      MI14GP,
      MI14P,
      MI14PL,
      MI14PM,
      MI14PS,
      MI14PW,
      MI17,
      MI171,
      MI171V,
      MI172,
      MI17P,
      MI17Z,
      MI2,
      MI22,
      MI24,
      MI24A,
      MI24BM,
      MI24DU,
      MI24ES,
      MI24K,
      MI24P,
      MI24PS,
      MI24RK,
      MI24V,
      MI24VM,
      MI24VP,
      MI26,
      MI26A,
      MI26M,
      MI26MS,
      MI26T,
      MI26TM,
      MI26TS,
      MI26TZ,
      MI27,
      MI28,
      MI28N,
      MI34,
      MI34A,
      MI34S,
      MI34VA,
      MI35,
      MI35D,
      MI35M,
      MI35P,
      MI38,
      MI40,
      MI52,
      MI54,
      MI58,
      MI6A,
      MI6AY,
      MI6T,
      MI6VKP,
      MI8,
      MI8AT,
      MI8BT,
      MI8K,
      MI8MT,
      MI8MTV,
      MI8P,
      MI8PPA,
      MI8PS,
      MI8R,
      MI8S,
      MI8SMV,
      MI8T,
      MI8TB,
      MI8TBK,
      MI8TG,
      MI8TM,
      MI8TP,
      MI8TV,
      MI8TZ,
      MI8VIP,
      MI8VZP,
      MI9HPG,
      MID,
      MIDFAG,
      MIG110,
      MIG142,
      MIG15,
      MIG15U,
      MIG21B,
      MIG21F,
      MIG21L,
      MIG21M,
      MIG23B,
      MIG23M,
      MIG23S,
      MIG25M,
      MIG25R,
      MIG25U,
      MIG27,
      MIG27M,
      MIG29K,
      MIG29M,
      MIG29N,
      MIG29S,
      MIG31B,
      MIG31D,
      MIG31M,
      MIG33,
      MIG35,
      MIGAS,
      MIGAT,
      MIGATS,
      MIGLFI,
      MILL,
      MILTR,
      MINI50,
      MIR3,
      MIR3A,
      MIR3AD,
      MIR3BS,
      MIR3BZ,
      MIR3C,
      MIR3CJ,
      MIR3CZ,
      MIR3D,
      MIR3D2,
      MIR3DO,
      MIR3DZ,
      MIR3E,
      MIR3EA,
      MIR3EB,
      MIR3EE,
      MIR3EL,
      MIR3EP,
      MIR3EV,
      MIR3EZ,
      MIR3O,
      MIR3R2,
      MIR3RP,
      MIR3RS,
      MIR3S,
      MIR4P,
      MIR5,
      MIR5BA,
      MIR5BD,
      MIR5BR,
      MIR5CA,
      MIR5CD,
      MIR5CR,
      MIR5D,
      MIR5DA,
      MIR5DD,
      MIR5DE,
      MIR5DG,
      MIR5DM,
      MIR5DR,
      MIR5DV,
      MIR5E,
      MIR5F,
      MIR5M,
      MIR5P,
      MIR5PA,
      MIR5R,
      MIR5RA,
      MIR5SD,
      MIR5V,
      MIREAD,
      MIRF1,
      MIRF1A,
      MIRF1B,
      MIRF1C,
      MIRF1D,
      MIRF1E,
      MIRF1R,
      MIST10,
      MIST20,
      MIST50,
      MIV,
      MJ53AU,
      MJ5SCI,
      MK1,
      MK1NIM,
      MK2,
      MK21,
      MK23,
      MK25,
      MK27,
      MK2A,
      MK2ACM,
      MK2C,
      MK2GNT,
      MK3,
      MK4,
      MK41,
      MK42,
      MK42A,
      MK42B,
      MK45,
      MK47,
      MK48,
      MK50,
      MK8,
      MK80,
      MK80LX,
      MK81,
      MK86,
      MK86LX,
      MK88,
      MK88LX,
      MK89,
      MKADV,
      ML1000,
      MMD,
      MNG,
      MO10,
      MO20,
      MO20JM,
      MO20KE,
      MO20MT,
      MO20RO,
      MO21,
      MO22,
      MO2J,
      MO2K,
      MOG,
      MOGA,
      MOGB,
      MOGC,
      MOL1,
      MOL100,
      MOL300,
      MOL400,
      MOM2M,
      MOM400,
      MONGOL,
      MONGOS,
      MOO,
      MOSS,
      MOU,
      MOUJIK,
      MR1,
      MR1A,
      MR2,
      MR3,
      MRC,
      MRCAN,
      MS760,
      MU2,
      MU2A,
      MU2B,
      MU2C,
      MU2D,
      MU2E,
      MU2F,
      MU2G,
      MU2J,
      MU2JMQ,
      MU2K,
      MU2S,
      MU3,
      MUREN2,
      MURENS,
      MUSH,
      MUSR25,
      MV22,
      MX1,
      MX2,
      MY104,
      MY20,
      MYSTB2,
      MYSTF,
      MYSTS,
      N145,
      N2130,
      N22,
      N22A,
      N22B,
      N22BMI,
      N22MIS,
      N24,
      N24A,
      N250,
      N25010,
      N2501F,
      N262,
      N262A,
      N262B,
      N262C,
      N262D,
      N270,
      N5A,
      N621,
      N821,
      NA1,
      NA16,
      NAC100,
      NAS332,
      NBE407,
      NBE412,
      NBE430,
      NBO105,
      NC130,
      NC130A,
      NC130E,
      NC130H,
      NC141A,
      NC212,
      NC2121,
      NC2122,
      NCH46,
      ND2501,
      ND2504,
      ND262C,
      ND3202,
      ND3400,
      NEACP,
      NEIVAR,
      NEIVAU,
      NESHD,
      NF4J,
      NF5,
      NF5A,
      NF5B,
      NH90,
      NH90NF,
      NH90TT,
      NHH2D,
      NIM1,
      NIM2,
      NIM200,
      NIMA3,
      NIMMK3,
      NIMMR1,
      NIMMR2,
      NIMR1,
      NKC135,
      NMM300,
      NMSP20,
      NOGA6,
      NORD,
      NP3A,
      NRD626,
      NSTR,
      NU1B,
      NUH1E,
      NY4,
      NY5,
      O1,
      O14,
      O1A,
      O1B,
      O1C,
      O1E,
      O1G,
      O2,
      O2337S,
      O29,
      O2A,
      O2B,
      OA010A,
      OA10,
      OA37,
      OA4,
      OA4M,
      OBS2,
      OC135B,
      OH1,
      OH13,
      OH13G,
      OH13H,
      OH13J,
      OH13K,
      OH13S,
      OH23,
      OH23A,
      OH23B,
      OH23C,
      OH23D,
      OH23F,
      OH23G,
      OH23HL,
      OH5,
      OH58,
      OH58A,
      OH58B,
      OH58C,
      OH58D,
      OH58DC,
      OH58JT,
      OH5A,
      OH6,
      OH6A,
      OH6B,
      OH6C,
      OH6D,
      OH6DA,
      OH6J,
      OMEGA2,
      ORAO1,
      ORAO2,
      ORAO2A,
      OT47B,
      OUR,
      OV1,
      OV10,
      OV10A,
      OV10B,
      OV10C,
      OV10D,
      OV10E,
      OV10F,
      OV1A,
      OV1B,
      OV1C,
      OV1D,
      P136,
      P148,
      P149,
      P149D,
      P166,
      P166B,
      P166C,
      P166D,
      P166M,
      P166S,
      P16DL2,
      P16DL3,
      P180,
      P2,
      P2E,
      P2F,
      P2H,
      P2J,
      P2V,
      P3A,
      P3B,
      P3C,
      P3C1,
      P3C2,
      P3C3,
      P3CAIP,
      P3CJ,
      P3SEN,
      P4,
      P51,
      P55A,
      P68,
      P68A,
      P68B,
      P68C,
      P68CTC,
      P68OBS,
      P95,
      P95MAR,
      PA11,
      PA12,
      PA14,
      PA15,
      PA16,
      PA17,
      PA18,
      PA2,
      PA20,
      PA200A,
      PA200E,
      PA200I,
      PA22,
      PA23,
      PA24,
      PA25,
      PA28,
      PA2815,
      PA2816,
      PA2818,
      PA2820,
      PA2821,
      PA2823,
      PA2826,
      PA28R,
      PA29,
      PA30,
      PA31,
      PA3131,
      PA3135,
      PA31T,
      PA32,
      PA3230,
      PA34,
      PA3422,
      PA34II,
      PA36,
      PA38,
      PA3811,
      PA41,
      PA42,
      PA4210,
      PA4272,
      PA44,
      PA4418,
      PA46,
      PA4635,
      PA5,
      PA60,
      PACK,
      PACMUS,
      PACSHA,
      PAH2,
      PANATL,
      PARO,
      PAT1,
      PAYE,
      PC12,
      PC1245,
      PC12E,
      PC6,
      PC6A,
      PC6B,
      PC6C,
      PC6CHR,
      PC7,
      PC7MK2,
      PC8,
      PC9,
      PC9A,
      PC9B,
      PC9MK2,
      PCHEL,
      PD808,
      PD808A,
      PD808E,
      PD808F,
      PD808P,
      PD808R,
      PD808T,
      PD808V,
      PHFGR1,
      PHFGR2,
      PILL,
      PINAVC,
      PIPER,
      PIR2C,
      PIR2D,
      PIR4,
      PIR5,
      PN200A,
      PN200E,
      PN200I,
      PO2A,
      PS1,
      PS1SHM,
      PS5,
      PT1020,
      PT1040,
      PT6,
      PT6A,
      PZ105L,
      PZ106B,
      PZ106T,
      PZ130T,
      PZL104,
      PZL110,
      PZL111,
      PZL126,
      PZL130,
      PZL230,
      PZLDRO,
      PZLM20,
      PZLSW4,
      PZLSW5,
      PZLT45,
      PZLW3,
      PZLW3A,
      PZLW3W,
      PZTS11,
      PZW3RM,
      PZW3WA,
      PZWI20,
      PZWI35,
      PZWI80,
      Q5,
      QF004E,
      QF004G,
      QU22,
      QU800,
      QU8800,
      R1,
      R1180,
      R2160,
      R235G,
      R30012,
      R30014,
      R30016,
      R90230,
      R90420,
      R95,
      RA5,
      RA7E,
      RAFAL,
      RAFALB,
      RAFALC,
      RAFALM,
      RAH66,
      RAL235,
      RANGER,
      RAY390,
      RB57,
      RC12,
      RC121,
      RC12DG,
      RC12DS,
      RC12F,
      RC12HG,
      RC12HS,
      RC12KG,
      RC12KS,
      RC12M,
      RC130,
      RC130A,
      RC130E,
      RC130H,
      RC130S,
      RC135,
      RC135A,
      RC135C,
      RC135D,
      RC135M,
      RC135S,
      RC135T,
      RC135U,
      RC135V,
      RC135W,
      RC135X,
      RCI2F,
      RCI2HS,
      RCI2M,
      RCOBRA,
      RDR400,
      REBEL,
      RF104G,
      RF111A,
      RF111C,
      RF18,
      RF18D,
      RF35,
      RF35XD,
      RF4,
      RF400,
      RF47FO,
      RF4B,
      RF4C,
      RF4E,
      RF4EJ,
      RF4K,
      RF5,
      RF5A,
      RF5E,
      RF5G,
      RF5T,
      RF600,
      RF8,
      RF84F,
      RF8A,
      RF8G,
      RF9,
      RFB100,
      RFB400,
      RFB600,
      RH1100,
      RH22,
      RH53,
      RH53A,
      RH53D,
      RJ1,
      RJ100,
      RJ115,
      RJ1HK,
      RJ200,
      RJ700A,
      RJ700B,
      RO162F,
      ROB100,
      ROB200,
      ROBX4,
      ROMISL,
      ROR22,
      ROR44,
      RP3A,
      RP3D,
      RQ1A,
      RQ41,
      RQ42,
      RQ4A,
      RSA40,
      RSA40A,
      RSA60,
      RSA75,
      RSA75A,
      RT26,
      RT33A,
      RU21,
      RU21J,
      RU38A,
      RUT151,
      RUT202,
      RV1,
      RV1D,
      RY21,
      RY40,
      RY65,
      S100B,
      S12E,
      S16SHE,
      S19,
      S1B2,
      S208,
      S210,
      S210M,
      S211,
      S211A,
      S22C,
      S235,
      S235E,
      S2A,
      S2BUC,
      S2C,
      S2E,
      S2G,
      S2N,
      S2RT,
      S2T,
      S2TRK,
      S312,
      S32C,
      S35,
      S35E,
      S365N2,
      S365N3,
      S366G1,
      S3A,
      S3B,
      S55CHK,
      S55T,
      S58,
      S58T,
      S600,
      S61,
      S61A,
      S61AN,
      S61L,
      S61N,
      S61N1,
      S62,
      S62B,
      S64E,
      S65A,
      S65E,
      S65SEA,
      S70,
      S70A,
      S70A1L,
      S70B2,
      S70BS,
      S70C,
      S70LOG,
      S76,
      S76A,
      S76B,
      S76C,
      S76E,
      S76M2,
      S76N,
      S76S,
      S7B,
      S7BM,
      S80E,
      S80M,
      S880,
      S890,
      S892,
      S894,
      S9,
      S92C,
      S92HB,
      S92U,
      SA237A,
      SA238A,
      SA315,
      SA315B,
      SA316,
      SA316A,
      SA316B,
      SA318,
      SA318C,
      SA319A,
      SA319B,
      SA319W,
      SA321,
      SA321F,
      SA321G,
      SA321H,
      SA321J,
      SA321K,
      SA321L,
      SA321M,
      SA330,
      SA330B,
      SA330E,
      SA330H,
      SA330J,
      SA330L,
      SA332,
      SA341,
      SA341B,
      SA341C,
      SA341D,
      SA341E,
      SA341F,
      SA341G,
      SA341H,
      SA341M,
      SA342,
      SA342A,
      SA342G,
      SA342J,
      SA342K,
      SA342L,
      SA342M,
      SA342V,
      SA350,
      SA350B,
      SA350E,
      SA35B2,
      SA35B3,
      SA35BA,
      SA360,
      SA360C,
      SA361,
      SA365,
      SA365C,
      SA365F,
      SA365K,
      SA365M,
      SA365N,
      SA365S,
      SA366G,
      SA36BB,
      SA37,
      SA3BUL,
      SA3TMK,
      SAA300,
      SAAB91,
      SAR50,
      SASS,
      SB32,
      SB34A,
      SB34B,
      SB35,
      SB35E,
      SB35M,
      SB35X,
      SB37,
      SB37M,
      SB39M,
      SB7L,
      SC269A,
      SC3,
      SC300C,
      SC330,
      SC7,
      SC95B,
      SCOUT,
      SCP,
      SCR125,
      SCTP,
      SD27,
      SE210,
      SE3130,
      SE313B,
      SEABAT,
      SEACD2,
      SEACOB,
      SEAGUL,
      SEALYX,
      SEARNG,
      SEASPT,
      SEATA,
      SEN,
      SENMK2,
      SETE4,
      SF25A,
      SF260,
      SF260A,
      SF260B,
      SF260C,
      SF260E,
      SF260F,
      SF260M,
      SF260T,
      SF260W,
      SF260Z,
      SF269D,
      SF340,
      SF37,
      SF5,
      SF5A,
      SF5B,
      SF600,
      SF600A,
      SF600T,
      SG28SI,
      SG300,
      SGAL4,
      SH14,
      SH14B,
      SH14C,
      SH14D,
      SH2,
      SH2D,
      SH2F,
      SH3,
      SH34,
      SH34G,
      SH34J,
      SH37,
      SH3A,
      SH3D,
      SH3DTS,
      SH3G,
      SH3H,
      SH5,
      SH5A,
      SH60,
      SH60B,
      SH60D,
      SH60F,
      SH60J,
      SH60R,
      SHAEW2,
      SHARF,
      SHD3,
      SHD6,
      SHERPA,
      SHF6,
      SHFMK1,
      SHFMK2,
      SHFRM1,
      SHFRM2,
      SHFRM5,
      SHM1,
      SHM51,
      SHT330,
      SHTM4,
      SHTSHE,
      SHTSTR,
      SISD27,
      SJ302,
      SK1100,
      SK35C,
      SK37,
      SK50,
      SK500,
      SK51,
      SK52,
      SK55,
      SK56,
      SK56M,
      SK58,
      SK59,
      SK60,
      SK61,
      SK70,
      SK700,
      SK700S,
      SK71,
      SKA,
      SKAEM7,
      SKHA3A,
      SKHAM5,
      SKHCM4,
      SKHRM3,
      SKHSM1,
      SKJ,
      SKM43,
      SKM43B,
      SKMK2A,
      SKMK48,
      SKMK50,
      SKMK7,
      SKW,
      SKY28,
      SKY3M,
      SKYCR,
      SKYFOX,
      SKYROK,
      SKYS,
      SL8,
      SL90L,
      SLVSTR,
      SM92,
      SM92P,
      SM94,
      SN601,
      SOKOG,
      SOKOJ,
      SOKOK,
      SOL47,
      SOLMRQ,
      SP2,
      SP2H,
      SP95,
      SPDFRT,
      SPF22R,
      SPK,
      SPKA,
      SPTE2E,
      SR71,
      SR71A,
      SR71B,
      SR71C,
      SRA1,
      SRA4,
      SS22A,
      SSCA,
      SSLC65,
      SST,
      ST170,
      ST1700,
      ST17MD,
      ST3320,
      ST33UT,
      ST360,
      ST3630,
      ST75,
      ST77,
      STRAT1,
      STRAT2,
      SU11,
      SU11U,
      SU15,
      SU15U,
      SU17,
      SU17M,
      SU17M1,
      SU17M2,
      SU17M3,
      SU17M4,
      SU17U,
      SU17UM,
      SU20,
      SU20M,
      SU20U,
      SU22,
      SU22BK,
      SU22BM,
      SU22G,
      SU22H2,
      SU22J2,
      SU22M,
      SU22M4,
      SU22U,
      SU24,
      SU24M,
      SU24MK,
      SU24MP,
      SU24MR,
      SU25,
      SU25BM,
      SU25K,
      SU25T,
      SU25TK,
      SU25TM,
      SU25UB,
      SU25UG,
      SU25UK,
      SU25UT,
      SU26M,
      SU27,
      SU27IB,
      SU27K,
      SU27LL,
      SU27M,
      SU27P,
      SU27PD,
      SU27S,
      SU27SM,
      SU27UB,
      SU28,
      SU29,
      SU30,
      SU30K,
      SU30M,
      SU30MK,
      SU32FN,
      SU33,
      SU34,
      SU35,
      SU37,
      SU38,
      SU39,
      SU3MKI,
      SU49,
      SU7,
      SU7B,
      SU7BKL,
      SU7BMK,
      SU7U,
      SU7UM,
      SU7UMK,
      SU9,
      SU9U,
      SULYNX,
      SUMSEN,
      SUPHOR,
      SUROK,
      SUS21,
      SUS32,
      SUS54,
      SUS80,
      SUS84,
      SUS986,
      SW3,
      SW3IV,
      SWATI,
      SWSFED,
      T1,
      T101E,
      T101GR,
      T101S,
      T106,
      T10HER,
      T11,
      T11A,
      T11CAC,
      T12,
      T130FR,
      T134,
      T154M2,
      T16FAL,
      T17,
      T18FAL,
      T19A,
      T19B,
      T1A,
      T1AJAY,
      T1B,
      T2,
      T201,
      T201AI,
      T203,
      T203PC,
      T204GR,
      T205KA,
      T23,
      T25,
      T25A,
      T25B,
      T27,
      T274,
      T274BR,
      T274TI,
      T27T,
      T28,
      T28A,
      T28B,
      T28C,
      T28D,
      T29,
      T29A,
      T2A,
      T2B,
      T2C,
      T2D,
      T2E,
      T2KAI,
      T2MIT,
      T3,
      T33,
      T33A,
      T33B,
      T33N,
      T34,
      T34A,
      T34B,
      T34C,
      T35,
      T35A,
      T35B,
      T35C,
      T35D,
      T35S,
      T35T,
      T36,
      T37,
      T37A,
      T37B,
      T37C,
      T37T,
      T38,
      T38A,
      T38B,
      T38D,
      T39,
      T39A,
      T39B,
      T39D,
      T39F,
      T4,
      T401SO,
      T407SK,
      T41,
      T411AI,
      T411WO,
      T417PE,
      T41A,
      T41B,
      T41D,
      T42,
      T420A,
      T420CL,
      T420ST,
      T422YA,
      T42A,
      T42B,
      T43,
      T430SP,
      T433FL,
      T43A,
      T44,
      T44K,
      T45,
      T45A,
      T45B,
      T45TS,
      T47,
      T471,
      T47A,
      T4KAWA,
      T5,
      T501,
      T6,
      T610,
      T610VO,
      T66,
      T67,
      T67B,
      T67C,
      T67M,
      T67M20,
      T67M26,
      T67MM2,
      T6G,
      T9,
      T910,
      T910KU,
      T9STO,
      TA16SF,
      TA3B,
      TA4,
      TA4B,
      TA4F,
      TA4G,
      TA4H,
      TA4J,
      TA4K,
      TA4KU,
      TA4M,
      TA4S,
      TA7,
      TA7C,
      TA7H,
      TA7P,
      TAGM23,
      TAV8,
      TAV8A,
      TAV8B,
      TAV8S,
      TB10,
      TB20,
      TB200,
      TB20PA,
      TB21,
      TB30,
      TB31,
      TB360,
      TB6000,
      TB9,
      TB9TC,
      TBM700,
      TC018E,
      TC130,
      TC130G,
      TC130Q,
      TC135S,
      TC135W,
      TC15,
      TC18F,
      TC19,
      TC20,
      TC3,
      TC4B,
      TC4C,
      TC4CA,
      TCH1,
      TCHAI,
      TE2,
      TE2A,
      TE2C,
      TF102A,
      TF104,
      TF104G,
      TF15,
      TF16N,
      TF18,
      TF18A,
      TF1O2A,
      TF35,
      TF35XD,
      TG10,
      TG1X,
      TH053A,
      TH1,
      TH13,
      TH13M,
      TH13S,
      TH13T,
      TH1F,
      TH1G,
      TH1L,
      TH1S,
      TH206,
      TH50,
      TH55,
      TH55A,
      TH55J,
      TH57,
      TH57A,
      TH57B,
      TH57C,
      TH67,
      TIGER,
      TIMIT,
      TK10,
      TL10,
      TORA,
      TORAF3,
      TORE,
      TORF2,
      TORF2A,
      TORF3,
      TORGMK,
      TORI,
      TORM1,
      TORM1A,
      TORM1B,
      TORM4,
      TORNAD,
      TORR,
      TOUCAN,
      TP100,
      TP101,
      TP102,
      TP400,
      TP600,
      TP84,
      TP88,
      TP883,
      TP89,
      TR1ATR,
      TR1B,
      TR1DRA,
      TR1REC,
      TR1TRI,
      TRAN,
      TRDT2E,
      TRDT3B,
      TRI300,
      TRI3B,
      TRI500,
      TRIC2,
      TRIC2A,
      TRID2E,
      TRIK1,
      TRIKC1,
      TROOP,
      TS2A,
      TS60,
      TS8,
      TSC1A3,
      TT300,
      TU104,
      TU104A,
      TU114,
      TU116,
      TU124,
      TU126,
      TU128,
      TU130,
      TU130L,
      TU134,
      TU1341,
      TU1343,
      TU134A,
      TU134B,
      TU142,
      TU142C,
      TU142D,
      TU142E,
      TU142H,
      TU142M,
      TU142R,
      TU142S,
      TU142Z,
      TU144,
      TU144D,
      TU144L,
      TU154,
      TU1541,
      TU1542,
      TU154A,
      TU154B,
      TU154L,
      TU154M,
      TU154O,
      TU154S,
      TU154T,
      TU156,
      TU156S,
      TU16,
      TU160,
      TU160S,
      TU1610,
      TU16KS,
      TU16N,
      TU16PH,
      TU16PJ,
      TU16PP,
      TU16RD,
      TU16RF,
      TU16RK,
      TU16T,
      TU20,
      TU204,
      TU2041,
      TU2042,
      TU204C,
      TU204M,
      TU214,
      TU22,
      TU22D,
      TU22M1,
      TU22M2,
      TU22M3,
      TU22MR,
      TU22U,
      TU2412,
      TU2422,
      TU2423,
      TU244,
      TU24S,
      TU24T,
      TU24U,
      TU26,
      TU28,
      TU330,
      TU334,
      TU3341,
      TU334C,
      TU334D,
      TU34,
      TU354,
      TU414,
      TU95,
      TU9522,
      TU95K,
      TU95K2,
      TU95M,
      TU95MR,
      TU95RT,
      TUCP,
      TURBVR,
      TURPOR,
      TW18,
      TWINOT,
      TWINSQ,
      TWINST,
      TZUG,
      U1,
      U10,
      U11,
      U11A,
      U125,
      U125A,
      U17,
      U17A,
      U17B,
      U1A,
      U2,
      U21,
      U21F,
      U25,
      U27A,
      U2R,
      U3,
      U36,
      U3A,
      U3B,
      U4,
      U42,
      U5,
      U6,
      U6A,
      U7,
      U7A,
      U7B,
      U7SC,
      U8,
      U8D,
      U8F,
      U8TB,
      U8TE,
      U9,
      U93,
      U9D,
      U9X,
      U9XI,
      UC026C,
      UC12B,
      UC12B2,
      UC12BH,
      UC12D,
      UC12F,
      UC12M,
      UC12M2,
      UC26C,
      UC35A,
      UC45J,
      UH1,
      UH12,
      UH12E,
      UH14,
      UH14A,
      UH19,
      UH19A,
      UH19B,
      UH19C,
      UH19D,
      UH19F,
      UH1AB,
      UH1B,
      UH1C,
      UH1D,
      UH1E,
      UH1F,
      UH1H,
      UH1J,
      UH1L,
      UH1M,
      UH1NTH,
      UH1P,
      UH1T,
      UH1V,
      UH2,
      UH2A,
      UH2B,
      UH3,
      UH34D,
      UH3A,
      UH3D,
      UH46,
      UH46A,
      UH46C,
      UH46D,
      UH60,
      UH60A,
      UH60AP,
      UH60B,
      UH60C,
      UH60J,
      UH60JA,
      UH60L,
      UH60P,
      UH60Q,
      UHMK88,
      UM1023,
      UM3071,
      UP2J,
      US1,
      US1A,
      US1SAR,
      US2,
      US2A,
      US2B,
      US2C,
      US2D,
      US3A,
      US496,
      UTV,
      UTVA75,
      UTVA95,
      UV18,
      UV18A,
      UV18AC,
      UV18B,
      UV20,
      UV20A,
      V22,
      V234,
      VA10,
      VA2,
      VA3B,
      VAR,
      VC025A,
      VC10,
      VC10C1,
      VC10CM,
      VC10K2,
      VC10K3,
      VC10M2,
      VC10M3,
      VC11,
      VC118,
      VC118A,
      VC118B,
      VC11A,
      VC11AG,
      VC11II,
      VC130,
      VC130H,
      VC131,
      VC131A,
      VC131H,
      VC135B,
      VC137,
      VC137C,
      VC137G,
      VC140,
      VC140B,
      VC1KK2,
      VC1KK3,
      VC1KK4,
      VC25,
      VC25A,
      VC26,
      VC6,
      VC6B,
      VC7,
      VC9,
      VC97,
      VC9C,
      VCONT,
      VFW614,
      VG21,
      VH3,
      VH34D,
      VH3A,
      VH3D,
      VH4,
      VH60N,
      VICTK2,
      VICTOR,
      VJ22,
      VKVNGD,
      VLCN,
      VOY,
      VP3A,
      VRT44A,
      VRT44B,
      VTOUR2,
      VU9,
      WAG22,
      WAGABO,
      WAI100,
      WAI500,
      WAI50H,
      WAI600,
      WC130,
      WC130B,
      WC130E,
      WC130H,
      WC135,
      WC135B,
      WC135N,
      WC135W,
      WG13,
      WG30,
      WG34,
      WSPRT,
      WSX,
      WW,
      WW24,
      X31A,
      XC2,
      XIANF7,
      XIHU5,
      XTS,
      Y11,
      Y11B,
      Y11M,
      Y11T,
      Y12,
      Y122,
      Y124,
      Y18MOO,
      Y27,
      Y36MP,
      Y36MPA,
      Y36MPB,
      Y5,
      Y5B,
      Y5C,
      Y7,
      Y710,
      Y7100,
      Y710C,
      Y720A,
      Y720B,
      Y7E,
      Y7H,
      Y7H50,
      Y7H500,
      Y8,
      Y8A,
      Y8B,
      Y8C,
      Y8D,
      Y8E,
      Y8ECM,
      Y8F,
      Y8H,
      Y8X,
      YA27U,
      YAK11,
      YAK112,
      YAK12,
      YAK13,
      YAK130,
      YAK142,
      YAK14V,
      YAK18,
      YAK18T,
      YAK242,
      YAK25,
      YAK27,
      YAK28,
      YAK28P,
      YAK28U,
      YAK30,
      YAK32,
      YAK36M,
      YAK38,
      YAK38A,
      YAK38B,
      YAK40,
      YAK41,
      YAK42,
      YAK42A,
      YAK42D,
      YAK42E,
      YAK42M,
      YAK42T,
      YAK461,
      YAK462,
      YAK52,
      YAK54,
      YAK56,
      YAK58,
      YAKFBA,
      YAMAL,
      YAS70A,
      YF11,
      YS11,
      YT25B,
      YUN12,
      Z11,
      Z142,
      Z142C,
      Z142CA,
      Z142L,
      Z143,
      Z242L,
      Z326,
      Z5,
      Z50,
      Z6,
      Z8,
      Z9,
      Z9100,
      Z9A,
      ZEPN05,
      ZEPN07,
      ZLNAER,
      ZLNAIR,
      ZLNATL,
      ZLNBAL,
      ZLNBAR,
      ZLNCHI,
      ZLNCON,
      ZLNCOO,
      ZLNDAS,
      ZLNDOL,
      ZLNHAR,
      ZLNHDC,
      ZLNHKB,
      ZLNHKC,
      ZLNHPD,
      ZLNHPF,
      ZLNHPH,
      ZLNIDF,
      ZLNQUE,
      ZLNSEA,
      ZLNSOK
    };

    AircraftTypeModelCode (value v);

    AircraftTypeModelCode (const char* v);

    AircraftTypeModelCode (const ::std::string& v);

    AircraftTypeModelCode (const ::xml_schema::token& v);

    AircraftTypeModelCode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    AircraftTypeModelCode (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    AircraftTypeModelCode (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    AircraftTypeModelCode (const AircraftTypeModelCode& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual AircraftTypeModelCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AircraftTypeModelCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AircraftTypeModelCode_convert ();
    }

    protected:
    value
    _xsd_AircraftTypeModelCode_convert () const;

    public:
    static const char* const _xsd_AircraftTypeModelCode_literals_[4758];
    static const value _xsd_AircraftTypeModelCode_indexes_[4758];
  };

  class AircraftTypeTakeoffAndLandingCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NKN,
      NOS,
      STOL,
      VSTOL,
      VTOL
    };

    AircraftTypeTakeoffAndLandingCode (value v);

    AircraftTypeTakeoffAndLandingCode (const char* v);

    AircraftTypeTakeoffAndLandingCode (const ::std::string& v);

    AircraftTypeTakeoffAndLandingCode (const ::xml_schema::token& v);

    AircraftTypeTakeoffAndLandingCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    AircraftTypeTakeoffAndLandingCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    AircraftTypeTakeoffAndLandingCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    AircraftTypeTakeoffAndLandingCode (const AircraftTypeTakeoffAndLandingCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual AircraftTypeTakeoffAndLandingCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AircraftTypeTakeoffAndLandingCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AircraftTypeTakeoffAndLandingCode_convert ();
    }

    protected:
    value
    _xsd_AircraftTypeTakeoffAndLandingCode_convert () const;

    public:
    static const char* const _xsd_AircraftTypeTakeoffAndLandingCode_literals_[5];
    static const value _xsd_AircraftTypeTakeoffAndLandingCode_indexes_[5];
  };

  class AircraftTypeTrainingCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NKN,
      NO,
      YES
    };

    AircraftTypeTrainingCategoryCode (value v);

    AircraftTypeTrainingCategoryCode (const char* v);

    AircraftTypeTrainingCategoryCode (const ::std::string& v);

    AircraftTypeTrainingCategoryCode (const ::xml_schema::token& v);

    AircraftTypeTrainingCategoryCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    AircraftTypeTrainingCategoryCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    AircraftTypeTrainingCategoryCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    AircraftTypeTrainingCategoryCode (const AircraftTypeTrainingCategoryCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual AircraftTypeTrainingCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AircraftTypeTrainingCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AircraftTypeTrainingCategoryCode_convert ();
    }

    protected:
    value
    _xsd_AircraftTypeTrainingCategoryCode_convert () const;

    public:
    static const char* const _xsd_AircraftTypeTrainingCategoryCode_literals_[3];
    static const value _xsd_AircraftTypeTrainingCategoryCode_indexes_[3];
  };

  class AircraftTypeWeatherQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ALL,
      CLEAR,
      NKN
    };

    AircraftTypeWeatherQualifierCode (value v);

    AircraftTypeWeatherQualifierCode (const char* v);

    AircraftTypeWeatherQualifierCode (const ::std::string& v);

    AircraftTypeWeatherQualifierCode (const ::xml_schema::token& v);

    AircraftTypeWeatherQualifierCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    AircraftTypeWeatherQualifierCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    AircraftTypeWeatherQualifierCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    AircraftTypeWeatherQualifierCode (const AircraftTypeWeatherQualifierCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual AircraftTypeWeatherQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AircraftTypeWeatherQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AircraftTypeWeatherQualifierCode_convert ();
    }

    protected:
    value
    _xsd_AircraftTypeWeatherQualifierCode_convert () const;

    public:
    static const char* const _xsd_AircraftTypeWeatherQualifierCode_literals_[3];
    static const value _xsd_AircraftTypeWeatherQualifierCode_indexes_[3];
  };

  class AirfieldAirTrafficControlPresenceIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    AirfieldAirTrafficControlPresenceIndicatorCode (value v);

    AirfieldAirTrafficControlPresenceIndicatorCode (const char* v);

    AirfieldAirTrafficControlPresenceIndicatorCode (const ::std::string& v);

    AirfieldAirTrafficControlPresenceIndicatorCode (const ::xml_schema::token& v);

    AirfieldAirTrafficControlPresenceIndicatorCode (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    AirfieldAirTrafficControlPresenceIndicatorCode (const ::xercesc::DOMAttr& a,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    AirfieldAirTrafficControlPresenceIndicatorCode (const ::std::string& s,
                                                    const ::xercesc::DOMElement* e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    AirfieldAirTrafficControlPresenceIndicatorCode (const AirfieldAirTrafficControlPresenceIndicatorCode& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    virtual AirfieldAirTrafficControlPresenceIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AirfieldAirTrafficControlPresenceIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AirfieldAirTrafficControlPresenceIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_AirfieldAirTrafficControlPresenceIndicatorCode_convert () const;

    public:
    static const char* const _xsd_AirfieldAirTrafficControlPresenceIndicatorCode_literals_[2];
    static const value _xsd_AirfieldAirTrafficControlPresenceIndicatorCode_indexes_[2];
  };

  class AirfieldInstrumentLandingSystemPresenceIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    AirfieldInstrumentLandingSystemPresenceIndicatorCode (value v);

    AirfieldInstrumentLandingSystemPresenceIndicatorCode (const char* v);

    AirfieldInstrumentLandingSystemPresenceIndicatorCode (const ::std::string& v);

    AirfieldInstrumentLandingSystemPresenceIndicatorCode (const ::xml_schema::token& v);

    AirfieldInstrumentLandingSystemPresenceIndicatorCode (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    AirfieldInstrumentLandingSystemPresenceIndicatorCode (const ::xercesc::DOMAttr& a,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    AirfieldInstrumentLandingSystemPresenceIndicatorCode (const ::std::string& s,
                                                          const ::xercesc::DOMElement* e,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    AirfieldInstrumentLandingSystemPresenceIndicatorCode (const AirfieldInstrumentLandingSystemPresenceIndicatorCode& x,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    virtual AirfieldInstrumentLandingSystemPresenceIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AirfieldInstrumentLandingSystemPresenceIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AirfieldInstrumentLandingSystemPresenceIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_AirfieldInstrumentLandingSystemPresenceIndicatorCode_convert () const;

    public:
    static const char* const _xsd_AirfieldInstrumentLandingSystemPresenceIndicatorCode_literals_[2];
    static const value _xsd_AirfieldInstrumentLandingSystemPresenceIndicatorCode_indexes_[2];
  };

  class AirfieldStatusDayOperationsCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BOTH,
      DAY,
      NIGHT,
      NKN
    };

    AirfieldStatusDayOperationsCode (value v);

    AirfieldStatusDayOperationsCode (const char* v);

    AirfieldStatusDayOperationsCode (const ::std::string& v);

    AirfieldStatusDayOperationsCode (const ::xml_schema::token& v);

    AirfieldStatusDayOperationsCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    AirfieldStatusDayOperationsCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    AirfieldStatusDayOperationsCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    AirfieldStatusDayOperationsCode (const AirfieldStatusDayOperationsCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual AirfieldStatusDayOperationsCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AirfieldStatusDayOperationsCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AirfieldStatusDayOperationsCode_convert ();
    }

    protected:
    value
    _xsd_AirfieldStatusDayOperationsCode_convert () const;

    public:
    static const char* const _xsd_AirfieldStatusDayOperationsCode_literals_[4];
    static const value _xsd_AirfieldStatusDayOperationsCode_indexes_[4];
  };

  class AirfieldStatusEvaluationIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    AirfieldStatusEvaluationIndicatorCode (value v);

    AirfieldStatusEvaluationIndicatorCode (const char* v);

    AirfieldStatusEvaluationIndicatorCode (const ::std::string& v);

    AirfieldStatusEvaluationIndicatorCode (const ::xml_schema::token& v);

    AirfieldStatusEvaluationIndicatorCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    AirfieldStatusEvaluationIndicatorCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    AirfieldStatusEvaluationIndicatorCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    AirfieldStatusEvaluationIndicatorCode (const AirfieldStatusEvaluationIndicatorCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual AirfieldStatusEvaluationIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AirfieldStatusEvaluationIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AirfieldStatusEvaluationIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_AirfieldStatusEvaluationIndicatorCode_convert () const;

    public:
    static const char* const _xsd_AirfieldStatusEvaluationIndicatorCode_literals_[2];
    static const value _xsd_AirfieldStatusEvaluationIndicatorCode_indexes_[2];
  };

  class AirfieldStatusFlightSupportCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      IFR,
      NKN,
      VFR
    };

    AirfieldStatusFlightSupportCategoryCode (value v);

    AirfieldStatusFlightSupportCategoryCode (const char* v);

    AirfieldStatusFlightSupportCategoryCode (const ::std::string& v);

    AirfieldStatusFlightSupportCategoryCode (const ::xml_schema::token& v);

    AirfieldStatusFlightSupportCategoryCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    AirfieldStatusFlightSupportCategoryCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    AirfieldStatusFlightSupportCategoryCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    AirfieldStatusFlightSupportCategoryCode (const AirfieldStatusFlightSupportCategoryCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual AirfieldStatusFlightSupportCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AirfieldStatusFlightSupportCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AirfieldStatusFlightSupportCategoryCode_convert ();
    }

    protected:
    value
    _xsd_AirfieldStatusFlightSupportCategoryCode_convert () const;

    public:
    static const char* const _xsd_AirfieldStatusFlightSupportCategoryCode_literals_[3];
    static const value _xsd_AirfieldStatusFlightSupportCategoryCode_indexes_[3];
  };

  class AirfieldTypeUseCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      A,
      B,
      C,
      D
    };

    AirfieldTypeUseCategoryCode (value v);

    AirfieldTypeUseCategoryCode (const char* v);

    AirfieldTypeUseCategoryCode (const ::std::string& v);

    AirfieldTypeUseCategoryCode (const ::xml_schema::token& v);

    AirfieldTypeUseCategoryCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    AirfieldTypeUseCategoryCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    AirfieldTypeUseCategoryCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    AirfieldTypeUseCategoryCode (const AirfieldTypeUseCategoryCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual AirfieldTypeUseCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AirfieldTypeUseCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AirfieldTypeUseCategoryCode_convert ();
    }

    protected:
    value
    _xsd_AirfieldTypeUseCategoryCode_convert () const;

    public:
    static const char* const _xsd_AirfieldTypeUseCategoryCode_literals_[4];
    static const value _xsd_AirfieldTypeUseCategoryCode_indexes_[4];
  };

  class AirfieldVisualNavigationalAidIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    AirfieldVisualNavigationalAidIndicatorCode (value v);

    AirfieldVisualNavigationalAidIndicatorCode (const char* v);

    AirfieldVisualNavigationalAidIndicatorCode (const ::std::string& v);

    AirfieldVisualNavigationalAidIndicatorCode (const ::xml_schema::token& v);

    AirfieldVisualNavigationalAidIndicatorCode (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    AirfieldVisualNavigationalAidIndicatorCode (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    AirfieldVisualNavigationalAidIndicatorCode (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    AirfieldVisualNavigationalAidIndicatorCode (const AirfieldVisualNavigationalAidIndicatorCode& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual AirfieldVisualNavigationalAidIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AirfieldVisualNavigationalAidIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AirfieldVisualNavigationalAidIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_AirfieldVisualNavigationalAidIndicatorCode_convert () const;

    public:
    static const char* const _xsd_AirfieldVisualNavigationalAidIndicatorCode_literals_[2];
    static const value _xsd_AirfieldVisualNavigationalAidIndicatorCode_indexes_[2];
  };

  class AmmunitionTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AAMIS,
      ALMIS,
      ASMIS,
      ATGDWP,
      BOMB,
      BOMBLT,
      CRUMSL,
      DPTHCH,
      EXPLOS,
      GNSHEL,
      HNDGRN,
      MINAHL,
      MINAPR,
      MINAT,
      MINATA,
      MINDPM,
      MINMOR,
      MINNKN,
      MINNOS,
      MINOFR,
      MINSEG,
      MINSEL,
      MINSHM,
      MINWAR,
      MISATR,
      MISGUI,
      MNMRTM,
      MRTMDC,
      MRTRBM,
      MVSEAM,
      NKN,
      NOS,
      PRJNOS,
      PRXFUS,
      PYROTC,
      RCKET,
      RKTATP,
      RKTATT,
      RKTHEV,
      RKTLGT,
      RKTMED,
      SEABDM,
      SEAMIN,
      SMAMMO,
      SRAMIS,
      SRSMIS,
      SUBMUN,
      TRPEDO
    };

    AmmunitionTypeCategoryCode (value v);

    AmmunitionTypeCategoryCode (const char* v);

    AmmunitionTypeCategoryCode (const ::std::string& v);

    AmmunitionTypeCategoryCode (const ::xml_schema::token& v);

    AmmunitionTypeCategoryCode (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    AmmunitionTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    AmmunitionTypeCategoryCode (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    AmmunitionTypeCategoryCode (const AmmunitionTypeCategoryCode& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual AmmunitionTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AmmunitionTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AmmunitionTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_AmmunitionTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_AmmunitionTypeCategoryCode_literals_[48];
    static const value _xsd_AmmunitionTypeCategoryCode_indexes_[48];
  };

  class AmmunitionTypeExerciseMineFlareColourCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      GREEN,
      ORANGE,
      RED,
      WHITE,
      YELLOW
    };

    AmmunitionTypeExerciseMineFlareColourCode (value v);

    AmmunitionTypeExerciseMineFlareColourCode (const char* v);

    AmmunitionTypeExerciseMineFlareColourCode (const ::std::string& v);

    AmmunitionTypeExerciseMineFlareColourCode (const ::xml_schema::token& v);

    AmmunitionTypeExerciseMineFlareColourCode (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    AmmunitionTypeExerciseMineFlareColourCode (const ::xercesc::DOMAttr& a,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    AmmunitionTypeExerciseMineFlareColourCode (const ::std::string& s,
                                               const ::xercesc::DOMElement* e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    AmmunitionTypeExerciseMineFlareColourCode (const AmmunitionTypeExerciseMineFlareColourCode& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual AmmunitionTypeExerciseMineFlareColourCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AmmunitionTypeExerciseMineFlareColourCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AmmunitionTypeExerciseMineFlareColourCode_convert ();
    }

    protected:
    value
    _xsd_AmmunitionTypeExerciseMineFlareColourCode_convert () const;

    public:
    static const char* const _xsd_AmmunitionTypeExerciseMineFlareColourCode_literals_[5];
    static const value _xsd_AmmunitionTypeExerciseMineFlareColourCode_indexes_[5];
  };

  class AmmunitionTypeMineMaritimeFiringCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ACOUAF,
      ACOUHF,
      ACOULF,
      ACOUST,
      ACTIVE,
      ANTENA,
      COARAS,
      COMBIN,
      CONTCT,
      FITWDA,
      FITWSC,
      INFLUN,
      MAGNET,
      MAGNHH,
      MAGNTT,
      MAGNVV,
      MINHSD,
      MULTLM,
      NKN,
      NOS,
      PASIVE,
      PRESUR,
      SENFNT,
      SEQUEN,
      VERSEN
    };

    AmmunitionTypeMineMaritimeFiringCode (value v);

    AmmunitionTypeMineMaritimeFiringCode (const char* v);

    AmmunitionTypeMineMaritimeFiringCode (const ::std::string& v);

    AmmunitionTypeMineMaritimeFiringCode (const ::xml_schema::token& v);

    AmmunitionTypeMineMaritimeFiringCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    AmmunitionTypeMineMaritimeFiringCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    AmmunitionTypeMineMaritimeFiringCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    AmmunitionTypeMineMaritimeFiringCode (const AmmunitionTypeMineMaritimeFiringCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual AmmunitionTypeMineMaritimeFiringCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AmmunitionTypeMineMaritimeFiringCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AmmunitionTypeMineMaritimeFiringCode_convert ();
    }

    protected:
    value
    _xsd_AmmunitionTypeMineMaritimeFiringCode_convert () const;

    public:
    static const char* const _xsd_AmmunitionTypeMineMaritimeFiringCode_literals_[25];
    static const value _xsd_AmmunitionTypeMineMaritimeFiringCode_indexes_[25];
  };

  class AnchorageBottomTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BOULDR,
      CLAY,
      COBBLS,
      CORAL,
      GRAVEL,
      LMNSTN,
      MUD,
      MUDSND,
      NOS,
      PEBBLS,
      RGHCRL,
      ROCK,
      ROUGH,
      SAND,
      SANDCR,
      SANDFN,
      SANDMD,
      SANDVC,
      SANDVF,
      SMTHFL,
      STBLSM
    };

    AnchorageBottomTypeCode (value v);

    AnchorageBottomTypeCode (const char* v);

    AnchorageBottomTypeCode (const ::std::string& v);

    AnchorageBottomTypeCode (const ::xml_schema::token& v);

    AnchorageBottomTypeCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    AnchorageBottomTypeCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    AnchorageBottomTypeCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    AnchorageBottomTypeCode (const AnchorageBottomTypeCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual AnchorageBottomTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AnchorageBottomTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AnchorageBottomTypeCode_convert ();
    }

    protected:
    value
    _xsd_AnchorageBottomTypeCode_convert () const;

    public:
    static const char* const _xsd_AnchorageBottomTypeCode_literals_[21];
    static const value _xsd_AnchorageBottomTypeCode_indexes_[21];
  };

  class AnchorageMooringsTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BUOY,
      DOLPIN,
      FXDPST,
      NOS
    };

    AnchorageMooringsTypeCode (value v);

    AnchorageMooringsTypeCode (const char* v);

    AnchorageMooringsTypeCode (const ::std::string& v);

    AnchorageMooringsTypeCode (const ::xml_schema::token& v);

    AnchorageMooringsTypeCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    AnchorageMooringsTypeCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    AnchorageMooringsTypeCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    AnchorageMooringsTypeCode (const AnchorageMooringsTypeCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual AnchorageMooringsTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AnchorageMooringsTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AnchorageMooringsTypeCode_convert ();
    }

    protected:
    value
    _xsd_AnchorageMooringsTypeCode_convert () const;

    public:
    static const char* const _xsd_AnchorageMooringsTypeCode_literals_[4];
    static const value _xsd_AnchorageMooringsTypeCode_indexes_[4];
  };

  class AnglePrecisionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_1000MN,
      cxx_100MN,
      cxx_100SEC,
      cxx_10DEG,
      cxx_10MN,
      cxx_10SEC,
      DEGREE,
      MIL,
      MINUTE,
      SECOND
    };

    AnglePrecisionCode (value v);

    AnglePrecisionCode (const char* v);

    AnglePrecisionCode (const ::std::string& v);

    AnglePrecisionCode (const ::xml_schema::token& v);

    AnglePrecisionCode (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    AnglePrecisionCode (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    AnglePrecisionCode (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    AnglePrecisionCode (const AnglePrecisionCode& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual AnglePrecisionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AnglePrecisionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AnglePrecisionCode_convert ();
    }

    protected:
    value
    _xsd_AnglePrecisionCode_convert () const;

    public:
    static const char* const _xsd_AnglePrecisionCode_literals_[10];
    static const value _xsd_AnglePrecisionCode_indexes_[10];
  };

  class ApproachDirectionCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      C,
      L,
      R,
      S,
      T
    };

    ApproachDirectionCategoryCode (value v);

    ApproachDirectionCategoryCode (const char* v);

    ApproachDirectionCategoryCode (const ::std::string& v);

    ApproachDirectionCategoryCode (const ::xml_schema::token& v);

    ApproachDirectionCategoryCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    ApproachDirectionCategoryCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    ApproachDirectionCategoryCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    ApproachDirectionCategoryCode (const ApproachDirectionCategoryCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual ApproachDirectionCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ApproachDirectionCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ApproachDirectionCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ApproachDirectionCategoryCode_convert () const;

    public:
    static const char* const _xsd_ApproachDirectionCategoryCode_literals_[5];
    static const value _xsd_ApproachDirectionCategoryCode_indexes_[5];
  };

  class AssociationStatusCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      END,
      START
    };

    AssociationStatusCategoryCode (value v);

    AssociationStatusCategoryCode (const char* v);

    AssociationStatusCategoryCode (const ::std::string& v);

    AssociationStatusCategoryCode (const ::xml_schema::token& v);

    AssociationStatusCategoryCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    AssociationStatusCategoryCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    AssociationStatusCategoryCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    AssociationStatusCategoryCode (const AssociationStatusCategoryCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual AssociationStatusCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AssociationStatusCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AssociationStatusCategoryCode_convert ();
    }

    protected:
    value
    _xsd_AssociationStatusCategoryCode_convert () const;

    public:
    static const char* const _xsd_AssociationStatusCategoryCode_literals_[2];
    static const value _xsd_AssociationStatusCategoryCode_indexes_[2];
  };

  class AtmosphereInversionLayerCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      A,
      B,
      C
    };

    AtmosphereInversionLayerCode (value v);

    AtmosphereInversionLayerCode (const char* v);

    AtmosphereInversionLayerCode (const ::std::string& v);

    AtmosphereInversionLayerCode (const ::xml_schema::token& v);

    AtmosphereInversionLayerCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    AtmosphereInversionLayerCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    AtmosphereInversionLayerCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    AtmosphereInversionLayerCode (const AtmosphereInversionLayerCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual AtmosphereInversionLayerCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AtmosphereInversionLayerCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AtmosphereInversionLayerCode_convert ();
    }

    protected:
    value
    _xsd_AtmosphereInversionLayerCode_convert () const;

    public:
    static const char* const _xsd_AtmosphereInversionLayerCode_literals_[3];
    static const value _xsd_AtmosphereInversionLayerCode_indexes_[3];
  };

  class AtmospherePressureSystemCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CLDFRT,
      HGHPRS,
      LOWPRS,
      OCCFRT,
      RDGLIN,
      SQLLIN,
      STAFRT,
      TRGLIN,
      UPCFRT,
      UPWFRT,
      WRMFRT
    };

    AtmospherePressureSystemCategoryCode (value v);

    AtmospherePressureSystemCategoryCode (const char* v);

    AtmospherePressureSystemCategoryCode (const ::std::string& v);

    AtmospherePressureSystemCategoryCode (const ::xml_schema::token& v);

    AtmospherePressureSystemCategoryCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    AtmospherePressureSystemCategoryCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    AtmospherePressureSystemCategoryCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    AtmospherePressureSystemCategoryCode (const AtmospherePressureSystemCategoryCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual AtmospherePressureSystemCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AtmospherePressureSystemCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AtmospherePressureSystemCategoryCode_convert ();
    }

    protected:
    value
    _xsd_AtmospherePressureSystemCategoryCode_convert () const;

    public:
    static const char* const _xsd_AtmospherePressureSystemCategoryCode_literals_[11];
    static const value _xsd_AtmospherePressureSystemCategoryCode_indexes_[11];
  };

  class AtmosphereTemperatureGradientCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NEUTRL,
      NKN,
      STABLE,
      UNSTAB
    };

    AtmosphereTemperatureGradientCode (value v);

    AtmosphereTemperatureGradientCode (const char* v);

    AtmosphereTemperatureGradientCode (const ::std::string& v);

    AtmosphereTemperatureGradientCode (const ::xml_schema::token& v);

    AtmosphereTemperatureGradientCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    AtmosphereTemperatureGradientCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    AtmosphereTemperatureGradientCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    AtmosphereTemperatureGradientCode (const AtmosphereTemperatureGradientCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual AtmosphereTemperatureGradientCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AtmosphereTemperatureGradientCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_AtmosphereTemperatureGradientCode_convert ();
    }

    protected:
    value
    _xsd_AtmosphereTemperatureGradientCode_convert () const;

    public:
    static const char* const _xsd_AtmosphereTemperatureGradientCode_literals_[4];
    static const value _xsd_AtmosphereTemperatureGradientCode_indexes_[4];
  };

  class BerthMajorVesselClassCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BARGE,
      BRKBLK,
      CONTNR,
      NOS,
      RORO
    };

    BerthMajorVesselClassCode (value v);

    BerthMajorVesselClassCode (const char* v);

    BerthMajorVesselClassCode (const ::std::string& v);

    BerthMajorVesselClassCode (const ::xml_schema::token& v);

    BerthMajorVesselClassCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    BerthMajorVesselClassCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    BerthMajorVesselClassCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    BerthMajorVesselClassCode (const BerthMajorVesselClassCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual BerthMajorVesselClassCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    BerthMajorVesselClassCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_BerthMajorVesselClassCode_convert ();
    }

    protected:
    value
    _xsd_BerthMajorVesselClassCode_convert () const;

    public:
    static const char* const _xsd_BerthMajorVesselClassCode_literals_[5];
    static const value _xsd_BerthMajorVesselClassCode_indexes_[5];
  };

  class BerthRailAvailabilityIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    BerthRailAvailabilityIndicatorCode (value v);

    BerthRailAvailabilityIndicatorCode (const char* v);

    BerthRailAvailabilityIndicatorCode (const ::std::string& v);

    BerthRailAvailabilityIndicatorCode (const ::xml_schema::token& v);

    BerthRailAvailabilityIndicatorCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    BerthRailAvailabilityIndicatorCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    BerthRailAvailabilityIndicatorCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    BerthRailAvailabilityIndicatorCode (const BerthRailAvailabilityIndicatorCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual BerthRailAvailabilityIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    BerthRailAvailabilityIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_BerthRailAvailabilityIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_BerthRailAvailabilityIndicatorCode_convert () const;

    public:
    static const char* const _xsd_BerthRailAvailabilityIndicatorCode_literals_[2];
    static const value _xsd_BerthRailAvailabilityIndicatorCode_indexes_[2];
  };

  class BerthRollOnRollOffIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    BerthRollOnRollOffIndicatorCode (value v);

    BerthRollOnRollOffIndicatorCode (const char* v);

    BerthRollOnRollOffIndicatorCode (const ::std::string& v);

    BerthRollOnRollOffIndicatorCode (const ::xml_schema::token& v);

    BerthRollOnRollOffIndicatorCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    BerthRollOnRollOffIndicatorCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    BerthRollOnRollOffIndicatorCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    BerthRollOnRollOffIndicatorCode (const BerthRollOnRollOffIndicatorCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual BerthRollOnRollOffIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    BerthRollOnRollOffIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_BerthRollOnRollOffIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_BerthRollOnRollOffIndicatorCode_convert () const;

    public:
    static const char* const _xsd_BerthRollOnRollOffIndicatorCode_literals_[2];
    static const value _xsd_BerthRollOnRollOffIndicatorCode_indexes_[2];
  };

  class BiologicalMaterielTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BACTRL,
      NKN,
      NOS,
      TOXIN,
      TOXMAT,
      VIRAL
    };

    BiologicalMaterielTypeCategoryCode (value v);

    BiologicalMaterielTypeCategoryCode (const char* v);

    BiologicalMaterielTypeCategoryCode (const ::std::string& v);

    BiologicalMaterielTypeCategoryCode (const ::xml_schema::token& v);

    BiologicalMaterielTypeCategoryCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    BiologicalMaterielTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    BiologicalMaterielTypeCategoryCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    BiologicalMaterielTypeCategoryCode (const BiologicalMaterielTypeCategoryCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual BiologicalMaterielTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    BiologicalMaterielTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_BiologicalMaterielTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_BiologicalMaterielTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_BiologicalMaterielTypeCategoryCode_literals_[6];
    static const value _xsd_BiologicalMaterielTypeCategoryCode_indexes_[6];
  };

  class BiologicalMaterielTypeSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CHLMYD,
      NOS,
      RCKETS
    };

    BiologicalMaterielTypeSubcategoryCode (value v);

    BiologicalMaterielTypeSubcategoryCode (const char* v);

    BiologicalMaterielTypeSubcategoryCode (const ::std::string& v);

    BiologicalMaterielTypeSubcategoryCode (const ::xml_schema::token& v);

    BiologicalMaterielTypeSubcategoryCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    BiologicalMaterielTypeSubcategoryCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    BiologicalMaterielTypeSubcategoryCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    BiologicalMaterielTypeSubcategoryCode (const BiologicalMaterielTypeSubcategoryCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual BiologicalMaterielTypeSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    BiologicalMaterielTypeSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_BiologicalMaterielTypeSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_BiologicalMaterielTypeSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_BiologicalMaterielTypeSubcategoryCode_literals_[3];
    static const value _xsd_BiologicalMaterielTypeSubcategoryCode_indexes_[3];
  };

  class BridgeTypeDesignTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ARCH,
      BXGRDR,
      CNTLVR,
      FERRY,
      FLTBOT,
      FLTNOS,
      FLTPNT,
      LIFT,
      MILMDG,
      MILVHL,
      NKN,
      NOS,
      RAFT,
      SLAB,
      SSPNSN,
      STRNGR,
      SWING,
      TRUSS
    };

    BridgeTypeDesignTypeCode (value v);

    BridgeTypeDesignTypeCode (const char* v);

    BridgeTypeDesignTypeCode (const ::std::string& v);

    BridgeTypeDesignTypeCode (const ::xml_schema::token& v);

    BridgeTypeDesignTypeCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    BridgeTypeDesignTypeCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    BridgeTypeDesignTypeCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    BridgeTypeDesignTypeCode (const BridgeTypeDesignTypeCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual BridgeTypeDesignTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    BridgeTypeDesignTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_BridgeTypeDesignTypeCode_convert ();
    }

    protected:
    value
    _xsd_BridgeTypeDesignTypeCode_convert () const;

    public:
    static const char* const _xsd_BridgeTypeDesignTypeCode_literals_[18];
    static const value _xsd_BridgeTypeDesignTypeCode_indexes_[18];
  };

  class BridgeUsageCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FOOT,
      MLTUSE,
      NKN,
      NOS,
      RAILWY,
      RLWYVH,
      VEHCLE
    };

    BridgeUsageCode (value v);

    BridgeUsageCode (const char* v);

    BridgeUsageCode (const ::std::string& v);

    BridgeUsageCode (const ::xml_schema::token& v);

    BridgeUsageCode (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    BridgeUsageCode (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    BridgeUsageCode (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    BridgeUsageCode (const BridgeUsageCode& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual BridgeUsageCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    BridgeUsageCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_BridgeUsageCode_convert ();
    }

    protected:
    value
    _xsd_BridgeUsageCode_convert () const;

    public:
    static const char* const _xsd_BridgeUsageCode_literals_[7];
    static const value _xsd_BridgeUsageCode_indexes_[7];
  };

  class CandidateTargetDetailAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      COLOC,
      COMPNT
    };

    CandidateTargetDetailAssociationCategoryCode (value v);

    CandidateTargetDetailAssociationCategoryCode (const char* v);

    CandidateTargetDetailAssociationCategoryCode (const ::std::string& v);

    CandidateTargetDetailAssociationCategoryCode (const ::xml_schema::token& v);

    CandidateTargetDetailAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    CandidateTargetDetailAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    CandidateTargetDetailAssociationCategoryCode (const ::std::string& s,
                                                  const ::xercesc::DOMElement* e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    CandidateTargetDetailAssociationCategoryCode (const CandidateTargetDetailAssociationCategoryCode& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    virtual CandidateTargetDetailAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CandidateTargetDetailAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CandidateTargetDetailAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_CandidateTargetDetailAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_CandidateTargetDetailAssociationCategoryCode_literals_[2];
    static const value _xsd_CandidateTargetDetailAssociationCategoryCode_indexes_[2];
  };

  class CandidateTargetDetailAuthorisationApprovalCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      APPAVL,
      APPEXC,
      NOTAPP
    };

    CandidateTargetDetailAuthorisationApprovalCode (value v);

    CandidateTargetDetailAuthorisationApprovalCode (const char* v);

    CandidateTargetDetailAuthorisationApprovalCode (const ::std::string& v);

    CandidateTargetDetailAuthorisationApprovalCode (const ::xml_schema::token& v);

    CandidateTargetDetailAuthorisationApprovalCode (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    CandidateTargetDetailAuthorisationApprovalCode (const ::xercesc::DOMAttr& a,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    CandidateTargetDetailAuthorisationApprovalCode (const ::std::string& s,
                                                    const ::xercesc::DOMElement* e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    CandidateTargetDetailAuthorisationApprovalCode (const CandidateTargetDetailAuthorisationApprovalCode& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    virtual CandidateTargetDetailAuthorisationApprovalCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CandidateTargetDetailAuthorisationApprovalCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CandidateTargetDetailAuthorisationApprovalCode_convert ();
    }

    protected:
    value
    _xsd_CandidateTargetDetailAuthorisationApprovalCode_convert () const;

    public:
    static const char* const _xsd_CandidateTargetDetailAuthorisationApprovalCode_literals_[3];
    static const value _xsd_CandidateTargetDetailAuthorisationApprovalCode_indexes_[3];
  };

  class CandidateTargetDetailCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CTDITM,
      CTDTYP
    };

    CandidateTargetDetailCategoryCode (value v);

    CandidateTargetDetailCategoryCode (const char* v);

    CandidateTargetDetailCategoryCode (const ::std::string& v);

    CandidateTargetDetailCategoryCode (const ::xml_schema::token& v);

    CandidateTargetDetailCategoryCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    CandidateTargetDetailCategoryCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    CandidateTargetDetailCategoryCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    CandidateTargetDetailCategoryCode (const CandidateTargetDetailCategoryCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual CandidateTargetDetailCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CandidateTargetDetailCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CandidateTargetDetailCategoryCode_convert ();
    }

    protected:
    value
    _xsd_CandidateTargetDetailCategoryCode_convert () const;

    public:
    static const char* const _xsd_CandidateTargetDetailCategoryCode_literals_[2];
    static const value _xsd_CandidateTargetDetailCategoryCode_indexes_[2];
  };

  class CandidateTargetDetailFocusTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ATTACK,
      CAPTUR,
      DEFEAT,
      DESTRY,
      DONOTA,
      ILLUMN,
      INFILT,
      INTCEP,
      JAM,
      LOCATE,
      MARK,
      NOS,
      NUTRLS,
      OBSRV,
      OCCUPY,
      RECCE,
      SUPPRS
    };

    CandidateTargetDetailFocusTypeCode (value v);

    CandidateTargetDetailFocusTypeCode (const char* v);

    CandidateTargetDetailFocusTypeCode (const ::std::string& v);

    CandidateTargetDetailFocusTypeCode (const ::xml_schema::token& v);

    CandidateTargetDetailFocusTypeCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    CandidateTargetDetailFocusTypeCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    CandidateTargetDetailFocusTypeCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    CandidateTargetDetailFocusTypeCode (const CandidateTargetDetailFocusTypeCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual CandidateTargetDetailFocusTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CandidateTargetDetailFocusTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CandidateTargetDetailFocusTypeCode_convert ();
    }

    protected:
    value
    _xsd_CandidateTargetDetailFocusTypeCode_convert () const;

    public:
    static const char* const _xsd_CandidateTargetDetailFocusTypeCode_literals_[17];
    static const value _xsd_CandidateTargetDetailFocusTypeCode_indexes_[17];
  };

  class CandidateTargetDetailSchemeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ABCA,
      BE,
      FIBE,
      ORGANL,
      SITENR
    };

    CandidateTargetDetailSchemeCode (value v);

    CandidateTargetDetailSchemeCode (const char* v);

    CandidateTargetDetailSchemeCode (const ::std::string& v);

    CandidateTargetDetailSchemeCode (const ::xml_schema::token& v);

    CandidateTargetDetailSchemeCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    CandidateTargetDetailSchemeCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    CandidateTargetDetailSchemeCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    CandidateTargetDetailSchemeCode (const CandidateTargetDetailSchemeCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual CandidateTargetDetailSchemeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CandidateTargetDetailSchemeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CandidateTargetDetailSchemeCode_convert ();
    }

    protected:
    value
    _xsd_CandidateTargetDetailSchemeCode_convert () const;

    public:
    static const char* const _xsd_CandidateTargetDetailSchemeCode_literals_[5];
    static const value _xsd_CandidateTargetDetailSchemeCode_indexes_[5];
  };

  class CandidateTargetListAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      COMPNT,
      INCPRT,
      PRECED,
      REPLAC
    };

    CandidateTargetListAssociationCategoryCode (value v);

    CandidateTargetListAssociationCategoryCode (const char* v);

    CandidateTargetListAssociationCategoryCode (const ::std::string& v);

    CandidateTargetListAssociationCategoryCode (const ::xml_schema::token& v);

    CandidateTargetListAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    CandidateTargetListAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    CandidateTargetListAssociationCategoryCode (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    CandidateTargetListAssociationCategoryCode (const CandidateTargetListAssociationCategoryCode& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual CandidateTargetListAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CandidateTargetListAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CandidateTargetListAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_CandidateTargetListAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_CandidateTargetListAssociationCategoryCode_literals_[4];
    static const value _xsd_CandidateTargetListAssociationCategoryCode_indexes_[4];
  };

  class CandidateTargetListAuthorisationIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    CandidateTargetListAuthorisationIndicatorCode (value v);

    CandidateTargetListAuthorisationIndicatorCode (const char* v);

    CandidateTargetListAuthorisationIndicatorCode (const ::std::string& v);

    CandidateTargetListAuthorisationIndicatorCode (const ::xml_schema::token& v);

    CandidateTargetListAuthorisationIndicatorCode (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    CandidateTargetListAuthorisationIndicatorCode (const ::xercesc::DOMAttr& a,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    CandidateTargetListAuthorisationIndicatorCode (const ::std::string& s,
                                                   const ::xercesc::DOMElement* e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    CandidateTargetListAuthorisationIndicatorCode (const CandidateTargetListAuthorisationIndicatorCode& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    virtual CandidateTargetListAuthorisationIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CandidateTargetListAuthorisationIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CandidateTargetListAuthorisationIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_CandidateTargetListAuthorisationIndicatorCode_convert () const;

    public:
    static const char* const _xsd_CandidateTargetListAuthorisationIndicatorCode_literals_[2];
    static const value _xsd_CandidateTargetListAuthorisationIndicatorCode_indexes_[2];
  };

  class CapabilityCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ENGI,
      FIRE,
      HNDLNG,
      MAIN,
      MOBL,
      OPERAT,
      STOR,
      SUPPRT,
      SURV,
      TRANSM
    };

    CapabilityCategoryCode (value v);

    CapabilityCategoryCode (const char* v);

    CapabilityCategoryCode (const ::std::string& v);

    CapabilityCategoryCode (const ::xml_schema::token& v);

    CapabilityCategoryCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    CapabilityCategoryCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    CapabilityCategoryCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    CapabilityCategoryCode (const CapabilityCategoryCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual CapabilityCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CapabilityCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CapabilityCategoryCode_convert ();
    }

    protected:
    value
    _xsd_CapabilityCategoryCode_convert () const;

    public:
    static const char* const _xsd_CapabilityCategoryCode_literals_[10];
    static const value _xsd_CapabilityCategoryCode_indexes_[10];
  };

  class CapabilityDayNightCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DAY,
      DN,
      N
    };

    CapabilityDayNightCode (value v);

    CapabilityDayNightCode (const char* v);

    CapabilityDayNightCode (const ::std::string& v);

    CapabilityDayNightCode (const ::xml_schema::token& v);

    CapabilityDayNightCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    CapabilityDayNightCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    CapabilityDayNightCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    CapabilityDayNightCode (const CapabilityDayNightCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual CapabilityDayNightCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CapabilityDayNightCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CapabilityDayNightCode_convert ();
    }

    protected:
    value
    _xsd_CapabilityDayNightCode_convert () const;

    public:
    static const char* const _xsd_CapabilityDayNightCode_literals_[3];
    static const value _xsd_CapabilityDayNightCode_indexes_[3];
  };

  class CapabilityReferenceAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ISAMPL,
      ISDFND,
      ISDSCR
    };

    CapabilityReferenceAssociationCategoryCode (value v);

    CapabilityReferenceAssociationCategoryCode (const char* v);

    CapabilityReferenceAssociationCategoryCode (const ::std::string& v);

    CapabilityReferenceAssociationCategoryCode (const ::xml_schema::token& v);

    CapabilityReferenceAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    CapabilityReferenceAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    CapabilityReferenceAssociationCategoryCode (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    CapabilityReferenceAssociationCategoryCode (const CapabilityReferenceAssociationCategoryCode& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual CapabilityReferenceAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CapabilityReferenceAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CapabilityReferenceAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_CapabilityReferenceAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_CapabilityReferenceAssociationCategoryCode_literals_[3];
    static const value _xsd_CapabilityReferenceAssociationCategoryCode_indexes_[3];
  };

  class CapabilityUnitOfMeasureCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CM,
      CMH,
      DEG,
      EA,
      GHZ,
      HR,
      HZ,
      ITEMPD,
      ITEMPH,
      ITEMPM,
      KG,
      KGH,
      KHZ,
      KM,
      KNOTS,
      KPH,
      LI,
      LPH,
      LPM,
      MANHUR,
      METRE,
      MHPRHR,
      MHZ,
      MINUTE,
      MPS,
      MTRCTN,
      NM,
      PPS,
      PRCNTG,
      RDM,
      SECOND,
      SMH,
      SQM,
      UNTLS,
      WATT
    };

    CapabilityUnitOfMeasureCode (value v);

    CapabilityUnitOfMeasureCode (const char* v);

    CapabilityUnitOfMeasureCode (const ::std::string& v);

    CapabilityUnitOfMeasureCode (const ::xml_schema::token& v);

    CapabilityUnitOfMeasureCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    CapabilityUnitOfMeasureCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    CapabilityUnitOfMeasureCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    CapabilityUnitOfMeasureCode (const CapabilityUnitOfMeasureCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual CapabilityUnitOfMeasureCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CapabilityUnitOfMeasureCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CapabilityUnitOfMeasureCode_convert ();
    }

    protected:
    value
    _xsd_CapabilityUnitOfMeasureCode_convert () const;

    public:
    static const char* const _xsd_CapabilityUnitOfMeasureCode_literals_[35];
    static const value _xsd_CapabilityUnitOfMeasureCode_indexes_[35];
  };

  class CargoCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ACFT,
      AGP,
      AMMO,
      ARAMEX,
      BOATS,
      BULK,
      CHE,
      CHILL,
      CLASS,
      COL,
      CON,
      CTR,
      DRY,
      FOP,
      FREEZE,
      GEN,
      HAZMAT,
      HYEQPT,
      LIQUID,
      MAC,
      MAIL,
      MAT,
      MCH,
      MED,
      MIM,
      OTR,
      PAX,
      PERS,
      POL,
      POW,
      SPECL,
      SUBS,
      SUG,
      TEX,
      TROOPS,
      VEH,
      VEHT,
      VEHW,
      WOUND
    };

    CargoCategoryCode (value v);

    CargoCategoryCode (const char* v);

    CargoCategoryCode (const ::std::string& v);

    CargoCategoryCode (const ::xml_schema::token& v);

    CargoCategoryCode (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    CargoCategoryCode (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    CargoCategoryCode (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    CargoCategoryCode (const CargoCategoryCode& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual CargoCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CargoCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CargoCategoryCode_convert ();
    }

    protected:
    value
    _xsd_CargoCategoryCode_convert () const;

    public:
    static const char* const _xsd_CargoCategoryCode_literals_[39];
    static const value _xsd_CargoCategoryCode_indexes_[39];
  };

  class CasualtyGroupCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FRFOR,
      LOCCIV,
      OPFOR
    };

    CasualtyGroupCode (value v);

    CasualtyGroupCode (const char* v);

    CasualtyGroupCode (const ::std::string& v);

    CasualtyGroupCode (const ::xml_schema::token& v);

    CasualtyGroupCode (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    CasualtyGroupCode (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    CasualtyGroupCode (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    CasualtyGroupCode (const CasualtyGroupCode& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual CasualtyGroupCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CasualtyGroupCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CasualtyGroupCode_convert ();
    }

    protected:
    value
    _xsd_CasualtyGroupCode_convert () const;

    public:
    static const char* const _xsd_CasualtyGroupCode_literals_[3];
    static const value _xsd_CasualtyGroupCode_indexes_[3];
  };

  class CbrnEquipmentTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ABICHM,
      ABIDET,
      ACHDET,
      ARDDET,
      BIOINT,
      BIOSTO,
      CBRNDC,
      CBRNRC,
      CHMMON,
      MSSPTR,
      NKN,
      NOS,
      RADKIT,
      RDSPTR
    };

    CbrnEquipmentTypeCategoryCode (value v);

    CbrnEquipmentTypeCategoryCode (const char* v);

    CbrnEquipmentTypeCategoryCode (const ::std::string& v);

    CbrnEquipmentTypeCategoryCode (const ::xml_schema::token& v);

    CbrnEquipmentTypeCategoryCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    CbrnEquipmentTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    CbrnEquipmentTypeCategoryCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    CbrnEquipmentTypeCategoryCode (const CbrnEquipmentTypeCategoryCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual CbrnEquipmentTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CbrnEquipmentTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CbrnEquipmentTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_CbrnEquipmentTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_CbrnEquipmentTypeCategoryCode_literals_[14];
    static const value _xsd_CbrnEquipmentTypeCategoryCode_indexes_[14];
  };

  class CbrnEventAlarmResultIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    CbrnEventAlarmResultIndicatorCode (value v);

    CbrnEventAlarmResultIndicatorCode (const char* v);

    CbrnEventAlarmResultIndicatorCode (const ::std::string& v);

    CbrnEventAlarmResultIndicatorCode (const ::xml_schema::token& v);

    CbrnEventAlarmResultIndicatorCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    CbrnEventAlarmResultIndicatorCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    CbrnEventAlarmResultIndicatorCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    CbrnEventAlarmResultIndicatorCode (const CbrnEventAlarmResultIndicatorCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual CbrnEventAlarmResultIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CbrnEventAlarmResultIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CbrnEventAlarmResultIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_CbrnEventAlarmResultIndicatorCode_convert () const;

    public:
    static const char* const _xsd_CbrnEventAlarmResultIndicatorCode_literals_[2];
    static const value _xsd_CbrnEventAlarmResultIndicatorCode_indexes_[2];
  };

  class CbrnEventCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CHMBIO,
      NKN,
      RADCTV,
      UNROTA
    };

    CbrnEventCategoryCode (value v);

    CbrnEventCategoryCode (const char* v);

    CbrnEventCategoryCode (const ::std::string& v);

    CbrnEventCategoryCode (const ::xml_schema::token& v);

    CbrnEventCategoryCode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    CbrnEventCategoryCode (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    CbrnEventCategoryCode (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    CbrnEventCategoryCode (const CbrnEventCategoryCode& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual CbrnEventCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CbrnEventCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CbrnEventCategoryCode_convert ();
    }

    protected:
    value
    _xsd_CbrnEventCategoryCode_convert () const;

    public:
    static const char* const _xsd_CbrnEventCategoryCode_literals_[4];
    static const value _xsd_CbrnEventCategoryCode_indexes_[4];
  };

  class CbrnEventConfirmationTestIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    CbrnEventConfirmationTestIndicatorCode (value v);

    CbrnEventConfirmationTestIndicatorCode (const char* v);

    CbrnEventConfirmationTestIndicatorCode (const ::std::string& v);

    CbrnEventConfirmationTestIndicatorCode (const ::xml_schema::token& v);

    CbrnEventConfirmationTestIndicatorCode (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    CbrnEventConfirmationTestIndicatorCode (const ::xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    CbrnEventConfirmationTestIndicatorCode (const ::std::string& s,
                                            const ::xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    CbrnEventConfirmationTestIndicatorCode (const CbrnEventConfirmationTestIndicatorCode& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual CbrnEventConfirmationTestIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CbrnEventConfirmationTestIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CbrnEventConfirmationTestIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_CbrnEventConfirmationTestIndicatorCode_convert () const;

    public:
    static const char* const _xsd_CbrnEventConfirmationTestIndicatorCode_literals_[2];
    static const value _xsd_CbrnEventConfirmationTestIndicatorCode_indexes_[2];
  };

  class CbrnEventMaterielContainerTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BML,
      BOM,
      BTL,
      BUK,
      CON,
      DRM,
      GEN,
      MNE,
      MSL,
      NKN,
      RCT,
      RKT,
      SHL,
      SPR,
      STK,
      TNK,
      TOR,
      WST
    };

    CbrnEventMaterielContainerTypeCode (value v);

    CbrnEventMaterielContainerTypeCode (const char* v);

    CbrnEventMaterielContainerTypeCode (const ::std::string& v);

    CbrnEventMaterielContainerTypeCode (const ::xml_schema::token& v);

    CbrnEventMaterielContainerTypeCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    CbrnEventMaterielContainerTypeCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    CbrnEventMaterielContainerTypeCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    CbrnEventMaterielContainerTypeCode (const CbrnEventMaterielContainerTypeCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual CbrnEventMaterielContainerTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CbrnEventMaterielContainerTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CbrnEventMaterielContainerTypeCode_convert ();
    }

    protected:
    value
    _xsd_CbrnEventMaterielContainerTypeCode_convert () const;

    public:
    static const char* const _xsd_CbrnEventMaterielContainerTypeCode_literals_[18];
    static const value _xsd_CbrnEventMaterielContainerTypeCode_indexes_[18];
  };

  class CbrnEventSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIRSMP,
      ALPRAD,
      ARBRST,
      BETRAD,
      BRNFIR,
      CBRNCL,
      CNTFLW,
      GAMRAD,
      LQDSMP,
      LRGSPL,
      NEUTRN,
      NKN,
      NOS,
      SBSRBU,
      SIBCA,
      SIRA,
      SMLSPL,
      SURBUR
    };

    CbrnEventSubcategoryCode (value v);

    CbrnEventSubcategoryCode (const char* v);

    CbrnEventSubcategoryCode (const ::std::string& v);

    CbrnEventSubcategoryCode (const ::xml_schema::token& v);

    CbrnEventSubcategoryCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    CbrnEventSubcategoryCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    CbrnEventSubcategoryCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    CbrnEventSubcategoryCode (const CbrnEventSubcategoryCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual CbrnEventSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CbrnEventSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CbrnEventSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_CbrnEventSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_CbrnEventSubcategoryCode_literals_[18];
    static const value _xsd_CbrnEventSubcategoryCode_indexes_[18];
  };

  class ChemicalBiologicalEventCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BIOALM,
      BIOATT,
      BIOSMP,
      BIROTA,
      CBFAC,
      CHMALM,
      CHMATT,
      CHMSMP,
      CHROTA,
      NKN
    };

    ChemicalBiologicalEventCategoryCode (value v);

    ChemicalBiologicalEventCategoryCode (const char* v);

    ChemicalBiologicalEventCategoryCode (const ::std::string& v);

    ChemicalBiologicalEventCategoryCode (const ::xml_schema::token& v);

    ChemicalBiologicalEventCategoryCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ChemicalBiologicalEventCategoryCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ChemicalBiologicalEventCategoryCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ChemicalBiologicalEventCategoryCode (const ChemicalBiologicalEventCategoryCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual ChemicalBiologicalEventCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ChemicalBiologicalEventCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ChemicalBiologicalEventCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ChemicalBiologicalEventCategoryCode_convert () const;

    public:
    static const char* const _xsd_ChemicalBiologicalEventCategoryCode_literals_[10];
    static const value _xsd_ChemicalBiologicalEventCategoryCode_indexes_[10];
  };

  class ChemicalBiologicalEventSpillSizeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      LRG,
      NKN,
      SML,
      XLG
    };

    ChemicalBiologicalEventSpillSizeCode (value v);

    ChemicalBiologicalEventSpillSizeCode (const char* v);

    ChemicalBiologicalEventSpillSizeCode (const ::std::string& v);

    ChemicalBiologicalEventSpillSizeCode (const ::xml_schema::token& v);

    ChemicalBiologicalEventSpillSizeCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ChemicalBiologicalEventSpillSizeCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ChemicalBiologicalEventSpillSizeCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ChemicalBiologicalEventSpillSizeCode (const ChemicalBiologicalEventSpillSizeCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual ChemicalBiologicalEventSpillSizeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ChemicalBiologicalEventSpillSizeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ChemicalBiologicalEventSpillSizeCode_convert ();
    }

    protected:
    value
    _xsd_ChemicalBiologicalEventSpillSizeCode_convert () const;

    public:
    static const char* const _xsd_ChemicalBiologicalEventSpillSizeCode_literals_[4];
    static const value _xsd_ChemicalBiologicalEventSpillSizeCode_indexes_[4];
  };

  class ChemicalMaterielTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BLISTR,
      BLOOD,
      CHKNG,
      GAGENT,
      INCPCT,
      IRRTNT,
      MUSTRD,
      NERVE,
      NKN,
      NOS,
      PNTRNG,
      TOXMAT,
      VAGENT,
      VOMTNG
    };

    ChemicalMaterielTypeCategoryCode (value v);

    ChemicalMaterielTypeCategoryCode (const char* v);

    ChemicalMaterielTypeCategoryCode (const ::std::string& v);

    ChemicalMaterielTypeCategoryCode (const ::xml_schema::token& v);

    ChemicalMaterielTypeCategoryCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    ChemicalMaterielTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    ChemicalMaterielTypeCategoryCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    ChemicalMaterielTypeCategoryCode (const ChemicalMaterielTypeCategoryCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual ChemicalMaterielTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ChemicalMaterielTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ChemicalMaterielTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ChemicalMaterielTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_ChemicalMaterielTypeCategoryCode_literals_[14];
    static const value _xsd_ChemicalMaterielTypeCategoryCode_indexes_[14];
  };

  class ChemicalMaterielTypeSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ARSINE,
      CHLRPC,
      CYCLSR,
      CYNGNC,
      DIPSGN,
      HDRNCY,
      LWSITE,
      MSTRDD,
      MSTRDL,
      NKN,
      NOS,
      NTRGNM,
      PHOSGN,
      PHSGNO,
      QNCLDN,
      SARIN,
      SOMAN,
      TABUN,
      TRGAS,
      TRMRCM,
      VX
    };

    ChemicalMaterielTypeSubcategoryCode (value v);

    ChemicalMaterielTypeSubcategoryCode (const char* v);

    ChemicalMaterielTypeSubcategoryCode (const ::std::string& v);

    ChemicalMaterielTypeSubcategoryCode (const ::xml_schema::token& v);

    ChemicalMaterielTypeSubcategoryCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ChemicalMaterielTypeSubcategoryCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ChemicalMaterielTypeSubcategoryCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ChemicalMaterielTypeSubcategoryCode (const ChemicalMaterielTypeSubcategoryCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual ChemicalMaterielTypeSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ChemicalMaterielTypeSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ChemicalMaterielTypeSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_ChemicalMaterielTypeSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_ChemicalMaterielTypeSubcategoryCode_literals_[21];
    static const value _xsd_ChemicalMaterielTypeSubcategoryCode_indexes_[21];
  };

  class CivilianPostTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIDADM,
      ALDRMN,
      COREXC,
      DEPTHD,
      GOVMST,
      GOVRNR,
      HEADST,
      MAYOR,
      NOS,
      POLCHF,
      PUBLSR,
      REGADM,
      RELATH
    };

    CivilianPostTypeCategoryCode (value v);

    CivilianPostTypeCategoryCode (const char* v);

    CivilianPostTypeCategoryCode (const ::std::string& v);

    CivilianPostTypeCategoryCode (const ::xml_schema::token& v);

    CivilianPostTypeCategoryCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    CivilianPostTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    CivilianPostTypeCategoryCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    CivilianPostTypeCategoryCode (const CivilianPostTypeCategoryCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual CivilianPostTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CivilianPostTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CivilianPostTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_CivilianPostTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_CivilianPostTypeCategoryCode_literals_[13];
    static const value _xsd_CivilianPostTypeCategoryCode_indexes_[13];
  };

  class CloudCoverAverageCoverageCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_0,
      cxx_1,
      cxx_2,
      cxx_3,
      cxx_4,
      cxx_5,
      cxx_6,
      cxx_7,
      cxx_78,
      cxx_8
    };

    CloudCoverAverageCoverageCode (value v);

    CloudCoverAverageCoverageCode (const char* v);

    CloudCoverAverageCoverageCode (const ::std::string& v);

    CloudCoverAverageCoverageCode (const ::xml_schema::token& v);

    CloudCoverAverageCoverageCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    CloudCoverAverageCoverageCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    CloudCoverAverageCoverageCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    CloudCoverAverageCoverageCode (const CloudCoverAverageCoverageCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual CloudCoverAverageCoverageCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CloudCoverAverageCoverageCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CloudCoverAverageCoverageCode_convert ();
    }

    protected:
    value
    _xsd_CloudCoverAverageCoverageCode_convert () const;

    public:
    static const char* const _xsd_CloudCoverAverageCoverageCode_literals_[10];
    static const value _xsd_CloudCoverAverageCoverageCode_indexes_[10];
  };

  class CloudCoverCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      C,
      RDACCL,
      SMOKE
    };

    CloudCoverCategoryCode (value v);

    CloudCoverCategoryCode (const char* v);

    CloudCoverCategoryCode (const ::std::string& v);

    CloudCoverCategoryCode (const ::xml_schema::token& v);

    CloudCoverCategoryCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    CloudCoverCategoryCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    CloudCoverCategoryCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    CloudCoverCategoryCode (const CloudCoverCategoryCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual CloudCoverCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CloudCoverCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CloudCoverCategoryCode_convert ();
    }

    protected:
    value
    _xsd_CloudCoverCategoryCode_convert () const;

    public:
    static const char* const _xsd_CloudCoverCategoryCode_literals_[3];
    static const value _xsd_CloudCoverCategoryCode_indexes_[3];
  };

  class ConsumableMaterielTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AMMO,
      BIOMAT,
      CHMMAT,
      CON,
      CROPS,
      DRUG,
      FLARE,
      FOO,
      FUEL,
      FUSE,
      GENSPL,
      IMEXDE,
      MAMNEX,
      MAP,
      MEDSPL,
      MONEY,
      NKN,
      PEREQU,
      POL,
      RADMAT,
      SPRPRT,
      WAT
    };

    ConsumableMaterielTypeCategoryCode (value v);

    ConsumableMaterielTypeCategoryCode (const char* v);

    ConsumableMaterielTypeCategoryCode (const ::std::string& v);

    ConsumableMaterielTypeCategoryCode (const ::xml_schema::token& v);

    ConsumableMaterielTypeCategoryCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    ConsumableMaterielTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    ConsumableMaterielTypeCategoryCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    ConsumableMaterielTypeCategoryCode (const ConsumableMaterielTypeCategoryCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual ConsumableMaterielTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConsumableMaterielTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ConsumableMaterielTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ConsumableMaterielTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_ConsumableMaterielTypeCategoryCode_literals_[22];
    static const value _xsd_ConsumableMaterielTypeCategoryCode_indexes_[22];
  };

  class ConsumableMaterielTypeHazardCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BIOLOG,
      CHM,
      COR,
      EXPLOS,
      INF,
      NKN,
      NOS,
      RAD,
      TOX
    };

    ConsumableMaterielTypeHazardCode (value v);

    ConsumableMaterielTypeHazardCode (const char* v);

    ConsumableMaterielTypeHazardCode (const ::std::string& v);

    ConsumableMaterielTypeHazardCode (const ::xml_schema::token& v);

    ConsumableMaterielTypeHazardCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    ConsumableMaterielTypeHazardCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    ConsumableMaterielTypeHazardCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    ConsumableMaterielTypeHazardCode (const ConsumableMaterielTypeHazardCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual ConsumableMaterielTypeHazardCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConsumableMaterielTypeHazardCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ConsumableMaterielTypeHazardCode_convert ();
    }

    protected:
    value
    _xsd_ConsumableMaterielTypeHazardCode_convert () const;

    public:
    static const char* const _xsd_ConsumableMaterielTypeHazardCode_literals_[9];
    static const value _xsd_ConsumableMaterielTypeHazardCode_indexes_[9];
  };

  class ConsumableMaterielTypeIssuingElementCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BALE,
      BARREL,
      BLK,
      BOX,
      CASE,
      COIL,
      CONTNR,
      CRATE,
      DAYSPL,
      DRM,
      JERCAN,
      PAK,
      PAL,
      RATION,
      ROUND,
      UNT
    };

    ConsumableMaterielTypeIssuingElementCode (value v);

    ConsumableMaterielTypeIssuingElementCode (const char* v);

    ConsumableMaterielTypeIssuingElementCode (const ::std::string& v);

    ConsumableMaterielTypeIssuingElementCode (const ::xml_schema::token& v);

    ConsumableMaterielTypeIssuingElementCode (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ConsumableMaterielTypeIssuingElementCode (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ConsumableMaterielTypeIssuingElementCode (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ConsumableMaterielTypeIssuingElementCode (const ConsumableMaterielTypeIssuingElementCode& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual ConsumableMaterielTypeIssuingElementCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConsumableMaterielTypeIssuingElementCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ConsumableMaterielTypeIssuingElementCode_convert ();
    }

    protected:
    value
    _xsd_ConsumableMaterielTypeIssuingElementCode_convert () const;

    public:
    static const char* const _xsd_ConsumableMaterielTypeIssuingElementCode_literals_[16];
    static const value _xsd_ConsumableMaterielTypeIssuingElementCode_indexes_[16];
  };

  class ConsumableMaterielTypeIssuingUnitOfMeasureCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CM,
      CNTMTR,
      DOZEN,
      EA,
      GRAM,
      GROSS,
      KILTON,
      KM,
      LI,
      LONGTN,
      METRE,
      MILGRM,
      MILLTR,
      MILMTR,
      MTRCTN,
      SHRTTN,
      SQM,
      KG
    };

    ConsumableMaterielTypeIssuingUnitOfMeasureCode (value v);

    ConsumableMaterielTypeIssuingUnitOfMeasureCode (const char* v);

    ConsumableMaterielTypeIssuingUnitOfMeasureCode (const ::std::string& v);

    ConsumableMaterielTypeIssuingUnitOfMeasureCode (const ::xml_schema::token& v);

    ConsumableMaterielTypeIssuingUnitOfMeasureCode (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    ConsumableMaterielTypeIssuingUnitOfMeasureCode (const ::xercesc::DOMAttr& a,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    ConsumableMaterielTypeIssuingUnitOfMeasureCode (const ::std::string& s,
                                                    const ::xercesc::DOMElement* e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    ConsumableMaterielTypeIssuingUnitOfMeasureCode (const ConsumableMaterielTypeIssuingUnitOfMeasureCode& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    virtual ConsumableMaterielTypeIssuingUnitOfMeasureCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConsumableMaterielTypeIssuingUnitOfMeasureCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ConsumableMaterielTypeIssuingUnitOfMeasureCode_convert ();
    }

    protected:
    value
    _xsd_ConsumableMaterielTypeIssuingUnitOfMeasureCode_convert () const;

    public:
    static const char* const _xsd_ConsumableMaterielTypeIssuingUnitOfMeasureCode_literals_[18];
    static const value _xsd_ConsumableMaterielTypeIssuingUnitOfMeasureCode_indexes_[18];
  };

  class ConsumableMaterielTypePerishabilityIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    ConsumableMaterielTypePerishabilityIndicatorCode (value v);

    ConsumableMaterielTypePerishabilityIndicatorCode (const char* v);

    ConsumableMaterielTypePerishabilityIndicatorCode (const ::std::string& v);

    ConsumableMaterielTypePerishabilityIndicatorCode (const ::xml_schema::token& v);

    ConsumableMaterielTypePerishabilityIndicatorCode (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    ConsumableMaterielTypePerishabilityIndicatorCode (const ::xercesc::DOMAttr& a,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    ConsumableMaterielTypePerishabilityIndicatorCode (const ::std::string& s,
                                                      const ::xercesc::DOMElement* e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    ConsumableMaterielTypePerishabilityIndicatorCode (const ConsumableMaterielTypePerishabilityIndicatorCode& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    virtual ConsumableMaterielTypePerishabilityIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConsumableMaterielTypePerishabilityIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ConsumableMaterielTypePerishabilityIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_ConsumableMaterielTypePerishabilityIndicatorCode_convert () const;

    public:
    static const char* const _xsd_ConsumableMaterielTypePerishabilityIndicatorCode_literals_[2];
    static const value _xsd_ConsumableMaterielTypePerishabilityIndicatorCode_indexes_[2];
  };

  class ConsumableMaterielTypeSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_2CB,
      AMPHTM,
      AVNFU,
      BALNHH,
      BATDWC,
      BBYTRP,
      BLOOD,
      BNDDR,
      BOOK,
      CLTHNG,
      COAL,
      COCANE,
      CRACK,
      DIESEL,
      DOB,
      ECSMDA,
      ECSMDE,
      ECSMDM,
      GHB,
      HANDBL,
      HASHSH,
      HASOIL,
      HEROIN,
      JP4F,
      JP5F,
      JP7F,
      JP8F,
      KEROS,
      KHAT,
      KTMINE,
      LEAFLT,
      LPG,
      LSD,
      LTRBMB,
      LUBRIC,
      MAGZNE,
      MARJUN,
      MATING,
      MEDICN,
      MORFIN,
      MSCLNE,
      MTHAMP,
      MURAL,
      NASF18,
      NASF34,
      NASF35,
      NASF40,
      NASF44,
      NATGAS,
      NBCKIT,
      NKN,
      NWSPPR,
      OIL,
      OPIUM,
      PAINT,
      PAPER,
      PCP,
      PEAT,
      PETROL,
      PMPHLT,
      PNTBRS,
      POSTER,
      PSLCYB,
      RATCO,
      RATFR,
      RATTI,
      REVET,
      SPRAY,
      UNIFRM,
      WIRE,
      WOOD,
      WTRHUM,
      WTRMED,
      WTROTH
    };

    ConsumableMaterielTypeSubcategoryCode (value v);

    ConsumableMaterielTypeSubcategoryCode (const char* v);

    ConsumableMaterielTypeSubcategoryCode (const ::std::string& v);

    ConsumableMaterielTypeSubcategoryCode (const ::xml_schema::token& v);

    ConsumableMaterielTypeSubcategoryCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ConsumableMaterielTypeSubcategoryCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ConsumableMaterielTypeSubcategoryCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ConsumableMaterielTypeSubcategoryCode (const ConsumableMaterielTypeSubcategoryCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual ConsumableMaterielTypeSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConsumableMaterielTypeSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ConsumableMaterielTypeSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_ConsumableMaterielTypeSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_ConsumableMaterielTypeSubcategoryCode_literals_[74];
    static const value _xsd_ConsumableMaterielTypeSubcategoryCode_indexes_[74];
  };

  class ConsumableMaterielTypeUnitedNationsNumberCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_1005,
      cxx_1008,
      cxx_1016,
      cxx_1017,
      cxx_1040,
      cxx_1045,
      cxx_1048,
      cxx_1050,
      cxx_1051,
      cxx_1053,
      cxx_1062,
      cxx_1064,
      cxx_1067,
      cxx_1076,
      cxx_1079,
      cxx_1080,
      cxx_1092,
      cxx_1093,
      cxx_1098,
      cxx_1114,
      cxx_1131,
      cxx_1134,
      cxx_1135,
      cxx_1143,
      cxx_1158,
      cxx_1184,
      cxx_1198,
      cxx_1238,
      cxx_1244,
      cxx_1245,
      cxx_1268,
      cxx_1282,
      cxx_1294,
      cxx_1338,
      cxx_1381,
      cxx_1541,
      cxx_1556,
      cxx_1557,
      cxx_1560,
      cxx_1569,
      cxx_1580,
      cxx_1589,
      cxx_1595,
      cxx_1605,
      cxx_1693,
      cxx_1695,
      cxx_1697,
      cxx_1698,
      cxx_1699,
      cxx_1722,
      cxx_1741,
      cxx_1754,
      cxx_1790,
      cxx_1809,
      cxx_1810,
      cxx_1830,
      cxx_1834,
      cxx_1836,
      cxx_1838,
      cxx_1859,
      cxx_1888,
      cxx_1889,
      cxx_1897,
      cxx_1911,
      cxx_1972,
      cxx_1978,
      cxx_1994,
      cxx_2029,
      cxx_2032,
      cxx_2055,
      cxx_2188,
      cxx_2194,
      cxx_2195,
      cxx_2196,
      cxx_2198,
      cxx_2199,
      cxx_2202,
      cxx_2204,
      cxx_2323,
      cxx_2329,
      cxx_2334,
      cxx_2382,
      cxx_2442,
      cxx_2480,
      cxx_2485,
      cxx_2521,
      cxx_2534,
      cxx_2668,
      cxx_2676,
      cxx_2692,
      cxx_2783,
      cxx_2810,
      cxx_2811,
      cxx_2814,
      cxx_2831,
      cxx_2900,
      cxx_2908,
      cxx_2909,
      cxx_2910,
      cxx_2911,
      cxx_2912,
      cxx_2913,
      cxx_2915,
      cxx_2916,
      cxx_2917,
      cxx_2919,
      cxx_3172,
      cxx_3246,
      cxx_3321,
      cxx_3322,
      cxx_3323,
      cxx_3324,
      cxx_3325,
      cxx_3326,
      cxx_3327,
      cxx_3328,
      cxx_3329,
      cxx_3330,
      cxx_3331,
      cxx_3332,
      cxx_3333,
      NOS
    };

    ConsumableMaterielTypeUnitedNationsNumberCode (value v);

    ConsumableMaterielTypeUnitedNationsNumberCode (const char* v);

    ConsumableMaterielTypeUnitedNationsNumberCode (const ::std::string& v);

    ConsumableMaterielTypeUnitedNationsNumberCode (const ::xml_schema::token& v);

    ConsumableMaterielTypeUnitedNationsNumberCode (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    ConsumableMaterielTypeUnitedNationsNumberCode (const ::xercesc::DOMAttr& a,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    ConsumableMaterielTypeUnitedNationsNumberCode (const ::std::string& s,
                                                   const ::xercesc::DOMElement* e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    ConsumableMaterielTypeUnitedNationsNumberCode (const ConsumableMaterielTypeUnitedNationsNumberCode& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    virtual ConsumableMaterielTypeUnitedNationsNumberCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConsumableMaterielTypeUnitedNationsNumberCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ConsumableMaterielTypeUnitedNationsNumberCode_convert ();
    }

    protected:
    value
    _xsd_ConsumableMaterielTypeUnitedNationsNumberCode_convert () const;

    public:
    static const char* const _xsd_ConsumableMaterielTypeUnitedNationsNumberCode_literals_[122];
    static const value _xsd_ConsumableMaterielTypeUnitedNationsNumberCode_indexes_[122];
  };

  class ContextAssessmentLimitingFactorsCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CROSS,
      EQPLMT,
      EXPSPL,
      FACLMT,
      MEDLMT,
      MNTCAP,
      MUNCAP,
      NOCHNG,
      NOLMTN,
      NOS,
      POL,
      PRSLMT,
      RRRCAP
    };

    ContextAssessmentLimitingFactorsCode (value v);

    ContextAssessmentLimitingFactorsCode (const char* v);

    ContextAssessmentLimitingFactorsCode (const ::std::string& v);

    ContextAssessmentLimitingFactorsCode (const ::xml_schema::token& v);

    ContextAssessmentLimitingFactorsCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ContextAssessmentLimitingFactorsCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ContextAssessmentLimitingFactorsCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ContextAssessmentLimitingFactorsCode (const ContextAssessmentLimitingFactorsCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual ContextAssessmentLimitingFactorsCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ContextAssessmentLimitingFactorsCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ContextAssessmentLimitingFactorsCode_convert ();
    }

    protected:
    value
    _xsd_ContextAssessmentLimitingFactorsCode_convert () const;

    public:
    static const char* const _xsd_ContextAssessmentLimitingFactorsCode_literals_[13];
    static const value _xsd_ContextAssessmentLimitingFactorsCode_indexes_[13];
  };

  class ContextAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ISNEXT,
      ISPART,
      SPPLMN,
      SPRCDS
    };

    ContextAssociationCategoryCode (value v);

    ContextAssociationCategoryCode (const char* v);

    ContextAssociationCategoryCode (const ::std::string& v);

    ContextAssociationCategoryCode (const ::xml_schema::token& v);

    ContextAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ContextAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ContextAssociationCategoryCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ContextAssociationCategoryCode (const ContextAssociationCategoryCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual ContextAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ContextAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ContextAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ContextAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_ContextAssociationCategoryCode_literals_[4];
    static const value _xsd_ContextAssociationCategoryCode_indexes_[4];
  };

  class ContextCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ASSESS,
      CORREC,
      CORREL,
      NEGATE,
      NOS,
      OIG,
      OVERLY,
      PREDCT
    };

    ContextCategoryCode (value v);

    ContextCategoryCode (const char* v);

    ContextCategoryCode (const ::std::string& v);

    ContextCategoryCode (const ::xml_schema::token& v);

    ContextCategoryCode (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ContextCategoryCode (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ContextCategoryCode (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ContextCategoryCode (const ContextCategoryCode& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual ContextCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ContextCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ContextCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ContextCategoryCode_convert () const;

    public:
    static const char* const _xsd_ContextCategoryCode_literals_[8];
    static const value _xsd_ContextCategoryCode_indexes_[8];
  };

  class ContextElementStatusCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ADDITN,
      REMOVL
    };

    ContextElementStatusCategoryCode (value v);

    ContextElementStatusCategoryCode (const char* v);

    ContextElementStatusCategoryCode (const ::std::string& v);

    ContextElementStatusCategoryCode (const ::xml_schema::token& v);

    ContextElementStatusCategoryCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    ContextElementStatusCategoryCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    ContextElementStatusCategoryCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    ContextElementStatusCategoryCode (const ContextElementStatusCategoryCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual ContextElementStatusCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ContextElementStatusCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ContextElementStatusCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ContextElementStatusCategoryCode_convert () const;

    public:
    static const char* const _xsd_ContextElementStatusCategoryCode_literals_[2];
    static const value _xsd_ContextElementStatusCategoryCode_indexes_[2];
  };

  class ContextObjectItemAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      INCLDE,
      ISRELV
    };

    ContextObjectItemAssociationCategoryCode (value v);

    ContextObjectItemAssociationCategoryCode (const char* v);

    ContextObjectItemAssociationCategoryCode (const ::std::string& v);

    ContextObjectItemAssociationCategoryCode (const ::xml_schema::token& v);

    ContextObjectItemAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ContextObjectItemAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ContextObjectItemAssociationCategoryCode (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ContextObjectItemAssociationCategoryCode (const ContextObjectItemAssociationCategoryCode& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual ContextObjectItemAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ContextObjectItemAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ContextObjectItemAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ContextObjectItemAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_ContextObjectItemAssociationCategoryCode_literals_[2];
    static const value _xsd_ContextObjectItemAssociationCategoryCode_indexes_[2];
  };

  class ContextReportingDataAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CONF,
      CORR,
      IMPL,
      ISDFT,
      NEGA,
      SUPR
    };

    ContextReportingDataAssociationCategoryCode (value v);

    ContextReportingDataAssociationCategoryCode (const char* v);

    ContextReportingDataAssociationCategoryCode (const ::std::string& v);

    ContextReportingDataAssociationCategoryCode (const ::xml_schema::token& v);

    ContextReportingDataAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ContextReportingDataAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ContextReportingDataAssociationCategoryCode (const ::std::string& s,
                                                 const ::xercesc::DOMElement* e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ContextReportingDataAssociationCategoryCode (const ContextReportingDataAssociationCategoryCode& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual ContextReportingDataAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ContextReportingDataAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ContextReportingDataAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ContextReportingDataAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_ContextReportingDataAssociationCategoryCode_literals_[6];
    static const value _xsd_ContextReportingDataAssociationCategoryCode_indexes_[6];
  };

  class ControlFeatureCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ACM,
      APPRDR,
      NOS,
      ROUTE,
      RTESEG
    };

    ControlFeatureCategoryCode (value v);

    ControlFeatureCategoryCode (const char* v);

    ControlFeatureCategoryCode (const ::std::string& v);

    ControlFeatureCategoryCode (const ::xml_schema::token& v);

    ControlFeatureCategoryCode (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    ControlFeatureCategoryCode (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    ControlFeatureCategoryCode (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    ControlFeatureCategoryCode (const ControlFeatureCategoryCode& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual ControlFeatureCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ControlFeatureCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ControlFeatureCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ControlFeatureCategoryCode_convert () const;

    public:
    static const char* const _xsd_ControlFeatureCategoryCode_literals_[5];
    static const value _xsd_ControlFeatureCategoryCode_indexes_[5];
  };

  class ControlFeatureStatusCbrnThreatLevelCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HIGH,
      LOW,
      MEDIUM
    };

    ControlFeatureStatusCbrnThreatLevelCode (value v);

    ControlFeatureStatusCbrnThreatLevelCode (const char* v);

    ControlFeatureStatusCbrnThreatLevelCode (const ::std::string& v);

    ControlFeatureStatusCbrnThreatLevelCode (const ::xml_schema::token& v);

    ControlFeatureStatusCbrnThreatLevelCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    ControlFeatureStatusCbrnThreatLevelCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    ControlFeatureStatusCbrnThreatLevelCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    ControlFeatureStatusCbrnThreatLevelCode (const ControlFeatureStatusCbrnThreatLevelCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual ControlFeatureStatusCbrnThreatLevelCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ControlFeatureStatusCbrnThreatLevelCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ControlFeatureStatusCbrnThreatLevelCode_convert ();
    }

    protected:
    value
    _xsd_ControlFeatureStatusCbrnThreatLevelCode_convert () const;

    public:
    static const char* const _xsd_ControlFeatureStatusCbrnThreatLevelCode_literals_[3];
    static const value _xsd_ControlFeatureStatusCbrnThreatLevelCode_indexes_[3];
  };

  class ControlFeatureStatusInvestigationStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DENIED,
      INVNEG,
      INVPOS,
      NKN,
      NONE,
      UNDINV
    };

    ControlFeatureStatusInvestigationStatusCode (value v);

    ControlFeatureStatusInvestigationStatusCode (const char* v);

    ControlFeatureStatusInvestigationStatusCode (const ::std::string& v);

    ControlFeatureStatusInvestigationStatusCode (const ::xml_schema::token& v);

    ControlFeatureStatusInvestigationStatusCode (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ControlFeatureStatusInvestigationStatusCode (const ::xercesc::DOMAttr& a,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ControlFeatureStatusInvestigationStatusCode (const ::std::string& s,
                                                 const ::xercesc::DOMElement* e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ControlFeatureStatusInvestigationStatusCode (const ControlFeatureStatusInvestigationStatusCode& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual ControlFeatureStatusInvestigationStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ControlFeatureStatusInvestigationStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ControlFeatureStatusInvestigationStatusCode_convert ();
    }

    protected:
    value
    _xsd_ControlFeatureStatusInvestigationStatusCode_convert () const;

    public:
    static const char* const _xsd_ControlFeatureStatusInvestigationStatusCode_literals_[6];
    static const value _xsd_ControlFeatureStatusInvestigationStatusCode_indexes_[6];
  };

  class ControlFeatureStatusSecurityStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      GUARDD,
      NKN,
      NONE,
      SECURD
    };

    ControlFeatureStatusSecurityStatusCode (value v);

    ControlFeatureStatusSecurityStatusCode (const char* v);

    ControlFeatureStatusSecurityStatusCode (const ::std::string& v);

    ControlFeatureStatusSecurityStatusCode (const ::xml_schema::token& v);

    ControlFeatureStatusSecurityStatusCode (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    ControlFeatureStatusSecurityStatusCode (const ::xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    ControlFeatureStatusSecurityStatusCode (const ::std::string& s,
                                            const ::xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    ControlFeatureStatusSecurityStatusCode (const ControlFeatureStatusSecurityStatusCode& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual ControlFeatureStatusSecurityStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ControlFeatureStatusSecurityStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ControlFeatureStatusSecurityStatusCode_convert ();
    }

    protected:
    value
    _xsd_ControlFeatureStatusSecurityStatusCode_convert () const;

    public:
    static const char* const _xsd_ControlFeatureStatusSecurityStatusCode_literals_[4];
    static const value _xsd_ControlFeatureStatusSecurityStatusCode_indexes_[4];
  };

  class ControlFeatureTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AAXIS,
      ACCPOS,
      ADACAR,
      ADAREA,
      ADIDZN,
      ADOPAR,
      AIMPT,
      AIRCAR,
      AIRCOA,
      AIRCSA,
      AIRCTP,
      AIREWA,
      AIRH,
      AIRRFL,
      ALRTAR,
      ALTRAR,
      AMBEXP,
      AMPDZN,
      AMPHOA,
      AMPOZN,
      AOC,
      AOI,
      AOP,
      AOR,
      APPRDR,
      ARA,
      ARFLDZ,
      ASLTPO,
      ASYGEN,
      ASYSPL,
      ATCAIR,
      ATTFIR,
      ATTPOS,
      AXIS,
      BASDZN,
      BATPOS,
      BCHH,
      BDYOR,
      BDYPOA,
      BDYPT,
      BERLIN,
      BIOATC,
      BIOCNT,
      BIOCTM,
      BIODPC,
      BLOPOS,
      BOMBAR,
      BOUNDR,
      BRDGH,
      BRKUPP,
      BUFRZN,
      BULEYE,
      CBRNHA,
      CBRNRA,
      CBRNRS,
      CFL,
      CHMATC,
      CHMCNT,
      CHMCTM,
      CHMDPC,
      CKPGEN,
      CLDRAD,
      CLSASP,
      CLSBSP,
      CLSCSP,
      CLSDSP,
      CLSESP,
      CLSFSP,
      CLSGSP,
      CLSHAR,
      CNTPTA,
      CNTPTL,
      COAPAR,
      COMCKP,
      COMMZ,
      CONCA,
      CONTAR,
      CONTZN,
      COOAAR,
      COORLV,
      CRCNZN,
      CRDALT,
      CRDPNT,
      CRSBAR,
      CRSVZN,
      CTLPNT,
      CZ,
      DA,
      DECPNT,
      DEFPOS,
      DEFZ,
      DMPI,
      DNGRAR,
      DNPKPT,
      DPBSLN,
      DROPPT,
      DZ,
      EA,
      ELCCAR,
      ENCRCL,
      ENDARP,
      ENDMPT,
      ENDRPT,
      ENGREG,
      ENTL,
      ENTPT,
      ENTRGT,
      EXITGT,
      EXITPT,
      EXTZON,
      FALRAR,
      FARRFP,
      FCZ,
      FEBA,
      FEZ,
      FINAPF,
      FIRING,
      FIRUMB,
      FLINRG,
      FLT,
      FNCOLN,
      FNPRFR,
      FOACAR,
      FOOPLN,
      FREFIR,
      FRUPPL,
      FSCL,
      FWDZON,
      GENARE,
      HAMZON,
      HDAZON,
      HIDE,
      HNDVGT,
      HOLDLN,
      IDSFPT,
      IFFOFF,
      IFFONL,
      IMPTPT,
      INCDPT,
      INFLIN,
      INIAPF,
      INITPT,
      INTOBJ,
      ISR,
      JEZ,
      JNTOAR,
      KEYTER,
      KILBOX,
      KILLA,
      LA,
      LAMZON,
      LANDPT,
      LFGEZN,
      LGHTLN,
      LIMADV,
      LIMARE,
      LNKPPT,
      LNMEZN,
      LOC,
      LODLND,
      LODSEA,
      LOGNOD,
      LRADLN,
      LZ,
      MAXIS,
      MDASEA,
      MEZ,
      MFGEZN,
      MLOPAR,
      MNBMAX,
      MNBTAR,
      MNSFD1,
      MNSFD2,
      MNTHAX,
      MRMEZN,
      MRSHGT,
      MSLARC,
      MSLDET,
      NAGTPT,
      NAMAIN,
      NFL,
      NFRARE,
      NGA,
      NGACIV,
      NOFLZN,
      NOS,
      NUCTGT,
      OBFARE,
      OBJA,
      OBRARE,
      OBSBLT,
      OBSGAP,
      OBSLAN,
      OBSLIN,
      OBSZON,
      OPERZN,
      ORBTPT,
      PHLINE,
      PIRAZN,
      PNTRBX,
      POPUPT,
      PRHBAR,
      PRITPT,
      PSSGPT,
      PTDPRT,
      PTINT,
      PZ,
      QZONE,
      RADARE,
      RADATC,
      RADCLD,
      RADDOS,
      RADDPC,
      RADDSR,
      RALYPT,
      RBFA,
      RCNSAR,
      RCZ,
      RDCOSP,
      REFCPT,
      REFLPT,
      REFRPT,
      RELL,
      RELPT,
      REPLIN,
      REPRPT,
      RFL,
      RIPL,
      RNDZPT,
      ROMIAR,
      ROTAAR,
      RRADLN,
      RSFARE,
      RSOPAR,
      RSOPZN,
      RSTRAR,
      RTETYP,
      SAFELN,
      SAFZ,
      SARPNT,
      SAWCTP,
      SEREAR,
      SFAREV,
      SFSCTR,
      SGA,
      SHPCZN,
      SITKIL,
      SMOKTG,
      SPEMAR,
      SPOFSP,
      SPRDPT,
      SPTPOS,
      SRADZN,
      SRCHAR,
      SSAMEN,
      SSAMEZ,
      SSMSAR,
      STAGA,
      STPT,
      STRTPT,
      SUPARE,
      SUSASP,
      TERMPT,
      TGTAOI,
      TGTLOC,
      TGTRPT,
      TKEOFF,
      TMREPT,
      TMSGAR,
      TRCNAR,
      TRNGAR,
      TRRSAR,
      TRSCRD,
      TRVLVL,
      TURNPT,
      UAVASP,
      UNEXOD,
      WAITA,
      WARNAR,
      WAYPT,
      WPNCTA,
      WPNFZN,
      XA,
      XSITE,
      ZFIRE,
      ZONEI,
      ZONEII
    };

    ControlFeatureTypeCategoryCode (value v);

    ControlFeatureTypeCategoryCode (const char* v);

    ControlFeatureTypeCategoryCode (const ::std::string& v);

    ControlFeatureTypeCategoryCode (const ::xml_schema::token& v);

    ControlFeatureTypeCategoryCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ControlFeatureTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ControlFeatureTypeCategoryCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ControlFeatureTypeCategoryCode (const ControlFeatureTypeCategoryCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual ControlFeatureTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ControlFeatureTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ControlFeatureTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ControlFeatureTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_ControlFeatureTypeCategoryCode_literals_[287];
    static const value _xsd_ControlFeatureTypeCategoryCode_indexes_[287];
  };

  class DemolitionStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ABNDIN,
      CANCLD,
      EXECTD,
      NKN,
      PLNPRL,
      PLNRES,
      PRPEXE,
      STATE1,
      STATE2
    };

    DemolitionStatusCode (value v);

    DemolitionStatusCode (const char* v);

    DemolitionStatusCode (const ::std::string& v);

    DemolitionStatusCode (const ::xml_schema::token& v);

    DemolitionStatusCode (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    DemolitionStatusCode (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    DemolitionStatusCode (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    DemolitionStatusCode (const DemolitionStatusCode& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual DemolitionStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DemolitionStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_DemolitionStatusCode_convert ();
    }

    protected:
    value
    _xsd_DemolitionStatusCode_convert () const;

    public:
    static const char* const _xsd_DemolitionStatusCode_literals_[9];
    static const value _xsd_DemolitionStatusCode_indexes_[9];
  };

  class DirectionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ALL,
      E,
      ENE,
      ESE,
      N,
      NE,
      NNE,
      NNW,
      NW,
      S,
      SE,
      SSE,
      SSW,
      SW,
      W,
      WNW,
      WSW
    };

    DirectionCode (value v);

    DirectionCode (const char* v);

    DirectionCode (const ::std::string& v);

    DirectionCode (const ::xml_schema::token& v);

    DirectionCode (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    DirectionCode (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    DirectionCode (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    DirectionCode (const DirectionCode& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual DirectionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DirectionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_DirectionCode_convert ();
    }

    protected:
    value
    _xsd_DirectionCode_convert () const;

    public:
    static const char* const _xsd_DirectionCode_literals_[17];
    static const value _xsd_DirectionCode_indexes_[17];
  };

  class DistancePrecisionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_100FT,
      cxx_100MTR,
      cxx_10FT,
      cxx_10MTR,
      cxx_300MTR,
      cxx_30MTR,
      cxx_3MTR,
      CM,
      FOOT,
      INCH,
      KILYRD,
      KM,
      METRE,
      MILE,
      MM,
      NM,
      YARD
    };

    DistancePrecisionCode (value v);

    DistancePrecisionCode (const char* v);

    DistancePrecisionCode (const ::std::string& v);

    DistancePrecisionCode (const ::xml_schema::token& v);

    DistancePrecisionCode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    DistancePrecisionCode (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    DistancePrecisionCode (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    DistancePrecisionCode (const DistancePrecisionCode& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual DistancePrecisionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DistancePrecisionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_DistancePrecisionCode_convert ();
    }

    protected:
    value
    _xsd_DistancePrecisionCode_convert () const;

    public:
    static const char* const _xsd_DistancePrecisionCode_literals_[17];
    static const value _xsd_DistancePrecisionCode_indexes_[17];
  };

  class DryDockMarineRailwaySizeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      L,
      M,
      S
    };

    DryDockMarineRailwaySizeCode (value v);

    DryDockMarineRailwaySizeCode (const char* v);

    DryDockMarineRailwaySizeCode (const ::std::string& v);

    DryDockMarineRailwaySizeCode (const ::xml_schema::token& v);

    DryDockMarineRailwaySizeCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    DryDockMarineRailwaySizeCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    DryDockMarineRailwaySizeCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    DryDockMarineRailwaySizeCode (const DryDockMarineRailwaySizeCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual DryDockMarineRailwaySizeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DryDockMarineRailwaySizeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_DryDockMarineRailwaySizeCode_convert ();
    }

    protected:
    value
    _xsd_DryDockMarineRailwaySizeCode_convert () const;

    public:
    static const char* const _xsd_DryDockMarineRailwaySizeCode_literals_[3];
    static const value _xsd_DryDockMarineRailwaySizeCode_indexes_[3];
  };

  class ElectronicEquipmentTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      C3I,
      COM,
      DPE,
      EW,
      FRC,
      ILS,
      NAV,
      NKN,
      NOS,
      PAS,
      RADAR,
      SEN
    };

    ElectronicEquipmentTypeCategoryCode (value v);

    ElectronicEquipmentTypeCategoryCode (const char* v);

    ElectronicEquipmentTypeCategoryCode (const ::std::string& v);

    ElectronicEquipmentTypeCategoryCode (const ::xml_schema::token& v);

    ElectronicEquipmentTypeCategoryCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ElectronicEquipmentTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ElectronicEquipmentTypeCategoryCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ElectronicEquipmentTypeCategoryCode (const ElectronicEquipmentTypeCategoryCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual ElectronicEquipmentTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ElectronicEquipmentTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ElectronicEquipmentTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ElectronicEquipmentTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_ElectronicEquipmentTypeCategoryCode_literals_[12];
    static const value _xsd_ElectronicEquipmentTypeCategoryCode_indexes_[12];
  };

  class ElectronicEquipmentTypeSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AMTRAD,
      AUDSTD,
      BEACON,
      BRAHMS,
      BTHTGE,
      BTHTGH,
      BUOYCL,
      C2IS,
      CBDCFD,
      CLSWZD,
      COMANT,
      COMSYS,
      COMVEH,
      CTRYTB,
      CVRRAD,
      DATLNK,
      DM40AP,
      DTLOPT,
      DTLRAD,
      ELSPSM,
      ELTOPT,
      FLIR,
      GPSCOM,
      GPSMIL,
      HFDFBL,
      HFDFOT,
      HFRDFD,
      IDNTFF,
      ILSLOC,
      INDETS,
      INTERC,
      INUWSS,
      LFRACS,
      LFRARC,
      LGLVTV,
      LORANC,
      LOUDSP,
      MBRPOS,
      MEGPHN,
      MGANDT,
      MINIRN,
      MRKRBA,
      MRKRIN,
      MRKRMD,
      MRKROU,
      NESTOR,
      NGOBDV,
      NKN,
      NOS,
      OPTICL,
      PANOVW,
      PHOTOG,
      PINS,
      PRKHLL,
      RADBRD,
      RADDFD,
      RADGDN,
      RADTLP,
      RADTLT,
      RDISAR,
      RDOTHR,
      RDRADT,
      RDRARB,
      RDRARS,
      RDRASA,
      RDRATC,
      RDRBNV,
      RDRCAT,
      RDRCBR,
      RDRCMR,
      RDRDFD,
      RDREST,
      RDREWA,
      RDRFC,
      RDRGRS,
      RDRGUD,
      RDRHFD,
      RDRHRL,
      RDRJST,
      RDRMET,
      RDRNAV,
      RDRPRI,
      RDRRNG,
      RDRSCP,
      RDRSLR,
      RDSLAR,
      RDSNRS,
      RNGLAS,
      RROTHR,
      RTINDD,
      RYDSTD,
      RYDSTN,
      SDRANG,
      SDSVST,
      SHETLC,
      SHINST,
      SNGSDE,
      SONAR,
      SWCBRD,
      TACTAN,
      TARPHS,
      TELEPH,
      TELEVS,
      TELGPH,
      TELSWT,
      TELTYP,
      THEINF,
      THRTWS,
      TORAN,
      TRNRCV,
      TRTMWV,
      VIDBRD,
      VINSON,
      VISSTR,
      VISUAL,
      VLAD,
      VSLBRG,
      WCSAIR
    };

    ElectronicEquipmentTypeSubcategoryCode (value v);

    ElectronicEquipmentTypeSubcategoryCode (const char* v);

    ElectronicEquipmentTypeSubcategoryCode (const ::std::string& v);

    ElectronicEquipmentTypeSubcategoryCode (const ::xml_schema::token& v);

    ElectronicEquipmentTypeSubcategoryCode (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    ElectronicEquipmentTypeSubcategoryCode (const ::xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    ElectronicEquipmentTypeSubcategoryCode (const ::std::string& s,
                                            const ::xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    ElectronicEquipmentTypeSubcategoryCode (const ElectronicEquipmentTypeSubcategoryCode& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual ElectronicEquipmentTypeSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ElectronicEquipmentTypeSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ElectronicEquipmentTypeSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_ElectronicEquipmentTypeSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_ElectronicEquipmentTypeSubcategoryCode_literals_[118];
    static const value _xsd_ElectronicEquipmentTypeSubcategoryCode_indexes_[118];
  };

  class EngineeringCapabilityCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BRCH,
      CNST,
      DEMO
    };

    EngineeringCapabilityCategoryCode (value v);

    EngineeringCapabilityCategoryCode (const char* v);

    EngineeringCapabilityCategoryCode (const ::std::string& v);

    EngineeringCapabilityCategoryCode (const ::xml_schema::token& v);

    EngineeringCapabilityCategoryCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    EngineeringCapabilityCategoryCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    EngineeringCapabilityCategoryCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    EngineeringCapabilityCategoryCode (const EngineeringCapabilityCategoryCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual EngineeringCapabilityCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EngineeringCapabilityCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_EngineeringCapabilityCategoryCode_convert ();
    }

    protected:
    value
    _xsd_EngineeringCapabilityCategoryCode_convert () const;

    public:
    static const char* const _xsd_EngineeringCapabilityCategoryCode_literals_[3];
    static const value _xsd_EngineeringCapabilityCategoryCode_indexes_[3];
  };

  class EngineeringCapabilityDescriptorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      RATE,
      TIME
    };

    EngineeringCapabilityDescriptorCode (value v);

    EngineeringCapabilityDescriptorCode (const char* v);

    EngineeringCapabilityDescriptorCode (const ::std::string& v);

    EngineeringCapabilityDescriptorCode (const ::xml_schema::token& v);

    EngineeringCapabilityDescriptorCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    EngineeringCapabilityDescriptorCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    EngineeringCapabilityDescriptorCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    EngineeringCapabilityDescriptorCode (const EngineeringCapabilityDescriptorCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual EngineeringCapabilityDescriptorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EngineeringCapabilityDescriptorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_EngineeringCapabilityDescriptorCode_convert ();
    }

    protected:
    value
    _xsd_EngineeringCapabilityDescriptorCode_convert () const;

    public:
    static const char* const _xsd_EngineeringCapabilityDescriptorCode_literals_[2];
    static const value _xsd_EngineeringCapabilityDescriptorCode_indexes_[2];
  };

  class EngineeringEquipmentTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BRDLVA,
      BRDVEH,
      BRIDGG,
      CNSTVE,
      CONST,
      CRANE,
      DITCHR,
      DOZER,
      ERTHMV,
      GRADER,
      MCBRLY,
      MINCLR,
      MINECL,
      MINEDT,
      MINEMR,
      MINLAY,
      MINLYR,
      MNLYAR,
      MNLYTR,
      NKN,
      NOS,
      PILDRV,
      POWSHV,
      RCKCRH,
      TFBRID
    };

    EngineeringEquipmentTypeCategoryCode (value v);

    EngineeringEquipmentTypeCategoryCode (const char* v);

    EngineeringEquipmentTypeCategoryCode (const ::std::string& v);

    EngineeringEquipmentTypeCategoryCode (const ::xml_schema::token& v);

    EngineeringEquipmentTypeCategoryCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    EngineeringEquipmentTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    EngineeringEquipmentTypeCategoryCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    EngineeringEquipmentTypeCategoryCode (const EngineeringEquipmentTypeCategoryCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual EngineeringEquipmentTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EngineeringEquipmentTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_EngineeringEquipmentTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_EngineeringEquipmentTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_EngineeringEquipmentTypeCategoryCode_literals_[25];
    static const value _xsd_EngineeringEquipmentTypeCategoryCode_indexes_[25];
  };

  class EquipmentTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIRCFT,
      CBRNEQ,
      ELCTRN,
      ENGEQ,
      MISCEQ,
      MRTMEQ,
      RAIL,
      VEHCLE,
      VESSEL,
      WEPTYP
    };

    EquipmentTypeCategoryCode (value v);

    EquipmentTypeCategoryCode (const char* v);

    EquipmentTypeCategoryCode (const ::std::string& v);

    EquipmentTypeCategoryCode (const ::xml_schema::token& v);

    EquipmentTypeCategoryCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    EquipmentTypeCategoryCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    EquipmentTypeCategoryCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    EquipmentTypeCategoryCode (const EquipmentTypeCategoryCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual EquipmentTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EquipmentTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_EquipmentTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_EquipmentTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_EquipmentTypeCategoryCode_literals_[10];
    static const value _xsd_EquipmentTypeCategoryCode_indexes_[10];
  };

  class EvacuationDestinationCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HOMHOL,
      MEDTHT,
      RETDTY
    };

    EvacuationDestinationCode (value v);

    EvacuationDestinationCode (const char* v);

    EvacuationDestinationCode (const ::std::string& v);

    EvacuationDestinationCode (const ::xml_schema::token& v);

    EvacuationDestinationCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    EvacuationDestinationCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    EvacuationDestinationCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    EvacuationDestinationCode (const EvacuationDestinationCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual EvacuationDestinationCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EvacuationDestinationCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_EvacuationDestinationCode_convert ();
    }

    protected:
    value
    _xsd_EvacuationDestinationCode_convert () const;

    public:
    static const char* const _xsd_EvacuationDestinationCode_literals_[3];
    static const value _xsd_EvacuationDestinationCode_indexes_[3];
  };

  class ExecutiveMilitaryOrganisationTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HQ,
      LOG,
      MILSVC,
      NOS,
      PRSNL,
      SUPPLY,
      TRNPTN
    };

    ExecutiveMilitaryOrganisationTypeCategoryCode (value v);

    ExecutiveMilitaryOrganisationTypeCategoryCode (const char* v);

    ExecutiveMilitaryOrganisationTypeCategoryCode (const ::std::string& v);

    ExecutiveMilitaryOrganisationTypeCategoryCode (const ::xml_schema::token& v);

    ExecutiveMilitaryOrganisationTypeCategoryCode (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    ExecutiveMilitaryOrganisationTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    ExecutiveMilitaryOrganisationTypeCategoryCode (const ::std::string& s,
                                                   const ::xercesc::DOMElement* e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    ExecutiveMilitaryOrganisationTypeCategoryCode (const ExecutiveMilitaryOrganisationTypeCategoryCode& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    virtual ExecutiveMilitaryOrganisationTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ExecutiveMilitaryOrganisationTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ExecutiveMilitaryOrganisationTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ExecutiveMilitaryOrganisationTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_ExecutiveMilitaryOrganisationTypeCategoryCode_literals_[7];
    static const value _xsd_ExecutiveMilitaryOrganisationTypeCategoryCode_indexes_[7];
  };

  class FacilityCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIRFLD,
      ANCHOR,
      APRON,
      BASIN,
      BERTH,
      BRIDGE,
      DRYDCK,
      HARBOR,
      JETTY,
      MILOBS,
      NETWRK,
      NOS,
      QUAY,
      RALWAY,
      ROAD,
      RUNWAY,
      SLPWAY
    };

    FacilityCategoryCode (value v);

    FacilityCategoryCode (const char* v);

    FacilityCategoryCode (const ::std::string& v);

    FacilityCategoryCode (const ::xml_schema::token& v);

    FacilityCategoryCode (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    FacilityCategoryCode (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    FacilityCategoryCode (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    FacilityCategoryCode (const FacilityCategoryCode& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual FacilityCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FacilityCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FacilityCategoryCode_convert ();
    }

    protected:
    value
    _xsd_FacilityCategoryCode_convert () const;

    public:
    static const char* const _xsd_FacilityCategoryCode_literals_[17];
    static const value _xsd_FacilityCategoryCode_indexes_[17];
  };

  class FacilityPrimaryConstructionMaterialCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ASPHLT,
      BIT,
      BRKMSN,
      CBLSTN,
      CLA,
      CNCRBL,
      CNCRTE,
      COM,
      COP,
      COR,
      EARTH,
      GRAVEL,
      ICE,
      LAT,
      MACDAM,
      MEM,
      METAL,
      MIX,
      NKN,
      NOS,
      PEBBLE,
      PEM,
      PER,
      PRSTCN,
      PSTEEL,
      REINCN,
      RLDERT,
      ROCK,
      SAND,
      SILT,
      SNOW,
      STELMT,
      WOOD
    };

    FacilityPrimaryConstructionMaterialCode (value v);

    FacilityPrimaryConstructionMaterialCode (const char* v);

    FacilityPrimaryConstructionMaterialCode (const ::std::string& v);

    FacilityPrimaryConstructionMaterialCode (const ::xml_schema::token& v);

    FacilityPrimaryConstructionMaterialCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    FacilityPrimaryConstructionMaterialCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    FacilityPrimaryConstructionMaterialCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    FacilityPrimaryConstructionMaterialCode (const FacilityPrimaryConstructionMaterialCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual FacilityPrimaryConstructionMaterialCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FacilityPrimaryConstructionMaterialCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FacilityPrimaryConstructionMaterialCode_convert ();
    }

    protected:
    value
    _xsd_FacilityPrimaryConstructionMaterialCode_convert () const;

    public:
    static const char* const _xsd_FacilityPrimaryConstructionMaterialCode_literals_[33];
    static const value _xsd_FacilityPrimaryConstructionMaterialCode_indexes_[33];
  };

  class FacilityStatusCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIRFST,
      MEDFST,
      MNMAST,
      NOS
    };

    FacilityStatusCategoryCode (value v);

    FacilityStatusCategoryCode (const char* v);

    FacilityStatusCategoryCode (const ::std::string& v);

    FacilityStatusCategoryCode (const ::xml_schema::token& v);

    FacilityStatusCategoryCode (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    FacilityStatusCategoryCode (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    FacilityStatusCategoryCode (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    FacilityStatusCategoryCode (const FacilityStatusCategoryCode& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual FacilityStatusCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FacilityStatusCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FacilityStatusCategoryCode_convert ();
    }

    protected:
    value
    _xsd_FacilityStatusCategoryCode_convert () const;

    public:
    static const char* const _xsd_FacilityStatusCategoryCode_literals_[4];
    static const value _xsd_FacilityStatusCategoryCode_indexes_[4];
  };

  class FacilityStatusEnemyActivityConditionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      COLD,
      HOT
    };

    FacilityStatusEnemyActivityConditionCode (value v);

    FacilityStatusEnemyActivityConditionCode (const char* v);

    FacilityStatusEnemyActivityConditionCode (const ::std::string& v);

    FacilityStatusEnemyActivityConditionCode (const ::xml_schema::token& v);

    FacilityStatusEnemyActivityConditionCode (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    FacilityStatusEnemyActivityConditionCode (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    FacilityStatusEnemyActivityConditionCode (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    FacilityStatusEnemyActivityConditionCode (const FacilityStatusEnemyActivityConditionCode& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual FacilityStatusEnemyActivityConditionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FacilityStatusEnemyActivityConditionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FacilityStatusEnemyActivityConditionCode_convert ();
    }

    protected:
    value
    _xsd_FacilityStatusEnemyActivityConditionCode_convert () const;

    public:
    static const char* const _xsd_FacilityStatusEnemyActivityConditionCode_literals_[2];
    static const value _xsd_FacilityStatusEnemyActivityConditionCode_indexes_[2];
  };

  class FacilityStatusOccupationProgramIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    FacilityStatusOccupationProgramIndicatorCode (value v);

    FacilityStatusOccupationProgramIndicatorCode (const char* v);

    FacilityStatusOccupationProgramIndicatorCode (const ::std::string& v);

    FacilityStatusOccupationProgramIndicatorCode (const ::xml_schema::token& v);

    FacilityStatusOccupationProgramIndicatorCode (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    FacilityStatusOccupationProgramIndicatorCode (const ::xercesc::DOMAttr& a,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    FacilityStatusOccupationProgramIndicatorCode (const ::std::string& s,
                                                  const ::xercesc::DOMElement* e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    FacilityStatusOccupationProgramIndicatorCode (const FacilityStatusOccupationProgramIndicatorCode& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    virtual FacilityStatusOccupationProgramIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FacilityStatusOccupationProgramIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FacilityStatusOccupationProgramIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_FacilityStatusOccupationProgramIndicatorCode_convert () const;

    public:
    static const char* const _xsd_FacilityStatusOccupationProgramIndicatorCode_literals_[2];
    static const value _xsd_FacilityStatusOccupationProgramIndicatorCode_indexes_[2];
  };

  class FacilityStatusOperationalStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MOPS,
      NKN,
      NOP,
      OPR,
      SOPS,
      TNOPS
    };

    FacilityStatusOperationalStatusCode (value v);

    FacilityStatusOperationalStatusCode (const char* v);

    FacilityStatusOperationalStatusCode (const ::std::string& v);

    FacilityStatusOperationalStatusCode (const ::xml_schema::token& v);

    FacilityStatusOperationalStatusCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    FacilityStatusOperationalStatusCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    FacilityStatusOperationalStatusCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    FacilityStatusOperationalStatusCode (const FacilityStatusOperationalStatusCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual FacilityStatusOperationalStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FacilityStatusOperationalStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FacilityStatusOperationalStatusCode_convert ();
    }

    protected:
    value
    _xsd_FacilityStatusOperationalStatusCode_convert () const;

    public:
    static const char* const _xsd_FacilityStatusOperationalStatusCode_literals_[6];
    static const value _xsd_FacilityStatusOperationalStatusCode_indexes_[6];
  };

  class FacilityStatusOperationalStatusQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BRCHED,
      BRNOUT,
      CVRFIR,
      DENIED,
      DISASM,
      DSTRYD,
      HVYDAM,
      INMNT,
      LGTDAM,
      LST,
      LVR,
      MARKED,
      MODDAM,
      NKN,
      PASABL,
      PRPEXE,
      PRTDSM,
      STERLZ,
      UNCNST
    };

    FacilityStatusOperationalStatusQualifierCode (value v);

    FacilityStatusOperationalStatusQualifierCode (const char* v);

    FacilityStatusOperationalStatusQualifierCode (const ::std::string& v);

    FacilityStatusOperationalStatusQualifierCode (const ::xml_schema::token& v);

    FacilityStatusOperationalStatusQualifierCode (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    FacilityStatusOperationalStatusQualifierCode (const ::xercesc::DOMAttr& a,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    FacilityStatusOperationalStatusQualifierCode (const ::std::string& s,
                                                  const ::xercesc::DOMElement* e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    FacilityStatusOperationalStatusQualifierCode (const FacilityStatusOperationalStatusQualifierCode& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    virtual FacilityStatusOperationalStatusQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FacilityStatusOperationalStatusQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FacilityStatusOperationalStatusQualifierCode_convert ();
    }

    protected:
    value
    _xsd_FacilityStatusOperationalStatusQualifierCode_convert () const;

    public:
    static const char* const _xsd_FacilityStatusOperationalStatusQualifierCode_literals_[19];
    static const value _xsd_FacilityStatusOperationalStatusQualifierCode_indexes_[19];
  };

  class FacilityStatusReserveIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    FacilityStatusReserveIndicatorCode (value v);

    FacilityStatusReserveIndicatorCode (const char* v);

    FacilityStatusReserveIndicatorCode (const ::std::string& v);

    FacilityStatusReserveIndicatorCode (const ::xml_schema::token& v);

    FacilityStatusReserveIndicatorCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    FacilityStatusReserveIndicatorCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    FacilityStatusReserveIndicatorCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    FacilityStatusReserveIndicatorCode (const FacilityStatusReserveIndicatorCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual FacilityStatusReserveIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FacilityStatusReserveIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FacilityStatusReserveIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_FacilityStatusReserveIndicatorCode_convert () const;

    public:
    static const char* const _xsd_FacilityStatusReserveIndicatorCode_literals_[2];
    static const value _xsd_FacilityStatusReserveIndicatorCode_indexes_[2];
  };

  class FacilityStatusSecurityStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      GUARDD,
      NKN,
      NONE,
      SECURD
    };

    FacilityStatusSecurityStatusCode (value v);

    FacilityStatusSecurityStatusCode (const char* v);

    FacilityStatusSecurityStatusCode (const ::std::string& v);

    FacilityStatusSecurityStatusCode (const ::xml_schema::token& v);

    FacilityStatusSecurityStatusCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    FacilityStatusSecurityStatusCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    FacilityStatusSecurityStatusCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    FacilityStatusSecurityStatusCode (const FacilityStatusSecurityStatusCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual FacilityStatusSecurityStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FacilityStatusSecurityStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FacilityStatusSecurityStatusCode_convert ();
    }

    protected:
    value
    _xsd_FacilityStatusSecurityStatusCode_convert () const;

    public:
    static const char* const _xsd_FacilityStatusSecurityStatusCode_literals_[4];
    static const value _xsd_FacilityStatusSecurityStatusCode_indexes_[4];
  };

  class FacilityTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ACCOM,
      AEWGRD,
      AIRFLD,
      ALTDCN,
      AMMCCH,
      ANCHOR,
      APRON,
      APRTBD,
      ASP,
      ATP,
      BANK,
      BARRCK,
      BASIN,
      BATH,
      BERM,
      BERTH,
      BFIFLD,
      BIVOUC,
      BLD,
      BRGTYP,
      BUA,
      BUNKER,
      CAMP,
      CAN,
      CBRNPS,
      CBTPST,
      CEM,
      CHM,
      CHPLCK,
      CIMICC,
      CITY,
      CKPPOL,
      CLSFAC,
      COB,
      COT,
      CP,
      CRP,
      CSCLPT,
      CTT,
      CUT,
      CVCLPT,
      CWY,
      DAM,
      DCH,
      DECONP,
      DEPBIO,
      DEPCHM,
      DEPENG,
      DEPMED,
      DEPMIS,
      DEPMUN,
      DEPNUC,
      DEPOT,
      DEPPOL,
      DMDBRS,
      DPCBRN,
      DRNSEW,
      DRSTAT,
      DRYDCK,
      DTCLPT,
      DTHARE,
      ELCINS,
      ELCSPL,
      ELIRDD,
      ELISSJ,
      ELIWAR,
      EMPLAC,
      EQIMFT,
      FACAIR,
      FACAMM,
      FACAR,
      FACARM,
      FACARP,
      FACATR,
      FACBRG,
      FACCHB,
      FACENG,
      FACGOV,
      FACMIL,
      FACMSL,
      FACNAV,
      FACPOW,
      FACPRO,
      FACSHP,
      FACSRU,
      FACTEC,
      FACTEL,
      FACTRN,
      FACVEH,
      FACWAT,
      FARM,
      FARP,
      FCRLBD,
      FCRSLB,
      FENCE,
      FERINS,
      FFBRKS,
      FHPT,
      FOBSPS,
      FORT,
      FOXHOL,
      FRGTER,
      FRTFCN,
      FSAAMM,
      FSMAMM,
      FSSAMM,
      FSSTAM,
      GASPFA,
      GAT,
      GVTBLD,
      HAMLET,
      HANGAR,
      HARBOR,
      HGHTCH,
      HOUSE,
      HPD,
      HPT,
      HQ,
      HSP,
      HSPFLD,
      HSPNOS,
      HUT,
      IMPBED,
      INDINS,
      INSTAL,
      INTCTR,
      JCT,
      JETTY,
      LGRLPT,
      LGTHSE,
      LOADPL,
      LOADPM,
      MAINTF,
      MBFSUB,
      MEDSPT,
      METFAC,
      MF,
      MFUMS,
      MILOBS,
      MINE,
      MNCPLX,
      MNINOS,
      MNINUG,
      MNINUW,
      MNTCPT,
      MONUM,
      MSS,
      MSSGRV,
      MTFAAR,
      MTFAIR,
      MTFMVH,
      MWY,
      NAVAST,
      NCLFAC,
      NETWRK,
      NKN,
      NOS,
      OBSP,
      OBSTWR,
      OFFICE,
      OMNIST,
      ORD,
      PASTRM,
      PCHREF,
      PERSBR,
      PIER,
      PIPLIN,
      PMPSTN,
      POLPT,
      POLSTA,
      PORT,
      POWARE,
      POWCMP,
      POWCPT,
      PRCXAC,
      PRCXCH,
      PRCXGM,
      PRCXMV,
      PRCXPT,
      PTL,
      PWPLFF,
      PWPLHL,
      PWPLNC,
      PWPLTH,
      QUAY,
      RAIL,
      RAILHD,
      RAILWY,
      RDJNCT,
      RDRHD,
      RDRPST,
      REFARE,
      RELAY,
      RELFAC,
      RES,
      REVETM,
      RFAREP,
      ROAD,
      ROMPT,
      ROWHSE,
      RRRSPT,
      RUI,
      RWCRSS,
      RWJNCT,
      SCHOOL,
      SENPST,
      SHD,
      SHLSUR,
      SHLUND,
      SHOP,
      SHORAN,
      SHYARD,
      SITADR,
      SITART,
      SITEEW,
      SITGSR,
      SITLOG,
      SITMLB,
      SITRAD,
      SITRFT,
      SLPWAY,
      SNSRFP,
      SNVRDR,
      SPTARE,
      STN,
      STP,
      STSSML,
      SUPDAM,
      SUPDMP,
      SUPPT,
      SWGFAC,
      TACAN,
      TCH,
      TOW,
      TOWN,
      TRAIL,
      TRANSF,
      TRFPST,
      TUN,
      TWFLAK,
      TWNHAL,
      TWTLTM,
      URBANA,
      VLLAGE,
      VST,
      WALL,
      WAREHS,
      WATSPL,
      WML,
      WRSHPL,
      WSHFAC,
      WSTPLE,
      WTRFAC,
      WTW,
      XLC,
      XRR
    };

    FacilityTypeCategoryCode (value v);

    FacilityTypeCategoryCode (const char* v);

    FacilityTypeCategoryCode (const ::std::string& v);

    FacilityTypeCategoryCode (const ::xml_schema::token& v);

    FacilityTypeCategoryCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    FacilityTypeCategoryCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    FacilityTypeCategoryCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    FacilityTypeCategoryCode (const FacilityTypeCategoryCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual FacilityTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FacilityTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FacilityTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_FacilityTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_FacilityTypeCategoryCode_literals_[256];
    static const value _xsd_FacilityTypeCategoryCode_indexes_[256];
  };

  class FeatureCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CF,
      GF,
      MF,
      NOS
    };

    FeatureCategoryCode (value v);

    FeatureCategoryCode (const char* v);

    FeatureCategoryCode (const ::std::string& v);

    FeatureCategoryCode (const ::xml_schema::token& v);

    FeatureCategoryCode (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    FeatureCategoryCode (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    FeatureCategoryCode (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    FeatureCategoryCode (const FeatureCategoryCode& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual FeatureCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FeatureCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FeatureCategoryCode_convert ();
    }

    protected:
    value
    _xsd_FeatureCategoryCode_convert () const;

    public:
    static const char* const _xsd_FeatureCategoryCode_literals_[4];
    static const value _xsd_FeatureCategoryCode_indexes_[4];
  };

  class FeatureTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CF,
      GF,
      MF,
      NOS
    };

    FeatureTypeCategoryCode (value v);

    FeatureTypeCategoryCode (const char* v);

    FeatureTypeCategoryCode (const ::std::string& v);

    FeatureTypeCategoryCode (const ::xml_schema::token& v);

    FeatureTypeCategoryCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    FeatureTypeCategoryCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    FeatureTypeCategoryCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    FeatureTypeCategoryCode (const FeatureTypeCategoryCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual FeatureTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FeatureTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FeatureTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_FeatureTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_FeatureTypeCategoryCode_literals_[4];
    static const value _xsd_FeatureTypeCategoryCode_indexes_[4];
  };

  class FeintIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    FeintIndicatorCode (value v);

    FeintIndicatorCode (const char* v);

    FeintIndicatorCode (const ::std::string& v);

    FeintIndicatorCode (const ::xml_schema::token& v);

    FeintIndicatorCode (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    FeintIndicatorCode (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    FeintIndicatorCode (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    FeintIndicatorCode (const FeintIndicatorCode& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual FeintIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FeintIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FeintIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_FeintIndicatorCode_convert () const;

    public:
    static const char* const _xsd_FeintIndicatorCode_literals_[2];
    static const value _xsd_FeintIndicatorCode_indexes_[2];
  };

  class FireCapabilityCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIRAIR,
      AIRGRD,
      AIRSEA,
      GRDAIR,
      GRDGRD,
      GRDSEA,
      SEAAIR,
      SEAGRD,
      SEASEA
    };

    FireCapabilityCategoryCode (value v);

    FireCapabilityCategoryCode (const char* v);

    FireCapabilityCategoryCode (const ::std::string& v);

    FireCapabilityCategoryCode (const ::xml_schema::token& v);

    FireCapabilityCategoryCode (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    FireCapabilityCategoryCode (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    FireCapabilityCategoryCode (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    FireCapabilityCategoryCode (const FireCapabilityCategoryCode& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual FireCapabilityCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FireCapabilityCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FireCapabilityCategoryCode_convert ();
    }

    protected:
    value
    _xsd_FireCapabilityCategoryCode_convert () const;

    public:
    static const char* const _xsd_FireCapabilityCategoryCode_literals_[9];
    static const value _xsd_FireCapabilityCategoryCode_indexes_[9];
  };

  class FireCapabilityDescriptorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BRTFIR,
      MRANGE,
      MRATFR,
      NRANGE,
      SFTDST,
      SSTRTF
    };

    FireCapabilityDescriptorCode (value v);

    FireCapabilityDescriptorCode (const char* v);

    FireCapabilityDescriptorCode (const ::std::string& v);

    FireCapabilityDescriptorCode (const ::xml_schema::token& v);

    FireCapabilityDescriptorCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    FireCapabilityDescriptorCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    FireCapabilityDescriptorCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    FireCapabilityDescriptorCode (const FireCapabilityDescriptorCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual FireCapabilityDescriptorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FireCapabilityDescriptorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FireCapabilityDescriptorCode_convert ();
    }

    protected:
    value
    _xsd_FireCapabilityDescriptorCode_convert () const;

    public:
    static const char* const _xsd_FireCapabilityDescriptorCode_literals_[6];
    static const value _xsd_FireCapabilityDescriptorCode_indexes_[6];
  };

  class FireCapabilityWeaponTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CONV,
      DUAL,
      NCC,
      NKN,
      NOS,
      NUC
    };

    FireCapabilityWeaponTypeCode (value v);

    FireCapabilityWeaponTypeCode (const char* v);

    FireCapabilityWeaponTypeCode (const ::std::string& v);

    FireCapabilityWeaponTypeCode (const ::xml_schema::token& v);

    FireCapabilityWeaponTypeCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    FireCapabilityWeaponTypeCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    FireCapabilityWeaponTypeCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    FireCapabilityWeaponTypeCode (const FireCapabilityWeaponTypeCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual FireCapabilityWeaponTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FireCapabilityWeaponTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_FireCapabilityWeaponTypeCode_convert ();
    }

    protected:
    value
    _xsd_FireCapabilityWeaponTypeCode_convert () const;

    public:
    static const char* const _xsd_FireCapabilityWeaponTypeCode_literals_[6];
    static const value _xsd_FireCapabilityWeaponTypeCode_indexes_[6];
  };

  class GenderCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FEMALE,
      MALE,
      NKN
    };

    GenderCode (value v);

    GenderCode (const char* v);

    GenderCode (const ::std::string& v);

    GenderCode (const ::xml_schema::token& v);

    GenderCode (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    GenderCode (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    GenderCode (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    GenderCode (const GenderCode& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual GenderCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GenderCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GenderCode_convert ();
    }

    protected:
    value
    _xsd_GenderCode_convert () const;

    public:
    static const char* const _xsd_GenderCode_literals_[3];
    static const value _xsd_GenderCode_indexes_[3];
  };

  class GeographicFeatureBottomHardnessCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ARMELB,
      ARMKNU,
      ARMPLM,
      ARMSHO,
      ARMWRS,
      NOPENT
    };

    GeographicFeatureBottomHardnessCode (value v);

    GeographicFeatureBottomHardnessCode (const char* v);

    GeographicFeatureBottomHardnessCode (const ::std::string& v);

    GeographicFeatureBottomHardnessCode (const ::xml_schema::token& v);

    GeographicFeatureBottomHardnessCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    GeographicFeatureBottomHardnessCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    GeographicFeatureBottomHardnessCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    GeographicFeatureBottomHardnessCode (const GeographicFeatureBottomHardnessCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual GeographicFeatureBottomHardnessCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GeographicFeatureBottomHardnessCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GeographicFeatureBottomHardnessCode_convert ();
    }

    protected:
    value
    _xsd_GeographicFeatureBottomHardnessCode_convert () const;

    public:
    static const char* const _xsd_GeographicFeatureBottomHardnessCode_literals_[6];
    static const value _xsd_GeographicFeatureBottomHardnessCode_indexes_[6];
  };

  class GeographicFeatureSolidSurfaceCompositionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BDROCK,
      CORAL,
      EARTH,
      ICE,
      NOS,
      SAND,
      SNOW
    };

    GeographicFeatureSolidSurfaceCompositionCode (value v);

    GeographicFeatureSolidSurfaceCompositionCode (const char* v);

    GeographicFeatureSolidSurfaceCompositionCode (const ::std::string& v);

    GeographicFeatureSolidSurfaceCompositionCode (const ::xml_schema::token& v);

    GeographicFeatureSolidSurfaceCompositionCode (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    GeographicFeatureSolidSurfaceCompositionCode (const ::xercesc::DOMAttr& a,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    GeographicFeatureSolidSurfaceCompositionCode (const ::std::string& s,
                                                  const ::xercesc::DOMElement* e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    GeographicFeatureSolidSurfaceCompositionCode (const GeographicFeatureSolidSurfaceCompositionCode& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    virtual GeographicFeatureSolidSurfaceCompositionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GeographicFeatureSolidSurfaceCompositionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GeographicFeatureSolidSurfaceCompositionCode_convert ();
    }

    protected:
    value
    _xsd_GeographicFeatureSolidSurfaceCompositionCode_convert () const;

    public:
    static const char* const _xsd_GeographicFeatureSolidSurfaceCompositionCode_literals_[7];
    static const value _xsd_GeographicFeatureSolidSurfaceCompositionCode_indexes_[7];
  };

  class GeographicFeatureStatusCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      LQDBDY,
      LQDSRF,
      SLDSRF
    };

    GeographicFeatureStatusCategoryCode (value v);

    GeographicFeatureStatusCategoryCode (const char* v);

    GeographicFeatureStatusCategoryCode (const ::std::string& v);

    GeographicFeatureStatusCategoryCode (const ::xml_schema::token& v);

    GeographicFeatureStatusCategoryCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    GeographicFeatureStatusCategoryCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    GeographicFeatureStatusCategoryCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    GeographicFeatureStatusCategoryCode (const GeographicFeatureStatusCategoryCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual GeographicFeatureStatusCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GeographicFeatureStatusCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GeographicFeatureStatusCategoryCode_convert ();
    }

    protected:
    value
    _xsd_GeographicFeatureStatusCategoryCode_convert () const;

    public:
    static const char* const _xsd_GeographicFeatureStatusCategoryCode_literals_[3];
    static const value _xsd_GeographicFeatureStatusCategoryCode_indexes_[3];
  };

  class GeographicFeatureStatusSurfaceRecirculationIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    GeographicFeatureStatusSurfaceRecirculationIndicatorCode (value v);

    GeographicFeatureStatusSurfaceRecirculationIndicatorCode (const char* v);

    GeographicFeatureStatusSurfaceRecirculationIndicatorCode (const ::std::string& v);

    GeographicFeatureStatusSurfaceRecirculationIndicatorCode (const ::xml_schema::token& v);

    GeographicFeatureStatusSurfaceRecirculationIndicatorCode (const ::xercesc::DOMElement& e,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    GeographicFeatureStatusSurfaceRecirculationIndicatorCode (const ::xercesc::DOMAttr& a,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    GeographicFeatureStatusSurfaceRecirculationIndicatorCode (const ::std::string& s,
                                                              const ::xercesc::DOMElement* e,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    GeographicFeatureStatusSurfaceRecirculationIndicatorCode (const GeographicFeatureStatusSurfaceRecirculationIndicatorCode& x,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    virtual GeographicFeatureStatusSurfaceRecirculationIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GeographicFeatureStatusSurfaceRecirculationIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GeographicFeatureStatusSurfaceRecirculationIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_GeographicFeatureStatusSurfaceRecirculationIndicatorCode_convert () const;

    public:
    static const char* const _xsd_GeographicFeatureStatusSurfaceRecirculationIndicatorCode_literals_[2];
    static const value _xsd_GeographicFeatureStatusSurfaceRecirculationIndicatorCode_indexes_[2];
  };

  class GeographicFeatureSurfaceCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      LQDSRF,
      NOS,
      SLDSRF
    };

    GeographicFeatureSurfaceCategoryCode (value v);

    GeographicFeatureSurfaceCategoryCode (const char* v);

    GeographicFeatureSurfaceCategoryCode (const ::std::string& v);

    GeographicFeatureSurfaceCategoryCode (const ::xml_schema::token& v);

    GeographicFeatureSurfaceCategoryCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    GeographicFeatureSurfaceCategoryCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    GeographicFeatureSurfaceCategoryCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    GeographicFeatureSurfaceCategoryCode (const GeographicFeatureSurfaceCategoryCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual GeographicFeatureSurfaceCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GeographicFeatureSurfaceCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GeographicFeatureSurfaceCategoryCode_convert ();
    }

    protected:
    value
    _xsd_GeographicFeatureSurfaceCategoryCode_convert () const;

    public:
    static const char* const _xsd_GeographicFeatureSurfaceCategoryCode_literals_[3];
    static const value _xsd_GeographicFeatureSurfaceCategoryCode_indexes_[3];
  };

  class GeographicFeatureTerrainCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FLAT,
      HILLY,
      MOUNTS,
      NKN,
      NOS,
      UNDULT,
      URBAN
    };

    GeographicFeatureTerrainCode (value v);

    GeographicFeatureTerrainCode (const char* v);

    GeographicFeatureTerrainCode (const ::std::string& v);

    GeographicFeatureTerrainCode (const ::xml_schema::token& v);

    GeographicFeatureTerrainCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    GeographicFeatureTerrainCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    GeographicFeatureTerrainCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    GeographicFeatureTerrainCode (const GeographicFeatureTerrainCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual GeographicFeatureTerrainCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GeographicFeatureTerrainCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GeographicFeatureTerrainCode_convert ();
    }

    protected:
    value
    _xsd_GeographicFeatureTerrainCode_convert () const;

    public:
    static const char* const _xsd_GeographicFeatureTerrainCode_literals_[7];
    static const value _xsd_GeographicFeatureTerrainCode_indexes_[7];
  };

  class GeographicFeatureTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CONTNT,
      CSTLHY,
      INLNDW,
      LNDFRM,
      NKN,
      NOS,
      SNOWIC,
      WETLND
    };

    GeographicFeatureTypeCategoryCode (value v);

    GeographicFeatureTypeCategoryCode (const char* v);

    GeographicFeatureTypeCategoryCode (const ::std::string& v);

    GeographicFeatureTypeCategoryCode (const ::xml_schema::token& v);

    GeographicFeatureTypeCategoryCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    GeographicFeatureTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    GeographicFeatureTypeCategoryCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    GeographicFeatureTypeCategoryCode (const GeographicFeatureTypeCategoryCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual GeographicFeatureTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GeographicFeatureTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GeographicFeatureTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_GeographicFeatureTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_GeographicFeatureTypeCategoryCode_literals_[8];
    static const value _xsd_GeographicFeatureTypeCategoryCode_indexes_[8];
  };

  class GeographicFeatureTypeSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BCKSHR,
      BEACH,
      BLUFF,
      BOG,
      CAVE,
      CAY,
      CHANEL,
      CRVCEC,
      CSTLNE,
      CUT,
      DPRSSN,
      DRYGAP,
      EMBANK,
      ESKER,
      FAN,
      FAULT,
      FLDDAR,
      FLUME,
      FORD,
      FRESHR,
      GEOTHR,
      GLACER,
      GULLY,
      HILL,
      HRBRNT,
      HUMOCK,
      ICECLF,
      ICEPKN,
      ICESHL,
      INLNDS,
      ISLAND,
      LAGOON,
      LEDGE,
      LKEPND,
      LNDSBJ,
      LNDSLD,
      LRGRCK,
      MARSH,
      MNTPSS,
      MORANE,
      MOUNTN,
      NRSHRE,
      PCKICE,
      PINGO,
      PLRICE,
      RAPIDS,
      RCKSTR,
      REEF,
      ROCK,
      RVRBNK,
      RVRSTR,
      RVRSTV,
      SEBKHA,
      SHRLNE,
      SLTPAN,
      SNDDUN,
      SNGSSS,
      SNWICE,
      SPRING,
      SWAMP,
      TUNDRA,
      UNDRGW,
      UNDRML,
      UNDRSR,
      VALLEY,
      VLCNOD,
      VOLCNO,
      WATER,
      WATRFL
    };

    GeographicFeatureTypeSubcategoryCode (value v);

    GeographicFeatureTypeSubcategoryCode (const char* v);

    GeographicFeatureTypeSubcategoryCode (const ::std::string& v);

    GeographicFeatureTypeSubcategoryCode (const ::xml_schema::token& v);

    GeographicFeatureTypeSubcategoryCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    GeographicFeatureTypeSubcategoryCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    GeographicFeatureTypeSubcategoryCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    GeographicFeatureTypeSubcategoryCode (const GeographicFeatureTypeSubcategoryCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual GeographicFeatureTypeSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GeographicFeatureTypeSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GeographicFeatureTypeSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_GeographicFeatureTypeSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_GeographicFeatureTypeSubcategoryCode_literals_[69];
    static const value _xsd_GeographicFeatureTypeSubcategoryCode_indexes_[69];
  };

  class GeometricVolumeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CN,
      SPHVOL,
      SURVOL
    };

    GeometricVolumeCategoryCode (value v);

    GeometricVolumeCategoryCode (const char* v);

    GeometricVolumeCategoryCode (const ::std::string& v);

    GeometricVolumeCategoryCode (const ::xml_schema::token& v);

    GeometricVolumeCategoryCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    GeometricVolumeCategoryCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    GeometricVolumeCategoryCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    GeometricVolumeCategoryCode (const GeometricVolumeCategoryCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual GeometricVolumeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GeometricVolumeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GeometricVolumeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_GeometricVolumeCategoryCode_convert () const;

    public:
    static const char* const _xsd_GeometricVolumeCategoryCode_literals_[3];
    static const value _xsd_GeometricVolumeCategoryCode_indexes_[3];
  };

  class GovernmentOrganisationTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      INTCIV,
      INTCMI,
      MILORG,
      NATCIV,
      NOS
    };

    GovernmentOrganisationTypeCategoryCode (value v);

    GovernmentOrganisationTypeCategoryCode (const char* v);

    GovernmentOrganisationTypeCategoryCode (const ::std::string& v);

    GovernmentOrganisationTypeCategoryCode (const ::xml_schema::token& v);

    GovernmentOrganisationTypeCategoryCode (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    GovernmentOrganisationTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    GovernmentOrganisationTypeCategoryCode (const ::std::string& s,
                                            const ::xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    GovernmentOrganisationTypeCategoryCode (const GovernmentOrganisationTypeCategoryCode& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual GovernmentOrganisationTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GovernmentOrganisationTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GovernmentOrganisationTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_GovernmentOrganisationTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_GovernmentOrganisationTypeCategoryCode_literals_[5];
    static const value _xsd_GovernmentOrganisationTypeCategoryCode_indexes_[5];
  };

  class GroupCharacteristicAgeGroupCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ADULT,
      CHILD,
      ELDRLY,
      MIXED,
      NKN
    };

    GroupCharacteristicAgeGroupCode (value v);

    GroupCharacteristicAgeGroupCode (const char* v);

    GroupCharacteristicAgeGroupCode (const ::std::string& v);

    GroupCharacteristicAgeGroupCode (const ::xml_schema::token& v);

    GroupCharacteristicAgeGroupCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    GroupCharacteristicAgeGroupCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    GroupCharacteristicAgeGroupCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    GroupCharacteristicAgeGroupCode (const GroupCharacteristicAgeGroupCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual GroupCharacteristicAgeGroupCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GroupCharacteristicAgeGroupCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GroupCharacteristicAgeGroupCode_convert ();
    }

    protected:
    value
    _xsd_GroupCharacteristicAgeGroupCode_convert () const;

    public:
    static const char* const _xsd_GroupCharacteristicAgeGroupCode_literals_[5];
    static const value _xsd_GroupCharacteristicAgeGroupCode_indexes_[5];
  };

  class GroupCharacteristicMaladyCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AFRTRP,
      AIDS,
      AMBDYS,
      ANTHRX,
      ANTMRS,
      ARBVRS,
      BOTULM,
      BRUCLS,
      BURULI,
      CAMPLB,
      CHAGAS,
      CHANCR,
      CHCKPX,
      CHLMDA,
      CHOLRA,
      COCCID,
      CROUP,
      CRYPTS,
      CYCLSP,
      DENGUE,
      DIPTHR,
      DONOVA,
      DRACUN,
      ECOLI,
      EHRLCH,
      ENCPHL,
      ERYSPL,
      FILARS,
      GASTRE,
      GIARDS,
      GONORH,
      HINFLZ,
      HANTAV,
      HEMRHG,
      HEPATA,
      HEPATB,
      HEPATC,
      HIV,
      HMNMPX,
      HYDATD,
      INFENT,
      INFLUN,
      LEGION,
      LSHMNA,
      LSHMNC,
      LSHMNM,
      LSHMNV,
      LEPRSY,
      LEPTOS,
      LISTRS,
      LYME,
      LYMPHG,
      MALARA,
      MEASLS,
      MENING,
      MENNGE,
      MENNGO,
      MENNGP,
      MNNGOC,
      MUMPS,
      ORNTHS,
      PRTPHY,
      PRTUSS,
      PLAGUE,
      PNEUMO,
      POLIO,
      PUERPL,
      QFEVER,
      RABIES,
      RLPSNG,
      RHEUMA,
      RIFTVF,
      RCKYMT,
      ROSSRV,
      RUBELA,
      RUBELC,
      SALMNL,
      SEPTCM,
      SCRLET,
      SCHSTO,
      SARS,
      SXLTRN,
      SHGLLS,
      SMLLPX,
      STREPT,
      SYPHLA,
      SYPHLC,
      SYPHLE,
      SYPHLL,
      SYPHLP,
      TETANS,
      TOXSHK,
      TOXPLS,
      TRNSSP,
      TRCHNS,
      TRYPNS,
      TUBERC,
      TULARM,
      TYPHOD,
      TYPHUS,
      URTHRT,
      VARCLL,
      VRHAEM,
      WTRBRN,
      YELLWF,
      YERSNS,
      NOS
    };

    GroupCharacteristicMaladyCode (value v);

    GroupCharacteristicMaladyCode (const char* v);

    GroupCharacteristicMaladyCode (const ::std::string& v);

    GroupCharacteristicMaladyCode (const ::xml_schema::token& v);

    GroupCharacteristicMaladyCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    GroupCharacteristicMaladyCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    GroupCharacteristicMaladyCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    GroupCharacteristicMaladyCode (const GroupCharacteristicMaladyCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual GroupCharacteristicMaladyCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GroupCharacteristicMaladyCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GroupCharacteristicMaladyCode_convert ();
    }

    protected:
    value
    _xsd_GroupCharacteristicMaladyCode_convert () const;

    public:
    static const char* const _xsd_GroupCharacteristicMaladyCode_literals_[107];
    static const value _xsd_GroupCharacteristicMaladyCode_indexes_[107];
  };

  class GroupCharacteristicMaladyTransmissibilityIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    GroupCharacteristicMaladyTransmissibilityIndicatorCode (value v);

    GroupCharacteristicMaladyTransmissibilityIndicatorCode (const char* v);

    GroupCharacteristicMaladyTransmissibilityIndicatorCode (const ::std::string& v);

    GroupCharacteristicMaladyTransmissibilityIndicatorCode (const ::xml_schema::token& v);

    GroupCharacteristicMaladyTransmissibilityIndicatorCode (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

    GroupCharacteristicMaladyTransmissibilityIndicatorCode (const ::xercesc::DOMAttr& a,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

    GroupCharacteristicMaladyTransmissibilityIndicatorCode (const ::std::string& s,
                                                            const ::xercesc::DOMElement* e,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

    GroupCharacteristicMaladyTransmissibilityIndicatorCode (const GroupCharacteristicMaladyTransmissibilityIndicatorCode& x,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

    virtual GroupCharacteristicMaladyTransmissibilityIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GroupCharacteristicMaladyTransmissibilityIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GroupCharacteristicMaladyTransmissibilityIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_GroupCharacteristicMaladyTransmissibilityIndicatorCode_convert () const;

    public:
    static const char* const _xsd_GroupCharacteristicMaladyTransmissibilityIndicatorCode_literals_[2];
    static const value _xsd_GroupCharacteristicMaladyTransmissibilityIndicatorCode_indexes_[2];
  };

  class GroupCharacteristicTriageCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      T1,
      T2,
      T3,
      T4
    };

    GroupCharacteristicTriageCode (value v);

    GroupCharacteristicTriageCode (const char* v);

    GroupCharacteristicTriageCode (const ::std::string& v);

    GroupCharacteristicTriageCode (const ::xml_schema::token& v);

    GroupCharacteristicTriageCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    GroupCharacteristicTriageCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    GroupCharacteristicTriageCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    GroupCharacteristicTriageCode (const GroupCharacteristicTriageCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual GroupCharacteristicTriageCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GroupCharacteristicTriageCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GroupCharacteristicTriageCode_convert ();
    }

    protected:
    value
    _xsd_GroupCharacteristicTriageCode_convert () const;

    public:
    static const char* const _xsd_GroupCharacteristicTriageCode_literals_[4];
    static const value _xsd_GroupCharacteristicTriageCode_indexes_[4];
  };

  class GroupOrganisationTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CIVCON,
      CRIMIN,
      DSPLPR,
      GANG,
      INTLCT,
      JRNLST,
      LNDOWN,
      LOCINH,
      MEDINT,
      MEDLCL,
      MEDNAT,
      MEDNOS,
      MRCHNT,
      NOS,
      POLCHF,
      POW,
      PRSNR,
      REFUGE,
      TERRST,
      VILELD,
      WRITER
    };

    GroupOrganisationTypeCategoryCode (value v);

    GroupOrganisationTypeCategoryCode (const char* v);

    GroupOrganisationTypeCategoryCode (const ::std::string& v);

    GroupOrganisationTypeCategoryCode (const ::xml_schema::token& v);

    GroupOrganisationTypeCategoryCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    GroupOrganisationTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    GroupOrganisationTypeCategoryCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    GroupOrganisationTypeCategoryCode (const GroupOrganisationTypeCategoryCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual GroupOrganisationTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GroupOrganisationTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_GroupOrganisationTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_GroupOrganisationTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_GroupOrganisationTypeCategoryCode_literals_[21];
    static const value _xsd_GroupOrganisationTypeCategoryCode_indexes_[21];
  };

  class HandlingCapabilityActionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HOIST,
      LOAD,
      LOADUN,
      UNLOAD
    };

    HandlingCapabilityActionCode (value v);

    HandlingCapabilityActionCode (const char* v);

    HandlingCapabilityActionCode (const ::std::string& v);

    HandlingCapabilityActionCode (const ::xml_schema::token& v);

    HandlingCapabilityActionCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    HandlingCapabilityActionCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    HandlingCapabilityActionCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    HandlingCapabilityActionCode (const HandlingCapabilityActionCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual HandlingCapabilityActionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HandlingCapabilityActionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HandlingCapabilityActionCode_convert ();
    }

    protected:
    value
    _xsd_HandlingCapabilityActionCode_convert () const;

    public:
    static const char* const _xsd_HandlingCapabilityActionCode_literals_[4];
    static const value _xsd_HandlingCapabilityActionCode_indexes_[4];
  };

  class HandlingCapabilityDescriptorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BLKLIQ,
      BLKVOL,
      MAXCNT,
      MCRHEI,
      MCRLEN,
      MCRWGT,
      MCRWID,
      NEQLMT
    };

    HandlingCapabilityDescriptorCode (value v);

    HandlingCapabilityDescriptorCode (const char* v);

    HandlingCapabilityDescriptorCode (const ::std::string& v);

    HandlingCapabilityDescriptorCode (const ::xml_schema::token& v);

    HandlingCapabilityDescriptorCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    HandlingCapabilityDescriptorCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    HandlingCapabilityDescriptorCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    HandlingCapabilityDescriptorCode (const HandlingCapabilityDescriptorCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual HandlingCapabilityDescriptorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HandlingCapabilityDescriptorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HandlingCapabilityDescriptorCode_convert ();
    }

    protected:
    value
    _xsd_HandlingCapabilityDescriptorCode_convert () const;

    public:
    static const char* const _xsd_HandlingCapabilityDescriptorCode_literals_[8];
    static const value _xsd_HandlingCapabilityDescriptorCode_indexes_[8];
  };

  class HarbourAirportNearIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourAirportNearIndicatorCode (value v);

    HarbourAirportNearIndicatorCode (const char* v);

    HarbourAirportNearIndicatorCode (const ::std::string& v);

    HarbourAirportNearIndicatorCode (const ::xml_schema::token& v);

    HarbourAirportNearIndicatorCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    HarbourAirportNearIndicatorCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    HarbourAirportNearIndicatorCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    HarbourAirportNearIndicatorCode (const HarbourAirportNearIndicatorCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual HarbourAirportNearIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourAirportNearIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourAirportNearIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourAirportNearIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourAirportNearIndicatorCode_literals_[2];
    static const value _xsd_HarbourAirportNearIndicatorCode_indexes_[2];
  };

  class HarbourBiologicallySecureAvailabilityIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourBiologicallySecureAvailabilityIndicatorCode (value v);

    HarbourBiologicallySecureAvailabilityIndicatorCode (const char* v);

    HarbourBiologicallySecureAvailabilityIndicatorCode (const ::std::string& v);

    HarbourBiologicallySecureAvailabilityIndicatorCode (const ::xml_schema::token& v);

    HarbourBiologicallySecureAvailabilityIndicatorCode (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

    HarbourBiologicallySecureAvailabilityIndicatorCode (const ::xercesc::DOMAttr& a,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

    HarbourBiologicallySecureAvailabilityIndicatorCode (const ::std::string& s,
                                                        const ::xercesc::DOMElement* e,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

    HarbourBiologicallySecureAvailabilityIndicatorCode (const HarbourBiologicallySecureAvailabilityIndicatorCode& x,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

    virtual HarbourBiologicallySecureAvailabilityIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourBiologicallySecureAvailabilityIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourBiologicallySecureAvailabilityIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourBiologicallySecureAvailabilityIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourBiologicallySecureAvailabilityIndicatorCode_literals_[2];
    static const value _xsd_HarbourBiologicallySecureAvailabilityIndicatorCode_indexes_[2];
  };

  class HarbourConvoyMarshallingIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourConvoyMarshallingIndicatorCode (value v);

    HarbourConvoyMarshallingIndicatorCode (const char* v);

    HarbourConvoyMarshallingIndicatorCode (const ::std::string& v);

    HarbourConvoyMarshallingIndicatorCode (const ::xml_schema::token& v);

    HarbourConvoyMarshallingIndicatorCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    HarbourConvoyMarshallingIndicatorCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    HarbourConvoyMarshallingIndicatorCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    HarbourConvoyMarshallingIndicatorCode (const HarbourConvoyMarshallingIndicatorCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual HarbourConvoyMarshallingIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourConvoyMarshallingIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourConvoyMarshallingIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourConvoyMarshallingIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourConvoyMarshallingIndicatorCode_literals_[2];
    static const value _xsd_HarbourConvoyMarshallingIndicatorCode_indexes_[2];
  };

  class HarbourDegaussingIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourDegaussingIndicatorCode (value v);

    HarbourDegaussingIndicatorCode (const char* v);

    HarbourDegaussingIndicatorCode (const ::std::string& v);

    HarbourDegaussingIndicatorCode (const ::xml_schema::token& v);

    HarbourDegaussingIndicatorCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    HarbourDegaussingIndicatorCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    HarbourDegaussingIndicatorCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    HarbourDegaussingIndicatorCode (const HarbourDegaussingIndicatorCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual HarbourDegaussingIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourDegaussingIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourDegaussingIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourDegaussingIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourDegaussingIndicatorCode_literals_[2];
    static const value _xsd_HarbourDegaussingIndicatorCode_indexes_[2];
  };

  class HarbourDirtyBallastIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourDirtyBallastIndicatorCode (value v);

    HarbourDirtyBallastIndicatorCode (const char* v);

    HarbourDirtyBallastIndicatorCode (const ::std::string& v);

    HarbourDirtyBallastIndicatorCode (const ::xml_schema::token& v);

    HarbourDirtyBallastIndicatorCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    HarbourDirtyBallastIndicatorCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    HarbourDirtyBallastIndicatorCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    HarbourDirtyBallastIndicatorCode (const HarbourDirtyBallastIndicatorCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual HarbourDirtyBallastIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourDirtyBallastIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourDirtyBallastIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourDirtyBallastIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourDirtyBallastIndicatorCode_literals_[2];
    static const value _xsd_HarbourDirtyBallastIndicatorCode_indexes_[2];
  };

  class HarbourEntranceRestrictionsIceIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourEntranceRestrictionsIceIndicatorCode (value v);

    HarbourEntranceRestrictionsIceIndicatorCode (const char* v);

    HarbourEntranceRestrictionsIceIndicatorCode (const ::std::string& v);

    HarbourEntranceRestrictionsIceIndicatorCode (const ::xml_schema::token& v);

    HarbourEntranceRestrictionsIceIndicatorCode (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    HarbourEntranceRestrictionsIceIndicatorCode (const ::xercesc::DOMAttr& a,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    HarbourEntranceRestrictionsIceIndicatorCode (const ::std::string& s,
                                                 const ::xercesc::DOMElement* e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    HarbourEntranceRestrictionsIceIndicatorCode (const HarbourEntranceRestrictionsIceIndicatorCode& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual HarbourEntranceRestrictionsIceIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourEntranceRestrictionsIceIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourEntranceRestrictionsIceIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourEntranceRestrictionsIceIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourEntranceRestrictionsIceIndicatorCode_literals_[2];
    static const value _xsd_HarbourEntranceRestrictionsIceIndicatorCode_indexes_[2];
  };

  class HarbourEntranceRestrictionsSwellIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourEntranceRestrictionsSwellIndicatorCode (value v);

    HarbourEntranceRestrictionsSwellIndicatorCode (const char* v);

    HarbourEntranceRestrictionsSwellIndicatorCode (const ::std::string& v);

    HarbourEntranceRestrictionsSwellIndicatorCode (const ::xml_schema::token& v);

    HarbourEntranceRestrictionsSwellIndicatorCode (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    HarbourEntranceRestrictionsSwellIndicatorCode (const ::xercesc::DOMAttr& a,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    HarbourEntranceRestrictionsSwellIndicatorCode (const ::std::string& s,
                                                   const ::xercesc::DOMElement* e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    HarbourEntranceRestrictionsSwellIndicatorCode (const HarbourEntranceRestrictionsSwellIndicatorCode& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    virtual HarbourEntranceRestrictionsSwellIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourEntranceRestrictionsSwellIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourEntranceRestrictionsSwellIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourEntranceRestrictionsSwellIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourEntranceRestrictionsSwellIndicatorCode_literals_[2];
    static const value _xsd_HarbourEntranceRestrictionsSwellIndicatorCode_indexes_[2];
  };

  class HarbourEstimatedTimeOfArrivalIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourEstimatedTimeOfArrivalIndicatorCode (value v);

    HarbourEstimatedTimeOfArrivalIndicatorCode (const char* v);

    HarbourEstimatedTimeOfArrivalIndicatorCode (const ::std::string& v);

    HarbourEstimatedTimeOfArrivalIndicatorCode (const ::xml_schema::token& v);

    HarbourEstimatedTimeOfArrivalIndicatorCode (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    HarbourEstimatedTimeOfArrivalIndicatorCode (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    HarbourEstimatedTimeOfArrivalIndicatorCode (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    HarbourEstimatedTimeOfArrivalIndicatorCode (const HarbourEstimatedTimeOfArrivalIndicatorCode& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual HarbourEstimatedTimeOfArrivalIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourEstimatedTimeOfArrivalIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourEstimatedTimeOfArrivalIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourEstimatedTimeOfArrivalIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourEstimatedTimeOfArrivalIndicatorCode_literals_[2];
    static const value _xsd_HarbourEstimatedTimeOfArrivalIndicatorCode_indexes_[2];
  };

  class HarbourFireFightingCapabilityCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AFLOAT,
      ASHORE,
      NOS
    };

    HarbourFireFightingCapabilityCode (value v);

    HarbourFireFightingCapabilityCode (const char* v);

    HarbourFireFightingCapabilityCode (const ::std::string& v);

    HarbourFireFightingCapabilityCode (const ::xml_schema::token& v);

    HarbourFireFightingCapabilityCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    HarbourFireFightingCapabilityCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    HarbourFireFightingCapabilityCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    HarbourFireFightingCapabilityCode (const HarbourFireFightingCapabilityCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual HarbourFireFightingCapabilityCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourFireFightingCapabilityCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourFireFightingCapabilityCode_convert ();
    }

    protected:
    value
    _xsd_HarbourFireFightingCapabilityCode_convert () const;

    public:
    static const char* const _xsd_HarbourFireFightingCapabilityCode_literals_[3];
    static const value _xsd_HarbourFireFightingCapabilityCode_indexes_[3];
  };

  class HarbourFireFightingIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourFireFightingIndicatorCode (value v);

    HarbourFireFightingIndicatorCode (const char* v);

    HarbourFireFightingIndicatorCode (const ::std::string& v);

    HarbourFireFightingIndicatorCode (const ::xml_schema::token& v);

    HarbourFireFightingIndicatorCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    HarbourFireFightingIndicatorCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    HarbourFireFightingIndicatorCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    HarbourFireFightingIndicatorCode (const HarbourFireFightingIndicatorCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual HarbourFireFightingIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourFireFightingIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourFireFightingIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourFireFightingIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourFireFightingIndicatorCode_literals_[2];
    static const value _xsd_HarbourFireFightingIndicatorCode_indexes_[2];
  };

  class HarbourFirstPortOfEntryIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourFirstPortOfEntryIndicatorCode (value v);

    HarbourFirstPortOfEntryIndicatorCode (const char* v);

    HarbourFirstPortOfEntryIndicatorCode (const ::std::string& v);

    HarbourFirstPortOfEntryIndicatorCode (const ::xml_schema::token& v);

    HarbourFirstPortOfEntryIndicatorCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    HarbourFirstPortOfEntryIndicatorCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    HarbourFirstPortOfEntryIndicatorCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    HarbourFirstPortOfEntryIndicatorCode (const HarbourFirstPortOfEntryIndicatorCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual HarbourFirstPortOfEntryIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourFirstPortOfEntryIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourFirstPortOfEntryIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourFirstPortOfEntryIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourFirstPortOfEntryIndicatorCode_literals_[2];
    static const value _xsd_HarbourFirstPortOfEntryIndicatorCode_indexes_[2];
  };

  class HarbourFreshWaterAvailabilityIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourFreshWaterAvailabilityIndicatorCode (value v);

    HarbourFreshWaterAvailabilityIndicatorCode (const char* v);

    HarbourFreshWaterAvailabilityIndicatorCode (const ::std::string& v);

    HarbourFreshWaterAvailabilityIndicatorCode (const ::xml_schema::token& v);

    HarbourFreshWaterAvailabilityIndicatorCode (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    HarbourFreshWaterAvailabilityIndicatorCode (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    HarbourFreshWaterAvailabilityIndicatorCode (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    HarbourFreshWaterAvailabilityIndicatorCode (const HarbourFreshWaterAvailabilityIndicatorCode& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual HarbourFreshWaterAvailabilityIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourFreshWaterAvailabilityIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourFreshWaterAvailabilityIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourFreshWaterAvailabilityIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourFreshWaterAvailabilityIndicatorCode_literals_[2];
    static const value _xsd_HarbourFreshWaterAvailabilityIndicatorCode_indexes_[2];
  };

  class HarbourLashIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourLashIndicatorCode (value v);

    HarbourLashIndicatorCode (const char* v);

    HarbourLashIndicatorCode (const ::std::string& v);

    HarbourLashIndicatorCode (const ::xml_schema::token& v);

    HarbourLashIndicatorCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    HarbourLashIndicatorCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    HarbourLashIndicatorCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    HarbourLashIndicatorCode (const HarbourLashIndicatorCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual HarbourLashIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourLashIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourLashIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourLashIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourLashIndicatorCode_literals_[2];
    static const value _xsd_HarbourLashIndicatorCode_indexes_[2];
  };

  class HarbourLighterageAvailabilityIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourLighterageAvailabilityIndicatorCode (value v);

    HarbourLighterageAvailabilityIndicatorCode (const char* v);

    HarbourLighterageAvailabilityIndicatorCode (const ::std::string& v);

    HarbourLighterageAvailabilityIndicatorCode (const ::xml_schema::token& v);

    HarbourLighterageAvailabilityIndicatorCode (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    HarbourLighterageAvailabilityIndicatorCode (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    HarbourLighterageAvailabilityIndicatorCode (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    HarbourLighterageAvailabilityIndicatorCode (const HarbourLighterageAvailabilityIndicatorCode& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual HarbourLighterageAvailabilityIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourLighterageAvailabilityIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourLighterageAvailabilityIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourLighterageAvailabilityIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourLighterageAvailabilityIndicatorCode_literals_[2];
    static const value _xsd_HarbourLighterageAvailabilityIndicatorCode_indexes_[2];
  };

  class HarbourOverheadLimitsIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourOverheadLimitsIndicatorCode (value v);

    HarbourOverheadLimitsIndicatorCode (const char* v);

    HarbourOverheadLimitsIndicatorCode (const ::std::string& v);

    HarbourOverheadLimitsIndicatorCode (const ::xml_schema::token& v);

    HarbourOverheadLimitsIndicatorCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    HarbourOverheadLimitsIndicatorCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    HarbourOverheadLimitsIndicatorCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    HarbourOverheadLimitsIndicatorCode (const HarbourOverheadLimitsIndicatorCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual HarbourOverheadLimitsIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourOverheadLimitsIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourOverheadLimitsIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourOverheadLimitsIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourOverheadLimitsIndicatorCode_literals_[2];
    static const value _xsd_HarbourOverheadLimitsIndicatorCode_indexes_[2];
  };

  class HarbourPassengerHandlingIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourPassengerHandlingIndicatorCode (value v);

    HarbourPassengerHandlingIndicatorCode (const char* v);

    HarbourPassengerHandlingIndicatorCode (const ::std::string& v);

    HarbourPassengerHandlingIndicatorCode (const ::xml_schema::token& v);

    HarbourPassengerHandlingIndicatorCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    HarbourPassengerHandlingIndicatorCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    HarbourPassengerHandlingIndicatorCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    HarbourPassengerHandlingIndicatorCode (const HarbourPassengerHandlingIndicatorCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual HarbourPassengerHandlingIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourPassengerHandlingIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourPassengerHandlingIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourPassengerHandlingIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourPassengerHandlingIndicatorCode_literals_[2];
    static const value _xsd_HarbourPassengerHandlingIndicatorCode_indexes_[2];
  };

  class HarbourPersistenceCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NKN,
      PERMAN,
      TEMPRY
    };

    HarbourPersistenceCode (value v);

    HarbourPersistenceCode (const char* v);

    HarbourPersistenceCode (const ::std::string& v);

    HarbourPersistenceCode (const ::xml_schema::token& v);

    HarbourPersistenceCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    HarbourPersistenceCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    HarbourPersistenceCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    HarbourPersistenceCode (const HarbourPersistenceCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual HarbourPersistenceCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourPersistenceCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourPersistenceCode_convert ();
    }

    protected:
    value
    _xsd_HarbourPersistenceCode_convert () const;

    public:
    static const char* const _xsd_HarbourPersistenceCode_literals_[3];
    static const value _xsd_HarbourPersistenceCode_indexes_[3];
  };

  class HarbourPilotageAvailabilityIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourPilotageAvailabilityIndicatorCode (value v);

    HarbourPilotageAvailabilityIndicatorCode (const char* v);

    HarbourPilotageAvailabilityIndicatorCode (const ::std::string& v);

    HarbourPilotageAvailabilityIndicatorCode (const ::xml_schema::token& v);

    HarbourPilotageAvailabilityIndicatorCode (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    HarbourPilotageAvailabilityIndicatorCode (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    HarbourPilotageAvailabilityIndicatorCode (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    HarbourPilotageAvailabilityIndicatorCode (const HarbourPilotageAvailabilityIndicatorCode& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual HarbourPilotageAvailabilityIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourPilotageAvailabilityIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourPilotageAvailabilityIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourPilotageAvailabilityIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourPilotageAvailabilityIndicatorCode_literals_[2];
    static const value _xsd_HarbourPilotageAvailabilityIndicatorCode_indexes_[2];
  };

  class HarbourPilotageRequirementIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourPilotageRequirementIndicatorCode (value v);

    HarbourPilotageRequirementIndicatorCode (const char* v);

    HarbourPilotageRequirementIndicatorCode (const ::std::string& v);

    HarbourPilotageRequirementIndicatorCode (const ::xml_schema::token& v);

    HarbourPilotageRequirementIndicatorCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    HarbourPilotageRequirementIndicatorCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    HarbourPilotageRequirementIndicatorCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    HarbourPilotageRequirementIndicatorCode (const HarbourPilotageRequirementIndicatorCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual HarbourPilotageRequirementIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourPilotageRequirementIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourPilotageRequirementIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourPilotageRequirementIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourPilotageRequirementIndicatorCode_literals_[2];
    static const value _xsd_HarbourPilotageRequirementIndicatorCode_indexes_[2];
  };

  class HarbourRefuellingAvailabilityIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourRefuellingAvailabilityIndicatorCode (value v);

    HarbourRefuellingAvailabilityIndicatorCode (const char* v);

    HarbourRefuellingAvailabilityIndicatorCode (const ::std::string& v);

    HarbourRefuellingAvailabilityIndicatorCode (const ::xml_schema::token& v);

    HarbourRefuellingAvailabilityIndicatorCode (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    HarbourRefuellingAvailabilityIndicatorCode (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    HarbourRefuellingAvailabilityIndicatorCode (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    HarbourRefuellingAvailabilityIndicatorCode (const HarbourRefuellingAvailabilityIndicatorCode& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual HarbourRefuellingAvailabilityIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourRefuellingAvailabilityIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourRefuellingAvailabilityIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourRefuellingAvailabilityIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourRefuellingAvailabilityIndicatorCode_literals_[2];
    static const value _xsd_HarbourRefuellingAvailabilityIndicatorCode_indexes_[2];
  };

  class HarbourRefuellingTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BKRBRG,
      FXDINS,
      NOS,
      TNKRRD
    };

    HarbourRefuellingTypeCode (value v);

    HarbourRefuellingTypeCode (const char* v);

    HarbourRefuellingTypeCode (const ::std::string& v);

    HarbourRefuellingTypeCode (const ::xml_schema::token& v);

    HarbourRefuellingTypeCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    HarbourRefuellingTypeCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    HarbourRefuellingTypeCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    HarbourRefuellingTypeCode (const HarbourRefuellingTypeCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual HarbourRefuellingTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourRefuellingTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourRefuellingTypeCode_convert ();
    }

    protected:
    value
    _xsd_HarbourRefuellingTypeCode_convert () const;

    public:
    static const char* const _xsd_HarbourRefuellingTypeCode_literals_[4];
    static const value _xsd_HarbourRefuellingTypeCode_indexes_[4];
  };

  class HarbourShelterQualityCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      E,
      F,
      G,
      P
    };

    HarbourShelterQualityCode (value v);

    HarbourShelterQualityCode (const char* v);

    HarbourShelterQualityCode (const ::std::string& v);

    HarbourShelterQualityCode (const ::xml_schema::token& v);

    HarbourShelterQualityCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    HarbourShelterQualityCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    HarbourShelterQualityCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    HarbourShelterQualityCode (const HarbourShelterQualityCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual HarbourShelterQualityCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourShelterQualityCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourShelterQualityCode_convert ();
    }

    protected:
    value
    _xsd_HarbourShelterQualityCode_convert () const;

    public:
    static const char* const _xsd_HarbourShelterQualityCode_literals_[4];
    static const value _xsd_HarbourShelterQualityCode_indexes_[4];
  };

  class HarbourTankerFacilitiesIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourTankerFacilitiesIndicatorCode (value v);

    HarbourTankerFacilitiesIndicatorCode (const char* v);

    HarbourTankerFacilitiesIndicatorCode (const ::std::string& v);

    HarbourTankerFacilitiesIndicatorCode (const ::xml_schema::token& v);

    HarbourTankerFacilitiesIndicatorCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    HarbourTankerFacilitiesIndicatorCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    HarbourTankerFacilitiesIndicatorCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    HarbourTankerFacilitiesIndicatorCode (const HarbourTankerFacilitiesIndicatorCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual HarbourTankerFacilitiesIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourTankerFacilitiesIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourTankerFacilitiesIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourTankerFacilitiesIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourTankerFacilitiesIndicatorCode_literals_[2];
    static const value _xsd_HarbourTankerFacilitiesIndicatorCode_indexes_[2];
  };

  class HarbourTransitAccommodationIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourTransitAccommodationIndicatorCode (value v);

    HarbourTransitAccommodationIndicatorCode (const char* v);

    HarbourTransitAccommodationIndicatorCode (const ::std::string& v);

    HarbourTransitAccommodationIndicatorCode (const ::xml_schema::token& v);

    HarbourTransitAccommodationIndicatorCode (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    HarbourTransitAccommodationIndicatorCode (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    HarbourTransitAccommodationIndicatorCode (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    HarbourTransitAccommodationIndicatorCode (const HarbourTransitAccommodationIndicatorCode& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual HarbourTransitAccommodationIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourTransitAccommodationIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourTransitAccommodationIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourTransitAccommodationIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourTransitAccommodationIndicatorCode_literals_[2];
    static const value _xsd_HarbourTransitAccommodationIndicatorCode_indexes_[2];
  };

  class HarbourTugAvailabilityIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourTugAvailabilityIndicatorCode (value v);

    HarbourTugAvailabilityIndicatorCode (const char* v);

    HarbourTugAvailabilityIndicatorCode (const ::std::string& v);

    HarbourTugAvailabilityIndicatorCode (const ::xml_schema::token& v);

    HarbourTugAvailabilityIndicatorCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    HarbourTugAvailabilityIndicatorCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    HarbourTugAvailabilityIndicatorCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    HarbourTugAvailabilityIndicatorCode (const HarbourTugAvailabilityIndicatorCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual HarbourTugAvailabilityIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourTugAvailabilityIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourTugAvailabilityIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourTugAvailabilityIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourTugAvailabilityIndicatorCode_literals_[2];
    static const value _xsd_HarbourTugAvailabilityIndicatorCode_indexes_[2];
  };

  class HarbourTurningAreaIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    HarbourTurningAreaIndicatorCode (value v);

    HarbourTurningAreaIndicatorCode (const char* v);

    HarbourTurningAreaIndicatorCode (const ::std::string& v);

    HarbourTurningAreaIndicatorCode (const ::xml_schema::token& v);

    HarbourTurningAreaIndicatorCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    HarbourTurningAreaIndicatorCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    HarbourTurningAreaIndicatorCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    HarbourTurningAreaIndicatorCode (const HarbourTurningAreaIndicatorCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual HarbourTurningAreaIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourTurningAreaIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourTurningAreaIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_HarbourTurningAreaIndicatorCode_convert () const;

    public:
    static const char* const _xsd_HarbourTurningAreaIndicatorCode_literals_[2];
    static const value _xsd_HarbourTurningAreaIndicatorCode_indexes_[2];
  };

  class HarbourTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CANAL,
      COASTB,
      COASTN,
      COASTT,
      INLAND,
      OPENRD,
      RIVERB,
      RIVERN,
      RIVERT
    };

    HarbourTypeCategoryCode (value v);

    HarbourTypeCategoryCode (const char* v);

    HarbourTypeCategoryCode (const ::std::string& v);

    HarbourTypeCategoryCode (const ::xml_schema::token& v);

    HarbourTypeCategoryCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    HarbourTypeCategoryCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    HarbourTypeCategoryCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    HarbourTypeCategoryCode (const HarbourTypeCategoryCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual HarbourTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_HarbourTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_HarbourTypeCategoryCode_literals_[9];
    static const value _xsd_HarbourTypeCategoryCode_indexes_[9];
  };

  class HarbourVehicleHandlingTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NKN,
      NOS,
      ROROFL,
      ROROFR,
      ROROML
    };

    HarbourVehicleHandlingTypeCode (value v);

    HarbourVehicleHandlingTypeCode (const char* v);

    HarbourVehicleHandlingTypeCode (const ::std::string& v);

    HarbourVehicleHandlingTypeCode (const ::xml_schema::token& v);

    HarbourVehicleHandlingTypeCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    HarbourVehicleHandlingTypeCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    HarbourVehicleHandlingTypeCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    HarbourVehicleHandlingTypeCode (const HarbourVehicleHandlingTypeCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual HarbourVehicleHandlingTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HarbourVehicleHandlingTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HarbourVehicleHandlingTypeCode_convert ();
    }

    protected:
    value
    _xsd_HarbourVehicleHandlingTypeCode_convert () const;

    public:
    static const char* const _xsd_HarbourVehicleHandlingTypeCode_literals_[5];
    static const value _xsd_HarbourVehicleHandlingTypeCode_indexes_[5];
  };

  class HoldingRequiredCalculationMethodCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      LVLOEF,
      TARGET
    };

    HoldingRequiredCalculationMethodCode (value v);

    HoldingRequiredCalculationMethodCode (const char* v);

    HoldingRequiredCalculationMethodCode (const ::std::string& v);

    HoldingRequiredCalculationMethodCode (const ::xml_schema::token& v);

    HoldingRequiredCalculationMethodCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    HoldingRequiredCalculationMethodCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    HoldingRequiredCalculationMethodCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    HoldingRequiredCalculationMethodCode (const HoldingRequiredCalculationMethodCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual HoldingRequiredCalculationMethodCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HoldingRequiredCalculationMethodCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HoldingRequiredCalculationMethodCode_convert ();
    }

    protected:
    value
    _xsd_HoldingRequiredCalculationMethodCode_convert () const;

    public:
    static const char* const _xsd_HoldingRequiredCalculationMethodCode_literals_[2];
    static const value _xsd_HoldingRequiredCalculationMethodCode_indexes_[2];
  };

  class HoldingTransferReasonCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DSTRYD,
      FXDTRM,
      INDFLN,
      ISSUE,
      NOS,
      PRMTRF,
      RTNCST,
      SCHSPL,
      SCRPPD,
      TOTDIN,
      TOTDOT,
      TRFMNT,
      TRFTRN
    };

    HoldingTransferReasonCode (value v);

    HoldingTransferReasonCode (const char* v);

    HoldingTransferReasonCode (const ::std::string& v);

    HoldingTransferReasonCode (const ::xml_schema::token& v);

    HoldingTransferReasonCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    HoldingTransferReasonCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    HoldingTransferReasonCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    HoldingTransferReasonCode (const HoldingTransferReasonCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual HoldingTransferReasonCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HoldingTransferReasonCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_HoldingTransferReasonCode_convert ();
    }

    protected:
    value
    _xsd_HoldingTransferReasonCode_convert () const;

    public:
    static const char* const _xsd_HoldingTransferReasonCode_literals_[13];
    static const value _xsd_HoldingTransferReasonCode_indexes_[13];
  };

  class IcingCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CLRICE,
      MIXICE,
      RIMICE
    };

    IcingCategoryCode (value v);

    IcingCategoryCode (const char* v);

    IcingCategoryCode (const ::std::string& v);

    IcingCategoryCode (const ::xml_schema::token& v);

    IcingCategoryCode (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    IcingCategoryCode (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    IcingCategoryCode (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    IcingCategoryCode (const IcingCategoryCode& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual IcingCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    IcingCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_IcingCategoryCode_convert ();
    }

    protected:
    value
    _xsd_IcingCategoryCode_convert () const;

    public:
    static const char* const _xsd_IcingCategoryCode_literals_[3];
    static const value _xsd_IcingCategoryCode_indexes_[3];
  };

  class IcingSeverityQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      LIGHT,
      MODER,
      SEVERE
    };

    IcingSeverityQualifierCode (value v);

    IcingSeverityQualifierCode (const char* v);

    IcingSeverityQualifierCode (const ::std::string& v);

    IcingSeverityQualifierCode (const ::xml_schema::token& v);

    IcingSeverityQualifierCode (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    IcingSeverityQualifierCode (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    IcingSeverityQualifierCode (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    IcingSeverityQualifierCode (const IcingSeverityQualifierCode& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual IcingSeverityQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    IcingSeverityQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_IcingSeverityQualifierCode_convert ();
    }

    protected:
    value
    _xsd_IcingSeverityQualifierCode_convert () const;

    public:
    static const char* const _xsd_IcingSeverityQualifierCode_literals_[3];
    static const value _xsd_IcingSeverityQualifierCode_indexes_[3];
  };

  class JettyRailServedIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    JettyRailServedIndicatorCode (value v);

    JettyRailServedIndicatorCode (const char* v);

    JettyRailServedIndicatorCode (const ::std::string& v);

    JettyRailServedIndicatorCode (const ::xml_schema::token& v);

    JettyRailServedIndicatorCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    JettyRailServedIndicatorCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    JettyRailServedIndicatorCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    JettyRailServedIndicatorCode (const JettyRailServedIndicatorCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual JettyRailServedIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    JettyRailServedIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_JettyRailServedIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_JettyRailServedIndicatorCode_convert () const;

    public:
    static const char* const _xsd_JettyRailServedIndicatorCode_literals_[2];
    static const value _xsd_JettyRailServedIndicatorCode_indexes_[2];
  };

  class LanguageCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AFGHAN,
      AFRAKN,
      AFREWE,
      AFRGA,
      AFRKKN,
      AFRKNS,
      AFRLNG,
      AFRMSH,
      ALBNAN,
      ALMNIC,
      AMHRIC,
      AMRNDN,
      ANGAUR,
      ARABIC,
      ARMNAN,
      ASSMES,
      ASSYRN,
      AYMARA,
      AZERI,
      AZRBJN,
      BAHSIN,
      BALOCH,
      BAMBRA,
      BANDJB,
      BANGLA,
      BANTU,
      BAPNES,
      BATEKE,
      BENGLI,
      BERBER,
      BHTSTB,
      BICHLM,
      BISLMA,
      BOJPOR,
      BUBI,
      BULGRN,
      BURMSE,
      BYLRSN,
      CAKCHQ,
      CAROLN,
      CHAMOR,
      CHICHW,
      CHNCNT,
      CHNESE,
      CHNHKK,
      CHNMND,
      CHNPTN,
      CIRCAS,
      COMORN,
      CREOLE,
      CREPAT,
      CRIOLO,
      CUSHTC,
      CZECH,
      DAGOMB,
      DANISH,
      DIALCT,
      DIOLA,
      DIVEHI,
      DJERMA,
      DUTCH,
      DZONGK,
      ENGLSH,
      ENGLSM,
      ESKIMO,
      ESTONN,
      FANG,
      FAROES,
      FARSI,
      FIJIAN,
      FILPNO,
      FINNSH,
      FLEMSH,
      FON,
      FRENCH,
      FRNHAL,
      FRNHBA,
      FRNHBR,
      FRNHCA,
      FRNHCO,
      FRNHNO,
      FRNHPA,
      FRNHPR,
      FULA,
      FULANI,
      GAN,
      GEORGN,
      GERMAN,
      GILBER,
      GREEK,
      GRFNCA,
      GRNLND,
      GUARAG,
      GUARAN,
      GUJART,
      HASNAR,
      HAUSSA,
      HEBREW,
      HINDI,
      HINDUS,
      HUNGRN,
      HUNSA,
      IBO,
      ICELND,
      INDIAN,
      INDQUE,
      IRISHG,
      ITALAN,
      JAPNES,
      JAVNES,
      KABYE,
      KANADA,
      KASHMR,
      KAZKHQ,
      KEKCHI,
      KHLKHM,
      KHMER,
      KIKNGO,
      KINGWN,
      KINYRW,
      KIRGZK,
      KIRUND,
      KISWHL,
      KOREAN,
      KRIO,
      KUNAMA,
      KURDSH,
      LAO,
      LAPP,
      LATIN,
      LATVAN,
      LINGAL,
      LITHUN,
      LUGAND,
      LURI,
      LUXEMB,
      MACDNN,
      MAHRAN,
      MALAY,
      MALAYL,
      MALAYO,
      MALGSY,
      MALTSE,
      MANDNG,
      MANDNK,
      MANDRN,
      MANXGL,
      MAORI,
      MARATH,
      MARSHL,
      MAYA,
      MELANP,
      MENDE,
      MINA,
      MINBEI,
      MINNAN,
      MOLDVN,
      MONGSG,
      MONKHM,
      MOROCN,
      MOTU,
      MYENE,
      NAHUA,
      NAPALS,
      NAURAN,
      NEPALI,
      NIGRCN,
      NILOCI,
      NILOHM,
      NILOTC,
      NORABN,
      NORTHS,
      NORWGN,
      NOS,
      NUBIAN,
      ORIYA,
      ORMNGA,
      PALAUN,
      PAPMNT,
      PASHAI,
      PASHTU,
      PERSN,
      PERSND,
      PIDGNE,
      POHNPN,
      POLISH,
      POLYNS,
      PORTGS,
      PULAR,
      PUNJAB,
      QIECHA,
      QUICHE,
      ROMNAN,
      ROMNSC,
      RUSSAN,
      SAMOAN,
      SANGHO,
      SANSKT,
      SARA,
      SCOTGA,
      SERBOC,
      SESTHS,
      SETSWN,
      SHONA,
      SINDBL,
      SINDHI,
      SINHAL,
      SIWATI,
      SLOVAK,
      SLOVNE,
      SLOVNN,
      SOMALI,
      SONNKE,
      SONSRL,
      SPANSH,
      SPNBSQ,
      SPNCST,
      SPNCTL,
      SPNGLC,
      SRNNTN,
      SUDANC,
      SURNMS,
      SWAHIL,
      SWEDSH,
      TABEDW,
      TAHTAN,
      TAIWNS,
      TAJIK,
      TAKITK,
      TAMIL,
      TELUGU,
      TEMNE,
      THAI,
      TIGRE,
      TIGRNY,
      TOBI,
      TOKELN,
      TONGAN,
      TOSK,
      TRUKES,
      TSHLUB,
      TSWANA,
      TURKIC,
      TURKMN,
      TURKSH,
      TUVALN,
      UKRANN,
      URDU,
      UZBEK,
      VIETNM,
      WALLSN,
      WELSH,
      WOLOF,
      WUSHNG,
      XHOSA,
      XIANG,
      YAPESE,
      YORUBA,
      YUECNT,
      ZULU
    };

    LanguageCategoryCode (value v);

    LanguageCategoryCode (const char* v);

    LanguageCategoryCode (const ::std::string& v);

    LanguageCategoryCode (const ::xml_schema::token& v);

    LanguageCategoryCode (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    LanguageCategoryCode (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    LanguageCategoryCode (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    LanguageCategoryCode (const LanguageCategoryCode& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual LanguageCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LanguageCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_LanguageCategoryCode_convert ();
    }

    protected:
    value
    _xsd_LanguageCategoryCode_convert () const;

    public:
    static const char* const _xsd_LanguageCategoryCode_literals_[260];
    static const value _xsd_LanguageCategoryCode_indexes_[260];
  };

  class LanguageSkillProficiencyCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_0,
      cxx_1,
      cxx_2,
      cxx_3,
      cxx_4,
      cxx_5
    };

    LanguageSkillProficiencyCode (value v);

    LanguageSkillProficiencyCode (const char* v);

    LanguageSkillProficiencyCode (const ::std::string& v);

    LanguageSkillProficiencyCode (const ::xml_schema::token& v);

    LanguageSkillProficiencyCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    LanguageSkillProficiencyCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    LanguageSkillProficiencyCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    LanguageSkillProficiencyCode (const LanguageSkillProficiencyCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual LanguageSkillProficiencyCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LanguageSkillProficiencyCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_LanguageSkillProficiencyCode_convert ();
    }

    protected:
    value
    _xsd_LanguageSkillProficiencyCode_convert () const;

    public:
    static const char* const _xsd_LanguageSkillProficiencyCode_literals_[6];
    static const value _xsd_LanguageSkillProficiencyCode_indexes_[6];
  };

  class LightCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CIVIL,
      DARK,
      DAY,
      MOON,
      NAUTIC
    };

    LightCategoryCode (value v);

    LightCategoryCode (const char* v);

    LightCategoryCode (const ::std::string& v);

    LightCategoryCode (const ::xml_schema::token& v);

    LightCategoryCode (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    LightCategoryCode (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    LightCategoryCode (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    LightCategoryCode (const LightCategoryCode& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual LightCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LightCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_LightCategoryCode_convert ();
    }

    protected:
    value
    _xsd_LightCategoryCode_convert () const;

    public:
    static const char* const _xsd_LightCategoryCode_literals_[5];
    static const value _xsd_LightCategoryCode_indexes_[5];
  };

  class LightMoonPhaseCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FUL,
      NEW,
      WAN,
      WAX
    };

    LightMoonPhaseCode (value v);

    LightMoonPhaseCode (const char* v);

    LightMoonPhaseCode (const ::std::string& v);

    LightMoonPhaseCode (const ::xml_schema::token& v);

    LightMoonPhaseCode (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    LightMoonPhaseCode (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    LightMoonPhaseCode (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    LightMoonPhaseCode (const LightMoonPhaseCode& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual LightMoonPhaseCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LightMoonPhaseCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_LightMoonPhaseCode_convert ();
    }

    protected:
    value
    _xsd_LightMoonPhaseCode_convert () const;

    public:
    static const char* const _xsd_LightMoonPhaseCode_literals_[4];
    static const value _xsd_LightMoonPhaseCode_indexes_[4];
  };

  class LiquidSurfaceStatusSeaStateCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_0,
      cxx_1,
      cxx_2,
      cxx_3,
      cxx_4,
      cxx_5,
      cxx_6,
      cxx_7,
      cxx_8,
      cxx_9
    };

    LiquidSurfaceStatusSeaStateCode (value v);

    LiquidSurfaceStatusSeaStateCode (const char* v);

    LiquidSurfaceStatusSeaStateCode (const ::std::string& v);

    LiquidSurfaceStatusSeaStateCode (const ::xml_schema::token& v);

    LiquidSurfaceStatusSeaStateCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    LiquidSurfaceStatusSeaStateCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    LiquidSurfaceStatusSeaStateCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    LiquidSurfaceStatusSeaStateCode (const LiquidSurfaceStatusSeaStateCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual LiquidSurfaceStatusSeaStateCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LiquidSurfaceStatusSeaStateCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_LiquidSurfaceStatusSeaStateCode_convert ();
    }

    protected:
    value
    _xsd_LiquidSurfaceStatusSeaStateCode_convert () const;

    public:
    static const char* const _xsd_LiquidSurfaceStatusSeaStateCode_literals_[10];
    static const value _xsd_LiquidSurfaceStatusSeaStateCode_indexes_[10];
  };

  class LiquidSurfaceStatusSurfaceConditionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DRAIND,
      ICE,
      LIQUID,
      MIXED,
      NKN
    };

    LiquidSurfaceStatusSurfaceConditionCode (value v);

    LiquidSurfaceStatusSurfaceConditionCode (const char* v);

    LiquidSurfaceStatusSurfaceConditionCode (const ::std::string& v);

    LiquidSurfaceStatusSurfaceConditionCode (const ::xml_schema::token& v);

    LiquidSurfaceStatusSurfaceConditionCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    LiquidSurfaceStatusSurfaceConditionCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    LiquidSurfaceStatusSurfaceConditionCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    LiquidSurfaceStatusSurfaceConditionCode (const LiquidSurfaceStatusSurfaceConditionCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual LiquidSurfaceStatusSurfaceConditionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LiquidSurfaceStatusSurfaceConditionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_LiquidSurfaceStatusSurfaceConditionCode_convert ();
    }

    protected:
    value
    _xsd_LiquidSurfaceStatusSurfaceConditionCode_convert () const;

    public:
    static const char* const _xsd_LiquidSurfaceStatusSurfaceConditionCode_literals_[5];
    static const value _xsd_LiquidSurfaceStatusSurfaceConditionCode_indexes_[5];
  };

  class LocationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      LN,
      PT,
      SURFAC,
      UND,
      VL
    };

    LocationCategoryCode (value v);

    LocationCategoryCode (const char* v);

    LocationCategoryCode (const ::std::string& v);

    LocationCategoryCode (const ::xml_schema::token& v);

    LocationCategoryCode (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    LocationCategoryCode (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    LocationCategoryCode (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    LocationCategoryCode (const LocationCategoryCode& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual LocationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LocationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_LocationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_LocationCategoryCode_convert () const;

    public:
    static const char* const _xsd_LocationCategoryCode_literals_[5];
    static const value _xsd_LocationCategoryCode_indexes_[5];
  };

  class MainActivityCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AGRCPR,
      EDUCPR,
      FOODPR,
      HLTHPR,
      INFSPR,
      NOS,
      SOCLPR
    };

    MainActivityCode (value v);

    MainActivityCode (const char* v);

    MainActivityCode (const ::std::string& v);

    MainActivityCode (const ::xml_schema::token& v);

    MainActivityCode (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    MainActivityCode (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    MainActivityCode (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    MainActivityCode (const MainActivityCode& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual MainActivityCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MainActivityCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MainActivityCode_convert ();
    }

    protected:
    value
    _xsd_MainActivityCode_convert () const;

    public:
    static const char* const _xsd_MainActivityCode_literals_[7];
    static const value _xsd_MainActivityCode_indexes_[7];
  };

  class MaintenanceCapabilityCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CABLE,
      ELEC,
      NAVGTE,
      PLUMBN,
      PNTSHP,
      SHPWRG,
      SHTBLS,
      STEAM,
      STLFBR,
      TNKCLN
    };

    MaintenanceCapabilityCategoryCode (value v);

    MaintenanceCapabilityCategoryCode (const char* v);

    MaintenanceCapabilityCategoryCode (const ::std::string& v);

    MaintenanceCapabilityCategoryCode (const ::xml_schema::token& v);

    MaintenanceCapabilityCategoryCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MaintenanceCapabilityCategoryCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MaintenanceCapabilityCategoryCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MaintenanceCapabilityCategoryCode (const MaintenanceCapabilityCategoryCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual MaintenanceCapabilityCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaintenanceCapabilityCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaintenanceCapabilityCategoryCode_convert ();
    }

    protected:
    value
    _xsd_MaintenanceCapabilityCategoryCode_convert () const;

    public:
    static const char* const _xsd_MaintenanceCapabilityCategoryCode_literals_[10];
    static const value _xsd_MaintenanceCapabilityCategoryCode_indexes_[10];
  };

  class MaintenanceCapabilityLevelCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      A,
      B,
      C,
      D
    };

    MaintenanceCapabilityLevelCode (value v);

    MaintenanceCapabilityLevelCode (const char* v);

    MaintenanceCapabilityLevelCode (const ::std::string& v);

    MaintenanceCapabilityLevelCode (const ::xml_schema::token& v);

    MaintenanceCapabilityLevelCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    MaintenanceCapabilityLevelCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    MaintenanceCapabilityLevelCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    MaintenanceCapabilityLevelCode (const MaintenanceCapabilityLevelCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual MaintenanceCapabilityLevelCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaintenanceCapabilityLevelCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaintenanceCapabilityLevelCode_convert ();
    }

    protected:
    value
    _xsd_MaintenanceCapabilityLevelCode_convert () const;

    public:
    static const char* const _xsd_MaintenanceCapabilityLevelCode_literals_[4];
    static const value _xsd_MaintenanceCapabilityLevelCode_indexes_[4];
  };

  class MaritimeEquipmentTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ANCHOR,
      BUOY,
      CUTTER,
      DCLAUN,
      DIAPHR,
      DVERTR,
      ELCTRD,
      FLOAT,
      KITEDP,
      MECHNF,
      MRTMDV,
      NKN,
      NOS,
      OBSTRM,
      OTTER,
      PARVNE,
      PELLET,
      RADARR,
      RBBRMR,
      SONARM,
      SWEEP,
      SWELLR,
      TASVST,
      TTASVS,
      WEIGHT
    };

    MaritimeEquipmentTypeCategoryCode (value v);

    MaritimeEquipmentTypeCategoryCode (const char* v);

    MaritimeEquipmentTypeCategoryCode (const ::std::string& v);

    MaritimeEquipmentTypeCategoryCode (const ::xml_schema::token& v);

    MaritimeEquipmentTypeCategoryCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MaritimeEquipmentTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MaritimeEquipmentTypeCategoryCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MaritimeEquipmentTypeCategoryCode (const MaritimeEquipmentTypeCategoryCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual MaritimeEquipmentTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaritimeEquipmentTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaritimeEquipmentTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_MaritimeEquipmentTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_MaritimeEquipmentTypeCategoryCode_literals_[25];
    static const value _xsd_MaritimeEquipmentTypeCategoryCode_indexes_[25];
  };

  class MaritimeEquipmentTypeSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BUOYBC,
      BUOYDN,
      BUOYDP,
      BUOYDT,
      BUOYMR,
      BUOYMS,
      BUOYNV,
      BUOYPM,
      BUOYPS,
      BUOYSD,
      BUOYSS,
      CUTTEN,
      CUTTEX,
      CUTTST,
      MCDFRR,
      MCJZBR,
      NOS,
      SHF,
      SONARB,
      SONOAC,
      SONOCA,
      SONODC,
      SONOPA,
      SONRAC,
      SONRCR,
      SONRDA,
      SONRDP,
      SONRDT,
      SONRHH,
      SONRPS,
      SONRRD,
      SONRSH,
      SONRVA,
      SONRVP,
      STAFF,
      SUBTAS,
      SUBTSS,
      SUBTWA,
      SWPAAF,
      SWPACC,
      SWPACE,
      SWPACL,
      SWPACO,
      SWPHAC,
      SWPHMA,
      SWPHME,
      SWPHVA,
      SWPHVE,
      SWPHVM,
      SWPMCC,
      SWPMCN,
      SWPMCS,
      SWPMCT,
      SWPMEC,
      SWPMGA,
      SWPMGC,
      SWPMGE,
      SWPMGO,
      SWPMGS,
      SWPORO,
      SWPPRS,
      SWPPRT
    };

    MaritimeEquipmentTypeSubcategoryCode (value v);

    MaritimeEquipmentTypeSubcategoryCode (const char* v);

    MaritimeEquipmentTypeSubcategoryCode (const ::std::string& v);

    MaritimeEquipmentTypeSubcategoryCode (const ::xml_schema::token& v);

    MaritimeEquipmentTypeSubcategoryCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    MaritimeEquipmentTypeSubcategoryCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    MaritimeEquipmentTypeSubcategoryCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    MaritimeEquipmentTypeSubcategoryCode (const MaritimeEquipmentTypeSubcategoryCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual MaritimeEquipmentTypeSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaritimeEquipmentTypeSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaritimeEquipmentTypeSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_MaritimeEquipmentTypeSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_MaritimeEquipmentTypeSubcategoryCode_literals_[62];
    static const value _xsd_MaritimeEquipmentTypeSubcategoryCode_indexes_[62];
  };

  class MaterielCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ILS,
      NOS
    };

    MaterielCategoryCode (value v);

    MaterielCategoryCode (const char* v);

    MaterielCategoryCode (const ::std::string& v);

    MaterielCategoryCode (const ::xml_schema::token& v);

    MaterielCategoryCode (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    MaterielCategoryCode (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    MaterielCategoryCode (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    MaterielCategoryCode (const MaterielCategoryCode& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual MaterielCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaterielCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaterielCategoryCode_convert ();
    }

    protected:
    value
    _xsd_MaterielCategoryCode_convert () const;

    public:
    static const char* const _xsd_MaterielCategoryCode_literals_[2];
    static const value _xsd_MaterielCategoryCode_indexes_[2];
  };

  class MaterielStatusBodyColourCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AUBURN,
      BEIGE,
      BLACK,
      BLUE,
      BLUELG,
      BRONZE,
      BROWN,
      CAMDSG,
      CAMDSR,
      CAMWNT,
      CAMWOD,
      CHROME,
      COPPER,
      CREAM,
      GOLD,
      GREEN,
      GREEND,
      GREENL,
      GREY,
      LAVNDR,
      MAROON,
      MULTI,
      NKN,
      NOS,
      ORANGE,
      PURPLE,
      RED,
      RUST,
      SILVER,
      TAN,
      TURQSE,
      WHITE,
      YELLOW
    };

    MaterielStatusBodyColourCode (value v);

    MaterielStatusBodyColourCode (const char* v);

    MaterielStatusBodyColourCode (const ::std::string& v);

    MaterielStatusBodyColourCode (const ::xml_schema::token& v);

    MaterielStatusBodyColourCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    MaterielStatusBodyColourCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    MaterielStatusBodyColourCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    MaterielStatusBodyColourCode (const MaterielStatusBodyColourCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual MaterielStatusBodyColourCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaterielStatusBodyColourCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaterielStatusBodyColourCode_convert ();
    }

    protected:
    value
    _xsd_MaterielStatusBodyColourCode_convert () const;

    public:
    static const char* const _xsd_MaterielStatusBodyColourCode_literals_[33];
    static const value _xsd_MaterielStatusBodyColourCode_indexes_[33];
  };

  class MaterielStatusBuoyMalfunctionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BUOYNT,
      NOFLAG,
      NOLGHT,
      NORADR,
      SERVCE
    };

    MaterielStatusBuoyMalfunctionCode (value v);

    MaterielStatusBuoyMalfunctionCode (const char* v);

    MaterielStatusBuoyMalfunctionCode (const ::std::string& v);

    MaterielStatusBuoyMalfunctionCode (const ::xml_schema::token& v);

    MaterielStatusBuoyMalfunctionCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MaterielStatusBuoyMalfunctionCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MaterielStatusBuoyMalfunctionCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MaterielStatusBuoyMalfunctionCode (const MaterielStatusBuoyMalfunctionCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual MaterielStatusBuoyMalfunctionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaterielStatusBuoyMalfunctionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaterielStatusBuoyMalfunctionCode_convert ();
    }

    protected:
    value
    _xsd_MaterielStatusBuoyMalfunctionCode_convert () const;

    public:
    static const char* const _xsd_MaterielStatusBuoyMalfunctionCode_literals_[5];
    static const value _xsd_MaterielStatusBuoyMalfunctionCode_indexes_[5];
  };

  class MaterielStatusCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MNESTA,
      NOS,
      UXOSTA
    };

    MaterielStatusCategoryCode (value v);

    MaterielStatusCategoryCode (const char* v);

    MaterielStatusCategoryCode (const ::std::string& v);

    MaterielStatusCategoryCode (const ::xml_schema::token& v);

    MaterielStatusCategoryCode (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    MaterielStatusCategoryCode (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    MaterielStatusCategoryCode (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    MaterielStatusCategoryCode (const MaterielStatusCategoryCode& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual MaterielStatusCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaterielStatusCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaterielStatusCategoryCode_convert ();
    }

    protected:
    value
    _xsd_MaterielStatusCategoryCode_convert () const;

    public:
    static const char* const _xsd_MaterielStatusCategoryCode_literals_[3];
    static const value _xsd_MaterielStatusCategoryCode_indexes_[3];
  };

  class MaterielStatusImoCompliantIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    MaterielStatusImoCompliantIndicatorCode (value v);

    MaterielStatusImoCompliantIndicatorCode (const char* v);

    MaterielStatusImoCompliantIndicatorCode (const ::std::string& v);

    MaterielStatusImoCompliantIndicatorCode (const ::xml_schema::token& v);

    MaterielStatusImoCompliantIndicatorCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    MaterielStatusImoCompliantIndicatorCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    MaterielStatusImoCompliantIndicatorCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    MaterielStatusImoCompliantIndicatorCode (const MaterielStatusImoCompliantIndicatorCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual MaterielStatusImoCompliantIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaterielStatusImoCompliantIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaterielStatusImoCompliantIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_MaterielStatusImoCompliantIndicatorCode_convert () const;

    public:
    static const char* const _xsd_MaterielStatusImoCompliantIndicatorCode_literals_[2];
    static const value _xsd_MaterielStatusImoCompliantIndicatorCode_indexes_[2];
  };

  class MaterielStatusMarkingCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NKN,
      NOS,
      NUMBER,
      STRIPE,
      STRIPS,
      SYMBOL,
      WRITNG
    };

    MaterielStatusMarkingCode (value v);

    MaterielStatusMarkingCode (const char* v);

    MaterielStatusMarkingCode (const ::std::string& v);

    MaterielStatusMarkingCode (const ::xml_schema::token& v);

    MaterielStatusMarkingCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    MaterielStatusMarkingCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    MaterielStatusMarkingCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    MaterielStatusMarkingCode (const MaterielStatusMarkingCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual MaterielStatusMarkingCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaterielStatusMarkingCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaterielStatusMarkingCode_convert ();
    }

    protected:
    value
    _xsd_MaterielStatusMarkingCode_convert () const;

    public:
    static const char* const _xsd_MaterielStatusMarkingCode_literals_[7];
    static const value _xsd_MaterielStatusMarkingCode_indexes_[7];
  };

  class MaterielStatusMarkingColourCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BLACK,
      BLUE,
      BROWN,
      GREEN,
      GREY,
      NKN,
      NOS,
      ORANGE,
      PURPLE,
      RED,
      SILVER,
      TAN,
      WHITE,
      YELLOW
    };

    MaterielStatusMarkingColourCode (value v);

    MaterielStatusMarkingColourCode (const char* v);

    MaterielStatusMarkingColourCode (const ::std::string& v);

    MaterielStatusMarkingColourCode (const ::xml_schema::token& v);

    MaterielStatusMarkingColourCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    MaterielStatusMarkingColourCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    MaterielStatusMarkingColourCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    MaterielStatusMarkingColourCode (const MaterielStatusMarkingColourCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual MaterielStatusMarkingColourCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaterielStatusMarkingColourCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaterielStatusMarkingColourCode_convert ();
    }

    protected:
    value
    _xsd_MaterielStatusMarkingColourCode_convert () const;

    public:
    static const char* const _xsd_MaterielStatusMarkingColourCode_literals_[14];
    static const value _xsd_MaterielStatusMarkingColourCode_indexes_[14];
  };

  class MaterielStatusOperationalStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MOPS,
      NKN,
      NOP,
      OPR,
      SOPS,
      TNOPS
    };

    MaterielStatusOperationalStatusCode (value v);

    MaterielStatusOperationalStatusCode (const char* v);

    MaterielStatusOperationalStatusCode (const ::std::string& v);

    MaterielStatusOperationalStatusCode (const ::xml_schema::token& v);

    MaterielStatusOperationalStatusCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MaterielStatusOperationalStatusCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MaterielStatusOperationalStatusCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MaterielStatusOperationalStatusCode (const MaterielStatusOperationalStatusCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual MaterielStatusOperationalStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaterielStatusOperationalStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaterielStatusOperationalStatusCode_convert ();
    }

    protected:
    value
    _xsd_MaterielStatusOperationalStatusCode_convert () const;

    public:
    static const char* const _xsd_MaterielStatusOperationalStatusCode_literals_[6];
    static const value _xsd_MaterielStatusOperationalStatusCode_indexes_[6];
  };

  class MaterielStatusOperationalStatusModeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CO,
      FC,
      FMC,
      FO,
      MC,
      MF,
      MO,
      NKN
    };

    MaterielStatusOperationalStatusModeCode (value v);

    MaterielStatusOperationalStatusModeCode (const char* v);

    MaterielStatusOperationalStatusModeCode (const ::std::string& v);

    MaterielStatusOperationalStatusModeCode (const ::xml_schema::token& v);

    MaterielStatusOperationalStatusModeCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    MaterielStatusOperationalStatusModeCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    MaterielStatusOperationalStatusModeCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    MaterielStatusOperationalStatusModeCode (const MaterielStatusOperationalStatusModeCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual MaterielStatusOperationalStatusModeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaterielStatusOperationalStatusModeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaterielStatusOperationalStatusModeCode_convert ();
    }

    protected:
    value
    _xsd_MaterielStatusOperationalStatusModeCode_convert () const;

    public:
    static const char* const _xsd_MaterielStatusOperationalStatusModeCode_literals_[8];
    static const value _xsd_MaterielStatusOperationalStatusModeCode_indexes_[8];
  };

  class MaterielStatusOperationalStatusQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CLEARD,
      DENIED,
      DISASM,
      DSTRYD,
      HVYDAM,
      IMMBLS,
      INMNT,
      INTREC,
      LGTDAM,
      LST,
      LVR,
      MODDAM,
      MTHBLD,
      NKN,
      SCRPPD,
      STERLZ
    };

    MaterielStatusOperationalStatusQualifierCode (value v);

    MaterielStatusOperationalStatusQualifierCode (const char* v);

    MaterielStatusOperationalStatusQualifierCode (const ::std::string& v);

    MaterielStatusOperationalStatusQualifierCode (const ::xml_schema::token& v);

    MaterielStatusOperationalStatusQualifierCode (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    MaterielStatusOperationalStatusQualifierCode (const ::xercesc::DOMAttr& a,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    MaterielStatusOperationalStatusQualifierCode (const ::std::string& s,
                                                  const ::xercesc::DOMElement* e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    MaterielStatusOperationalStatusQualifierCode (const MaterielStatusOperationalStatusQualifierCode& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    virtual MaterielStatusOperationalStatusQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaterielStatusOperationalStatusQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaterielStatusOperationalStatusQualifierCode_convert ();
    }

    protected:
    value
    _xsd_MaterielStatusOperationalStatusQualifierCode_convert () const;

    public:
    static const char* const _xsd_MaterielStatusOperationalStatusQualifierCode_literals_[16];
    static const value _xsd_MaterielStatusOperationalStatusQualifierCode_indexes_[16];
  };

  class MaterielStatusReserveIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    MaterielStatusReserveIndicatorCode (value v);

    MaterielStatusReserveIndicatorCode (const char* v);

    MaterielStatusReserveIndicatorCode (const ::std::string& v);

    MaterielStatusReserveIndicatorCode (const ::xml_schema::token& v);

    MaterielStatusReserveIndicatorCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    MaterielStatusReserveIndicatorCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    MaterielStatusReserveIndicatorCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    MaterielStatusReserveIndicatorCode (const MaterielStatusReserveIndicatorCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual MaterielStatusReserveIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaterielStatusReserveIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaterielStatusReserveIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_MaterielStatusReserveIndicatorCode_convert () const;

    public:
    static const char* const _xsd_MaterielStatusReserveIndicatorCode_literals_[2];
    static const value _xsd_MaterielStatusReserveIndicatorCode_indexes_[2];
  };

  class MaterielStatusSafetyStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ARMED,
      NUTRLD,
      NKN,
      SAFE,
      UNASMB
    };

    MaterielStatusSafetyStatusCode (value v);

    MaterielStatusSafetyStatusCode (const char* v);

    MaterielStatusSafetyStatusCode (const ::std::string& v);

    MaterielStatusSafetyStatusCode (const ::xml_schema::token& v);

    MaterielStatusSafetyStatusCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    MaterielStatusSafetyStatusCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    MaterielStatusSafetyStatusCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    MaterielStatusSafetyStatusCode (const MaterielStatusSafetyStatusCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual MaterielStatusSafetyStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaterielStatusSafetyStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaterielStatusSafetyStatusCode_convert ();
    }

    protected:
    value
    _xsd_MaterielStatusSafetyStatusCode_convert () const;

    public:
    static const char* const _xsd_MaterielStatusSafetyStatusCode_literals_[5];
    static const value _xsd_MaterielStatusSafetyStatusCode_indexes_[5];
  };

  class MaterielTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CM,
      EQ,
      NOS
    };

    MaterielTypeCategoryCode (value v);

    MaterielTypeCategoryCode (const char* v);

    MaterielTypeCategoryCode (const ::std::string& v);

    MaterielTypeCategoryCode (const ::xml_schema::token& v);

    MaterielTypeCategoryCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    MaterielTypeCategoryCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    MaterielTypeCategoryCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    MaterielTypeCategoryCode (const MaterielTypeCategoryCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual MaterielTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaterielTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaterielTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_MaterielTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_MaterielTypeCategoryCode_literals_[3];
    static const value _xsd_MaterielTypeCategoryCode_indexes_[3];
  };

  class MaterielTypeSupplyClassCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CLS1,
      CLS2,
      CLS3,
      CLS3A,
      CLS4,
      CLS5
    };

    MaterielTypeSupplyClassCode (value v);

    MaterielTypeSupplyClassCode (const char* v);

    MaterielTypeSupplyClassCode (const ::std::string& v);

    MaterielTypeSupplyClassCode (const ::xml_schema::token& v);

    MaterielTypeSupplyClassCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    MaterielTypeSupplyClassCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    MaterielTypeSupplyClassCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    MaterielTypeSupplyClassCode (const MaterielTypeSupplyClassCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual MaterielTypeSupplyClassCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MaterielTypeSupplyClassCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MaterielTypeSupplyClassCode_convert ();
    }

    protected:
    value
    _xsd_MaterielTypeSupplyClassCode_convert () const;

    public:
    static const char* const _xsd_MaterielTypeSupplyClassCode_literals_[6];
    static const value _xsd_MaterielTypeSupplyClassCode_indexes_[6];
  };

  class MedicalFacilityStatusIntervalCasualtyTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BTLSTR,
      DISEAS,
      NONBAT,
      WOUND
    };

    MedicalFacilityStatusIntervalCasualtyTypeCode (value v);

    MedicalFacilityStatusIntervalCasualtyTypeCode (const char* v);

    MedicalFacilityStatusIntervalCasualtyTypeCode (const ::std::string& v);

    MedicalFacilityStatusIntervalCasualtyTypeCode (const ::xml_schema::token& v);

    MedicalFacilityStatusIntervalCasualtyTypeCode (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    MedicalFacilityStatusIntervalCasualtyTypeCode (const ::xercesc::DOMAttr& a,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    MedicalFacilityStatusIntervalCasualtyTypeCode (const ::std::string& s,
                                                   const ::xercesc::DOMElement* e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    MedicalFacilityStatusIntervalCasualtyTypeCode (const MedicalFacilityStatusIntervalCasualtyTypeCode& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    virtual MedicalFacilityStatusIntervalCasualtyTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MedicalFacilityStatusIntervalCasualtyTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MedicalFacilityStatusIntervalCasualtyTypeCode_convert ();
    }

    protected:
    value
    _xsd_MedicalFacilityStatusIntervalCasualtyTypeCode_convert () const;

    public:
    static const char* const _xsd_MedicalFacilityStatusIntervalCasualtyTypeCode_literals_[4];
    static const value _xsd_MedicalFacilityStatusIntervalCasualtyTypeCode_indexes_[4];
  };

  class MedicalFacilityStatusPendingSurgeryTriageCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      T1,
      T2,
      T3
    };

    MedicalFacilityStatusPendingSurgeryTriageCode (value v);

    MedicalFacilityStatusPendingSurgeryTriageCode (const char* v);

    MedicalFacilityStatusPendingSurgeryTriageCode (const ::std::string& v);

    MedicalFacilityStatusPendingSurgeryTriageCode (const ::xml_schema::token& v);

    MedicalFacilityStatusPendingSurgeryTriageCode (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    MedicalFacilityStatusPendingSurgeryTriageCode (const ::xercesc::DOMAttr& a,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    MedicalFacilityStatusPendingSurgeryTriageCode (const ::std::string& s,
                                                   const ::xercesc::DOMElement* e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    MedicalFacilityStatusPendingSurgeryTriageCode (const MedicalFacilityStatusPendingSurgeryTriageCode& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    virtual MedicalFacilityStatusPendingSurgeryTriageCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MedicalFacilityStatusPendingSurgeryTriageCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MedicalFacilityStatusPendingSurgeryTriageCode_convert ();
    }

    protected:
    value
    _xsd_MedicalFacilityStatusPendingSurgeryTriageCode_convert () const;

    public:
    static const char* const _xsd_MedicalFacilityStatusPendingSurgeryTriageCode_literals_[3];
    static const value _xsd_MedicalFacilityStatusPendingSurgeryTriageCode_indexes_[3];
  };

  class MeteorologicFeatureCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ATMOS,
      COVER,
      CYCL,
      FNLCLD,
      HURR,
      ICING,
      JTSTRM,
      LGTNNG,
      LIGHT,
      NOS,
      PRECIP,
      STORM,
      THST,
      THSTRN,
      TORN,
      TRST,
      TYPH,
      VISIB,
      WHIR,
      WIND,
      WTRSPT
    };

    MeteorologicFeatureCategoryCode (value v);

    MeteorologicFeatureCategoryCode (const char* v);

    MeteorologicFeatureCategoryCode (const ::std::string& v);

    MeteorologicFeatureCategoryCode (const ::xml_schema::token& v);

    MeteorologicFeatureCategoryCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    MeteorologicFeatureCategoryCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    MeteorologicFeatureCategoryCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    MeteorologicFeatureCategoryCode (const MeteorologicFeatureCategoryCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual MeteorologicFeatureCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MeteorologicFeatureCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MeteorologicFeatureCategoryCode_convert ();
    }

    protected:
    value
    _xsd_MeteorologicFeatureCategoryCode_convert () const;

    public:
    static const char* const _xsd_MeteorologicFeatureCategoryCode_literals_[21];
    static const value _xsd_MeteorologicFeatureCategoryCode_indexes_[21];
  };

  class MeteorologicFeatureInterpretationCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ABMAX,
      ABMIN,
      AVMAX,
      AVMIN,
      NOMIN
    };

    MeteorologicFeatureInterpretationCode (value v);

    MeteorologicFeatureInterpretationCode (const char* v);

    MeteorologicFeatureInterpretationCode (const ::std::string& v);

    MeteorologicFeatureInterpretationCode (const ::xml_schema::token& v);

    MeteorologicFeatureInterpretationCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    MeteorologicFeatureInterpretationCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    MeteorologicFeatureInterpretationCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    MeteorologicFeatureInterpretationCode (const MeteorologicFeatureInterpretationCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual MeteorologicFeatureInterpretationCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MeteorologicFeatureInterpretationCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MeteorologicFeatureInterpretationCode_convert ();
    }

    protected:
    value
    _xsd_MeteorologicFeatureInterpretationCode_convert () const;

    public:
    static const char* const _xsd_MeteorologicFeatureInterpretationCode_literals_[5];
    static const value _xsd_MeteorologicFeatureInterpretationCode_indexes_[5];
  };

  class MeteorologicFeatureSourceCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FOR,
      OBSRVD
    };

    MeteorologicFeatureSourceCode (value v);

    MeteorologicFeatureSourceCode (const char* v);

    MeteorologicFeatureSourceCode (const ::std::string& v);

    MeteorologicFeatureSourceCode (const ::xml_schema::token& v);

    MeteorologicFeatureSourceCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    MeteorologicFeatureSourceCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    MeteorologicFeatureSourceCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    MeteorologicFeatureSourceCode (const MeteorologicFeatureSourceCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual MeteorologicFeatureSourceCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MeteorologicFeatureSourceCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MeteorologicFeatureSourceCode_convert ();
    }

    protected:
    value
    _xsd_MeteorologicFeatureSourceCode_convert () const;

    public:
    static const char* const _xsd_MeteorologicFeatureSourceCode_literals_[2];
    static const value _xsd_MeteorologicFeatureSourceCode_indexes_[2];
  };

  class MilitaryObstacleCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MNFLD,
      NOS
    };

    MilitaryObstacleCategoryCode (value v);

    MilitaryObstacleCategoryCode (const char* v);

    MilitaryObstacleCategoryCode (const ::std::string& v);

    MilitaryObstacleCategoryCode (const ::xml_schema::token& v);

    MilitaryObstacleCategoryCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    MilitaryObstacleCategoryCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    MilitaryObstacleCategoryCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    MilitaryObstacleCategoryCode (const MilitaryObstacleCategoryCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual MilitaryObstacleCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MilitaryObstacleCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MilitaryObstacleCategoryCode_convert ();
    }

    protected:
    value
    _xsd_MilitaryObstacleCategoryCode_convert () const;

    public:
    static const char* const _xsd_MilitaryObstacleCategoryCode_literals_[2];
    static const value _xsd_MilitaryObstacleCategoryCode_indexes_[2];
  };

  class MilitaryObstacleTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ABATIS,
      ANTOBS,
      ANTWAL,
      ATDTCH,
      BARBEN,
      BARVEH,
      BPSOBS,
      CRATER,
      DCHNOS,
      DGT,
      DMDBRS,
      FBKOBS,
      MINEAP,
      MINEAT,
      MINEFD,
      MINEMX,
      MNFLLA,
      MNFLMA,
      NOS,
      ROADBL,
      TRPWIR,
      TTRHDN,
      WALL,
      WIRAFN,
      WIRDCN,
      WIRDFN,
      WIRHFN,
      WIRLFN,
      WIRNOS,
      WIRSCN,
      WIRSFN,
      WIRTCN
    };

    MilitaryObstacleTypeCategoryCode (value v);

    MilitaryObstacleTypeCategoryCode (const char* v);

    MilitaryObstacleTypeCategoryCode (const ::std::string& v);

    MilitaryObstacleTypeCategoryCode (const ::xml_schema::token& v);

    MilitaryObstacleTypeCategoryCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    MilitaryObstacleTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    MilitaryObstacleTypeCategoryCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    MilitaryObstacleTypeCategoryCode (const MilitaryObstacleTypeCategoryCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual MilitaryObstacleTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MilitaryObstacleTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MilitaryObstacleTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_MilitaryObstacleTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_MilitaryObstacleTypeCategoryCode_literals_[32];
    static const value _xsd_MilitaryObstacleTypeCategoryCode_indexes_[32];
  };

  class MilitaryObstacleTypeSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FXAMOV,
      MOVABL,
      MOVAPR
    };

    MilitaryObstacleTypeSubcategoryCode (value v);

    MilitaryObstacleTypeSubcategoryCode (const char* v);

    MilitaryObstacleTypeSubcategoryCode (const ::std::string& v);

    MilitaryObstacleTypeSubcategoryCode (const ::xml_schema::token& v);

    MilitaryObstacleTypeSubcategoryCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MilitaryObstacleTypeSubcategoryCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MilitaryObstacleTypeSubcategoryCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MilitaryObstacleTypeSubcategoryCode (const MilitaryObstacleTypeSubcategoryCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual MilitaryObstacleTypeSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MilitaryObstacleTypeSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MilitaryObstacleTypeSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_MilitaryObstacleTypeSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_MilitaryObstacleTypeSubcategoryCode_literals_[3];
    static const value _xsd_MilitaryObstacleTypeSubcategoryCode_indexes_[3];
  };

  class MilitaryOrganisationTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      EXCMIL,
      MILPST,
      NOS,
      TASK,
      UNIT
    };

    MilitaryOrganisationTypeCategoryCode (value v);

    MilitaryOrganisationTypeCategoryCode (const char* v);

    MilitaryOrganisationTypeCategoryCode (const ::std::string& v);

    MilitaryOrganisationTypeCategoryCode (const ::xml_schema::token& v);

    MilitaryOrganisationTypeCategoryCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    MilitaryOrganisationTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    MilitaryOrganisationTypeCategoryCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    MilitaryOrganisationTypeCategoryCode (const MilitaryOrganisationTypeCategoryCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual MilitaryOrganisationTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MilitaryOrganisationTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MilitaryOrganisationTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_MilitaryOrganisationTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_MilitaryOrganisationTypeCategoryCode_literals_[5];
    static const value _xsd_MilitaryOrganisationTypeCategoryCode_indexes_[5];
  };

  class MilitaryOrganisationTypeServiceCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIRFRC,
      ARMY,
      BRDRGD,
      COASTG,
      COMBND,
      CVLSVC,
      GUERLL,
      JOINT,
      LCLDFF,
      LCLMLT,
      MARINE,
      NAVY,
      NKN,
      NOS,
      PAR,
      SPFRC,
      TERFRC
    };

    MilitaryOrganisationTypeServiceCode (value v);

    MilitaryOrganisationTypeServiceCode (const char* v);

    MilitaryOrganisationTypeServiceCode (const ::std::string& v);

    MilitaryOrganisationTypeServiceCode (const ::xml_schema::token& v);

    MilitaryOrganisationTypeServiceCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MilitaryOrganisationTypeServiceCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MilitaryOrganisationTypeServiceCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MilitaryOrganisationTypeServiceCode (const MilitaryOrganisationTypeServiceCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual MilitaryOrganisationTypeServiceCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MilitaryOrganisationTypeServiceCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MilitaryOrganisationTypeServiceCode_convert ();
    }

    protected:
    value
    _xsd_MilitaryOrganisationTypeServiceCode_convert () const;

    public:
    static const char* const _xsd_MilitaryOrganisationTypeServiceCode_literals_[17];
    static const value _xsd_MilitaryOrganisationTypeServiceCode_indexes_[17];
  };

  class MilitaryPostTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AHLCDR,
      AIRLSN,
      AJAATC,
      ANSPHY,
      APAUTH,
      ARBNMC,
      ASCAIR,
      AUTCDR,
      DNTPHY,
      FAC,
      FACAIR,
      FOOAOP,
      GMCDR,
      GUNNER,
      GYNPHY,
      HDNPHY,
      INMPHY,
      INTOFF,
      JAATC,
      LIAISN,
      MANTCH,
      MCKNET,
      NOS,
      OPSOFF,
      ORTPHY,
      OTHPHY,
      POC,
      PRCPHY,
      PSYPHY,
      PTHPHY,
      RADPHY,
      RFLEMN,
      SAPPER,
      SCOUT,
      SNIPER,
      SURPHY,
      TAC,
      TACAIR
    };

    MilitaryPostTypeCategoryCode (value v);

    MilitaryPostTypeCategoryCode (const char* v);

    MilitaryPostTypeCategoryCode (const ::std::string& v);

    MilitaryPostTypeCategoryCode (const ::xml_schema::token& v);

    MilitaryPostTypeCategoryCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    MilitaryPostTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    MilitaryPostTypeCategoryCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    MilitaryPostTypeCategoryCode (const MilitaryPostTypeCategoryCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual MilitaryPostTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MilitaryPostTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MilitaryPostTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_MilitaryPostTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_MilitaryPostTypeCategoryCode_literals_[38];
    static const value _xsd_MilitaryPostTypeCategoryCode_indexes_[38];
  };

  class MilitaryPostTypeRankCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      EPTE,
      NCO,
      NKN,
      OF1,
      OF10,
      OF2,
      OF3,
      OF4,
      OF5,
      OF6,
      OF7,
      OF8,
      OF9,
      OFFR,
      OR1,
      OR2,
      OR3,
      OR4,
      OR5,
      OR6,
      OR7,
      OR8,
      OR9,
      OTHR
    };

    MilitaryPostTypeRankCode (value v);

    MilitaryPostTypeRankCode (const char* v);

    MilitaryPostTypeRankCode (const ::std::string& v);

    MilitaryPostTypeRankCode (const ::xml_schema::token& v);

    MilitaryPostTypeRankCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    MilitaryPostTypeRankCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    MilitaryPostTypeRankCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    MilitaryPostTypeRankCode (const MilitaryPostTypeRankCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual MilitaryPostTypeRankCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MilitaryPostTypeRankCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MilitaryPostTypeRankCode_convert ();
    }

    protected:
    value
    _xsd_MilitaryPostTypeRankCode_convert () const;

    public:
    static const char* const _xsd_MilitaryPostTypeRankCode_literals_[24];
    static const value _xsd_MilitaryPostTypeRankCode_indexes_[24];
  };

  class MinePresenceCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NKN,
      NO,
      YES
    };

    MinePresenceCode (value v);

    MinePresenceCode (const char* v);

    MinePresenceCode (const ::std::string& v);

    MinePresenceCode (const ::xml_schema::token& v);

    MinePresenceCode (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    MinePresenceCode (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    MinePresenceCode (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    MinePresenceCode (const MinePresenceCode& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual MinePresenceCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinePresenceCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinePresenceCode_convert ();
    }

    protected:
    value
    _xsd_MinePresenceCode_convert () const;

    public:
    static const char* const _xsd_MinePresenceCode_literals_[3];
    static const value _xsd_MinePresenceCode_indexes_[3];
  };

  class MineStatusAirDropEffectCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ARMMAL,
      ARMMBU,
      ARMMS,
      ARMMSB,
      NORMAL,
      PARAM,
      PARAMB,
      PARAMS,
      PARMAL,
      PARMBU,
      PARMS,
      SKIP,
      SKIPBU,
      UNK
    };

    MineStatusAirDropEffectCode (value v);

    MineStatusAirDropEffectCode (const char* v);

    MineStatusAirDropEffectCode (const ::std::string& v);

    MineStatusAirDropEffectCode (const ::xml_schema::token& v);

    MineStatusAirDropEffectCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    MineStatusAirDropEffectCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    MineStatusAirDropEffectCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    MineStatusAirDropEffectCode (const MineStatusAirDropEffectCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual MineStatusAirDropEffectCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MineStatusAirDropEffectCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MineStatusAirDropEffectCode_convert ();
    }

    protected:
    value
    _xsd_MineStatusAirDropEffectCode_convert () const;

    public:
    static const char* const _xsd_MineStatusAirDropEffectCode_literals_[14];
    static const value _xsd_MineStatusAirDropEffectCode_indexes_[14];
  };

  class MineStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ACTVED,
      CLSSFD,
      CNTRMN,
      IDNTMN,
      MNLFPL,
      MRKDMN,
      NEUTRL,
      RECVRD,
      REMOVD,
      RNDERD,
      SUNKMN
    };

    MineStatusCode (value v);

    MineStatusCode (const char* v);

    MineStatusCode (const ::std::string& v);

    MineStatusCode (const ::xml_schema::token& v);

    MineStatusCode (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    MineStatusCode (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    MineStatusCode (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    MineStatusCode (const MineStatusCode& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual MineStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MineStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MineStatusCode_convert ();
    }

    protected:
    value
    _xsd_MineStatusCode_convert () const;

    public:
    static const char* const _xsd_MineStatusCode_literals_[11];
    static const value _xsd_MineStatusCode_indexes_[11];
  };

  class MineStatusMaritimeMineQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CNTMND,
      DISPSD,
      EXPLLS,
      EXPLRS,
      FLOATN,
      FOULED,
      NEUTRL,
      NOTDLT,
      RECVRD,
      REMOVD,
      RNDRSF,
      SUNKEN
    };

    MineStatusMaritimeMineQualifierCode (value v);

    MineStatusMaritimeMineQualifierCode (const char* v);

    MineStatusMaritimeMineQualifierCode (const ::std::string& v);

    MineStatusMaritimeMineQualifierCode (const ::xml_schema::token& v);

    MineStatusMaritimeMineQualifierCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MineStatusMaritimeMineQualifierCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MineStatusMaritimeMineQualifierCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MineStatusMaritimeMineQualifierCode (const MineStatusMaritimeMineQualifierCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual MineStatusMaritimeMineQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MineStatusMaritimeMineQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MineStatusMaritimeMineQualifierCode_convert ();
    }

    protected:
    value
    _xsd_MineStatusMaritimeMineQualifierCode_convert () const;

    public:
    static const char* const _xsd_MineStatusMaritimeMineQualifierCode_literals_[12];
    static const value _xsd_MineStatusMaritimeMineQualifierCode_indexes_[12];
  };

  class MinefieldCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MNFLND,
      MNFMRT
    };

    MinefieldCategoryCode (value v);

    MinefieldCategoryCode (const char* v);

    MinefieldCategoryCode (const ::std::string& v);

    MinefieldCategoryCode (const ::xml_schema::token& v);

    MinefieldCategoryCode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    MinefieldCategoryCode (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    MinefieldCategoryCode (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    MinefieldCategoryCode (const MinefieldCategoryCode& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual MinefieldCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldCategoryCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldCategoryCode_convert () const;

    public:
    static const char* const _xsd_MinefieldCategoryCode_literals_[2];
    static const value _xsd_MinefieldCategoryCode_indexes_[2];
  };

  class MinefieldLandDepthPlacementCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MIXED,
      NKN,
      SUBSRF,
      SURFCE
    };

    MinefieldLandDepthPlacementCode (value v);

    MinefieldLandDepthPlacementCode (const char* v);

    MinefieldLandDepthPlacementCode (const ::std::string& v);

    MinefieldLandDepthPlacementCode (const ::xml_schema::token& v);

    MinefieldLandDepthPlacementCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    MinefieldLandDepthPlacementCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    MinefieldLandDepthPlacementCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    MinefieldLandDepthPlacementCode (const MinefieldLandDepthPlacementCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual MinefieldLandDepthPlacementCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldLandDepthPlacementCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldLandDepthPlacementCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldLandDepthPlacementCode_convert () const;

    public:
    static const char* const _xsd_MinefieldLandDepthPlacementCode_literals_[4];
    static const value _xsd_MinefieldLandDepthPlacementCode_indexes_[4];
  };

  class MinefieldLandFunctionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HTACT,
      LTACT,
      MTACT,
      NUISNC,
      PHONEY,
      PROTCT
    };

    MinefieldLandFunctionCode (value v);

    MinefieldLandFunctionCode (const char* v);

    MinefieldLandFunctionCode (const ::std::string& v);

    MinefieldLandFunctionCode (const ::xml_schema::token& v);

    MinefieldLandFunctionCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    MinefieldLandFunctionCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    MinefieldLandFunctionCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    MinefieldLandFunctionCode (const MinefieldLandFunctionCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual MinefieldLandFunctionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldLandFunctionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldLandFunctionCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldLandFunctionCode_convert () const;

    public:
    static const char* const _xsd_MinefieldLandFunctionCode_literals_[6];
    static const value _xsd_MinefieldLandFunctionCode_indexes_[6];
  };

  class MinefieldLandPatternCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NKN,
      REGMNF,
      REGTHK,
      SCATTR
    };

    MinefieldLandPatternCode (value v);

    MinefieldLandPatternCode (const char* v);

    MinefieldLandPatternCode (const ::std::string& v);

    MinefieldLandPatternCode (const ::xml_schema::token& v);

    MinefieldLandPatternCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    MinefieldLandPatternCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    MinefieldLandPatternCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    MinefieldLandPatternCode (const MinefieldLandPatternCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual MinefieldLandPatternCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldLandPatternCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldLandPatternCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldLandPatternCode_convert () const;

    public:
    static const char* const _xsd_MinefieldLandPatternCode_literals_[4];
    static const value _xsd_MinefieldLandPatternCode_indexes_[4];
  };

  class MinefieldLandPersistenceCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NKN,
      PERMAN,
      REMOTE,
      SLFDST
    };

    MinefieldLandPersistenceCode (value v);

    MinefieldLandPersistenceCode (const char* v);

    MinefieldLandPersistenceCode (const ::std::string& v);

    MinefieldLandPersistenceCode (const ::xml_schema::token& v);

    MinefieldLandPersistenceCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    MinefieldLandPersistenceCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    MinefieldLandPersistenceCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    MinefieldLandPersistenceCode (const MinefieldLandPersistenceCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual MinefieldLandPersistenceCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldLandPersistenceCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldLandPersistenceCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldLandPersistenceCode_convert () const;

    public:
    static const char* const _xsd_MinefieldLandPersistenceCode_literals_[4];
    static const value _xsd_MinefieldLandPersistenceCode_indexes_[4];
  };

  class MinefieldLandStoppingPowerCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HIGH,
      LOW,
      MEDIUM
    };

    MinefieldLandStoppingPowerCode (value v);

    MinefieldLandStoppingPowerCode (const char* v);

    MinefieldLandStoppingPowerCode (const ::std::string& v);

    MinefieldLandStoppingPowerCode (const ::xml_schema::token& v);

    MinefieldLandStoppingPowerCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    MinefieldLandStoppingPowerCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    MinefieldLandStoppingPowerCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    MinefieldLandStoppingPowerCode (const MinefieldLandStoppingPowerCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual MinefieldLandStoppingPowerCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldLandStoppingPowerCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldLandStoppingPowerCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldLandStoppingPowerCode_convert () const;

    public:
    static const char* const _xsd_MinefieldLandStoppingPowerCode_literals_[3];
    static const value _xsd_MinefieldLandStoppingPowerCode_indexes_[3];
  };

  class MinefieldMaritimeBottomNaturalCamouflageCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BTMCVR,
      BTMDEP,
      IRREGL,
      NOS,
      RGHBTM,
      RTHRST,
      SFTBTM,
      STBSMT
    };

    MinefieldMaritimeBottomNaturalCamouflageCode (value v);

    MinefieldMaritimeBottomNaturalCamouflageCode (const char* v);

    MinefieldMaritimeBottomNaturalCamouflageCode (const ::std::string& v);

    MinefieldMaritimeBottomNaturalCamouflageCode (const ::xml_schema::token& v);

    MinefieldMaritimeBottomNaturalCamouflageCode (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    MinefieldMaritimeBottomNaturalCamouflageCode (const ::xercesc::DOMAttr& a,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    MinefieldMaritimeBottomNaturalCamouflageCode (const ::std::string& s,
                                                  const ::xercesc::DOMElement* e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    MinefieldMaritimeBottomNaturalCamouflageCode (const MinefieldMaritimeBottomNaturalCamouflageCode& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    virtual MinefieldMaritimeBottomNaturalCamouflageCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldMaritimeBottomNaturalCamouflageCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldMaritimeBottomNaturalCamouflageCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldMaritimeBottomNaturalCamouflageCode_convert () const;

    public:
    static const char* const _xsd_MinefieldMaritimeBottomNaturalCamouflageCode_literals_[8];
    static const value _xsd_MinefieldMaritimeBottomNaturalCamouflageCode_indexes_[8];
  };

  class MinefieldMaritimeDepthPlacementCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BOTTOM,
      NKN,
      SEASUR,
      SURFZN,
      VOLUME
    };

    MinefieldMaritimeDepthPlacementCode (value v);

    MinefieldMaritimeDepthPlacementCode (const char* v);

    MinefieldMaritimeDepthPlacementCode (const ::std::string& v);

    MinefieldMaritimeDepthPlacementCode (const ::xml_schema::token& v);

    MinefieldMaritimeDepthPlacementCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MinefieldMaritimeDepthPlacementCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MinefieldMaritimeDepthPlacementCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    MinefieldMaritimeDepthPlacementCode (const MinefieldMaritimeDepthPlacementCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual MinefieldMaritimeDepthPlacementCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldMaritimeDepthPlacementCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldMaritimeDepthPlacementCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldMaritimeDepthPlacementCode_convert () const;

    public:
    static const char* const _xsd_MinefieldMaritimeDepthPlacementCode_literals_[5];
    static const value _xsd_MinefieldMaritimeDepthPlacementCode_indexes_[5];
  };

  class MinefieldMaritimeFunctionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DEFSV,
      OFFSV,
      PROTCT
    };

    MinefieldMaritimeFunctionCode (value v);

    MinefieldMaritimeFunctionCode (const char* v);

    MinefieldMaritimeFunctionCode (const ::std::string& v);

    MinefieldMaritimeFunctionCode (const ::xml_schema::token& v);

    MinefieldMaritimeFunctionCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    MinefieldMaritimeFunctionCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    MinefieldMaritimeFunctionCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    MinefieldMaritimeFunctionCode (const MinefieldMaritimeFunctionCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual MinefieldMaritimeFunctionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldMaritimeFunctionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldMaritimeFunctionCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldMaritimeFunctionCode_convert () const;

    public:
    static const char* const _xsd_MinefieldMaritimeFunctionCode_literals_[3];
    static const value _xsd_MinefieldMaritimeFunctionCode_indexes_[3];
  };

  class MinefieldMaritimeStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CLOSED,
      OPEN
    };

    MinefieldMaritimeStatusCode (value v);

    MinefieldMaritimeStatusCode (const char* v);

    MinefieldMaritimeStatusCode (const ::std::string& v);

    MinefieldMaritimeStatusCode (const ::xml_schema::token& v);

    MinefieldMaritimeStatusCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusCode (const MinefieldMaritimeStatusCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual MinefieldMaritimeStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldMaritimeStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldMaritimeStatusCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldMaritimeStatusCode_convert () const;

    public:
    static const char* const _xsd_MinefieldMaritimeStatusCode_literals_[2];
    static const value _xsd_MinefieldMaritimeStatusCode_indexes_[2];
  };

  class MinefieldMaritimeStatusColourCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      GREEN,
      RED,
      YELLOW
    };

    MinefieldMaritimeStatusColourCode (value v);

    MinefieldMaritimeStatusColourCode (const char* v);

    MinefieldMaritimeStatusColourCode (const ::std::string& v);

    MinefieldMaritimeStatusColourCode (const ::xml_schema::token& v);

    MinefieldMaritimeStatusColourCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusColourCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusColourCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusColourCode (const MinefieldMaritimeStatusColourCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual MinefieldMaritimeStatusColourCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldMaritimeStatusColourCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldMaritimeStatusColourCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldMaritimeStatusColourCode_convert () const;

    public:
    static const char* const _xsd_MinefieldMaritimeStatusColourCode_literals_[3];
    static const value _xsd_MinefieldMaritimeStatusColourCode_indexes_[3];
  };

  class MinefieldMaritimeStatusExpectedLevelMcmCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HVYMCM,
      LGTMCM,
      MODMCM,
      NOMCM
    };

    MinefieldMaritimeStatusExpectedLevelMcmCode (value v);

    MinefieldMaritimeStatusExpectedLevelMcmCode (const char* v);

    MinefieldMaritimeStatusExpectedLevelMcmCode (const ::std::string& v);

    MinefieldMaritimeStatusExpectedLevelMcmCode (const ::xml_schema::token& v);

    MinefieldMaritimeStatusExpectedLevelMcmCode (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusExpectedLevelMcmCode (const ::xercesc::DOMAttr& a,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusExpectedLevelMcmCode (const ::std::string& s,
                                                 const ::xercesc::DOMElement* e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusExpectedLevelMcmCode (const MinefieldMaritimeStatusExpectedLevelMcmCode& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual MinefieldMaritimeStatusExpectedLevelMcmCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldMaritimeStatusExpectedLevelMcmCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldMaritimeStatusExpectedLevelMcmCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldMaritimeStatusExpectedLevelMcmCode_convert () const;

    public:
    static const char* const _xsd_MinefieldMaritimeStatusExpectedLevelMcmCode_literals_[4];
    static const value _xsd_MinefieldMaritimeStatusExpectedLevelMcmCode_indexes_[4];
  };

  class MinefieldMaritimeStatusMineDetectionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      SGHTD,
      SWACAF,
      SWACCO,
      SWACEX,
      SWACIN,
      SWACLF,
      SWBTTS,
      SWCRSS,
      SWDVNG,
      SWENWS,
      SWJASS,
      SWMACL,
      SWMAIN,
      SWMEAN,
      SWMECH,
      SWMECN,
      SWMEEL,
      SWMENE,
      SWMEOL,
      SWMEOR,
      SWMESN,
      SWMESO,
      SWMETE,
      SWPRGS,
      SWRNJS,
      SWSNSE,
      SWTWFD,
      SWUNDS
    };

    MinefieldMaritimeStatusMineDetectionCode (value v);

    MinefieldMaritimeStatusMineDetectionCode (const char* v);

    MinefieldMaritimeStatusMineDetectionCode (const ::std::string& v);

    MinefieldMaritimeStatusMineDetectionCode (const ::xml_schema::token& v);

    MinefieldMaritimeStatusMineDetectionCode (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusMineDetectionCode (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusMineDetectionCode (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusMineDetectionCode (const MinefieldMaritimeStatusMineDetectionCode& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual MinefieldMaritimeStatusMineDetectionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldMaritimeStatusMineDetectionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldMaritimeStatusMineDetectionCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldMaritimeStatusMineDetectionCode_convert () const;

    public:
    static const char* const _xsd_MinefieldMaritimeStatusMineDetectionCode_literals_[28];
    static const value _xsd_MinefieldMaritimeStatusMineDetectionCode_indexes_[28];
  };

  class MinefieldMaritimeStatusMineZoneRiskCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      LITTLE,
      SERIOS,
      VRYGRT
    };

    MinefieldMaritimeStatusMineZoneRiskCode (value v);

    MinefieldMaritimeStatusMineZoneRiskCode (const char* v);

    MinefieldMaritimeStatusMineZoneRiskCode (const ::std::string& v);

    MinefieldMaritimeStatusMineZoneRiskCode (const ::xml_schema::token& v);

    MinefieldMaritimeStatusMineZoneRiskCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusMineZoneRiskCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusMineZoneRiskCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusMineZoneRiskCode (const MinefieldMaritimeStatusMineZoneRiskCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual MinefieldMaritimeStatusMineZoneRiskCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldMaritimeStatusMineZoneRiskCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldMaritimeStatusMineZoneRiskCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldMaritimeStatusMineZoneRiskCode_convert () const;

    public:
    static const char* const _xsd_MinefieldMaritimeStatusMineZoneRiskCode_literals_[3];
    static const value _xsd_MinefieldMaritimeStatusMineZoneRiskCode_indexes_[3];
  };

  class MinefieldMaritimeStatusSeedingCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      EIGHTH,
      FIFTH,
      FIRST,
      FOURTH,
      INITAL,
      NINTH,
      SECOND,
      SEVNTH,
      SIXTH,
      THIRD
    };

    MinefieldMaritimeStatusSeedingCode (value v);

    MinefieldMaritimeStatusSeedingCode (const char* v);

    MinefieldMaritimeStatusSeedingCode (const ::std::string& v);

    MinefieldMaritimeStatusSeedingCode (const ::xml_schema::token& v);

    MinefieldMaritimeStatusSeedingCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusSeedingCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusSeedingCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    MinefieldMaritimeStatusSeedingCode (const MinefieldMaritimeStatusSeedingCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual MinefieldMaritimeStatusSeedingCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldMaritimeStatusSeedingCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldMaritimeStatusSeedingCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldMaritimeStatusSeedingCode_convert () const;

    public:
    static const char* const _xsd_MinefieldMaritimeStatusSeedingCode_literals_[10];
    static const value _xsd_MinefieldMaritimeStatusSeedingCode_indexes_[10];
  };

  class MinefieldMaritimeSubfunctionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ANTINV,
      ANTPSG,
      ANTSHP,
      ATTRIT,
      BLCKDE,
      DELAY,
      HARASS,
      NOS,
      PRTCLS,
      STRCLS
    };

    MinefieldMaritimeSubfunctionCode (value v);

    MinefieldMaritimeSubfunctionCode (const char* v);

    MinefieldMaritimeSubfunctionCode (const ::std::string& v);

    MinefieldMaritimeSubfunctionCode (const ::xml_schema::token& v);

    MinefieldMaritimeSubfunctionCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    MinefieldMaritimeSubfunctionCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    MinefieldMaritimeSubfunctionCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    MinefieldMaritimeSubfunctionCode (const MinefieldMaritimeSubfunctionCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual MinefieldMaritimeSubfunctionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinefieldMaritimeSubfunctionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MinefieldMaritimeSubfunctionCode_convert ();
    }

    protected:
    value
    _xsd_MinefieldMaritimeSubfunctionCode_convert () const;

    public:
    static const char* const _xsd_MinefieldMaritimeSubfunctionCode_literals_[10];
    static const value _xsd_MinefieldMaritimeSubfunctionCode_indexes_[10];
  };

  class MiscellaneousEquipmentTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIRCMP,
      AIRREF,
      AROBSL,
      BCNLGT,
      BOTTLE,
      CABLE,
      CABLER,
      CNTDLS,
      CONTNR,
      DECOY,
      DEMOEQ,
      DSPNSR,
      ELCMED,
      FILM,
      FLAG,
      GENER,
      GUIDNC,
      HAZLGT,
      LAMP,
      LAPSE,
      LINE,
      MAGTPE,
      MARKER,
      MCHNRY,
      MEGPHN,
      NKN,
      NOS,
      PAPER,
      PHOTOG,
      PRTMAC,
      ROPE,
      SIGLGT,
      SMKGEN,
      SRCHLT,
      TANK
    };

    MiscellaneousEquipmentTypeCategoryCode (value v);

    MiscellaneousEquipmentTypeCategoryCode (const char* v);

    MiscellaneousEquipmentTypeCategoryCode (const ::std::string& v);

    MiscellaneousEquipmentTypeCategoryCode (const ::xml_schema::token& v);

    MiscellaneousEquipmentTypeCategoryCode (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    MiscellaneousEquipmentTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    MiscellaneousEquipmentTypeCategoryCode (const ::std::string& s,
                                            const ::xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    MiscellaneousEquipmentTypeCategoryCode (const MiscellaneousEquipmentTypeCategoryCode& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual MiscellaneousEquipmentTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MiscellaneousEquipmentTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MiscellaneousEquipmentTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_MiscellaneousEquipmentTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_MiscellaneousEquipmentTypeCategoryCode_literals_[35];
    static const value _xsd_MiscellaneousEquipmentTypeCategoryCode_indexes_[35];
  };

  class MiscellaneousEquipmentTypeSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BCD,
      BCDW,
      BOOM,
      BWD,
      CD,
      CDWD,
      WD
    };

    MiscellaneousEquipmentTypeSubcategoryCode (value v);

    MiscellaneousEquipmentTypeSubcategoryCode (const char* v);

    MiscellaneousEquipmentTypeSubcategoryCode (const ::std::string& v);

    MiscellaneousEquipmentTypeSubcategoryCode (const ::xml_schema::token& v);

    MiscellaneousEquipmentTypeSubcategoryCode (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    MiscellaneousEquipmentTypeSubcategoryCode (const ::xercesc::DOMAttr& a,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    MiscellaneousEquipmentTypeSubcategoryCode (const ::std::string& s,
                                               const ::xercesc::DOMElement* e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    MiscellaneousEquipmentTypeSubcategoryCode (const MiscellaneousEquipmentTypeSubcategoryCode& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual MiscellaneousEquipmentTypeSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MiscellaneousEquipmentTypeSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MiscellaneousEquipmentTypeSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_MiscellaneousEquipmentTypeSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_MiscellaneousEquipmentTypeSubcategoryCode_literals_[7];
    static const value _xsd_MiscellaneousEquipmentTypeSubcategoryCode_indexes_[7];
  };

  class MissionPrimacyCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      PRIME,
      SCNDRY,
      THIRD
    };

    MissionPrimacyCode (value v);

    MissionPrimacyCode (const char* v);

    MissionPrimacyCode (const ::std::string& v);

    MissionPrimacyCode (const ::xml_schema::token& v);

    MissionPrimacyCode (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    MissionPrimacyCode (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    MissionPrimacyCode (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    MissionPrimacyCode (const MissionPrimacyCode& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual MissionPrimacyCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MissionPrimacyCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MissionPrimacyCode_convert ();
    }

    protected:
    value
    _xsd_MissionPrimacyCode_convert () const;

    public:
    static const char* const _xsd_MissionPrimacyCode_literals_[3];
    static const value _xsd_MissionPrimacyCode_indexes_[3];
  };

  class MobilityCapabilityCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIRBRN,
      AIRCMP,
      AIRFW,
      AIRLGT,
      AIRRW,
      AMPH,
      ANIMNT,
      ARCTIC,
      DSMNTD,
      LNDRAI,
      LNDSPP,
      LNDTRC,
      LNDTWD,
      LNDWHL,
      MLC,
      ROADMR,
      SELFDP,
      WATBAY,
      WATCNL,
      WATCRK,
      WATFJR,
      WATLAK,
      WATNTD,
      WATRVR,
      WATSEA,
      WATSUB,
      WATSUR,
      WATSWM,
      WATTDL
    };

    MobilityCapabilityCategoryCode (value v);

    MobilityCapabilityCategoryCode (const char* v);

    MobilityCapabilityCategoryCode (const ::std::string& v);

    MobilityCapabilityCategoryCode (const ::xml_schema::token& v);

    MobilityCapabilityCategoryCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    MobilityCapabilityCategoryCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    MobilityCapabilityCategoryCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    MobilityCapabilityCategoryCode (const MobilityCapabilityCategoryCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual MobilityCapabilityCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MobilityCapabilityCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MobilityCapabilityCategoryCode_convert ();
    }

    protected:
    value
    _xsd_MobilityCapabilityCategoryCode_convert () const;

    public:
    static const char* const _xsd_MobilityCapabilityCategoryCode_literals_[29];
    static const value _xsd_MobilityCapabilityCategoryCode_indexes_[29];
  };

  class MobilityCapabilityDescriptorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MALTID,
      MAXFOR,
      MDEPTH,
      MLCOWT,
      MLCOWW,
      MLCTRK,
      MLCTWT,
      MLCTWW,
      MLCWHL,
      MNLAND,
      MNMSPD,
      MNTOFF,
      MOBGRA,
      MRANGE,
      MSPEED,
      MSSLOP,
      MTRENC,
      NDEPTH,
      NRANGE,
      PRANGE,
      PSPEED
    };

    MobilityCapabilityDescriptorCode (value v);

    MobilityCapabilityDescriptorCode (const char* v);

    MobilityCapabilityDescriptorCode (const ::std::string& v);

    MobilityCapabilityDescriptorCode (const ::xml_schema::token& v);

    MobilityCapabilityDescriptorCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    MobilityCapabilityDescriptorCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    MobilityCapabilityDescriptorCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    MobilityCapabilityDescriptorCode (const MobilityCapabilityDescriptorCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual MobilityCapabilityDescriptorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MobilityCapabilityDescriptorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MobilityCapabilityDescriptorCode_convert ();
    }

    protected:
    value
    _xsd_MobilityCapabilityDescriptorCode_convert () const;

    public:
    static const char* const _xsd_MobilityCapabilityDescriptorCode_literals_[21];
    static const value _xsd_MobilityCapabilityDescriptorCode_indexes_[21];
  };

  class MobilityCapabilityTerrainTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CRSCTY,
      NKN,
      NOS,
      ROAD,
      SNOW,
      TERIND
    };

    MobilityCapabilityTerrainTypeCode (value v);

    MobilityCapabilityTerrainTypeCode (const char* v);

    MobilityCapabilityTerrainTypeCode (const ::std::string& v);

    MobilityCapabilityTerrainTypeCode (const ::xml_schema::token& v);

    MobilityCapabilityTerrainTypeCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MobilityCapabilityTerrainTypeCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MobilityCapabilityTerrainTypeCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MobilityCapabilityTerrainTypeCode (const MobilityCapabilityTerrainTypeCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual MobilityCapabilityTerrainTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MobilityCapabilityTerrainTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MobilityCapabilityTerrainTypeCode_convert ();
    }

    protected:
    value
    _xsd_MobilityCapabilityTerrainTypeCode_convert () const;

    public:
    static const char* const _xsd_MobilityCapabilityTerrainTypeCode_literals_[6];
    static const value _xsd_MobilityCapabilityTerrainTypeCode_indexes_[6];
  };

  class MobilityCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FOOT,
      NKN,
      TRACK,
      WHEEL,
      WHLAWD,
      WHTR
    };

    MobilityCode (value v);

    MobilityCode (const char* v);

    MobilityCode (const ::std::string& v);

    MobilityCode (const ::xml_schema::token& v);

    MobilityCode (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    MobilityCode (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    MobilityCode (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    MobilityCode (const MobilityCode& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual MobilityCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MobilityCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MobilityCode_convert ();
    }

    protected:
    value
    _xsd_MobilityCode_convert () const;

    public:
    static const char* const _xsd_MobilityCode_literals_[6];
    static const value _xsd_MobilityCode_indexes_[6];
  };

  class ModeOfTransportationCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIR,
      IWT,
      MULTI,
      PIPE,
      RAIL,
      ROAD,
      SEA,
      TERR
    };

    ModeOfTransportationCode (value v);

    ModeOfTransportationCode (const char* v);

    ModeOfTransportationCode (const ::std::string& v);

    ModeOfTransportationCode (const ::xml_schema::token& v);

    ModeOfTransportationCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ModeOfTransportationCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ModeOfTransportationCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ModeOfTransportationCode (const ModeOfTransportationCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual ModeOfTransportationCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ModeOfTransportationCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ModeOfTransportationCode_convert ();
    }

    protected:
    value
    _xsd_ModeOfTransportationCode_convert () const;

    public:
    static const char* const _xsd_ModeOfTransportationCode_literals_[8];
    static const value _xsd_ModeOfTransportationCode_indexes_[8];
  };

  class NetworkArchitectureCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ARCNET,
      ETHRNT,
      MIXED,
      NOS,
      TKNRNG,
      WRLESS
    };

    NetworkArchitectureCode (value v);

    NetworkArchitectureCode (const char* v);

    NetworkArchitectureCode (const ::std::string& v);

    NetworkArchitectureCode (const ::xml_schema::token& v);

    NetworkArchitectureCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    NetworkArchitectureCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    NetworkArchitectureCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    NetworkArchitectureCode (const NetworkArchitectureCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual NetworkArchitectureCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NetworkArchitectureCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NetworkArchitectureCode_convert ();
    }

    protected:
    value
    _xsd_NetworkArchitectureCode_convert () const;

    public:
    static const char* const _xsd_NetworkArchitectureCode_literals_[6];
    static const value _xsd_NetworkArchitectureCode_indexes_[6];
  };

  class NetworkCapacityBandwidthCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_100MBP,
      cxx_10GBPS,
      cxx_10MBPS,
      cxx_1GBPS,
      cxx_56KBPS,
      cxx_64KBPS,
      E1,
      E2,
      E3,
      EUROCM,
      FDDI,
      FRMRLY,
      ISDN,
      NOS,
      SONET,
      SWTD56,
      T1,
      T3
    };

    NetworkCapacityBandwidthCode (value v);

    NetworkCapacityBandwidthCode (const char* v);

    NetworkCapacityBandwidthCode (const ::std::string& v);

    NetworkCapacityBandwidthCode (const ::xml_schema::token& v);

    NetworkCapacityBandwidthCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    NetworkCapacityBandwidthCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    NetworkCapacityBandwidthCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    NetworkCapacityBandwidthCode (const NetworkCapacityBandwidthCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual NetworkCapacityBandwidthCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NetworkCapacityBandwidthCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NetworkCapacityBandwidthCode_convert ();
    }

    protected:
    value
    _xsd_NetworkCapacityBandwidthCode_convert () const;

    public:
    static const char* const _xsd_NetworkCapacityBandwidthCode_literals_[18];
    static const value _xsd_NetworkCapacityBandwidthCode_indexes_[18];
  };

  class NetworkCapacityProtocolCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      APLTLK,
      ATM,
      DECNET,
      HVQCK,
      HVQCK2,
      IPV6,
      IPXSPX,
      MIDS,
      NETBEU,
      NOS,
      OSI,
      SNA,
      TCPIP,
      UDP,
      X25,
      X400
    };

    NetworkCapacityProtocolCode (value v);

    NetworkCapacityProtocolCode (const char* v);

    NetworkCapacityProtocolCode (const ::std::string& v);

    NetworkCapacityProtocolCode (const ::xml_schema::token& v);

    NetworkCapacityProtocolCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    NetworkCapacityProtocolCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    NetworkCapacityProtocolCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    NetworkCapacityProtocolCode (const NetworkCapacityProtocolCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual NetworkCapacityProtocolCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NetworkCapacityProtocolCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NetworkCapacityProtocolCode_convert ();
    }

    protected:
    value
    _xsd_NetworkCapacityProtocolCode_convert () const;

    public:
    static const char* const _xsd_NetworkCapacityProtocolCode_literals_[16];
    static const value _xsd_NetworkCapacityProtocolCode_indexes_[16];
  };

  class NetworkCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BRDCST,
      MLTCST,
      NKN,
      NOS,
      PTTOPT
    };

    NetworkCategoryCode (value v);

    NetworkCategoryCode (const char* v);

    NetworkCategoryCode (const ::std::string& v);

    NetworkCategoryCode (const ::xml_schema::token& v);

    NetworkCategoryCode (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    NetworkCategoryCode (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    NetworkCategoryCode (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    NetworkCategoryCode (const NetworkCategoryCode& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual NetworkCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NetworkCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NetworkCategoryCode_convert ();
    }

    protected:
    value
    _xsd_NetworkCategoryCode_convert () const;

    public:
    static const char* const _xsd_NetworkCategoryCode_literals_[5];
    static const value _xsd_NetworkCategoryCode_indexes_[5];
  };

  class NetworkFrequencyBandCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      EHF,
      HF,
      LF,
      MF,
      SHF,
      UHF,
      VHF,
      VLF
    };

    NetworkFrequencyBandCode (value v);

    NetworkFrequencyBandCode (const char* v);

    NetworkFrequencyBandCode (const ::std::string& v);

    NetworkFrequencyBandCode (const ::xml_schema::token& v);

    NetworkFrequencyBandCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    NetworkFrequencyBandCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    NetworkFrequencyBandCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    NetworkFrequencyBandCode (const NetworkFrequencyBandCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual NetworkFrequencyBandCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NetworkFrequencyBandCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NetworkFrequencyBandCode_convert ();
    }

    protected:
    value
    _xsd_NetworkFrequencyBandCode_convert () const;

    public:
    static const char* const _xsd_NetworkFrequencyBandCode_literals_[8];
    static const value _xsd_NetworkFrequencyBandCode_indexes_[8];
  };

  class NetworkFrequencyModulationCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DBSBND,
      FRQMOD,
      FRQSHF,
      LWSBND,
      PHSHKY,
      UPSBND
    };

    NetworkFrequencyModulationCode (value v);

    NetworkFrequencyModulationCode (const char* v);

    NetworkFrequencyModulationCode (const ::std::string& v);

    NetworkFrequencyModulationCode (const ::xml_schema::token& v);

    NetworkFrequencyModulationCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    NetworkFrequencyModulationCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    NetworkFrequencyModulationCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    NetworkFrequencyModulationCode (const NetworkFrequencyModulationCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual NetworkFrequencyModulationCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NetworkFrequencyModulationCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NetworkFrequencyModulationCode_convert ();
    }

    protected:
    value
    _xsd_NetworkFrequencyModulationCode_convert () const;

    public:
    static const char* const _xsd_NetworkFrequencyModulationCode_literals_[6];
    static const value _xsd_NetworkFrequencyModulationCode_indexes_[6];
  };

  class NetworkMeansCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CABLE,
      COAXCB,
      DDCDLN,
      DIALUP,
      FBROPT,
      INFRED,
      LASER,
      MASER,
      MICROW,
      MIXED,
      NKN,
      NOS,
      RDLNKG,
      RDLNKS,
      RDLTER,
      RDLTRO,
      RDRLY,
      TWTPRC
    };

    NetworkMeansCode (value v);

    NetworkMeansCode (const char* v);

    NetworkMeansCode (const ::std::string& v);

    NetworkMeansCode (const ::xml_schema::token& v);

    NetworkMeansCode (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    NetworkMeansCode (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    NetworkMeansCode (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    NetworkMeansCode (const NetworkMeansCode& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual NetworkMeansCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NetworkMeansCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NetworkMeansCode_convert ();
    }

    protected:
    value
    _xsd_NetworkMeansCode_convert () const;

    public:
    static const char* const _xsd_NetworkMeansCode_literals_[18];
    static const value _xsd_NetworkMeansCode_indexes_[18];
  };

  class NetworkServiceCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DATTRF,
      FAX,
      IFF,
      IMAGE,
      MCI,
      MHS,
      NOS,
      TDL,
      VIDSVC,
      VOCSVC
    };

    NetworkServiceCategoryCode (value v);

    NetworkServiceCategoryCode (const char* v);

    NetworkServiceCategoryCode (const ::std::string& v);

    NetworkServiceCategoryCode (const ::xml_schema::token& v);

    NetworkServiceCategoryCode (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    NetworkServiceCategoryCode (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    NetworkServiceCategoryCode (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    NetworkServiceCategoryCode (const NetworkServiceCategoryCode& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual NetworkServiceCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NetworkServiceCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NetworkServiceCategoryCode_convert ();
    }

    protected:
    value
    _xsd_NetworkServiceCategoryCode_convert () const;

    public:
    static const char* const _xsd_NetworkServiceCategoryCode_literals_[10];
    static const value _xsd_NetworkServiceCategoryCode_indexes_[10];
  };

  class NetworkServiceCryptographicIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    NetworkServiceCryptographicIndicatorCode (value v);

    NetworkServiceCryptographicIndicatorCode (const char* v);

    NetworkServiceCryptographicIndicatorCode (const ::std::string& v);

    NetworkServiceCryptographicIndicatorCode (const ::xml_schema::token& v);

    NetworkServiceCryptographicIndicatorCode (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    NetworkServiceCryptographicIndicatorCode (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    NetworkServiceCryptographicIndicatorCode (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    NetworkServiceCryptographicIndicatorCode (const NetworkServiceCryptographicIndicatorCode& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual NetworkServiceCryptographicIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NetworkServiceCryptographicIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NetworkServiceCryptographicIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_NetworkServiceCryptographicIndicatorCode_convert () const;

    public:
    static const char* const _xsd_NetworkServiceCryptographicIndicatorCode_literals_[2];
    static const value _xsd_NetworkServiceCryptographicIndicatorCode_indexes_[2];
  };

  class NetworkServiceStatusIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    NetworkServiceStatusIndicatorCode (value v);

    NetworkServiceStatusIndicatorCode (const char* v);

    NetworkServiceStatusIndicatorCode (const ::std::string& v);

    NetworkServiceStatusIndicatorCode (const ::xml_schema::token& v);

    NetworkServiceStatusIndicatorCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    NetworkServiceStatusIndicatorCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    NetworkServiceStatusIndicatorCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    NetworkServiceStatusIndicatorCode (const NetworkServiceStatusIndicatorCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual NetworkServiceStatusIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NetworkServiceStatusIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NetworkServiceStatusIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_NetworkServiceStatusIndicatorCode_convert () const;

    public:
    static const char* const _xsd_NetworkServiceStatusIndicatorCode_literals_[2];
    static const value _xsd_NetworkServiceStatusIndicatorCode_indexes_[2];
  };

  class NetworkServiceSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DRCTRY,
      EMAIL,
      FTP,
      HTTP,
      IFFM1,
      IFFM2,
      IFFM3,
      IFFM3A,
      IFFM4,
      IFFM5,
      IFFMC,
      IFFMS,
      LNK1,
      LNK11,
      LNK11B,
      LNK14,
      LNK16D,
      LNK16V,
      LNK22,
      LNK4,
      MCIMD1,
      MCIMD2,
      MCIMD3,
      MOBILE,
      NOS,
      PAGER,
      RMTACC,
      TELEPH,
      TELEX,
      TELNET
    };

    NetworkServiceSubcategoryCode (value v);

    NetworkServiceSubcategoryCode (const char* v);

    NetworkServiceSubcategoryCode (const ::std::string& v);

    NetworkServiceSubcategoryCode (const ::xml_schema::token& v);

    NetworkServiceSubcategoryCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    NetworkServiceSubcategoryCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    NetworkServiceSubcategoryCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    NetworkServiceSubcategoryCode (const NetworkServiceSubcategoryCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual NetworkServiceSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NetworkServiceSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NetworkServiceSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_NetworkServiceSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_NetworkServiceSubcategoryCode_literals_[30];
    static const value _xsd_NetworkServiceSubcategoryCode_indexes_[30];
  };

  class NetworkSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CIRCSW,
      PCKSWT,
      VRTSWT,
      NKN,
      NOS
    };

    NetworkSubcategoryCode (value v);

    NetworkSubcategoryCode (const char* v);

    NetworkSubcategoryCode (const ::std::string& v);

    NetworkSubcategoryCode (const ::xml_schema::token& v);

    NetworkSubcategoryCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    NetworkSubcategoryCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    NetworkSubcategoryCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    NetworkSubcategoryCode (const NetworkSubcategoryCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual NetworkSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NetworkSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NetworkSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_NetworkSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_NetworkSubcategoryCode_literals_[5];
    static const value _xsd_NetworkSubcategoryCode_indexes_[5];
  };

  class NuclearEventCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NKN,
      NROTA,
      NUCATT,
      NUCSMP,
      NUCTST,
      NUCWAR,
      NUCWEP,
      NUCWST
    };

    NuclearEventCategoryCode (value v);

    NuclearEventCategoryCode (const char* v);

    NuclearEventCategoryCode (const ::std::string& v);

    NuclearEventCategoryCode (const ::xml_schema::token& v);

    NuclearEventCategoryCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    NuclearEventCategoryCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    NuclearEventCategoryCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    NuclearEventCategoryCode (const NuclearEventCategoryCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual NuclearEventCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NuclearEventCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NuclearEventCategoryCode_convert ();
    }

    protected:
    value
    _xsd_NuclearEventCategoryCode_convert () const;

    public:
    static const char* const _xsd_NuclearEventCategoryCode_literals_[8];
    static const value _xsd_NuclearEventCategoryCode_indexes_[8];
  };

  class NuclearWeaponEventCraterPresenceCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CRATER,
      NKN,
      NONE
    };

    NuclearWeaponEventCraterPresenceCode (value v);

    NuclearWeaponEventCraterPresenceCode (const char* v);

    NuclearWeaponEventCraterPresenceCode (const ::std::string& v);

    NuclearWeaponEventCraterPresenceCode (const ::xml_schema::token& v);

    NuclearWeaponEventCraterPresenceCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    NuclearWeaponEventCraterPresenceCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    NuclearWeaponEventCraterPresenceCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    NuclearWeaponEventCraterPresenceCode (const NuclearWeaponEventCraterPresenceCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual NuclearWeaponEventCraterPresenceCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NuclearWeaponEventCraterPresenceCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NuclearWeaponEventCraterPresenceCode_convert ();
    }

    protected:
    value
    _xsd_NuclearWeaponEventCraterPresenceCode_convert () const;

    public:
    static const char* const _xsd_NuclearWeaponEventCraterPresenceCode_literals_[3];
    static const value _xsd_NuclearWeaponEventCraterPresenceCode_indexes_[3];
  };

  class NuclearYieldGroupCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ALFA,
      BRAVO,
      CHARLI,
      DELTA,
      ECHO,
      FOXTRT,
      GOLF,
      NKN,
      NOS
    };

    NuclearYieldGroupCode (value v);

    NuclearYieldGroupCode (const char* v);

    NuclearYieldGroupCode (const ::std::string& v);

    NuclearYieldGroupCode (const ::xml_schema::token& v);

    NuclearYieldGroupCode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    NuclearYieldGroupCode (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    NuclearYieldGroupCode (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    NuclearYieldGroupCode (const NuclearYieldGroupCode& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual NuclearYieldGroupCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NuclearYieldGroupCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_NuclearYieldGroupCode_convert ();
    }

    protected:
    value
    _xsd_NuclearYieldGroupCode_convert () const;

    public:
    static const char* const _xsd_NuclearYieldGroupCode_literals_[9];
    static const value _xsd_NuclearYieldGroupCode_indexes_[9];
  };

  class ObjectItemAddressAuthorisationIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    ObjectItemAddressAuthorisationIndicatorCode (value v);

    ObjectItemAddressAuthorisationIndicatorCode (const char* v);

    ObjectItemAddressAuthorisationIndicatorCode (const ::std::string& v);

    ObjectItemAddressAuthorisationIndicatorCode (const ::xml_schema::token& v);

    ObjectItemAddressAuthorisationIndicatorCode (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ObjectItemAddressAuthorisationIndicatorCode (const ::xercesc::DOMAttr& a,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ObjectItemAddressAuthorisationIndicatorCode (const ::std::string& s,
                                                 const ::xercesc::DOMElement* e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ObjectItemAddressAuthorisationIndicatorCode (const ObjectItemAddressAuthorisationIndicatorCode& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual ObjectItemAddressAuthorisationIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemAddressAuthorisationIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemAddressAuthorisationIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemAddressAuthorisationIndicatorCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemAddressAuthorisationIndicatorCode_literals_[2];
    static const value _xsd_ObjectItemAddressAuthorisationIndicatorCode_indexes_[2];
  };

  class ObjectItemAddressPrimacyCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      PRIME,
      SCNDRY,
      THIRD
    };

    ObjectItemAddressPrimacyCode (value v);

    ObjectItemAddressPrimacyCode (const char* v);

    ObjectItemAddressPrimacyCode (const ::std::string& v);

    ObjectItemAddressPrimacyCode (const ::xml_schema::token& v);

    ObjectItemAddressPrimacyCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ObjectItemAddressPrimacyCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ObjectItemAddressPrimacyCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ObjectItemAddressPrimacyCode (const ObjectItemAddressPrimacyCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual ObjectItemAddressPrimacyCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemAddressPrimacyCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemAddressPrimacyCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemAddressPrimacyCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemAddressPrimacyCode_literals_[3];
    static const value _xsd_ObjectItemAddressPrimacyCode_indexes_[3];
  };

  class ObjectItemAddressTransmitReceiveCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      RECEIV,
      TRNREC,
      TRNSMT
    };

    ObjectItemAddressTransmitReceiveCode (value v);

    ObjectItemAddressTransmitReceiveCode (const char* v);

    ObjectItemAddressTransmitReceiveCode (const ::std::string& v);

    ObjectItemAddressTransmitReceiveCode (const ::xml_schema::token& v);

    ObjectItemAddressTransmitReceiveCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ObjectItemAddressTransmitReceiveCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ObjectItemAddressTransmitReceiveCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ObjectItemAddressTransmitReceiveCode (const ObjectItemAddressTransmitReceiveCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual ObjectItemAddressTransmitReceiveCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemAddressTransmitReceiveCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemAddressTransmitReceiveCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemAddressTransmitReceiveCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemAddressTransmitReceiveCode_literals_[3];
    static const value _xsd_ObjectItemAddressTransmitReceiveCode_indexes_[3];
  };

  class ObjectItemAliasCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ALTNAM,
      ELINT,
      EMSSNS,
      GEOLOC,
      TRACK,
      UNITDS
    };

    ObjectItemAliasCategoryCode (value v);

    ObjectItemAliasCategoryCode (const char* v);

    ObjectItemAliasCategoryCode (const ::std::string& v);

    ObjectItemAliasCategoryCode (const ::xml_schema::token& v);

    ObjectItemAliasCategoryCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ObjectItemAliasCategoryCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ObjectItemAliasCategoryCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ObjectItemAliasCategoryCode (const ObjectItemAliasCategoryCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual ObjectItemAliasCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemAliasCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemAliasCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemAliasCategoryCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemAliasCategoryCode_literals_[6];
    static const value _xsd_ObjectItemAliasCategoryCode_indexes_[6];
  };

  class ObjectItemAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ADMINS,
      AUGMNT,
      CMDCTL,
      CONSUM,
      CONTNS,
      CONTRL,
      COORDN,
      DETECT,
      DISE,
      EMPLOY,
      ENCLOS,
      ESTA,
      EXPLOT,
      FUCS,
      HSADMI,
      HSASGN,
      HSATCH,
      HSCNSL,
      HSFPEM,
      HSLOFF,
      HSMAIN,
      HSMMBR,
      HSOPER,
      HSPOC,
      INSTAL,
      INTRST,
      ISACAU,
      ISAFBY,
      ISASTO,
      ISAUNT,
      ISAUTO,
      ISBDFR,
      ISBDLE,
      ISBDRR,
      ISBDRT,
      ISBOND,
      ISBRTH,
      ISCNNC,
      ISCNVY,
      ISCONS,
      ISCOUS,
      ISCPTR,
      ISCPTS,
      ISDAUG,
      ISEND,
      ISFATH,
      ISFSTN,
      ISFTLW,
      ISGRDD,
      ISGRDF,
      ISGRDM,
      ISGRDS,
      ISHUSB,
      ISLGLF,
      ISLGLM,
      ISLOAD,
      ISLOF,
      ISMOTH,
      ISMTLW,
      ISNEPH,
      ISNIEC,
      ISOWNR,
      ISPABD,
      ISPART,
      ISPEER,
      ISPPRA,
      ISPPRP,
      ISPREA,
      ISPREP,
      ISPRTC,
      ISROF,
      ISSCSR,
      ISSECN,
      ISSIST,
      ISSITU,
      ISSON,
      ISSPNR,
      ISSPPL,
      ISSPRT,
      ISSTRT,
      ISSUPR,
      ISUCOM,
      ISUNCL,
      ISWIFE,
      MAINTN,
      NKN,
      NOS,
      OBSRVS,
      OPERAT,
      POSESS,
      PRTENC,
      PRVLOG,
      RATES,
      REPAIR,
      REPORT,
      SERVES,
      SUPPL,
      TRNSPT,
      USES
    };

    ObjectItemAssociationCategoryCode (value v);

    ObjectItemAssociationCategoryCode (const char* v);

    ObjectItemAssociationCategoryCode (const ::std::string& v);

    ObjectItemAssociationCategoryCode (const ::xml_schema::token& v);

    ObjectItemAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    ObjectItemAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    ObjectItemAssociationCategoryCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    ObjectItemAssociationCategoryCode (const ObjectItemAssociationCategoryCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual ObjectItemAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemAssociationCategoryCode_literals_[99];
    static const value _xsd_ObjectItemAssociationCategoryCode_indexes_[99];
  };

  class ObjectItemAssociationSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ALTFOR,
      ASGND,
      ATPRCL,
      ATTACH,
      CASP1,
      CASP2,
      CASP3,
      CASP4,
      COMD,
      DETACH,
      DIRSUP,
      FORCE,
      GENSRI,
      GENSUP,
      HSCPTD,
      HSNSPT,
      ISCPER,
      ONCALL,
      OPCOMD,
      OPCON,
      ORGANC,
      REINFC,
      RESERV,
      ROLE,
      SAME,
      SPTAMM,
      SPTENG,
      SPTMED,
      SPTMVT,
      SPTPAR,
      SPTPOL,
      SPTPST,
      SPTRAT,
      SPTRRE,
      SPTSPL,
      SPTTRN,
      TACCNT,
      TACCOM
    };

    ObjectItemAssociationSubcategoryCode (value v);

    ObjectItemAssociationSubcategoryCode (const char* v);

    ObjectItemAssociationSubcategoryCode (const ::std::string& v);

    ObjectItemAssociationSubcategoryCode (const ::xml_schema::token& v);

    ObjectItemAssociationSubcategoryCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ObjectItemAssociationSubcategoryCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ObjectItemAssociationSubcategoryCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ObjectItemAssociationSubcategoryCode (const ObjectItemAssociationSubcategoryCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual ObjectItemAssociationSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemAssociationSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemAssociationSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemAssociationSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemAssociationSubcategoryCode_literals_[38];
    static const value _xsd_ObjectItemAssociationSubcategoryCode_indexes_[38];
  };

  class ObjectItemCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FA,
      FE,
      MA,
      NKN,
      OR,
      PE
    };

    ObjectItemCategoryCode (value v);

    ObjectItemCategoryCode (const char* v);

    ObjectItemCategoryCode (const ::std::string& v);

    ObjectItemCategoryCode (const ::xml_schema::token& v);

    ObjectItemCategoryCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ObjectItemCategoryCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ObjectItemCategoryCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ObjectItemCategoryCode (const ObjectItemCategoryCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual ObjectItemCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemCategoryCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemCategoryCode_literals_[6];
    static const value _xsd_ObjectItemCategoryCode_indexes_[6];
  };

  class ObjectItemGroupAccountDetailQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AILING,
      ASSKIA,
      AWTNPU,
      CAPTRD,
      COMSTR,
      CPTRAI,
      DESRTD,
      DETD,
      DISEAS,
      EVADNG,
      HEALTH,
      INJRDW,
      KIA,
      KILL,
      MIA,
      MIS,
      NOCHUT,
      PARCHT,
      PRBCPT,
      RESCUD,
      SAFCPT,
      UNK
    };

    ObjectItemGroupAccountDetailQualifierCode (value v);

    ObjectItemGroupAccountDetailQualifierCode (const char* v);

    ObjectItemGroupAccountDetailQualifierCode (const ::std::string& v);

    ObjectItemGroupAccountDetailQualifierCode (const ::xml_schema::token& v);

    ObjectItemGroupAccountDetailQualifierCode (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    ObjectItemGroupAccountDetailQualifierCode (const ::xercesc::DOMAttr& a,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    ObjectItemGroupAccountDetailQualifierCode (const ::std::string& s,
                                               const ::xercesc::DOMElement* e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    ObjectItemGroupAccountDetailQualifierCode (const ObjectItemGroupAccountDetailQualifierCode& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual ObjectItemGroupAccountDetailQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemGroupAccountDetailQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemGroupAccountDetailQualifierCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemGroupAccountDetailQualifierCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemGroupAccountDetailQualifierCode_literals_[22];
    static const value _xsd_ObjectItemGroupAccountDetailQualifierCode_indexes_[22];
  };

  class ObjectItemHostilityStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AFR,
      AHO,
      AIV,
      ANT,
      FAKER,
      FR,
      HO,
      IV,
      JOKER,
      NEUTRL,
      PENDNG,
      SUSPCT,
      UNK
    };

    ObjectItemHostilityStatusCode (value v);

    ObjectItemHostilityStatusCode (const char* v);

    ObjectItemHostilityStatusCode (const ::std::string& v);

    ObjectItemHostilityStatusCode (const ::xml_schema::token& v);

    ObjectItemHostilityStatusCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    ObjectItemHostilityStatusCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    ObjectItemHostilityStatusCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    ObjectItemHostilityStatusCode (const ObjectItemHostilityStatusCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual ObjectItemHostilityStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemHostilityStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemHostilityStatusCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemHostilityStatusCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemHostilityStatusCode_literals_[13];
    static const value _xsd_ObjectItemHostilityStatusCode_indexes_[13];
  };

  class ObjectItemLocationMeaningCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ADRPRP,
      ASSCP,
      CEOFMA,
      CMDDET,
      COM,
      CTRMNB,
      DSPCTR,
      FRMCTR,
      LNBRNG,
      ORGPRL,
      POSOIM,
      SHAPE,
      SOUND,
      STDPOS
    };

    ObjectItemLocationMeaningCode (value v);

    ObjectItemLocationMeaningCode (const char* v);

    ObjectItemLocationMeaningCode (const ::std::string& v);

    ObjectItemLocationMeaningCode (const ::xml_schema::token& v);

    ObjectItemLocationMeaningCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    ObjectItemLocationMeaningCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    ObjectItemLocationMeaningCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    ObjectItemLocationMeaningCode (const ObjectItemLocationMeaningCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual ObjectItemLocationMeaningCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemLocationMeaningCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemLocationMeaningCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemLocationMeaningCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemLocationMeaningCode_literals_[14];
    static const value _xsd_ObjectItemLocationMeaningCode_indexes_[14];
  };

  class ObjectItemLocationRelativeSpeedCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FAST,
      MEDIUM,
      SLOW,
      ZERO
    };

    ObjectItemLocationRelativeSpeedCode (value v);

    ObjectItemLocationRelativeSpeedCode (const char* v);

    ObjectItemLocationRelativeSpeedCode (const ::std::string& v);

    ObjectItemLocationRelativeSpeedCode (const ::xml_schema::token& v);

    ObjectItemLocationRelativeSpeedCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ObjectItemLocationRelativeSpeedCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ObjectItemLocationRelativeSpeedCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ObjectItemLocationRelativeSpeedCode (const ObjectItemLocationRelativeSpeedCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual ObjectItemLocationRelativeSpeedCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemLocationRelativeSpeedCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemLocationRelativeSpeedCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemLocationRelativeSpeedCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemLocationRelativeSpeedCode_literals_[4];
    static const value _xsd_ObjectItemLocationRelativeSpeedCode_indexes_[4];
  };

  class ObjectItemReferenceAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HASINS,
      ISACTV,
      ISAUTH,
      ISDEAC,
      ISDSCR,
      ISGRPH,
      ISRFNC,
      ISRPTD
    };

    ObjectItemReferenceAssociationCategoryCode (value v);

    ObjectItemReferenceAssociationCategoryCode (const char* v);

    ObjectItemReferenceAssociationCategoryCode (const ::std::string& v);

    ObjectItemReferenceAssociationCategoryCode (const ::xml_schema::token& v);

    ObjectItemReferenceAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ObjectItemReferenceAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ObjectItemReferenceAssociationCategoryCode (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ObjectItemReferenceAssociationCategoryCode (const ObjectItemReferenceAssociationCategoryCode& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual ObjectItemReferenceAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemReferenceAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemReferenceAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemReferenceAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemReferenceAssociationCategoryCode_literals_[8];
    static const value _xsd_ObjectItemReferenceAssociationCategoryCode_indexes_[8];
  };

  class ObjectItemStatusBoobyTrapPresenceCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      UNK,
      YES
    };

    ObjectItemStatusBoobyTrapPresenceCode (value v);

    ObjectItemStatusBoobyTrapPresenceCode (const char* v);

    ObjectItemStatusBoobyTrapPresenceCode (const ::std::string& v);

    ObjectItemStatusBoobyTrapPresenceCode (const ::xml_schema::token& v);

    ObjectItemStatusBoobyTrapPresenceCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ObjectItemStatusBoobyTrapPresenceCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ObjectItemStatusBoobyTrapPresenceCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ObjectItemStatusBoobyTrapPresenceCode (const ObjectItemStatusBoobyTrapPresenceCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual ObjectItemStatusBoobyTrapPresenceCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemStatusBoobyTrapPresenceCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemStatusBoobyTrapPresenceCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemStatusBoobyTrapPresenceCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemStatusBoobyTrapPresenceCode_literals_[3];
    static const value _xsd_ObjectItemStatusBoobyTrapPresenceCode_indexes_[3];
  };

  class ObjectItemStatusCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CF,
      FA,
      GF,
      MA,
      NKN,
      OR,
      PE
    };

    ObjectItemStatusCategoryCode (value v);

    ObjectItemStatusCategoryCode (const char* v);

    ObjectItemStatusCategoryCode (const ::std::string& v);

    ObjectItemStatusCategoryCode (const ::xml_schema::token& v);

    ObjectItemStatusCategoryCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ObjectItemStatusCategoryCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ObjectItemStatusCategoryCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ObjectItemStatusCategoryCode (const ObjectItemStatusCategoryCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual ObjectItemStatusCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemStatusCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemStatusCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemStatusCategoryCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemStatusCategoryCode_literals_[7];
    static const value _xsd_ObjectItemStatusCategoryCode_indexes_[7];
  };

  class ObjectItemStatusEmissionControlCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      EMCON1,
      EMCON2,
      EMCON3
    };

    ObjectItemStatusEmissionControlCode (value v);

    ObjectItemStatusEmissionControlCode (const char* v);

    ObjectItemStatusEmissionControlCode (const ::std::string& v);

    ObjectItemStatusEmissionControlCode (const ::xml_schema::token& v);

    ObjectItemStatusEmissionControlCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ObjectItemStatusEmissionControlCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ObjectItemStatusEmissionControlCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ObjectItemStatusEmissionControlCode (const ObjectItemStatusEmissionControlCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual ObjectItemStatusEmissionControlCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectItemStatusEmissionControlCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectItemStatusEmissionControlCode_convert ();
    }

    protected:
    value
    _xsd_ObjectItemStatusEmissionControlCode_convert () const;

    public:
    static const char* const _xsd_ObjectItemStatusEmissionControlCode_literals_[3];
    static const value _xsd_ObjectItemStatusEmissionControlCode_indexes_[3];
  };

  class ObjectTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FA,
      FE,
      MA,
      NKN,
      OR,
      PE
    };

    ObjectTypeCategoryCode (value v);

    ObjectTypeCategoryCode (const char* v);

    ObjectTypeCategoryCode (const ::std::string& v);

    ObjectTypeCategoryCode (const ::xml_schema::token& v);

    ObjectTypeCategoryCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ObjectTypeCategoryCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ObjectTypeCategoryCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ObjectTypeCategoryCode (const ObjectTypeCategoryCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual ObjectTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ObjectTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_ObjectTypeCategoryCode_literals_[6];
    static const value _xsd_ObjectTypeCategoryCode_indexes_[6];
  };

  class ObjectTypeDecoyIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    ObjectTypeDecoyIndicatorCode (value v);

    ObjectTypeDecoyIndicatorCode (const char* v);

    ObjectTypeDecoyIndicatorCode (const ::std::string& v);

    ObjectTypeDecoyIndicatorCode (const ::xml_schema::token& v);

    ObjectTypeDecoyIndicatorCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ObjectTypeDecoyIndicatorCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ObjectTypeDecoyIndicatorCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ObjectTypeDecoyIndicatorCode (const ObjectTypeDecoyIndicatorCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual ObjectTypeDecoyIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectTypeDecoyIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectTypeDecoyIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_ObjectTypeDecoyIndicatorCode_convert () const;

    public:
    static const char* const _xsd_ObjectTypeDecoyIndicatorCode_literals_[2];
    static const value _xsd_ObjectTypeDecoyIndicatorCode_indexes_[2];
  };

  class ObjectTypeEstablishmentCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CES,
      PCG
    };

    ObjectTypeEstablishmentCategoryCode (value v);

    ObjectTypeEstablishmentCategoryCode (const char* v);

    ObjectTypeEstablishmentCategoryCode (const ::std::string& v);

    ObjectTypeEstablishmentCategoryCode (const ::xml_schema::token& v);

    ObjectTypeEstablishmentCategoryCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ObjectTypeEstablishmentCategoryCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ObjectTypeEstablishmentCategoryCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ObjectTypeEstablishmentCategoryCode (const ObjectTypeEstablishmentCategoryCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual ObjectTypeEstablishmentCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectTypeEstablishmentCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectTypeEstablishmentCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ObjectTypeEstablishmentCategoryCode_convert () const;

    public:
    static const char* const _xsd_ObjectTypeEstablishmentCategoryCode_literals_[2];
    static const value _xsd_ObjectTypeEstablishmentCategoryCode_indexes_[2];
  };

  class ObjectTypeEstablishmentEnvironmentConditionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ARC,
      DES,
      JUN,
      MOUNTN,
      NKN,
      NOS,
      TMP,
      TRP
    };

    ObjectTypeEstablishmentEnvironmentConditionCode (value v);

    ObjectTypeEstablishmentEnvironmentConditionCode (const char* v);

    ObjectTypeEstablishmentEnvironmentConditionCode (const ::std::string& v);

    ObjectTypeEstablishmentEnvironmentConditionCode (const ::xml_schema::token& v);

    ObjectTypeEstablishmentEnvironmentConditionCode (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    ObjectTypeEstablishmentEnvironmentConditionCode (const ::xercesc::DOMAttr& a,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    ObjectTypeEstablishmentEnvironmentConditionCode (const ::std::string& s,
                                                     const ::xercesc::DOMElement* e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    ObjectTypeEstablishmentEnvironmentConditionCode (const ObjectTypeEstablishmentEnvironmentConditionCode& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    virtual ObjectTypeEstablishmentEnvironmentConditionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectTypeEstablishmentEnvironmentConditionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectTypeEstablishmentEnvironmentConditionCode_convert ();
    }

    protected:
    value
    _xsd_ObjectTypeEstablishmentEnvironmentConditionCode_convert () const;

    public:
    static const char* const _xsd_ObjectTypeEstablishmentEnvironmentConditionCode_literals_[8];
    static const value _xsd_ObjectTypeEstablishmentEnvironmentConditionCode_indexes_[8];
  };

  class ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode (value v);

    ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode (const char* v);

    ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode (const ::std::string& v);

    ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode (const ::xml_schema::token& v);

    ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode (const ::xercesc::DOMElement& e,
                                                                   ::xml_schema::flags f = 0,
                                                                   ::xml_schema::container* c = 0);

    ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode (const ::xercesc::DOMAttr& a,
                                                                   ::xml_schema::flags f = 0,
                                                                   ::xml_schema::container* c = 0);

    ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode (const ::std::string& s,
                                                                   const ::xercesc::DOMElement* e,
                                                                   ::xml_schema::flags f = 0,
                                                                   ::xml_schema::container* c = 0);

    ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode (const ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode& x,
                                                                   ::xml_schema::flags f = 0,
                                                                   ::xml_schema::container* c = 0);

    virtual ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode_convert () const;

    public:
    static const char* const _xsd_ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode_literals_[2];
    static const value _xsd_ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode_indexes_[2];
  };

  class ObjectTypeEstablishmentOperationalModeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CV,
      HU,
      IS,
      PE,
      PK,
      PSO,
      WA
    };

    ObjectTypeEstablishmentOperationalModeCode (value v);

    ObjectTypeEstablishmentOperationalModeCode (const char* v);

    ObjectTypeEstablishmentOperationalModeCode (const ::std::string& v);

    ObjectTypeEstablishmentOperationalModeCode (const ::xml_schema::token& v);

    ObjectTypeEstablishmentOperationalModeCode (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ObjectTypeEstablishmentOperationalModeCode (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ObjectTypeEstablishmentOperationalModeCode (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ObjectTypeEstablishmentOperationalModeCode (const ObjectTypeEstablishmentOperationalModeCode& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual ObjectTypeEstablishmentOperationalModeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectTypeEstablishmentOperationalModeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectTypeEstablishmentOperationalModeCode_convert ();
    }

    protected:
    value
    _xsd_ObjectTypeEstablishmentOperationalModeCode_convert () const;

    public:
    static const char* const _xsd_ObjectTypeEstablishmentOperationalModeCode_literals_[7];
    static const value _xsd_ObjectTypeEstablishmentOperationalModeCode_indexes_[7];
  };

  class ObjectTypeReferenceAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HASCAP,
      HASTNG,
      ISDSCR,
      ISMNTN,
      ISPRCR,
      ISRFNC,
      ISSPCF
    };

    ObjectTypeReferenceAssociationCategoryCode (value v);

    ObjectTypeReferenceAssociationCategoryCode (const char* v);

    ObjectTypeReferenceAssociationCategoryCode (const ::std::string& v);

    ObjectTypeReferenceAssociationCategoryCode (const ::xml_schema::token& v);

    ObjectTypeReferenceAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ObjectTypeReferenceAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ObjectTypeReferenceAssociationCategoryCode (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ObjectTypeReferenceAssociationCategoryCode (const ObjectTypeReferenceAssociationCategoryCode& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual ObjectTypeReferenceAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectTypeReferenceAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ObjectTypeReferenceAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ObjectTypeReferenceAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_ObjectTypeReferenceAssociationCategoryCode_literals_[7];
    static const value _xsd_ObjectTypeReferenceAssociationCategoryCode_indexes_[7];
  };

  class OperationalCapabilityCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIRBRN,
      AIRDEF,
      AIRGRD,
      AIRINT,
      AMPH,
      ANTSUB,
      ARASLT,
      ARC,
      ARLRFL,
      ARTYSV,
      ATTACK,
      BIOMAT,
      C2,
      CAS,
      CBRNDC,
      CHMDEC,
      CHMMAT,
      CHMSMK,
      CIVLWE,
      CMDOPS,
      CNTRIN,
      CTRINT,
      ELCRNG,
      ENGCBT,
      ENGCN,
      ENGCNN,
      EW,
      EWDF,
      EWINTC,
      EWJAM,
      FINANC,
      INTERO,
      JNTINT,
      LABOUR,
      LEGAL,
      MAINT,
      MARINE,
      MARTME,
      MCM,
      MEDEVC,
      MIAREX,
      MIOPS,
      MITCEX,
      MNTELO,
      MNTOD,
      MNTODM,
      MOUNTN,
      MRTGRR,
      MWR,
      NUCMAT,
      PERSVC,
      PSO,
      PUBAF,
      PUBAFB,
      PUBAFJ,
      RADMAT,
      RAILWY,
      RECCE,
      RECVRY,
      REPLHO,
      SAR,
      SCOUT,
      SGFC,
      SGNC,
      SGNLE,
      SGNSE,
      SGRDRL,
      SGRDTA,
      SGRDTE,
      SGSPT,
      SIGINT,
      SIGRAD,
      SPLC1,
      SPLC2,
      SPLC3,
      SPLC3A,
      SPLC4,
      SPLC5,
      SPLLDB,
      SPLWAT,
      SRV,
      SRVGM,
      SRVLR,
      SRVMET,
      SRVSEN,
      TAIRRE,
      TGT,
      TGTAFL,
      TGTARD,
      TGTASD,
      TGTNG,
      THTMSD,
      TRAIN,
      TRNAPD,
      TRNMSL,
      TRNMVC,
      TRNSPD,
      UTILTY,
      WATER
    };

    OperationalCapabilityCategoryCode (value v);

    OperationalCapabilityCategoryCode (const char* v);

    OperationalCapabilityCategoryCode (const ::std::string& v);

    OperationalCapabilityCategoryCode (const ::xml_schema::token& v);

    OperationalCapabilityCategoryCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    OperationalCapabilityCategoryCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    OperationalCapabilityCategoryCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    OperationalCapabilityCategoryCode (const OperationalCapabilityCategoryCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual OperationalCapabilityCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OperationalCapabilityCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OperationalCapabilityCategoryCode_convert ();
    }

    protected:
    value
    _xsd_OperationalCapabilityCategoryCode_convert () const;

    public:
    static const char* const _xsd_OperationalCapabilityCategoryCode_literals_[99];
    static const value _xsd_OperationalCapabilityCategoryCode_indexes_[99];
  };

  class OperationalCapabilityLevelCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CORPS,
      DIV,
      FORCE,
      OPR,
      STRTGC,
      TACTCL,
      THTRE
    };

    OperationalCapabilityLevelCode (value v);

    OperationalCapabilityLevelCode (const char* v);

    OperationalCapabilityLevelCode (const ::std::string& v);

    OperationalCapabilityLevelCode (const ::xml_schema::token& v);

    OperationalCapabilityLevelCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    OperationalCapabilityLevelCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    OperationalCapabilityLevelCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    OperationalCapabilityLevelCode (const OperationalCapabilityLevelCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual OperationalCapabilityLevelCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OperationalCapabilityLevelCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OperationalCapabilityLevelCode_convert ();
    }

    protected:
    value
    _xsd_OperationalCapabilityLevelCode_convert () const;

    public:
    static const char* const _xsd_OperationalCapabilityLevelCode_literals_[7];
    static const value _xsd_OperationalCapabilityLevelCode_indexes_[7];
  };

  class OperationalCapabilityQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HIGH,
      LOW,
      MEDIUM
    };

    OperationalCapabilityQualifierCode (value v);

    OperationalCapabilityQualifierCode (const char* v);

    OperationalCapabilityQualifierCode (const ::std::string& v);

    OperationalCapabilityQualifierCode (const ::xml_schema::token& v);

    OperationalCapabilityQualifierCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    OperationalCapabilityQualifierCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    OperationalCapabilityQualifierCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    OperationalCapabilityQualifierCode (const OperationalCapabilityQualifierCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual OperationalCapabilityQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OperationalCapabilityQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OperationalCapabilityQualifierCode_convert ();
    }

    protected:
    value
    _xsd_OperationalCapabilityQualifierCode_convert () const;

    public:
    static const char* const _xsd_OperationalCapabilityQualifierCode_literals_[3];
    static const value _xsd_OperationalCapabilityQualifierCode_indexes_[3];
  };

  class OperationalInformationGroupCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CORENU,
      FRDNEU,
      FRNENO,
      GLBSGN,
      UNCORR,
      PLNORD
    };

    OperationalInformationGroupCategoryCode (value v);

    OperationalInformationGroupCategoryCode (const char* v);

    OperationalInformationGroupCategoryCode (const ::std::string& v);

    OperationalInformationGroupCategoryCode (const ::xml_schema::token& v);

    OperationalInformationGroupCategoryCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    OperationalInformationGroupCategoryCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    OperationalInformationGroupCategoryCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    OperationalInformationGroupCategoryCode (const OperationalInformationGroupCategoryCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual OperationalInformationGroupCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OperationalInformationGroupCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OperationalInformationGroupCategoryCode_convert ();
    }

    protected:
    value
    _xsd_OperationalInformationGroupCategoryCode_convert () const;

    public:
    static const char* const _xsd_OperationalInformationGroupCategoryCode_literals_[6];
    static const value _xsd_OperationalInformationGroupCategoryCode_indexes_[6];
  };

  class OperationalInformationGroupOrganisationAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      RESP,
      PROXY
    };

    OperationalInformationGroupOrganisationAssociationCategoryCode (value v);

    OperationalInformationGroupOrganisationAssociationCategoryCode (const char* v);

    OperationalInformationGroupOrganisationAssociationCategoryCode (const ::std::string& v);

    OperationalInformationGroupOrganisationAssociationCategoryCode (const ::xml_schema::token& v);

    OperationalInformationGroupOrganisationAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                                                    ::xml_schema::flags f = 0,
                                                                    ::xml_schema::container* c = 0);

    OperationalInformationGroupOrganisationAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                                                    ::xml_schema::flags f = 0,
                                                                    ::xml_schema::container* c = 0);

    OperationalInformationGroupOrganisationAssociationCategoryCode (const ::std::string& s,
                                                                    const ::xercesc::DOMElement* e,
                                                                    ::xml_schema::flags f = 0,
                                                                    ::xml_schema::container* c = 0);

    OperationalInformationGroupOrganisationAssociationCategoryCode (const OperationalInformationGroupOrganisationAssociationCategoryCode& x,
                                                                    ::xml_schema::flags f = 0,
                                                                    ::xml_schema::container* c = 0);

    virtual OperationalInformationGroupOrganisationAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OperationalInformationGroupOrganisationAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OperationalInformationGroupOrganisationAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_OperationalInformationGroupOrganisationAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_OperationalInformationGroupOrganisationAssociationCategoryCode_literals_[2];
    static const value _xsd_OperationalInformationGroupOrganisationAssociationCategoryCode_indexes_[2];
  };

  class OrbitAreaAlignmentCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CENTRE,
      LEFT,
      RIGHT
    };

    OrbitAreaAlignmentCode (value v);

    OrbitAreaAlignmentCode (const char* v);

    OrbitAreaAlignmentCode (const ::std::string& v);

    OrbitAreaAlignmentCode (const ::xml_schema::token& v);

    OrbitAreaAlignmentCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    OrbitAreaAlignmentCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    OrbitAreaAlignmentCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    OrbitAreaAlignmentCode (const OrbitAreaAlignmentCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual OrbitAreaAlignmentCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrbitAreaAlignmentCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrbitAreaAlignmentCode_convert ();
    }

    protected:
    value
    _xsd_OrbitAreaAlignmentCode_convert () const;

    public:
    static const char* const _xsd_OrbitAreaAlignmentCode_literals_[3];
    static const value _xsd_OrbitAreaAlignmentCode_indexes_[3];
  };

  class OrderCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ADLOGO,
      FRAGO,
      OPORD,
      WNGO,
      NOS
    };

    OrderCategoryCode (value v);

    OrderCategoryCode (const char* v);

    OrderCategoryCode (const ::std::string& v);

    OrderCategoryCode (const ::xml_schema::token& v);

    OrderCategoryCode (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    OrderCategoryCode (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    OrderCategoryCode (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    OrderCategoryCode (const OrderCategoryCode& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual OrderCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrderCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrderCategoryCode_convert ();
    }

    protected:
    value
    _xsd_OrderCategoryCode_convert () const;

    public:
    static const char* const _xsd_OrderCategoryCode_literals_[5];
    static const value _xsd_OrderCategoryCode_indexes_[5];
  };

  class OrderStatusExecutionStateCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ISSUED,
      STOPPD
    };

    OrderStatusExecutionStateCode (value v);

    OrderStatusExecutionStateCode (const char* v);

    OrderStatusExecutionStateCode (const ::std::string& v);

    OrderStatusExecutionStateCode (const ::xml_schema::token& v);

    OrderStatusExecutionStateCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    OrderStatusExecutionStateCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    OrderStatusExecutionStateCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    OrderStatusExecutionStateCode (const OrderStatusExecutionStateCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual OrderStatusExecutionStateCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrderStatusExecutionStateCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrderStatusExecutionStateCode_convert ();
    }

    protected:
    value
    _xsd_OrderStatusExecutionStateCode_convert () const;

    public:
    static const char* const _xsd_OrderStatusExecutionStateCode_literals_[2];
    static const value _xsd_OrderStatusExecutionStateCode_indexes_[2];
  };

  class OrganisationActionAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      APPR,
      CONTRL,
      COOR,
      INIT,
      INTRST,
      ISSCRM,
      LIAISN,
      OBSRVD,
      PLAN,
      POC,
      PROVDR,
      REP,
      REQUST,
      SSPCTD
    };

    OrganisationActionAssociationCategoryCode (value v);

    OrganisationActionAssociationCategoryCode (const char* v);

    OrganisationActionAssociationCategoryCode (const ::std::string& v);

    OrganisationActionAssociationCategoryCode (const ::xml_schema::token& v);

    OrganisationActionAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    OrganisationActionAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    OrganisationActionAssociationCategoryCode (const ::std::string& s,
                                               const ::xercesc::DOMElement* e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    OrganisationActionAssociationCategoryCode (const OrganisationActionAssociationCategoryCode& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual OrganisationActionAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationActionAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationActionAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationActionAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_OrganisationActionAssociationCategoryCode_literals_[14];
    static const value _xsd_OrganisationActionAssociationCategoryCode_indexes_[14];
  };

  class OrganisationActionTaskRuleOfEngagementStatusCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AUTHRQ,
      AUTHRS,
      CANCEL,
      CNCLRQ,
      DENYRQ
    };

    OrganisationActionTaskRuleOfEngagementStatusCategoryCode (value v);

    OrganisationActionTaskRuleOfEngagementStatusCategoryCode (const char* v);

    OrganisationActionTaskRuleOfEngagementStatusCategoryCode (const ::std::string& v);

    OrganisationActionTaskRuleOfEngagementStatusCategoryCode (const ::xml_schema::token& v);

    OrganisationActionTaskRuleOfEngagementStatusCategoryCode (const ::xercesc::DOMElement& e,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    OrganisationActionTaskRuleOfEngagementStatusCategoryCode (const ::xercesc::DOMAttr& a,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    OrganisationActionTaskRuleOfEngagementStatusCategoryCode (const ::std::string& s,
                                                              const ::xercesc::DOMElement* e,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    OrganisationActionTaskRuleOfEngagementStatusCategoryCode (const OrganisationActionTaskRuleOfEngagementStatusCategoryCode& x,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    virtual OrganisationActionTaskRuleOfEngagementStatusCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationActionTaskRuleOfEngagementStatusCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationActionTaskRuleOfEngagementStatusCategoryCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationActionTaskRuleOfEngagementStatusCategoryCode_convert () const;

    public:
    static const char* const _xsd_OrganisationActionTaskRuleOfEngagementStatusCategoryCode_literals_[5];
    static const value _xsd_OrganisationActionTaskRuleOfEngagementStatusCategoryCode_indexes_[5];
  };

  class OrganisationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CO,
      NOS,
      UN
    };

    OrganisationCategoryCode (value v);

    OrganisationCategoryCode (const char* v);

    OrganisationCategoryCode (const ::std::string& v);

    OrganisationCategoryCode (const ::xml_schema::token& v);

    OrganisationCategoryCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    OrganisationCategoryCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    OrganisationCategoryCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    OrganisationCategoryCode (const OrganisationCategoryCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual OrganisationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationCategoryCode_convert () const;

    public:
    static const char* const _xsd_OrganisationCategoryCode_literals_[3];
    static const value _xsd_OrganisationCategoryCode_indexes_[3];
  };

  class OrganisationMaterielTypeAssociationReportableTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      LFRIL,
      RIC
    };

    OrganisationMaterielTypeAssociationReportableTypeCode (value v);

    OrganisationMaterielTypeAssociationReportableTypeCode (const char* v);

    OrganisationMaterielTypeAssociationReportableTypeCode (const ::std::string& v);

    OrganisationMaterielTypeAssociationReportableTypeCode (const ::xml_schema::token& v);

    OrganisationMaterielTypeAssociationReportableTypeCode (const ::xercesc::DOMElement& e,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

    OrganisationMaterielTypeAssociationReportableTypeCode (const ::xercesc::DOMAttr& a,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

    OrganisationMaterielTypeAssociationReportableTypeCode (const ::std::string& s,
                                                           const ::xercesc::DOMElement* e,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

    OrganisationMaterielTypeAssociationReportableTypeCode (const OrganisationMaterielTypeAssociationReportableTypeCode& x,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

    virtual OrganisationMaterielTypeAssociationReportableTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationMaterielTypeAssociationReportableTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationMaterielTypeAssociationReportableTypeCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationMaterielTypeAssociationReportableTypeCode_convert () const;

    public:
    static const char* const _xsd_OrganisationMaterielTypeAssociationReportableTypeCode_literals_[2];
    static const value _xsd_OrganisationMaterielTypeAssociationReportableTypeCode_indexes_[2];
  };

  class OrganisationPlanOrderAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      APPR,
      DISTR,
      PREP,
      EXEC,
      ISSHQ
    };

    OrganisationPlanOrderAssociationCategoryCode (value v);

    OrganisationPlanOrderAssociationCategoryCode (const char* v);

    OrganisationPlanOrderAssociationCategoryCode (const ::std::string& v);

    OrganisationPlanOrderAssociationCategoryCode (const ::xml_schema::token& v);

    OrganisationPlanOrderAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    OrganisationPlanOrderAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    OrganisationPlanOrderAssociationCategoryCode (const ::std::string& s,
                                                  const ::xercesc::DOMElement* e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    OrganisationPlanOrderAssociationCategoryCode (const OrganisationPlanOrderAssociationCategoryCode& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    virtual OrganisationPlanOrderAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationPlanOrderAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationPlanOrderAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationPlanOrderAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_OrganisationPlanOrderAssociationCategoryCode_literals_[5];
    static const value _xsd_OrganisationPlanOrderAssociationCategoryCode_indexes_[5];
  };

  class OrganisationReferenceAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ISAPRL,
      ISCLSF,
      ISCNGF,
      ISCRTR,
      ISPLNR,
      ISRLSA
    };

    OrganisationReferenceAssociationCategoryCode (value v);

    OrganisationReferenceAssociationCategoryCode (const char* v);

    OrganisationReferenceAssociationCategoryCode (const ::std::string& v);

    OrganisationReferenceAssociationCategoryCode (const ::xml_schema::token& v);

    OrganisationReferenceAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    OrganisationReferenceAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    OrganisationReferenceAssociationCategoryCode (const ::std::string& s,
                                                  const ::xercesc::DOMElement* e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    OrganisationReferenceAssociationCategoryCode (const OrganisationReferenceAssociationCategoryCode& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    virtual OrganisationReferenceAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationReferenceAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationReferenceAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationReferenceAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_OrganisationReferenceAssociationCategoryCode_literals_[6];
    static const value _xsd_OrganisationReferenceAssociationCategoryCode_indexes_[6];
  };

  class OrganisationStatusAvailabilityCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AFT30D,
      BTW163,
      BTW484,
      BTW515,
      NA,
      WTN48H
    };

    OrganisationStatusAvailabilityCode (value v);

    OrganisationStatusAvailabilityCode (const char* v);

    OrganisationStatusAvailabilityCode (const ::std::string& v);

    OrganisationStatusAvailabilityCode (const ::xml_schema::token& v);

    OrganisationStatusAvailabilityCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    OrganisationStatusAvailabilityCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    OrganisationStatusAvailabilityCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    OrganisationStatusAvailabilityCode (const OrganisationStatusAvailabilityCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual OrganisationStatusAvailabilityCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationStatusAvailabilityCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationStatusAvailabilityCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationStatusAvailabilityCode_convert () const;

    public:
    static const char* const _xsd_OrganisationStatusAvailabilityCode_literals_[6];
    static const value _xsd_OrganisationStatusAvailabilityCode_indexes_[6];
  };

  class OrganisationStatusCbrnDressStateCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MOPP0,
      MOPP1,
      MOPP2,
      MOPP3,
      MOPPRY
    };

    OrganisationStatusCbrnDressStateCode (value v);

    OrganisationStatusCbrnDressStateCode (const char* v);

    OrganisationStatusCbrnDressStateCode (const ::std::string& v);

    OrganisationStatusCbrnDressStateCode (const ::xml_schema::token& v);

    OrganisationStatusCbrnDressStateCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    OrganisationStatusCbrnDressStateCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    OrganisationStatusCbrnDressStateCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    OrganisationStatusCbrnDressStateCode (const OrganisationStatusCbrnDressStateCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual OrganisationStatusCbrnDressStateCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationStatusCbrnDressStateCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationStatusCbrnDressStateCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationStatusCbrnDressStateCode_convert () const;

    public:
    static const char* const _xsd_OrganisationStatusCbrnDressStateCode_literals_[5];
    static const value _xsd_OrganisationStatusCbrnDressStateCode_indexes_[5];
  };

  class OrganisationStatusCommandAndControlRoleCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ADVNCP,
      FRWDHQ,
      LOGCP,
      LPFRGE,
      MAINCP,
      MOBLCP,
      MOBLHQ,
      NATLHQ,
      NKN,
      PEACCP,
      PEACHQ,
      PRWRHQ,
      REARCP,
      RESVCP,
      STATCP,
      STATHQ,
      STUPCP,
      STUPHQ,
      TACTCP,
      TACTHQ
    };

    OrganisationStatusCommandAndControlRoleCode (value v);

    OrganisationStatusCommandAndControlRoleCode (const char* v);

    OrganisationStatusCommandAndControlRoleCode (const ::std::string& v);

    OrganisationStatusCommandAndControlRoleCode (const ::xml_schema::token& v);

    OrganisationStatusCommandAndControlRoleCode (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    OrganisationStatusCommandAndControlRoleCode (const ::xercesc::DOMAttr& a,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    OrganisationStatusCommandAndControlRoleCode (const ::std::string& s,
                                                 const ::xercesc::DOMElement* e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    OrganisationStatusCommandAndControlRoleCode (const OrganisationStatusCommandAndControlRoleCode& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual OrganisationStatusCommandAndControlRoleCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationStatusCommandAndControlRoleCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationStatusCommandAndControlRoleCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationStatusCommandAndControlRoleCode_convert () const;

    public:
    static const char* const _xsd_OrganisationStatusCommandAndControlRoleCode_literals_[20];
    static const value _xsd_OrganisationStatusCommandAndControlRoleCode_indexes_[20];
  };

  class OrganisationStatusCommitmentStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      COMM,
      UNCOMM
    };

    OrganisationStatusCommitmentStatusCode (value v);

    OrganisationStatusCommitmentStatusCode (const char* v);

    OrganisationStatusCommitmentStatusCode (const ::std::string& v);

    OrganisationStatusCommitmentStatusCode (const ::xml_schema::token& v);

    OrganisationStatusCommitmentStatusCode (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    OrganisationStatusCommitmentStatusCode (const ::xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    OrganisationStatusCommitmentStatusCode (const ::std::string& s,
                                            const ::xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    OrganisationStatusCommitmentStatusCode (const OrganisationStatusCommitmentStatusCode& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual OrganisationStatusCommitmentStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationStatusCommitmentStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationStatusCommitmentStatusCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationStatusCommitmentStatusCode_convert () const;

    public:
    static const char* const _xsd_OrganisationStatusCommitmentStatusCode_literals_[2];
    static const value _xsd_OrganisationStatusCommitmentStatusCode_indexes_[2];
  };

  class OrganisationStatusFireModeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HLDFIR,
      NKN,
      WPNFRE,
      WPNTGT
    };

    OrganisationStatusFireModeCode (value v);

    OrganisationStatusFireModeCode (const char* v);

    OrganisationStatusFireModeCode (const ::std::string& v);

    OrganisationStatusFireModeCode (const ::xml_schema::token& v);

    OrganisationStatusFireModeCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    OrganisationStatusFireModeCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    OrganisationStatusFireModeCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    OrganisationStatusFireModeCode (const OrganisationStatusFireModeCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual OrganisationStatusFireModeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationStatusFireModeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationStatusFireModeCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationStatusFireModeCode_convert () const;

    public:
    static const char* const _xsd_OrganisationStatusFireModeCode_literals_[4];
    static const value _xsd_OrganisationStatusFireModeCode_indexes_[4];
  };

  class OrganisationStatusOperationalStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MOPS,
      NKN,
      NOP,
      OPR,
      SOPS,
      TNOPS
    };

    OrganisationStatusOperationalStatusCode (value v);

    OrganisationStatusOperationalStatusCode (const char* v);

    OrganisationStatusOperationalStatusCode (const ::std::string& v);

    OrganisationStatusOperationalStatusCode (const ::xml_schema::token& v);

    OrganisationStatusOperationalStatusCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    OrganisationStatusOperationalStatusCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    OrganisationStatusOperationalStatusCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    OrganisationStatusOperationalStatusCode (const OrganisationStatusOperationalStatusCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual OrganisationStatusOperationalStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationStatusOperationalStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationStatusOperationalStatusCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationStatusOperationalStatusCode_convert () const;

    public:
    static const char* const _xsd_OrganisationStatusOperationalStatusCode_literals_[6];
    static const value _xsd_OrganisationStatusOperationalStatusCode_indexes_[6];
  };

  class OrganisationStatusOperationalStatusQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DSTRYD,
      HVYDAM,
      LGTDAM,
      LST,
      LVR,
      MODDAM,
      NKN
    };

    OrganisationStatusOperationalStatusQualifierCode (value v);

    OrganisationStatusOperationalStatusQualifierCode (const char* v);

    OrganisationStatusOperationalStatusQualifierCode (const ::std::string& v);

    OrganisationStatusOperationalStatusQualifierCode (const ::xml_schema::token& v);

    OrganisationStatusOperationalStatusQualifierCode (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    OrganisationStatusOperationalStatusQualifierCode (const ::xercesc::DOMAttr& a,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    OrganisationStatusOperationalStatusQualifierCode (const ::std::string& s,
                                                      const ::xercesc::DOMElement* e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    OrganisationStatusOperationalStatusQualifierCode (const OrganisationStatusOperationalStatusQualifierCode& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    virtual OrganisationStatusOperationalStatusQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationStatusOperationalStatusQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationStatusOperationalStatusQualifierCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationStatusOperationalStatusQualifierCode_convert () const;

    public:
    static const char* const _xsd_OrganisationStatusOperationalStatusQualifierCode_literals_[7];
    static const value _xsd_OrganisationStatusOperationalStatusQualifierCode_indexes_[7];
  };

  class OrganisationStatusReadinessCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIRALR,
      BTLSTN,
      GRDALR,
      NKN,
      NOS,
      NRD12H,
      RDNS1,
      RDNS2,
      RDNS3,
      RDNS4,
      RDNS5,
      RDNS6,
      RDNS7,
      RDNS8,
      RDNS9,
      RDY10M,
      RDY12H,
      RDY15M,
      RDY20M,
      RDY2H,
      RDY30M,
      RDY3H,
      RDY5M,
      RDY60M,
      RDY6H,
      RDYL5M,
      RED,
      RNYALR,
      WHITE,
      WT10D,
      WT180D,
      WT20D,
      WT2D,
      WT30D,
      WT365D,
      WT5D,
      WT60D,
      WT90D,
      YELLOW
    };

    OrganisationStatusReadinessCode (value v);

    OrganisationStatusReadinessCode (const char* v);

    OrganisationStatusReadinessCode (const ::std::string& v);

    OrganisationStatusReadinessCode (const ::xml_schema::token& v);

    OrganisationStatusReadinessCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    OrganisationStatusReadinessCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    OrganisationStatusReadinessCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    OrganisationStatusReadinessCode (const OrganisationStatusReadinessCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual OrganisationStatusReadinessCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationStatusReadinessCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationStatusReadinessCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationStatusReadinessCode_convert () const;

    public:
    static const char* const _xsd_OrganisationStatusReadinessCode_literals_[39];
    static const value _xsd_OrganisationStatusReadinessCode_indexes_[39];
  };

  class OrganisationStatusReinforcementCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DETD,
      NKN,
      NORM,
      REIN,
      RIDT
    };

    OrganisationStatusReinforcementCode (value v);

    OrganisationStatusReinforcementCode (const char* v);

    OrganisationStatusReinforcementCode (const ::std::string& v);

    OrganisationStatusReinforcementCode (const ::xml_schema::token& v);

    OrganisationStatusReinforcementCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    OrganisationStatusReinforcementCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    OrganisationStatusReinforcementCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    OrganisationStatusReinforcementCode (const OrganisationStatusReinforcementCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual OrganisationStatusReinforcementCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationStatusReinforcementCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationStatusReinforcementCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationStatusReinforcementCode_convert () const;

    public:
    static const char* const _xsd_OrganisationStatusReinforcementCode_literals_[5];
    static const value _xsd_OrganisationStatusReinforcementCode_indexes_[5];
  };

  class OrganisationStatusReserveIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    OrganisationStatusReserveIndicatorCode (value v);

    OrganisationStatusReserveIndicatorCode (const char* v);

    OrganisationStatusReserveIndicatorCode (const ::std::string& v);

    OrganisationStatusReserveIndicatorCode (const ::xml_schema::token& v);

    OrganisationStatusReserveIndicatorCode (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    OrganisationStatusReserveIndicatorCode (const ::xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    OrganisationStatusReserveIndicatorCode (const ::std::string& s,
                                            const ::xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    OrganisationStatusReserveIndicatorCode (const OrganisationStatusReserveIndicatorCode& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual OrganisationStatusReserveIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationStatusReserveIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationStatusReserveIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationStatusReserveIndicatorCode_convert () const;

    public:
    static const char* const _xsd_OrganisationStatusReserveIndicatorCode_literals_[2];
    static const value _xsd_OrganisationStatusReserveIndicatorCode_indexes_[2];
  };

  class OrganisationStatusTrainingCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AMBER,
      GREEN,
      NKN,
      RED
    };

    OrganisationStatusTrainingCode (value v);

    OrganisationStatusTrainingCode (const char* v);

    OrganisationStatusTrainingCode (const ::std::string& v);

    OrganisationStatusTrainingCode (const ::xml_schema::token& v);

    OrganisationStatusTrainingCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    OrganisationStatusTrainingCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    OrganisationStatusTrainingCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    OrganisationStatusTrainingCode (const OrganisationStatusTrainingCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual OrganisationStatusTrainingCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationStatusTrainingCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationStatusTrainingCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationStatusTrainingCode_convert () const;

    public:
    static const char* const _xsd_OrganisationStatusTrainingCode_literals_[4];
    static const value _xsd_OrganisationStatusTrainingCode_indexes_[4];
  };

  class OrganisationStatusUsageStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      INACT,
      NKN,
      OUTACT
    };

    OrganisationStatusUsageStatusCode (value v);

    OrganisationStatusUsageStatusCode (const char* v);

    OrganisationStatusUsageStatusCode (const ::std::string& v);

    OrganisationStatusUsageStatusCode (const ::xml_schema::token& v);

    OrganisationStatusUsageStatusCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    OrganisationStatusUsageStatusCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    OrganisationStatusUsageStatusCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    OrganisationStatusUsageStatusCode (const OrganisationStatusUsageStatusCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual OrganisationStatusUsageStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationStatusUsageStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationStatusUsageStatusCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationStatusUsageStatusCode_convert () const;

    public:
    static const char* const _xsd_OrganisationStatusUsageStatusCode_literals_[3];
    static const value _xsd_OrganisationStatusUsageStatusCode_indexes_[3];
  };

  class OrganisationTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CIVPST,
      GRPORG,
      GVTORG,
      NOS,
      PVSORG
    };

    OrganisationTypeCategoryCode (value v);

    OrganisationTypeCategoryCode (const char* v);

    OrganisationTypeCategoryCode (const ::std::string& v);

    OrganisationTypeCategoryCode (const ::xml_schema::token& v);

    OrganisationTypeCategoryCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    OrganisationTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    OrganisationTypeCategoryCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    OrganisationTypeCategoryCode (const OrganisationTypeCategoryCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual OrganisationTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_OrganisationTypeCategoryCode_literals_[5];
    static const value _xsd_OrganisationTypeCategoryCode_indexes_[5];
  };

  class OrganisationTypeCommandAndControlCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIROPC,
      ARCNTC,
      AROPCC,
      ARSOPC,
      AWACS,
      CAOC,
      CC,
      CNTRPC,
      CNTRPP,
      CP,
      DASC,
      DASCAR,
      FACC,
      GRBOPC,
      HQ,
      MTACMC,
      MTADRC,
      MTAOPC,
      NKN,
      NOS,
      OC,
      RAPPRC,
      SAMOPC,
      SQDOPC,
      TACOPC,
      TACP,
      WNGOPC
    };

    OrganisationTypeCommandAndControlCategoryCode (value v);

    OrganisationTypeCommandAndControlCategoryCode (const char* v);

    OrganisationTypeCommandAndControlCategoryCode (const ::std::string& v);

    OrganisationTypeCommandAndControlCategoryCode (const ::xml_schema::token& v);

    OrganisationTypeCommandAndControlCategoryCode (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    OrganisationTypeCommandAndControlCategoryCode (const ::xercesc::DOMAttr& a,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    OrganisationTypeCommandAndControlCategoryCode (const ::std::string& s,
                                                   const ::xercesc::DOMElement* e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    OrganisationTypeCommandAndControlCategoryCode (const OrganisationTypeCommandAndControlCategoryCode& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    virtual OrganisationTypeCommandAndControlCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationTypeCommandAndControlCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationTypeCommandAndControlCategoryCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationTypeCommandAndControlCategoryCode_convert () const;

    public:
    static const char* const _xsd_OrganisationTypeCommandAndControlCategoryCode_literals_[27];
    static const value _xsd_OrganisationTypeCommandAndControlCategoryCode_indexes_[27];
  };

  class OrganisationTypeCommandFunctionIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    OrganisationTypeCommandFunctionIndicatorCode (value v);

    OrganisationTypeCommandFunctionIndicatorCode (const char* v);

    OrganisationTypeCommandFunctionIndicatorCode (const ::std::string& v);

    OrganisationTypeCommandFunctionIndicatorCode (const ::xml_schema::token& v);

    OrganisationTypeCommandFunctionIndicatorCode (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    OrganisationTypeCommandFunctionIndicatorCode (const ::xercesc::DOMAttr& a,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    OrganisationTypeCommandFunctionIndicatorCode (const ::std::string& s,
                                                  const ::xercesc::DOMElement* e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    OrganisationTypeCommandFunctionIndicatorCode (const OrganisationTypeCommandFunctionIndicatorCode& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    virtual OrganisationTypeCommandFunctionIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganisationTypeCommandFunctionIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_OrganisationTypeCommandFunctionIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_OrganisationTypeCommandFunctionIndicatorCode_convert () const;

    public:
    static const char* const _xsd_OrganisationTypeCommandFunctionIndicatorCode_literals_[2];
    static const value _xsd_OrganisationTypeCommandFunctionIndicatorCode_indexes_[2];
  };

  class PersistencyCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NKN,
      NONPRS,
      PRSTNT,
      THCKND
    };

    PersistencyCode (value v);

    PersistencyCode (const char* v);

    PersistencyCode (const ::std::string& v);

    PersistencyCode (const ::xml_schema::token& v);

    PersistencyCode (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    PersistencyCode (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    PersistencyCode (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    PersistencyCode (const PersistencyCode& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual PersistencyCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PersistencyCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PersistencyCode_convert ();
    }

    protected:
    value
    _xsd_PersistencyCode_convert () const;

    public:
    static const char* const _xsd_PersistencyCode_literals_[4];
    static const value _xsd_PersistencyCode_indexes_[4];
  };

  class PersonBloodTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      APLUS,
      AMNUS,
      ABPLUS,
      ABMNUS,
      BPLUS,
      BMNUS,
      NKN,
      OPLUS,
      OMNUS
    };

    PersonBloodTypeCode (value v);

    PersonBloodTypeCode (const char* v);

    PersonBloodTypeCode (const ::std::string& v);

    PersonBloodTypeCode (const ::xml_schema::token& v);

    PersonBloodTypeCode (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    PersonBloodTypeCode (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    PersonBloodTypeCode (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    PersonBloodTypeCode (const PersonBloodTypeCode& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual PersonBloodTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PersonBloodTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PersonBloodTypeCode_convert ();
    }

    protected:
    value
    _xsd_PersonBloodTypeCode_convert () const;

    public:
    static const char* const _xsd_PersonBloodTypeCode_literals_[9];
    static const value _xsd_PersonBloodTypeCode_indexes_[9];
  };

  class PersonIdentificationDocumentCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CIVID,
      MILID,
      MILORD,
      NOS,
      PSSPRT
    };

    PersonIdentificationDocumentCode (value v);

    PersonIdentificationDocumentCode (const char* v);

    PersonIdentificationDocumentCode (const ::std::string& v);

    PersonIdentificationDocumentCode (const ::xml_schema::token& v);

    PersonIdentificationDocumentCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    PersonIdentificationDocumentCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    PersonIdentificationDocumentCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    PersonIdentificationDocumentCode (const PersonIdentificationDocumentCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual PersonIdentificationDocumentCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PersonIdentificationDocumentCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PersonIdentificationDocumentCode_convert ();
    }

    protected:
    value
    _xsd_PersonIdentificationDocumentCode_convert () const;

    public:
    static const char* const _xsd_PersonIdentificationDocumentCode_literals_[5];
    static const value _xsd_PersonIdentificationDocumentCode_indexes_[5];
  };

  class PersonLanguageSkillGeneralProficiencyCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ELEM,
      EXCLNT,
      FAIR,
      NKN,
      NONE,
      VERY
    };

    PersonLanguageSkillGeneralProficiencyCode (value v);

    PersonLanguageSkillGeneralProficiencyCode (const char* v);

    PersonLanguageSkillGeneralProficiencyCode (const ::std::string& v);

    PersonLanguageSkillGeneralProficiencyCode (const ::xml_schema::token& v);

    PersonLanguageSkillGeneralProficiencyCode (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    PersonLanguageSkillGeneralProficiencyCode (const ::xercesc::DOMAttr& a,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    PersonLanguageSkillGeneralProficiencyCode (const ::std::string& s,
                                               const ::xercesc::DOMElement* e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    PersonLanguageSkillGeneralProficiencyCode (const PersonLanguageSkillGeneralProficiencyCode& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual PersonLanguageSkillGeneralProficiencyCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PersonLanguageSkillGeneralProficiencyCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PersonLanguageSkillGeneralProficiencyCode_convert ();
    }

    protected:
    value
    _xsd_PersonLanguageSkillGeneralProficiencyCode_convert () const;

    public:
    static const char* const _xsd_PersonLanguageSkillGeneralProficiencyCode_literals_[6];
    static const value _xsd_PersonLanguageSkillGeneralProficiencyCode_indexes_[6];
  };

  class PersonProfessingIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    PersonProfessingIndicatorCode (value v);

    PersonProfessingIndicatorCode (const char* v);

    PersonProfessingIndicatorCode (const ::std::string& v);

    PersonProfessingIndicatorCode (const ::xml_schema::token& v);

    PersonProfessingIndicatorCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    PersonProfessingIndicatorCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    PersonProfessingIndicatorCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    PersonProfessingIndicatorCode (const PersonProfessingIndicatorCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual PersonProfessingIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PersonProfessingIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PersonProfessingIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_PersonProfessingIndicatorCode_convert () const;

    public:
    static const char* const _xsd_PersonProfessingIndicatorCode_literals_[2];
    static const value _xsd_PersonProfessingIndicatorCode_indexes_[2];
  };

  class PersonStatusDutyStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ABS,
      ADU,
      AKIA,
      ARR,
      DEC,
      DESRTD,
      HSP,
      HST,
      MIS,
      NKN,
      OLV,
      POW
    };

    PersonStatusDutyStatusCode (value v);

    PersonStatusDutyStatusCode (const char* v);

    PersonStatusDutyStatusCode (const ::std::string& v);

    PersonStatusDutyStatusCode (const ::xml_schema::token& v);

    PersonStatusDutyStatusCode (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    PersonStatusDutyStatusCode (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    PersonStatusDutyStatusCode (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    PersonStatusDutyStatusCode (const PersonStatusDutyStatusCode& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual PersonStatusDutyStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PersonStatusDutyStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PersonStatusDutyStatusCode_convert ();
    }

    protected:
    value
    _xsd_PersonStatusDutyStatusCode_convert () const;

    public:
    static const char* const _xsd_PersonStatusDutyStatusCode_literals_[12];
    static const value _xsd_PersonStatusDutyStatusCode_indexes_[12];
  };

  class PersonStatusPhysicalStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FT,
      IN,
      IW,
      NKN,
      SI
    };

    PersonStatusPhysicalStatusCode (value v);

    PersonStatusPhysicalStatusCode (const char* v);

    PersonStatusPhysicalStatusCode (const ::std::string& v);

    PersonStatusPhysicalStatusCode (const ::xml_schema::token& v);

    PersonStatusPhysicalStatusCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    PersonStatusPhysicalStatusCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    PersonStatusPhysicalStatusCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    PersonStatusPhysicalStatusCode (const PersonStatusPhysicalStatusCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual PersonStatusPhysicalStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PersonStatusPhysicalStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PersonStatusPhysicalStatusCode_convert ();
    }

    protected:
    value
    _xsd_PersonStatusPhysicalStatusCode_convert () const;

    public:
    static const char* const _xsd_PersonStatusPhysicalStatusCode_literals_[5];
    static const value _xsd_PersonStatusPhysicalStatusCode_indexes_[5];
  };

  class PersonStatusPhysicalStatusQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ILLCNT,
      ILLNCN,
      ILLUNK,
      INJRD,
      NKN,
      PRGNT,
      WNDD
    };

    PersonStatusPhysicalStatusQualifierCode (value v);

    PersonStatusPhysicalStatusQualifierCode (const char* v);

    PersonStatusPhysicalStatusQualifierCode (const ::std::string& v);

    PersonStatusPhysicalStatusQualifierCode (const ::xml_schema::token& v);

    PersonStatusPhysicalStatusQualifierCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    PersonStatusPhysicalStatusQualifierCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    PersonStatusPhysicalStatusQualifierCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    PersonStatusPhysicalStatusQualifierCode (const PersonStatusPhysicalStatusQualifierCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual PersonStatusPhysicalStatusQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PersonStatusPhysicalStatusQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PersonStatusPhysicalStatusQualifierCode_convert ();
    }

    protected:
    value
    _xsd_PersonStatusPhysicalStatusQualifierCode_convert () const;

    public:
    static const char* const _xsd_PersonStatusPhysicalStatusQualifierCode_literals_[7];
    static const value _xsd_PersonStatusPhysicalStatusQualifierCode_indexes_[7];
  };

  class PersonStatusReserveIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    PersonStatusReserveIndicatorCode (value v);

    PersonStatusReserveIndicatorCode (const char* v);

    PersonStatusReserveIndicatorCode (const ::std::string& v);

    PersonStatusReserveIndicatorCode (const ::xml_schema::token& v);

    PersonStatusReserveIndicatorCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    PersonStatusReserveIndicatorCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    PersonStatusReserveIndicatorCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    PersonStatusReserveIndicatorCode (const PersonStatusReserveIndicatorCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual PersonStatusReserveIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PersonStatusReserveIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PersonStatusReserveIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_PersonStatusReserveIndicatorCode_convert () const;

    public:
    static const char* const _xsd_PersonStatusReserveIndicatorCode_literals_[2];
    static const value _xsd_PersonStatusReserveIndicatorCode_indexes_[2];
  };

  class PersonTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CIV,
      MILTRY,
      NKN,
      NOS,
      PAR
    };

    PersonTypeCategoryCode (value v);

    PersonTypeCategoryCode (const char* v);

    PersonTypeCategoryCode (const ::std::string& v);

    PersonTypeCategoryCode (const ::xml_schema::token& v);

    PersonTypeCategoryCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    PersonTypeCategoryCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    PersonTypeCategoryCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    PersonTypeCategoryCode (const PersonTypeCategoryCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual PersonTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PersonTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PersonTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_PersonTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_PersonTypeCategoryCode_literals_[5];
    static const value _xsd_PersonTypeCategoryCode_indexes_[5];
  };

  class PersonTypeRankCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      EPTE,
      NCO,
      NKN,
      OF1,
      OF10,
      OF2,
      OF3,
      OF4,
      OF5,
      OF6,
      OF7,
      OF8,
      OF9,
      OFFR,
      OR1,
      OR2,
      OR3,
      OR4,
      OR5,
      OR6,
      OR7,
      OR8,
      OR9,
      OTHR
    };

    PersonTypeRankCode (value v);

    PersonTypeRankCode (const char* v);

    PersonTypeRankCode (const ::std::string& v);

    PersonTypeRankCode (const ::xml_schema::token& v);

    PersonTypeRankCode (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    PersonTypeRankCode (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    PersonTypeRankCode (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    PersonTypeRankCode (const PersonTypeRankCode& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual PersonTypeRankCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PersonTypeRankCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PersonTypeRankCode_convert ();
    }

    protected:
    value
    _xsd_PersonTypeRankCode_convert () const;

    public:
    static const char* const _xsd_PersonTypeRankCode_literals_[24];
    static const value _xsd_PersonTypeRankCode_indexes_[24];
  };

  class PersonTypeSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DEFCTR,
      DETNEE,
      DSPLPR,
      DSRTR,
      ENGNER,
      GOVEMP,
      INTLCT,
      JRNLST,
      LNDOWN,
      MEDCAL,
      MEDINT,
      MEDLCL,
      MEDNAT,
      MEDNOS,
      MESSNG,
      MISSNR,
      MRCHNT,
      NKN,
      NONGVE,
      NOS,
      PARARS,
      PARTSN,
      PILOT,
      POLCHF,
      POLCMN,
      POW,
      PRSNR,
      REFUGE,
      REPAT,
      SABOTR,
      SPY,
      TERRST,
      UNLCMB,
      VILELD,
      VIP,
      WRITER
    };

    PersonTypeSubcategoryCode (value v);

    PersonTypeSubcategoryCode (const char* v);

    PersonTypeSubcategoryCode (const ::std::string& v);

    PersonTypeSubcategoryCode (const ::xml_schema::token& v);

    PersonTypeSubcategoryCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    PersonTypeSubcategoryCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    PersonTypeSubcategoryCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    PersonTypeSubcategoryCode (const PersonTypeSubcategoryCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual PersonTypeSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PersonTypeSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PersonTypeSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_PersonTypeSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_PersonTypeSubcategoryCode_literals_[36];
    static const value _xsd_PersonTypeSubcategoryCode_indexes_[36];
  };

  class PhysicalAddressCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MLADDR,
      NOS,
      PHADDR,
      PSTMRK,
      RTADDR
    };

    PhysicalAddressCategoryCode (value v);

    PhysicalAddressCategoryCode (const char* v);

    PhysicalAddressCategoryCode (const ::std::string& v);

    PhysicalAddressCategoryCode (const ::xml_schema::token& v);

    PhysicalAddressCategoryCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    PhysicalAddressCategoryCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    PhysicalAddressCategoryCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    PhysicalAddressCategoryCode (const PhysicalAddressCategoryCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual PhysicalAddressCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PhysicalAddressCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PhysicalAddressCategoryCode_convert ();
    }

    protected:
    value
    _xsd_PhysicalAddressCategoryCode_convert () const;

    public:
    static const char* const _xsd_PhysicalAddressCategoryCode_literals_[5];
    static const value _xsd_PhysicalAddressCategoryCode_indexes_[5];
  };

  class PlanCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      OPLAN,
      NOS
    };

    PlanCategoryCode (value v);

    PlanCategoryCode (const char* v);

    PlanCategoryCode (const ::std::string& v);

    PlanCategoryCode (const ::xml_schema::token& v);

    PlanCategoryCode (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    PlanCategoryCode (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    PlanCategoryCode (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    PlanCategoryCode (const PlanCategoryCode& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual PlanCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PlanCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PlanCategoryCode_convert ();
    }

    protected:
    value
    _xsd_PlanCategoryCode_convert () const;

    public:
    static const char* const _xsd_PlanCategoryCode_literals_[2];
    static const value _xsd_PlanCategoryCode_indexes_[2];
  };

  class PlanOrderAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ISAMND,
      ISDTCH,
      ISORDR,
      ISSPRD,
      ISSUPP
    };

    PlanOrderAssociationCategoryCode (value v);

    PlanOrderAssociationCategoryCode (const char* v);

    PlanOrderAssociationCategoryCode (const ::std::string& v);

    PlanOrderAssociationCategoryCode (const ::xml_schema::token& v);

    PlanOrderAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    PlanOrderAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    PlanOrderAssociationCategoryCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    PlanOrderAssociationCategoryCode (const PlanOrderAssociationCategoryCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual PlanOrderAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PlanOrderAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PlanOrderAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_PlanOrderAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_PlanOrderAssociationCategoryCode_literals_[5];
    static const value _xsd_PlanOrderAssociationCategoryCode_indexes_[5];
  };

  class PlanOrderCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ORDER,
      PLAN
    };

    PlanOrderCategoryCode (value v);

    PlanOrderCategoryCode (const char* v);

    PlanOrderCategoryCode (const ::std::string& v);

    PlanOrderCategoryCode (const ::xml_schema::token& v);

    PlanOrderCategoryCode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    PlanOrderCategoryCode (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    PlanOrderCategoryCode (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    PlanOrderCategoryCode (const PlanOrderCategoryCode& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual PlanOrderCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PlanOrderCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PlanOrderCategoryCode_convert ();
    }

    protected:
    value
    _xsd_PlanOrderCategoryCode_convert () const;

    public:
    static const char* const _xsd_PlanOrderCategoryCode_literals_[2];
    static const value _xsd_PlanOrderCategoryCode_indexes_[2];
  };

  class PlanOrderComponentContentReferenceCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HASINS,
      ISAMPL,
      ISDISS,
      ISPROV,
      ISRCRD,
      ISSPCM,
      ISSPPM
    };

    PlanOrderComponentContentReferenceCategoryCode (value v);

    PlanOrderComponentContentReferenceCategoryCode (const char* v);

    PlanOrderComponentContentReferenceCategoryCode (const ::std::string& v);

    PlanOrderComponentContentReferenceCategoryCode (const ::xml_schema::token& v);

    PlanOrderComponentContentReferenceCategoryCode (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    PlanOrderComponentContentReferenceCategoryCode (const ::xercesc::DOMAttr& a,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    PlanOrderComponentContentReferenceCategoryCode (const ::std::string& s,
                                                    const ::xercesc::DOMElement* e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    PlanOrderComponentContentReferenceCategoryCode (const PlanOrderComponentContentReferenceCategoryCode& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    virtual PlanOrderComponentContentReferenceCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PlanOrderComponentContentReferenceCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PlanOrderComponentContentReferenceCategoryCode_convert ();
    }

    protected:
    value
    _xsd_PlanOrderComponentContentReferenceCategoryCode_convert () const;

    public:
    static const char* const _xsd_PlanOrderComponentContentReferenceCategoryCode_literals_[7];
    static const value _xsd_PlanOrderComponentContentReferenceCategoryCode_indexes_[7];
  };

  class PlanOrderComponentStructureCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ISDISS,
      ISPRNT,
      ISREPL
    };

    PlanOrderComponentStructureCategoryCode (value v);

    PlanOrderComponentStructureCategoryCode (const char* v);

    PlanOrderComponentStructureCategoryCode (const ::std::string& v);

    PlanOrderComponentStructureCategoryCode (const ::xml_schema::token& v);

    PlanOrderComponentStructureCategoryCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    PlanOrderComponentStructureCategoryCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    PlanOrderComponentStructureCategoryCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    PlanOrderComponentStructureCategoryCode (const PlanOrderComponentStructureCategoryCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual PlanOrderComponentStructureCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PlanOrderComponentStructureCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PlanOrderComponentStructureCategoryCode_convert ();
    }

    protected:
    value
    _xsd_PlanOrderComponentStructureCategoryCode_convert () const;

    public:
    static const char* const _xsd_PlanOrderComponentStructureCategoryCode_literals_[3];
    static const value _xsd_PlanOrderComponentStructureCategoryCode_indexes_[3];
  };

  class PlanOrderDistributionAcknowledgementCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ACK,
      READ,
      RCVD
    };

    PlanOrderDistributionAcknowledgementCode (value v);

    PlanOrderDistributionAcknowledgementCode (const char* v);

    PlanOrderDistributionAcknowledgementCode (const ::std::string& v);

    PlanOrderDistributionAcknowledgementCode (const ::xml_schema::token& v);

    PlanOrderDistributionAcknowledgementCode (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    PlanOrderDistributionAcknowledgementCode (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    PlanOrderDistributionAcknowledgementCode (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    PlanOrderDistributionAcknowledgementCode (const PlanOrderDistributionAcknowledgementCode& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual PlanOrderDistributionAcknowledgementCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PlanOrderDistributionAcknowledgementCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PlanOrderDistributionAcknowledgementCode_convert ();
    }

    protected:
    value
    _xsd_PlanOrderDistributionAcknowledgementCode_convert () const;

    public:
    static const char* const _xsd_PlanOrderDistributionAcknowledgementCode_literals_[3];
    static const value _xsd_PlanOrderDistributionAcknowledgementCode_indexes_[3];
  };

  class PlanOrderDistributionCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DSTEXE,
      DSTINF
    };

    PlanOrderDistributionCategoryCode (value v);

    PlanOrderDistributionCategoryCode (const char* v);

    PlanOrderDistributionCategoryCode (const ::std::string& v);

    PlanOrderDistributionCategoryCode (const ::xml_schema::token& v);

    PlanOrderDistributionCategoryCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    PlanOrderDistributionCategoryCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    PlanOrderDistributionCategoryCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    PlanOrderDistributionCategoryCode (const PlanOrderDistributionCategoryCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual PlanOrderDistributionCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PlanOrderDistributionCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PlanOrderDistributionCategoryCode_convert ();
    }

    protected:
    value
    _xsd_PlanOrderDistributionCategoryCode_convert () const;

    public:
    static const char* const _xsd_PlanOrderDistributionCategoryCode_literals_[2];
    static const value _xsd_PlanOrderDistributionCategoryCode_indexes_[2];
  };

  class PlanOrderHeaderContentTimeZoneCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      Z,
      A,
      B,
      C,
      D,
      E,
      F,
      G,
      H,
      I,
      K,
      L,
      M,
      Y,
      X,
      W,
      V,
      U,
      T,
      S,
      R,
      Q,
      P,
      O,
      N
    };

    PlanOrderHeaderContentTimeZoneCode (value v);

    PlanOrderHeaderContentTimeZoneCode (const char* v);

    PlanOrderHeaderContentTimeZoneCode (const ::std::string& v);

    PlanOrderHeaderContentTimeZoneCode (const ::xml_schema::token& v);

    PlanOrderHeaderContentTimeZoneCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    PlanOrderHeaderContentTimeZoneCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    PlanOrderHeaderContentTimeZoneCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    PlanOrderHeaderContentTimeZoneCode (const PlanOrderHeaderContentTimeZoneCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual PlanOrderHeaderContentTimeZoneCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PlanOrderHeaderContentTimeZoneCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PlanOrderHeaderContentTimeZoneCode_convert ();
    }

    protected:
    value
    _xsd_PlanOrderHeaderContentTimeZoneCode_convert () const;

    public:
    static const char* const _xsd_PlanOrderHeaderContentTimeZoneCode_literals_[25];
    static const value _xsd_PlanOrderHeaderContentTimeZoneCode_indexes_[25];
  };

  class PlanStatusDevelopmentStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      COMPL,
      NCOMPL
    };

    PlanStatusDevelopmentStatusCode (value v);

    PlanStatusDevelopmentStatusCode (const char* v);

    PlanStatusDevelopmentStatusCode (const ::std::string& v);

    PlanStatusDevelopmentStatusCode (const ::xml_schema::token& v);

    PlanStatusDevelopmentStatusCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    PlanStatusDevelopmentStatusCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    PlanStatusDevelopmentStatusCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    PlanStatusDevelopmentStatusCode (const PlanStatusDevelopmentStatusCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual PlanStatusDevelopmentStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PlanStatusDevelopmentStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PlanStatusDevelopmentStatusCode_convert ();
    }

    protected:
    value
    _xsd_PlanStatusDevelopmentStatusCode_convert () const;

    public:
    static const char* const _xsd_PlanStatusDevelopmentStatusCode_literals_[2];
    static const value _xsd_PlanStatusDevelopmentStatusCode_indexes_[2];
  };

  class PlanStatusStateCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      APPRVD,
      CANCEL,
      WTHDRN
    };

    PlanStatusStateCode (value v);

    PlanStatusStateCode (const char* v);

    PlanStatusStateCode (const ::std::string& v);

    PlanStatusStateCode (const ::xml_schema::token& v);

    PlanStatusStateCode (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    PlanStatusStateCode (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    PlanStatusStateCode (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    PlanStatusStateCode (const PlanStatusStateCode& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual PlanStatusStateCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PlanStatusStateCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PlanStatusStateCode_convert ();
    }

    protected:
    value
    _xsd_PlanStatusStateCode_convert () const;

    public:
    static const char* const _xsd_PlanStatusStateCode_literals_[3];
    static const value _xsd_PlanStatusStateCode_indexes_[3];
  };

  class PointCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ABS,
      REL
    };

    PointCategoryCode (value v);

    PointCategoryCode (const char* v);

    PointCategoryCode (const ::std::string& v);

    PointCategoryCode (const ::xml_schema::token& v);

    PointCategoryCode (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    PointCategoryCode (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    PointCategoryCode (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    PointCategoryCode (const PointCategoryCode& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual PointCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PointCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PointCategoryCode_convert ();
    }

    protected:
    value
    _xsd_PointCategoryCode_convert () const;

    public:
    static const char* const _xsd_PointCategoryCode_literals_[2];
    static const value _xsd_PointCategoryCode_indexes_[2];
  };

  class PrecipitationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DRZLE,
      FDRZLE,
      FRAIN,
      HAIL,
      ICECRY,
      ICEPLT,
      NPR,
      RAIN,
      RAINSR,
      SLEET,
      SNOW,
      SNWGRN,
      SNWSHR
    };

    PrecipitationCategoryCode (value v);

    PrecipitationCategoryCode (const char* v);

    PrecipitationCategoryCode (const ::std::string& v);

    PrecipitationCategoryCode (const ::xml_schema::token& v);

    PrecipitationCategoryCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    PrecipitationCategoryCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    PrecipitationCategoryCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    PrecipitationCategoryCode (const PrecipitationCategoryCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual PrecipitationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PrecipitationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PrecipitationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_PrecipitationCategoryCode_convert () const;

    public:
    static const char* const _xsd_PrecipitationCategoryCode_literals_[13];
    static const value _xsd_PrecipitationCategoryCode_indexes_[13];
  };

  class PrivateSectorOrganisationTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AGRCTL,
      DEFIND,
      FSHIND,
      MFG,
      MULTIN,
      NEWSMD,
      NOS,
      PHLNTP,
      RETAIL,
      TRADE
    };

    PrivateSectorOrganisationTypeCategoryCode (value v);

    PrivateSectorOrganisationTypeCategoryCode (const char* v);

    PrivateSectorOrganisationTypeCategoryCode (const ::std::string& v);

    PrivateSectorOrganisationTypeCategoryCode (const ::xml_schema::token& v);

    PrivateSectorOrganisationTypeCategoryCode (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    PrivateSectorOrganisationTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    PrivateSectorOrganisationTypeCategoryCode (const ::std::string& s,
                                               const ::xercesc::DOMElement* e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    PrivateSectorOrganisationTypeCategoryCode (const PrivateSectorOrganisationTypeCategoryCode& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual PrivateSectorOrganisationTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PrivateSectorOrganisationTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PrivateSectorOrganisationTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_PrivateSectorOrganisationTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_PrivateSectorOrganisationTypeCategoryCode_literals_[10];
    static const value _xsd_PrivateSectorOrganisationTypeCategoryCode_indexes_[10];
  };

  class QuayContainerHandlingTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CNTSTR,
      EMPCNT,
      NOS,
      RCHSTK,
      RGHTER,
      SHNTER,
      SHPTSH
    };

    QuayContainerHandlingTypeCode (value v);

    QuayContainerHandlingTypeCode (const char* v);

    QuayContainerHandlingTypeCode (const ::std::string& v);

    QuayContainerHandlingTypeCode (const ::xml_schema::token& v);

    QuayContainerHandlingTypeCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    QuayContainerHandlingTypeCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    QuayContainerHandlingTypeCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    QuayContainerHandlingTypeCode (const QuayContainerHandlingTypeCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual QuayContainerHandlingTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    QuayContainerHandlingTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_QuayContainerHandlingTypeCode_convert ();
    }

    protected:
    value
    _xsd_QuayContainerHandlingTypeCode_convert () const;

    public:
    static const char* const _xsd_QuayContainerHandlingTypeCode_literals_[7];
    static const value _xsd_QuayContainerHandlingTypeCode_indexes_[7];
  };

  class QuayCraneOffloadingTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FLTCRN,
      NOS,
      RAILCR,
      STATCR,
      TRKCRW,
      WHLCRN
    };

    QuayCraneOffloadingTypeCode (value v);

    QuayCraneOffloadingTypeCode (const char* v);

    QuayCraneOffloadingTypeCode (const ::std::string& v);

    QuayCraneOffloadingTypeCode (const ::xml_schema::token& v);

    QuayCraneOffloadingTypeCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    QuayCraneOffloadingTypeCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    QuayCraneOffloadingTypeCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    QuayCraneOffloadingTypeCode (const QuayCraneOffloadingTypeCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual QuayCraneOffloadingTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    QuayCraneOffloadingTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_QuayCraneOffloadingTypeCode_convert ();
    }

    protected:
    value
    _xsd_QuayCraneOffloadingTypeCode_convert () const;

    public:
    static const char* const _xsd_QuayCraneOffloadingTypeCode_literals_[6];
    static const value _xsd_QuayCraneOffloadingTypeCode_indexes_[6];
  };

  class QuayRailServedIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    QuayRailServedIndicatorCode (value v);

    QuayRailServedIndicatorCode (const char* v);

    QuayRailServedIndicatorCode (const ::std::string& v);

    QuayRailServedIndicatorCode (const ::xml_schema::token& v);

    QuayRailServedIndicatorCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    QuayRailServedIndicatorCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    QuayRailServedIndicatorCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    QuayRailServedIndicatorCode (const QuayRailServedIndicatorCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual QuayRailServedIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    QuayRailServedIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_QuayRailServedIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_QuayRailServedIndicatorCode_convert () const;

    public:
    static const char* const _xsd_QuayRailServedIndicatorCode_literals_[2];
    static const value _xsd_QuayRailServedIndicatorCode_indexes_[2];
  };

  class QuayStorageCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CBRN,
      GRNSIL,
      HAZCAR,
      LQDSTR,
      MNTEXP,
      NOS,
      OPENAR,
      RFRGTD,
      VEHCLE,
      WARHSE
    };

    QuayStorageCode (value v);

    QuayStorageCode (const char* v);

    QuayStorageCode (const ::std::string& v);

    QuayStorageCode (const ::xml_schema::token& v);

    QuayStorageCode (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    QuayStorageCode (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    QuayStorageCode (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    QuayStorageCode (const QuayStorageCode& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual QuayStorageCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    QuayStorageCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_QuayStorageCode_convert ();
    }

    protected:
    value
    _xsd_QuayStorageCode_convert () const;

    public:
    static const char* const _xsd_QuayStorageCode_literals_[10];
    static const value _xsd_QuayStorageCode_indexes_[10];
  };

  class RadioactiveEventCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NOS,
      NUCEVT,
      RADALM,
      RADEVT
    };

    RadioactiveEventCategoryCode (value v);

    RadioactiveEventCategoryCode (const char* v);

    RadioactiveEventCategoryCode (const ::std::string& v);

    RadioactiveEventCategoryCode (const ::xml_schema::token& v);

    RadioactiveEventCategoryCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    RadioactiveEventCategoryCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    RadioactiveEventCategoryCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    RadioactiveEventCategoryCode (const RadioactiveEventCategoryCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual RadioactiveEventCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RadioactiveEventCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RadioactiveEventCategoryCode_convert ();
    }

    protected:
    value
    _xsd_RadioactiveEventCategoryCode_convert () const;

    public:
    static const char* const _xsd_RadioactiveEventCategoryCode_literals_[4];
    static const value _xsd_RadioactiveEventCategoryCode_indexes_[4];
  };

  class RadioactiveEventDoseRateTrendCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DECR,
      INCR,
      INIT,
      NKN,
      PEAK,
      SAME,
      BACK
    };

    RadioactiveEventDoseRateTrendCode (value v);

    RadioactiveEventDoseRateTrendCode (const char* v);

    RadioactiveEventDoseRateTrendCode (const ::std::string& v);

    RadioactiveEventDoseRateTrendCode (const ::xml_schema::token& v);

    RadioactiveEventDoseRateTrendCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    RadioactiveEventDoseRateTrendCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    RadioactiveEventDoseRateTrendCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    RadioactiveEventDoseRateTrendCode (const RadioactiveEventDoseRateTrendCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual RadioactiveEventDoseRateTrendCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RadioactiveEventDoseRateTrendCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RadioactiveEventDoseRateTrendCode_convert ();
    }

    protected:
    value
    _xsd_RadioactiveEventDoseRateTrendCode_convert () const;

    public:
    static const char* const _xsd_RadioactiveEventDoseRateTrendCode_literals_[7];
    static const value _xsd_RadioactiveEventDoseRateTrendCode_indexes_[7];
  };

  class RadioactiveEventRelativeDecayRateCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DF,
      DN,
      DS
    };

    RadioactiveEventRelativeDecayRateCode (value v);

    RadioactiveEventRelativeDecayRateCode (const char* v);

    RadioactiveEventRelativeDecayRateCode (const ::std::string& v);

    RadioactiveEventRelativeDecayRateCode (const ::xml_schema::token& v);

    RadioactiveEventRelativeDecayRateCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    RadioactiveEventRelativeDecayRateCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    RadioactiveEventRelativeDecayRateCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    RadioactiveEventRelativeDecayRateCode (const RadioactiveEventRelativeDecayRateCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual RadioactiveEventRelativeDecayRateCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RadioactiveEventRelativeDecayRateCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RadioactiveEventRelativeDecayRateCode_convert ();
    }

    protected:
    value
    _xsd_RadioactiveEventRelativeDecayRateCode_convert () const;

    public:
    static const char* const _xsd_RadioactiveEventRelativeDecayRateCode_literals_[3];
    static const value _xsd_RadioactiveEventRelativeDecayRateCode_indexes_[3];
  };

  class RadioactiveMaterielTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CESIUM,
      COBALT,
      FRFUEL,
      IODINE,
      NKN,
      NOS,
      NROTA,
      NUCFLT,
      PLTNUM,
      SPFUEL,
      TOXMAT
    };

    RadioactiveMaterielTypeCategoryCode (value v);

    RadioactiveMaterielTypeCategoryCode (const char* v);

    RadioactiveMaterielTypeCategoryCode (const ::std::string& v);

    RadioactiveMaterielTypeCategoryCode (const ::xml_schema::token& v);

    RadioactiveMaterielTypeCategoryCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    RadioactiveMaterielTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    RadioactiveMaterielTypeCategoryCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    RadioactiveMaterielTypeCategoryCode (const RadioactiveMaterielTypeCategoryCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual RadioactiveMaterielTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RadioactiveMaterielTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RadioactiveMaterielTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_RadioactiveMaterielTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_RadioactiveMaterielTypeCategoryCode_literals_[11];
    static const value _xsd_RadioactiveMaterielTypeCategoryCode_indexes_[11];
  };

  class RadioactiveMaterielTypePrimaryRadiationCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ALPHA,
      BETA,
      GAMMA,
      NEUTRN,
      NKN
    };

    RadioactiveMaterielTypePrimaryRadiationCode (value v);

    RadioactiveMaterielTypePrimaryRadiationCode (const char* v);

    RadioactiveMaterielTypePrimaryRadiationCode (const ::std::string& v);

    RadioactiveMaterielTypePrimaryRadiationCode (const ::xml_schema::token& v);

    RadioactiveMaterielTypePrimaryRadiationCode (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    RadioactiveMaterielTypePrimaryRadiationCode (const ::xercesc::DOMAttr& a,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    RadioactiveMaterielTypePrimaryRadiationCode (const ::std::string& s,
                                                 const ::xercesc::DOMElement* e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    RadioactiveMaterielTypePrimaryRadiationCode (const RadioactiveMaterielTypePrimaryRadiationCode& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual RadioactiveMaterielTypePrimaryRadiationCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RadioactiveMaterielTypePrimaryRadiationCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RadioactiveMaterielTypePrimaryRadiationCode_convert ();
    }

    protected:
    value
    _xsd_RadioactiveMaterielTypePrimaryRadiationCode_convert () const;

    public:
    static const char* const _xsd_RadioactiveMaterielTypePrimaryRadiationCode_literals_[5];
    static const value _xsd_RadioactiveMaterielTypePrimaryRadiationCode_indexes_[5];
  };

  class RailcarTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      LCMTVE,
      NKN,
      NOS,
      RLDEQP,
      RLLSTK,
      TRAIN,
      TRAM
    };

    RailcarTypeCategoryCode (value v);

    RailcarTypeCategoryCode (const char* v);

    RailcarTypeCategoryCode (const ::std::string& v);

    RailcarTypeCategoryCode (const ::xml_schema::token& v);

    RailcarTypeCategoryCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    RailcarTypeCategoryCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    RailcarTypeCategoryCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    RailcarTypeCategoryCode (const RailcarTypeCategoryCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual RailcarTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RailcarTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RailcarTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_RailcarTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_RailcarTypeCategoryCode_literals_[7];
    static const value _xsd_RailcarTypeCategoryCode_indexes_[7];
  };

  class RailcarTypeSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      LCMDSE,
      LCMDSL,
      LCMELC,
      LCMSTM,
      LCMTND,
      NKN,
      NOS,
      WGNART,
      WGNBRK,
      WGNCAR,
      WGNCRG,
      WGNCSS,
      WGNCTL,
      WGNFLB,
      WGNFUL,
      WGNHPR,
      WGNISO,
      WGNLQD,
      WGNMNR,
      WGNOPC,
      WGNPAS,
      WGNRFG,
      WGNRPR,
      WGNSPP,
      WGNWAT,
      WGNWFL
    };

    RailcarTypeSubcategoryCode (value v);

    RailcarTypeSubcategoryCode (const char* v);

    RailcarTypeSubcategoryCode (const ::std::string& v);

    RailcarTypeSubcategoryCode (const ::xml_schema::token& v);

    RailcarTypeSubcategoryCode (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    RailcarTypeSubcategoryCode (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    RailcarTypeSubcategoryCode (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    RailcarTypeSubcategoryCode (const RailcarTypeSubcategoryCode& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual RailcarTypeSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RailcarTypeSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RailcarTypeSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_RailcarTypeSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_RailcarTypeSubcategoryCode_literals_[26];
    static const value _xsd_RailcarTypeSubcategoryCode_indexes_[26];
  };

  class RailwaySignalSystemCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CL,
      CP,
      EL,
      NKN,
      PL,
      SF,
      Z
    };

    RailwaySignalSystemCode (value v);

    RailwaySignalSystemCode (const char* v);

    RailwaySignalSystemCode (const ::std::string& v);

    RailwaySignalSystemCode (const ::xml_schema::token& v);

    RailwaySignalSystemCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    RailwaySignalSystemCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    RailwaySignalSystemCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    RailwaySignalSystemCode (const RailwaySignalSystemCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual RailwaySignalSystemCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RailwaySignalSystemCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RailwaySignalSystemCode_convert ();
    }

    protected:
    value
    _xsd_RailwaySignalSystemCode_convert () const;

    public:
    static const char* const _xsd_RailwaySignalSystemCode_literals_[7];
    static const value _xsd_RailwaySignalSystemCode_indexes_[7];
  };

  class RailwaySignalSystemEfficiencyCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_50,
      cxx_70,
      cxx_80,
      cxx_85
    };

    RailwaySignalSystemEfficiencyCode (value v);

    RailwaySignalSystemEfficiencyCode (const char* v);

    RailwaySignalSystemEfficiencyCode (const ::std::string& v);

    RailwaySignalSystemEfficiencyCode (const ::xml_schema::token& v);

    RailwaySignalSystemEfficiencyCode (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    RailwaySignalSystemEfficiencyCode (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    RailwaySignalSystemEfficiencyCode (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    RailwaySignalSystemEfficiencyCode (const RailwaySignalSystemEfficiencyCode& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual RailwaySignalSystemEfficiencyCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RailwaySignalSystemEfficiencyCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RailwaySignalSystemEfficiencyCode_convert ();
    }

    protected:
    value
    _xsd_RailwaySignalSystemEfficiencyCode_convert () const;

    public:
    static const char* const _xsd_RailwaySignalSystemEfficiencyCode_literals_[4];
    static const value _xsd_RailwaySignalSystemEfficiencyCode_indexes_[4];
  };

  class RailwayTrackGaugeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NAR,
      STD
    };

    RailwayTrackGaugeCode (value v);

    RailwayTrackGaugeCode (const char* v);

    RailwayTrackGaugeCode (const ::std::string& v);

    RailwayTrackGaugeCode (const ::xml_schema::token& v);

    RailwayTrackGaugeCode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    RailwayTrackGaugeCode (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    RailwayTrackGaugeCode (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    RailwayTrackGaugeCode (const RailwayTrackGaugeCode& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual RailwayTrackGaugeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RailwayTrackGaugeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RailwayTrackGaugeCode_convert ();
    }

    protected:
    value
    _xsd_RailwayTrackGaugeCode_convert () const;

    public:
    static const char* const _xsd_RailwayTrackGaugeCode_literals_[2];
    static const value _xsd_RailwayTrackGaugeCode_indexes_[2];
  };

  class RailwayTractionSystemCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      E,
      NE
    };

    RailwayTractionSystemCode (value v);

    RailwayTractionSystemCode (const char* v);

    RailwayTractionSystemCode (const ::std::string& v);

    RailwayTractionSystemCode (const ::xml_schema::token& v);

    RailwayTractionSystemCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    RailwayTractionSystemCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    RailwayTractionSystemCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    RailwayTractionSystemCode (const RailwayTractionSystemCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual RailwayTractionSystemCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RailwayTractionSystemCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RailwayTractionSystemCode_convert ();
    }

    protected:
    value
    _xsd_RailwayTractionSystemCode_convert () const;

    public:
    static const char* const _xsd_RailwayTractionSystemCode_literals_[2];
    static const value _xsd_RailwayTractionSystemCode_indexes_[2];
  };

  class ReferenceAssociationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CANCEL,
      GRPHDP,
      INCLDE,
      ISAMND,
      ISATTC,
      ISDRVD,
      ISMODF,
      PRVATH,
      REFRNC,
      SUPLMN,
      SUPRCD
    };

    ReferenceAssociationCategoryCode (value v);

    ReferenceAssociationCategoryCode (const char* v);

    ReferenceAssociationCategoryCode (const ::std::string& v);

    ReferenceAssociationCategoryCode (const ::xml_schema::token& v);

    ReferenceAssociationCategoryCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    ReferenceAssociationCategoryCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    ReferenceAssociationCategoryCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    ReferenceAssociationCategoryCode (const ReferenceAssociationCategoryCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual ReferenceAssociationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReferenceAssociationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReferenceAssociationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ReferenceAssociationCategoryCode_convert () const;

    public:
    static const char* const _xsd_ReferenceAssociationCategoryCode_literals_[11];
    static const value _xsd_ReferenceAssociationCategoryCode_indexes_[11];
  };

  class ReferenceContentCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ADMDOC,
      AUTHRS,
      CERTFC,
      DRCTV,
      GUIDNC,
      HISDOC,
      HLTDOC,
      IDDOC,
      INSTRC,
      LGLDOC,
      MAP,
      MTF,
      NOS,
      ORDER,
      PERDOC,
      REPORT,
      STFFJR,
      TECDOC,
      TEMPLT,
      TSTDOC
    };

    ReferenceContentCategoryCode (value v);

    ReferenceContentCategoryCode (const char* v);

    ReferenceContentCategoryCode (const ::std::string& v);

    ReferenceContentCategoryCode (const ::xml_schema::token& v);

    ReferenceContentCategoryCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ReferenceContentCategoryCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ReferenceContentCategoryCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ReferenceContentCategoryCode (const ReferenceContentCategoryCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual ReferenceContentCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReferenceContentCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReferenceContentCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ReferenceContentCategoryCode_convert () const;

    public:
    static const char* const _xsd_ReferenceContentCategoryCode_literals_[20];
    static const value _xsd_ReferenceContentCategoryCode_indexes_[20];
  };

  class ReferenceLifecycleCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DRAFT,
      FINAL,
      OBSLTE
    };

    ReferenceLifecycleCode (value v);

    ReferenceLifecycleCode (const char* v);

    ReferenceLifecycleCode (const ::std::string& v);

    ReferenceLifecycleCode (const ::xml_schema::token& v);

    ReferenceLifecycleCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ReferenceLifecycleCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ReferenceLifecycleCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ReferenceLifecycleCode (const ReferenceLifecycleCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual ReferenceLifecycleCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReferenceLifecycleCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReferenceLifecycleCode_convert ();
    }

    protected:
    value
    _xsd_ReferenceLifecycleCode_convert () const;

    public:
    static const char* const _xsd_ReferenceLifecycleCode_literals_[3];
    static const value _xsd_ReferenceLifecycleCode_indexes_[3];
  };

  class ReferenceMediumTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ELCFLD,
      ELCFLN,
      FILM,
      MAGTPE,
      NKN,
      NOS,
      PAPERB
    };

    ReferenceMediumTypeCode (value v);

    ReferenceMediumTypeCode (const char* v);

    ReferenceMediumTypeCode (const ::std::string& v);

    ReferenceMediumTypeCode (const ::xml_schema::token& v);

    ReferenceMediumTypeCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    ReferenceMediumTypeCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    ReferenceMediumTypeCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    ReferenceMediumTypeCode (const ReferenceMediumTypeCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual ReferenceMediumTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReferenceMediumTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReferenceMediumTypeCode_convert ();
    }

    protected:
    value
    _xsd_ReferenceMediumTypeCode_convert () const;

    public:
    static const char* const _xsd_ReferenceMediumTypeCode_literals_[7];
    static const value _xsd_ReferenceMediumTypeCode_indexes_[7];
  };

  class ReferenceTransmittalTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      COUMSG,
      ELCTRF,
      EMLMSG,
      FAXMSG,
      NKN,
      NOS,
      PHNMSG,
      RADMSG,
      SFXMSG,
      TELEX,
      VIDEO
    };

    ReferenceTransmittalTypeCode (value v);

    ReferenceTransmittalTypeCode (const char* v);

    ReferenceTransmittalTypeCode (const ::std::string& v);

    ReferenceTransmittalTypeCode (const ::xml_schema::token& v);

    ReferenceTransmittalTypeCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ReferenceTransmittalTypeCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ReferenceTransmittalTypeCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ReferenceTransmittalTypeCode (const ReferenceTransmittalTypeCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual ReferenceTransmittalTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReferenceTransmittalTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReferenceTransmittalTypeCode_convert ();
    }

    protected:
    value
    _xsd_ReferenceTransmittalTypeCode_convert () const;

    public:
    static const char* const _xsd_ReferenceTransmittalTypeCode_literals_[11];
    static const value _xsd_ReferenceTransmittalTypeCode_indexes_[11];
  };

  class ReferenceVerificationCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      REFUNV,
      REFVER,
      REFVNA
    };

    ReferenceVerificationCode (value v);

    ReferenceVerificationCode (const char* v);

    ReferenceVerificationCode (const ::std::string& v);

    ReferenceVerificationCode (const ::xml_schema::token& v);

    ReferenceVerificationCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ReferenceVerificationCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ReferenceVerificationCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ReferenceVerificationCode (const ReferenceVerificationCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual ReferenceVerificationCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReferenceVerificationCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReferenceVerificationCode_convert ();
    }

    protected:
    value
    _xsd_ReferenceVerificationCode_convert () const;

    public:
    static const char* const _xsd_ReferenceVerificationCode_literals_[3];
    static const value _xsd_ReferenceVerificationCode_indexes_[3];
  };

  class RelativeCoordinateSystemReferenceCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      OBJREF,
      PNTREF
    };

    RelativeCoordinateSystemReferenceCategoryCode (value v);

    RelativeCoordinateSystemReferenceCategoryCode (const char* v);

    RelativeCoordinateSystemReferenceCategoryCode (const ::std::string& v);

    RelativeCoordinateSystemReferenceCategoryCode (const ::xml_schema::token& v);

    RelativeCoordinateSystemReferenceCategoryCode (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    RelativeCoordinateSystemReferenceCategoryCode (const ::xercesc::DOMAttr& a,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    RelativeCoordinateSystemReferenceCategoryCode (const ::std::string& s,
                                                   const ::xercesc::DOMElement* e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    RelativeCoordinateSystemReferenceCategoryCode (const RelativeCoordinateSystemReferenceCategoryCode& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    virtual RelativeCoordinateSystemReferenceCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RelativeCoordinateSystemReferenceCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RelativeCoordinateSystemReferenceCategoryCode_convert ();
    }

    protected:
    value
    _xsd_RelativeCoordinateSystemReferenceCategoryCode_convert () const;

    public:
    static const char* const _xsd_RelativeCoordinateSystemReferenceCategoryCode_literals_[2];
    static const value _xsd_RelativeCoordinateSystemReferenceCategoryCode_indexes_[2];
  };

  class ReleaseCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CONT,
      NKN,
      NOS,
      PUFF,
      SPRAY
    };

    ReleaseCategoryCode (value v);

    ReleaseCategoryCode (const char* v);

    ReleaseCategoryCode (const ::std::string& v);

    ReleaseCategoryCode (const ::xml_schema::token& v);

    ReleaseCategoryCode (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ReleaseCategoryCode (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ReleaseCategoryCode (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ReleaseCategoryCode (const ReleaseCategoryCode& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual ReleaseCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReleaseCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReleaseCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ReleaseCategoryCode_convert () const;

    public:
    static const char* const _xsd_ReleaseCategoryCode_literals_[5];
    static const value _xsd_ReleaseCategoryCode_indexes_[5];
  };

  class ReportingDataAccuracyCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_1,
      cxx_2,
      cxx_3,
      cxx_4,
      cxx_5,
      cxx_6
    };

    ReportingDataAccuracyCode (value v);

    ReportingDataAccuracyCode (const char* v);

    ReportingDataAccuracyCode (const ::std::string& v);

    ReportingDataAccuracyCode (const ::xml_schema::token& v);

    ReportingDataAccuracyCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ReportingDataAccuracyCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ReportingDataAccuracyCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ReportingDataAccuracyCode (const ReportingDataAccuracyCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual ReportingDataAccuracyCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReportingDataAccuracyCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReportingDataAccuracyCode_convert ();
    }

    protected:
    value
    _xsd_ReportingDataAccuracyCode_convert () const;

    public:
    static const char* const _xsd_ReportingDataAccuracyCode_literals_[6];
    static const value _xsd_ReportingDataAccuracyCode_indexes_[6];
  };

  class ReportingDataCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ASS,
      ERR,
      INFER,
      PLAN,
      PRDCTD,
      REP
    };

    ReportingDataCategoryCode (value v);

    ReportingDataCategoryCode (const char* v);

    ReportingDataCategoryCode (const ::std::string& v);

    ReportingDataCategoryCode (const ::xml_schema::token& v);

    ReportingDataCategoryCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ReportingDataCategoryCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ReportingDataCategoryCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ReportingDataCategoryCode (const ReportingDataCategoryCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual ReportingDataCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReportingDataCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReportingDataCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ReportingDataCategoryCode_convert () const;

    public:
    static const char* const _xsd_ReportingDataCategoryCode_literals_[6];
    static const value _xsd_ReportingDataCategoryCode_indexes_[6];
  };

  class ReportingDataCountingIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    ReportingDataCountingIndicatorCode (value v);

    ReportingDataCountingIndicatorCode (const char* v);

    ReportingDataCountingIndicatorCode (const ::std::string& v);

    ReportingDataCountingIndicatorCode (const ::xml_schema::token& v);

    ReportingDataCountingIndicatorCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    ReportingDataCountingIndicatorCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    ReportingDataCountingIndicatorCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    ReportingDataCountingIndicatorCode (const ReportingDataCountingIndicatorCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual ReportingDataCountingIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReportingDataCountingIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReportingDataCountingIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_ReportingDataCountingIndicatorCode_convert () const;

    public:
    static const char* const _xsd_ReportingDataCountingIndicatorCode_literals_[2];
    static const value _xsd_ReportingDataCountingIndicatorCode_indexes_[2];
  };

  class ReportingDataCredibilityCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      IND,
      RPTFCT,
      RPTPLA,
      RPTUNC
    };

    ReportingDataCredibilityCode (value v);

    ReportingDataCredibilityCode (const char* v);

    ReportingDataCredibilityCode (const ::std::string& v);

    ReportingDataCredibilityCode (const ::xml_schema::token& v);

    ReportingDataCredibilityCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ReportingDataCredibilityCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ReportingDataCredibilityCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ReportingDataCredibilityCode (const ReportingDataCredibilityCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual ReportingDataCredibilityCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReportingDataCredibilityCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReportingDataCredibilityCode_convert ();
    }

    protected:
    value
    _xsd_ReportingDataCredibilityCode_convert () const;

    public:
    static const char* const _xsd_ReportingDataCredibilityCode_literals_[4];
    static const value _xsd_ReportingDataCredibilityCode_indexes_[4];
  };

  class ReportingDataEntityCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ACTEFF,
      ACTEVD,
      ACTEVS,
      ACTLOC,
      ACTTST,
      CNTASS,
      CTDAUT,
      CTLAUT,
      CTLIST,
      HLDTRF,
      HOLDNG,
      NTSRST,
      OIADDR,
      OIAFFL,
      OIASST,
      OICAPA,
      OIGRPA,
      OIHSTS,
      OILOCA,
      OISTAT,
      OITYPE,
      ORGSTR,
      REQANS,
      TPRSPR
    };

    ReportingDataEntityCategoryCode (value v);

    ReportingDataEntityCategoryCode (const char* v);

    ReportingDataEntityCategoryCode (const ::std::string& v);

    ReportingDataEntityCategoryCode (const ::xml_schema::token& v);

    ReportingDataEntityCategoryCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ReportingDataEntityCategoryCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ReportingDataEntityCategoryCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ReportingDataEntityCategoryCode (const ReportingDataEntityCategoryCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual ReportingDataEntityCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReportingDataEntityCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReportingDataEntityCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ReportingDataEntityCategoryCode_convert () const;

    public:
    static const char* const _xsd_ReportingDataEntityCategoryCode_literals_[24];
    static const value _xsd_ReportingDataEntityCategoryCode_indexes_[24];
  };

  class ReportingDataRealDataExerciseUseOnlyCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      REAL
    };

    ReportingDataRealDataExerciseUseOnlyCode (value v);

    ReportingDataRealDataExerciseUseOnlyCode (const char* v);

    ReportingDataRealDataExerciseUseOnlyCode (const ::std::string& v);

    ReportingDataRealDataExerciseUseOnlyCode (const ::xml_schema::token& v);

    ReportingDataRealDataExerciseUseOnlyCode (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ReportingDataRealDataExerciseUseOnlyCode (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ReportingDataRealDataExerciseUseOnlyCode (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ReportingDataRealDataExerciseUseOnlyCode (const ReportingDataRealDataExerciseUseOnlyCode& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual ReportingDataRealDataExerciseUseOnlyCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReportingDataRealDataExerciseUseOnlyCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReportingDataRealDataExerciseUseOnlyCode_convert ();
    }

    protected:
    value
    _xsd_ReportingDataRealDataExerciseUseOnlyCode_convert () const;

    public:
    static const char* const _xsd_ReportingDataRealDataExerciseUseOnlyCode_literals_[1];
    static const value _xsd_ReportingDataRealDataExerciseUseOnlyCode_indexes_[1];
  };

  class ReportingDataReliabilityCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      A,
      B,
      C,
      D,
      E,
      F
    };

    ReportingDataReliabilityCode (value v);

    ReportingDataReliabilityCode (const char* v);

    ReportingDataReliabilityCode (const ::std::string& v);

    ReportingDataReliabilityCode (const ::xml_schema::token& v);

    ReportingDataReliabilityCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ReportingDataReliabilityCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ReportingDataReliabilityCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ReportingDataReliabilityCode (const ReportingDataReliabilityCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual ReportingDataReliabilityCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReportingDataReliabilityCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReportingDataReliabilityCode_convert ();
    }

    protected:
    value
    _xsd_ReportingDataReliabilityCode_convert () const;

    public:
    static const char* const _xsd_ReportingDataReliabilityCode_literals_[6];
    static const value _xsd_ReportingDataReliabilityCode_indexes_[6];
  };

  class ReportingDataSourceTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIRIFR,
      AIRREC,
      AOBSR,
      ARTOBS,
      CAPDOC,
      CAPMAT,
      CBRR,
      CMRR,
      COMINT,
      CONTAC,
      DEFECT,
      ELINT,
      EYOBSN,
      FLRNG,
      FO,
      FOWOL,
      GRDREC,
      GSRA,
      HUMINT,
      INFLIT,
      LRRP,
      OBSR,
      PI,
      POW,
      REFUGE,
      RPV,
      SAT,
      SIGINT,
      SLAR,
      SORNG,
      TACAIR,
      TGTB,
      UGS,
      UNSPEC,
      VARI
    };

    ReportingDataSourceTypeCode (value v);

    ReportingDataSourceTypeCode (const char* v);

    ReportingDataSourceTypeCode (const ::std::string& v);

    ReportingDataSourceTypeCode (const ::xml_schema::token& v);

    ReportingDataSourceTypeCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ReportingDataSourceTypeCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ReportingDataSourceTypeCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ReportingDataSourceTypeCode (const ReportingDataSourceTypeCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual ReportingDataSourceTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReportingDataSourceTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReportingDataSourceTypeCode_convert ();
    }

    protected:
    value
    _xsd_ReportingDataSourceTypeCode_convert () const;

    public:
    static const char* const _xsd_ReportingDataSourceTypeCode_literals_[35];
    static const value _xsd_ReportingDataSourceTypeCode_indexes_[35];
  };

  class ReportingDataTimingCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      RDABST,
      RDRELT,
      TIMNA
    };

    ReportingDataTimingCategoryCode (value v);

    ReportingDataTimingCategoryCode (const char* v);

    ReportingDataTimingCategoryCode (const ::std::string& v);

    ReportingDataTimingCategoryCode (const ::xml_schema::token& v);

    ReportingDataTimingCategoryCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ReportingDataTimingCategoryCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ReportingDataTimingCategoryCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    ReportingDataTimingCategoryCode (const ReportingDataTimingCategoryCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual ReportingDataTimingCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReportingDataTimingCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ReportingDataTimingCategoryCode_convert ();
    }

    protected:
    value
    _xsd_ReportingDataTimingCategoryCode_convert () const;

    public:
    static const char* const _xsd_ReportingDataTimingCategoryCode_literals_[3];
    static const value _xsd_ReportingDataTimingCategoryCode_indexes_[3];
  };

  class RequestAnswerCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      UNA,
      UNK,
      YES
    };

    RequestAnswerCategoryCode (value v);

    RequestAnswerCategoryCode (const char* v);

    RequestAnswerCategoryCode (const ::std::string& v);

    RequestAnswerCategoryCode (const ::xml_schema::token& v);

    RequestAnswerCategoryCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    RequestAnswerCategoryCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    RequestAnswerCategoryCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    RequestAnswerCategoryCode (const RequestAnswerCategoryCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual RequestAnswerCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RequestAnswerCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RequestAnswerCategoryCode_convert ();
    }

    protected:
    value
    _xsd_RequestAnswerCategoryCode_convert () const;

    public:
    static const char* const _xsd_RequestAnswerCategoryCode_literals_[4];
    static const value _xsd_RequestAnswerCategoryCode_indexes_[4];
  };

  class RequestCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ACTION,
      ASSOC,
      CAPAB,
      HOLDNG,
      HOSTIL,
      LOCATN,
      PRESNC,
      STATUS,
      TYPE
    };

    RequestCategoryCode (value v);

    RequestCategoryCode (const char* v);

    RequestCategoryCode (const ::std::string& v);

    RequestCategoryCode (const ::xml_schema::token& v);

    RequestCategoryCode (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    RequestCategoryCode (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    RequestCategoryCode (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    RequestCategoryCode (const RequestCategoryCode& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual RequestCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RequestCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RequestCategoryCode_convert ();
    }

    protected:
    value
    _xsd_RequestCategoryCode_convert () const;

    public:
    static const char* const _xsd_RequestCategoryCode_literals_[9];
    static const value _xsd_RequestCategoryCode_indexes_[9];
  };

  class RequestImmediateInterestIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    RequestImmediateInterestIndicatorCode (value v);

    RequestImmediateInterestIndicatorCode (const char* v);

    RequestImmediateInterestIndicatorCode (const ::std::string& v);

    RequestImmediateInterestIndicatorCode (const ::xml_schema::token& v);

    RequestImmediateInterestIndicatorCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    RequestImmediateInterestIndicatorCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    RequestImmediateInterestIndicatorCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    RequestImmediateInterestIndicatorCode (const RequestImmediateInterestIndicatorCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual RequestImmediateInterestIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RequestImmediateInterestIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RequestImmediateInterestIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_RequestImmediateInterestIndicatorCode_convert () const;

    public:
    static const char* const _xsd_RequestImmediateInterestIndicatorCode_literals_[2];
    static const value _xsd_RequestImmediateInterestIndicatorCode_indexes_[2];
  };

  class RoadCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      A,
      B,
      C,
      D,
      E,
      NOS,
      P,
      R
    };

    RoadCategoryCode (value v);

    RoadCategoryCode (const char* v);

    RoadCategoryCode (const ::std::string& v);

    RoadCategoryCode (const ::xml_schema::token& v);

    RoadCategoryCode (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    RoadCategoryCode (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    RoadCategoryCode (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    RoadCategoryCode (const RoadCategoryCode& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual RoadCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RoadCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RoadCategoryCode_convert ();
    }

    protected:
    value
    _xsd_RoadCategoryCode_convert () const;

    public:
    static const char* const _xsd_RoadCategoryCode_literals_[8];
    static const value _xsd_RoadCategoryCode_indexes_[8];
  };

  class RoadQualityCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      E,
      F,
      G,
      P
    };

    RoadQualityCode (value v);

    RoadQualityCode (const char* v);

    RoadQualityCode (const ::std::string& v);

    RoadQualityCode (const ::xml_schema::token& v);

    RoadQualityCode (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    RoadQualityCode (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    RoadQualityCode (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    RoadQualityCode (const RoadQualityCode& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual RoadQualityCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RoadQualityCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RoadQualityCode_convert ();
    }

    protected:
    value
    _xsd_RoadQualityCode_convert () const;

    public:
    static const char* const _xsd_RoadQualityCode_literals_[4];
    static const value _xsd_RoadQualityCode_indexes_[4];
  };

  class RoadShoulderWidthCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_1,
      cxx_2,
      cxx_3
    };

    RoadShoulderWidthCode (value v);

    RoadShoulderWidthCode (const char* v);

    RoadShoulderWidthCode (const ::std::string& v);

    RoadShoulderWidthCode (const ::xml_schema::token& v);

    RoadShoulderWidthCode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    RoadShoulderWidthCode (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    RoadShoulderWidthCode (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    RoadShoulderWidthCode (const RoadShoulderWidthCode& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual RoadShoulderWidthCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RoadShoulderWidthCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RoadShoulderWidthCode_convert ();
    }

    protected:
    value
    _xsd_RoadShoulderWidthCode_convert () const;

    public:
    static const char* const _xsd_RoadShoulderWidthCode_literals_[3];
    static const value _xsd_RoadShoulderWidthCode_indexes_[3];
  };

  class RoadWeatherConditionCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AWR,
      FWR,
      LAWR
    };

    RoadWeatherConditionCategoryCode (value v);

    RoadWeatherConditionCategoryCode (const char* v);

    RoadWeatherConditionCategoryCode (const ::std::string& v);

    RoadWeatherConditionCategoryCode (const ::xml_schema::token& v);

    RoadWeatherConditionCategoryCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    RoadWeatherConditionCategoryCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    RoadWeatherConditionCategoryCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    RoadWeatherConditionCategoryCode (const RoadWeatherConditionCategoryCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual RoadWeatherConditionCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RoadWeatherConditionCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RoadWeatherConditionCategoryCode_convert ();
    }

    protected:
    value
    _xsd_RoadWeatherConditionCategoryCode_convert () const;

    public:
    static const char* const _xsd_RoadWeatherConditionCategoryCode_literals_[3];
    static const value _xsd_RoadWeatherConditionCategoryCode_indexes_[3];
  };

  class RouteDirectionUsageCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ALTRNG,
      ONEWAY,
      TWOWAY
    };

    RouteDirectionUsageCode (value v);

    RouteDirectionUsageCode (const char* v);

    RouteDirectionUsageCode (const ::std::string& v);

    RouteDirectionUsageCode (const ::xml_schema::token& v);

    RouteDirectionUsageCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    RouteDirectionUsageCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    RouteDirectionUsageCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    RouteDirectionUsageCode (const RouteDirectionUsageCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual RouteDirectionUsageCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RouteDirectionUsageCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RouteDirectionUsageCode_convert ();
    }

    protected:
    value
    _xsd_RouteDirectionUsageCode_convert () const;

    public:
    static const char* const _xsd_RouteDirectionUsageCode_literals_[3];
    static const value _xsd_RouteDirectionUsageCode_indexes_[3];
  };

  class RouteSegmentCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIRRTE,
      NOS
    };

    RouteSegmentCategoryCode (value v);

    RouteSegmentCategoryCode (const char* v);

    RouteSegmentCategoryCode (const ::std::string& v);

    RouteSegmentCategoryCode (const ::xml_schema::token& v);

    RouteSegmentCategoryCode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    RouteSegmentCategoryCode (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    RouteSegmentCategoryCode (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    RouteSegmentCategoryCode (const RouteSegmentCategoryCode& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual RouteSegmentCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RouteSegmentCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RouteSegmentCategoryCode_convert ();
    }

    protected:
    value
    _xsd_RouteSegmentCategoryCode_convert () const;

    public:
    static const char* const _xsd_RouteSegmentCategoryCode_literals_[2];
    static const value _xsd_RouteSegmentCategoryCode_indexes_[2];
  };

  class RouteTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ADVRTE,
      AIRCOR,
      AIRRTE,
      AIRWAY,
      ALTSPL,
      APRCOR,
      ATS,
      CONDRT,
      CONVRT,
      DCT,
      EGRRTU,
      FLTPTH,
      GRCLRT,
      INGRTE,
      LATR,
      LLTR,
      MAMNST,
      MAMNTR,
      MRR,
      MSR,
      NAVRTE,
      NKN,
      NOS,
      POLRRT,
      QROUTE,
      QRTESG,
      REFTRK,
      RETFRT,
      RHLNRT,
      SPCCDR,
      STDART,
      STRDRT,
      SUPRRT,
      TACAN,
      TMMRRT,
      TRNKRT,
      TRSTRT,
      UNMVRT,
      USCTRT,
      VARTRA
    };

    RouteTypeCategoryCode (value v);

    RouteTypeCategoryCode (const char* v);

    RouteTypeCategoryCode (const ::std::string& v);

    RouteTypeCategoryCode (const ::xml_schema::token& v);

    RouteTypeCategoryCode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    RouteTypeCategoryCode (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    RouteTypeCategoryCode (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    RouteTypeCategoryCode (const RouteTypeCategoryCode& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual RouteTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RouteTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RouteTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_RouteTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_RouteTypeCategoryCode_literals_[40];
    static const value _xsd_RouteTypeCategoryCode_indexes_[40];
  };

  class RunwayLightingPresenceIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    RunwayLightingPresenceIndicatorCode (value v);

    RunwayLightingPresenceIndicatorCode (const char* v);

    RunwayLightingPresenceIndicatorCode (const ::std::string& v);

    RunwayLightingPresenceIndicatorCode (const ::xml_schema::token& v);

    RunwayLightingPresenceIndicatorCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    RunwayLightingPresenceIndicatorCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    RunwayLightingPresenceIndicatorCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    RunwayLightingPresenceIndicatorCode (const RunwayLightingPresenceIndicatorCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual RunwayLightingPresenceIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RunwayLightingPresenceIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RunwayLightingPresenceIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_RunwayLightingPresenceIndicatorCode_convert () const;

    public:
    static const char* const _xsd_RunwayLightingPresenceIndicatorCode_literals_[2];
    static const value _xsd_RunwayLightingPresenceIndicatorCode_indexes_[2];
  };

  class RunwayPavementEvaluationMethodCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      T,
      U
    };

    RunwayPavementEvaluationMethodCode (value v);

    RunwayPavementEvaluationMethodCode (const char* v);

    RunwayPavementEvaluationMethodCode (const ::std::string& v);

    RunwayPavementEvaluationMethodCode (const ::xml_schema::token& v);

    RunwayPavementEvaluationMethodCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    RunwayPavementEvaluationMethodCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    RunwayPavementEvaluationMethodCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    RunwayPavementEvaluationMethodCode (const RunwayPavementEvaluationMethodCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual RunwayPavementEvaluationMethodCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RunwayPavementEvaluationMethodCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RunwayPavementEvaluationMethodCode_convert ();
    }

    protected:
    value
    _xsd_RunwayPavementEvaluationMethodCode_convert () const;

    public:
    static const char* const _xsd_RunwayPavementEvaluationMethodCode_literals_[2];
    static const value _xsd_RunwayPavementEvaluationMethodCode_indexes_[2];
  };

  class RunwayPavementMaximumTyrePressureCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      W,
      X,
      Y,
      Z
    };

    RunwayPavementMaximumTyrePressureCode (value v);

    RunwayPavementMaximumTyrePressureCode (const char* v);

    RunwayPavementMaximumTyrePressureCode (const ::std::string& v);

    RunwayPavementMaximumTyrePressureCode (const ::xml_schema::token& v);

    RunwayPavementMaximumTyrePressureCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    RunwayPavementMaximumTyrePressureCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    RunwayPavementMaximumTyrePressureCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    RunwayPavementMaximumTyrePressureCode (const RunwayPavementMaximumTyrePressureCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual RunwayPavementMaximumTyrePressureCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RunwayPavementMaximumTyrePressureCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RunwayPavementMaximumTyrePressureCode_convert ();
    }

    protected:
    value
    _xsd_RunwayPavementMaximumTyrePressureCode_convert () const;

    public:
    static const char* const _xsd_RunwayPavementMaximumTyrePressureCode_literals_[4];
    static const value _xsd_RunwayPavementMaximumTyrePressureCode_indexes_[4];
  };

  class RunwayPavementSubgradeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      A,
      B,
      C,
      D
    };

    RunwayPavementSubgradeCategoryCode (value v);

    RunwayPavementSubgradeCategoryCode (const char* v);

    RunwayPavementSubgradeCategoryCode (const ::std::string& v);

    RunwayPavementSubgradeCategoryCode (const ::xml_schema::token& v);

    RunwayPavementSubgradeCategoryCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    RunwayPavementSubgradeCategoryCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    RunwayPavementSubgradeCategoryCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    RunwayPavementSubgradeCategoryCode (const RunwayPavementSubgradeCategoryCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual RunwayPavementSubgradeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RunwayPavementSubgradeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RunwayPavementSubgradeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_RunwayPavementSubgradeCategoryCode_convert () const;

    public:
    static const char* const _xsd_RunwayPavementSubgradeCategoryCode_literals_[4];
    static const value _xsd_RunwayPavementSubgradeCategoryCode_indexes_[4];
  };

  class RunwayPavementTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      F,
      R
    };

    RunwayPavementTypeCode (value v);

    RunwayPavementTypeCode (const char* v);

    RunwayPavementTypeCode (const ::std::string& v);

    RunwayPavementTypeCode (const ::xml_schema::token& v);

    RunwayPavementTypeCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    RunwayPavementTypeCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    RunwayPavementTypeCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    RunwayPavementTypeCode (const RunwayPavementTypeCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual RunwayPavementTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RunwayPavementTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RunwayPavementTypeCode_convert ();
    }

    protected:
    value
    _xsd_RunwayPavementTypeCode_convert () const;

    public:
    static const char* const _xsd_RunwayPavementTypeCode_literals_[2];
    static const value _xsd_RunwayPavementTypeCode_indexes_[2];
  };

  class SecurityClassificationLevelCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_0,
      cxx_1,
      cxx_2,
      cxx_3,
      cxx_4,
      cxx_5
    };

    SecurityClassificationLevelCode (value v);

    SecurityClassificationLevelCode (const char* v);

    SecurityClassificationLevelCode (const ::std::string& v);

    SecurityClassificationLevelCode (const ::xml_schema::token& v);

    SecurityClassificationLevelCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    SecurityClassificationLevelCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    SecurityClassificationLevelCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    SecurityClassificationLevelCode (const SecurityClassificationLevelCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual SecurityClassificationLevelCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SecurityClassificationLevelCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SecurityClassificationLevelCode_convert ();
    }

    protected:
    value
    _xsd_SecurityClassificationLevelCode_convert () const;

    public:
    static const char* const _xsd_SecurityClassificationLevelCode_literals_[6];
    static const value _xsd_SecurityClassificationLevelCode_indexes_[6];
  };

  class SolidSurfaceStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CLEARD,
      CNTMND,
      DSTRYD,
      HVYDAM,
      LGTDAM,
      MODDAM,
      NKN,
      OBSTRD
    };

    SolidSurfaceStatusCode (value v);

    SolidSurfaceStatusCode (const char* v);

    SolidSurfaceStatusCode (const ::std::string& v);

    SolidSurfaceStatusCode (const ::xml_schema::token& v);

    SolidSurfaceStatusCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    SolidSurfaceStatusCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    SolidSurfaceStatusCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    SolidSurfaceStatusCode (const SolidSurfaceStatusCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual SolidSurfaceStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SolidSurfaceStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SolidSurfaceStatusCode_convert ();
    }

    protected:
    value
    _xsd_SolidSurfaceStatusCode_convert () const;

    public:
    static const char* const _xsd_SolidSurfaceStatusCode_literals_[8];
    static const value _xsd_SolidSurfaceStatusCode_indexes_[8];
  };

  class SolidSurfaceStatusSurfaceConditionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DUST,
      EARTH,
      FLOOD,
      ICE,
      NKN,
      NOS,
      SAND,
      SNOW
    };

    SolidSurfaceStatusSurfaceConditionCode (value v);

    SolidSurfaceStatusSurfaceConditionCode (const char* v);

    SolidSurfaceStatusSurfaceConditionCode (const ::std::string& v);

    SolidSurfaceStatusSurfaceConditionCode (const ::xml_schema::token& v);

    SolidSurfaceStatusSurfaceConditionCode (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    SolidSurfaceStatusSurfaceConditionCode (const ::xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    SolidSurfaceStatusSurfaceConditionCode (const ::std::string& s,
                                            const ::xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    SolidSurfaceStatusSurfaceConditionCode (const SolidSurfaceStatusSurfaceConditionCode& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual SolidSurfaceStatusSurfaceConditionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SolidSurfaceStatusSurfaceConditionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SolidSurfaceStatusSurfaceConditionCode_convert ();
    }

    protected:
    value
    _xsd_SolidSurfaceStatusSurfaceConditionCode_convert () const;

    public:
    static const char* const _xsd_SolidSurfaceStatusSurfaceConditionCode_literals_[8];
    static const value _xsd_SolidSurfaceStatusSurfaceConditionCode_indexes_[8];
  };

  class SolidSurfaceStatusSurfaceFirmnessCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      HARD,
      MODER,
      SOFT,
      VSOFT
    };

    SolidSurfaceStatusSurfaceFirmnessCode (value v);

    SolidSurfaceStatusSurfaceFirmnessCode (const char* v);

    SolidSurfaceStatusSurfaceFirmnessCode (const ::std::string& v);

    SolidSurfaceStatusSurfaceFirmnessCode (const ::xml_schema::token& v);

    SolidSurfaceStatusSurfaceFirmnessCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    SolidSurfaceStatusSurfaceFirmnessCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    SolidSurfaceStatusSurfaceFirmnessCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    SolidSurfaceStatusSurfaceFirmnessCode (const SolidSurfaceStatusSurfaceFirmnessCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual SolidSurfaceStatusSurfaceFirmnessCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SolidSurfaceStatusSurfaceFirmnessCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SolidSurfaceStatusSurfaceFirmnessCode_convert ();
    }

    protected:
    value
    _xsd_SolidSurfaceStatusSurfaceFirmnessCode_convert () const;

    public:
    static const char* const _xsd_SolidSurfaceStatusSurfaceFirmnessCode_literals_[4];
    static const value _xsd_SolidSurfaceStatusSurfaceFirmnessCode_indexes_[4];
  };

  class SpeedPrecisionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      KNOTS,
      KPH,
      MPS
    };

    SpeedPrecisionCode (value v);

    SpeedPrecisionCode (const char* v);

    SpeedPrecisionCode (const ::std::string& v);

    SpeedPrecisionCode (const ::xml_schema::token& v);

    SpeedPrecisionCode (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    SpeedPrecisionCode (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    SpeedPrecisionCode (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    SpeedPrecisionCode (const SpeedPrecisionCode& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual SpeedPrecisionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SpeedPrecisionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SpeedPrecisionCode_convert ();
    }

    protected:
    value
    _xsd_SpeedPrecisionCode_convert () const;

    public:
    static const char* const _xsd_SpeedPrecisionCode_literals_[3];
    static const value _xsd_SpeedPrecisionCode_indexes_[3];
  };

  class StorageCapabilityConditionCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CC,
      CS,
      HS,
      OS
    };

    StorageCapabilityConditionCode (value v);

    StorageCapabilityConditionCode (const char* v);

    StorageCapabilityConditionCode (const ::std::string& v);

    StorageCapabilityConditionCode (const ::xml_schema::token& v);

    StorageCapabilityConditionCode (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    StorageCapabilityConditionCode (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    StorageCapabilityConditionCode (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    StorageCapabilityConditionCode (const StorageCapabilityConditionCode& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual StorageCapabilityConditionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    StorageCapabilityConditionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_StorageCapabilityConditionCode_convert ();
    }

    protected:
    value
    _xsd_StorageCapabilityConditionCode_convert () const;

    public:
    static const char* const _xsd_StorageCapabilityConditionCode_literals_[4];
    static const value _xsd_StorageCapabilityConditionCode_indexes_[4];
  };

  class StorageCapabilityDescriptorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BLKLIQ,
      BLKVOL,
      MAXCNT,
      MCRHEI,
      MCRLEN,
      MCRWGT,
      MCRWID,
      MLNLEN,
      MSRFAR,
      MWGTBR,
      NEQLMT
    };

    StorageCapabilityDescriptorCode (value v);

    StorageCapabilityDescriptorCode (const char* v);

    StorageCapabilityDescriptorCode (const ::std::string& v);

    StorageCapabilityDescriptorCode (const ::xml_schema::token& v);

    StorageCapabilityDescriptorCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    StorageCapabilityDescriptorCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    StorageCapabilityDescriptorCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    StorageCapabilityDescriptorCode (const StorageCapabilityDescriptorCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual StorageCapabilityDescriptorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    StorageCapabilityDescriptorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_StorageCapabilityDescriptorCode_convert ();
    }

    protected:
    value
    _xsd_StorageCapabilityDescriptorCode_convert () const;

    public:
    static const char* const _xsd_StorageCapabilityDescriptorCode_literals_[11];
    static const value _xsd_StorageCapabilityDescriptorCode_indexes_[11];
  };

  class SubsurfaceVesselTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      DSV,
      NKN,
      NOS,
      SS,
      SSA,
      SSAN,
      SSB,
      SSBN,
      SSC,
      SSG,
      SSGN,
      SSK,
      SSN,
      SST,
      SSU,
      SSUN,
      SSW,
      TS,
      TSG,
      TSR,
      YSG,
      YSR,
      YSRV,
      YSV
    };

    SubsurfaceVesselTypeCategoryCode (value v);

    SubsurfaceVesselTypeCategoryCode (const char* v);

    SubsurfaceVesselTypeCategoryCode (const ::std::string& v);

    SubsurfaceVesselTypeCategoryCode (const ::xml_schema::token& v);

    SubsurfaceVesselTypeCategoryCode (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    SubsurfaceVesselTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    SubsurfaceVesselTypeCategoryCode (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    SubsurfaceVesselTypeCategoryCode (const SubsurfaceVesselTypeCategoryCode& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual SubsurfaceVesselTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SubsurfaceVesselTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SubsurfaceVesselTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_SubsurfaceVesselTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_SubsurfaceVesselTypeCategoryCode_literals_[24];
    static const value _xsd_SubsurfaceVesselTypeCategoryCode_indexes_[24];
  };

  class SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode (value v);

    SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode (const char* v);

    SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode (const ::std::string& v);

    SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode (const ::xml_schema::token& v);

    SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode (const ::xercesc::DOMElement& e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode (const ::xercesc::DOMAttr& a,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode (const ::std::string& s,
                                                         const ::xercesc::DOMElement* e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode (const SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode& x,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    virtual SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode_convert () const;

    public:
    static const char* const _xsd_SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode_literals_[2];
    static const value _xsd_SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode_indexes_[2];
  };

  class SupportCapabilityCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BEDDNG,
      CMPAIR,
      DECK,
      EDUCTN,
      ELECTR,
      ENGINE,
      FODRAT,
      FUELHE,
      HELPLT,
      HLTHCR,
      INFSTR,
      LUNDRY,
      MEDCAL,
      MEDSPL,
      MESSNG,
      PERSEQ,
      RECRTN,
      SECRTY,
      SEWAGE,
      SHLTER,
      SPLC1,
      SPLC2,
      SPLC3,
      SPLC3A,
      SPLC4,
      SPLC5,
      WATER
    };

    SupportCapabilityCategoryCode (value v);

    SupportCapabilityCategoryCode (const char* v);

    SupportCapabilityCategoryCode (const ::std::string& v);

    SupportCapabilityCategoryCode (const ::xml_schema::token& v);

    SupportCapabilityCategoryCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    SupportCapabilityCategoryCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    SupportCapabilityCategoryCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    SupportCapabilityCategoryCode (const SupportCapabilityCategoryCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual SupportCapabilityCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SupportCapabilityCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SupportCapabilityCategoryCode_convert ();
    }

    protected:
    value
    _xsd_SupportCapabilityCategoryCode_convert () const;

    public:
    static const char* const _xsd_SupportCapabilityCategoryCode_literals_[27];
    static const value _xsd_SupportCapabilityCategoryCode_indexes_[27];
  };

  class SupportCapabilityDescriptorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BEDCNT,
      BLKLIQ,
      BLKVOL,
      MAXCNT,
      OPRCNT
    };

    SupportCapabilityDescriptorCode (value v);

    SupportCapabilityDescriptorCode (const char* v);

    SupportCapabilityDescriptorCode (const ::std::string& v);

    SupportCapabilityDescriptorCode (const ::xml_schema::token& v);

    SupportCapabilityDescriptorCode (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    SupportCapabilityDescriptorCode (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    SupportCapabilityDescriptorCode (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    SupportCapabilityDescriptorCode (const SupportCapabilityDescriptorCode& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual SupportCapabilityDescriptorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SupportCapabilityDescriptorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SupportCapabilityDescriptorCode_convert ();
    }

    protected:
    value
    _xsd_SupportCapabilityDescriptorCode_convert () const;

    public:
    static const char* const _xsd_SupportCapabilityDescriptorCode_literals_[5];
    static const value _xsd_SupportCapabilityDescriptorCode_indexes_[5];
  };

  class SurfaceCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CORDAR,
      ELLPSE,
      FA,
      ORBTAR,
      PLYAAR,
      PLYGAR,
      TRCKAR
    };

    SurfaceCategoryCode (value v);

    SurfaceCategoryCode (const char* v);

    SurfaceCategoryCode (const ::std::string& v);

    SurfaceCategoryCode (const ::xml_schema::token& v);

    SurfaceCategoryCode (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    SurfaceCategoryCode (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    SurfaceCategoryCode (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    SurfaceCategoryCode (const SurfaceCategoryCode& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual SurfaceCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SurfaceCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SurfaceCategoryCode_convert ();
    }

    protected:
    value
    _xsd_SurfaceCategoryCode_convert () const;

    public:
    static const char* const _xsd_SurfaceCategoryCode_literals_[7];
    static const value _xsd_SurfaceCategoryCode_indexes_[7];
  };

  class SurfaceVesselTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AA,
      AAR,
      AAV,
      AB,
      ABU,
      ABUD,
      AD,
      ADG,
      AE,
      AEL,
      AEM,
      AET,
      AETL,
      AF,
      AFDB,
      AFDL,
      AFDM,
      AFL,
      AFS,
      AFT,
      AG,
      AGB,
      AGBL,
      AGBN,
      AGCL,
      AGCM,
      AGDS,
      AGE,
      AGF,
      AGH,
      AGI,
      AGM,
      AGMS,
      AGOB,
      AGOR,
      AGOS,
      AGP,
      AGR,
      AGS,
      AGSA,
      AGSC,
      AGSL,
      AGT,
      AGTT,
      AH,
      AK,
      AKL,
      AKR,
      AKS,
      AKSL,
      AKV,
      ALS,
      AN,
      ANL,
      AO,
      AOE,
      AOL,
      AOR,
      AORL,
      AOS,
      AOSR,
      AOT,
      AOTL,
      AP,
      APB,
      APCR,
      APCT,
      APL,
      AR,
      ARB,
      ARC,
      ARD,
      ARDM,
      ARH,
      ARL,
      ARR,
      ARS,
      ARSD,
      ARV,
      AS,
      ASL,
      ASR,
      ASVR,
      AT,
      ATA,
      ATF,
      ATR,
      ATS,
      AV,
      AVB,
      AVM,
      AVR,
      AVS,
      AVT,
      AWT,
      AWW,
      AX,
      AXL,
      AXS,
      BB,
      CA,
      CAT,
      CATBAT,
      CC,
      CG,
      CGH,
      CGHN,
      CGN,
      CH,
      CUTTER,
      CV,
      CVG,
      CVGN,
      CVH,
      CVHG,
      CVHGN,
      CVHN,
      CVL,
      CVLG,
      CVN,
      CVS,
      CVT,
      DD,
      DDG,
      DDGH,
      DDH,
      DDT,
      DE,
      DHOW,
      FF,
      FFG,
      FFGH,
      FFH,
      FFL,
      FFLG,
      FFT,
      FS,
      HUSBAT,
      KETCH,
      LARC,
      LARCV,
      LC,
      LCAC,
      LCC,
      LCFS,
      LCM,
      LCMJ,
      LCP,
      LCPA,
      LCPL,
      LCT,
      LCU,
      LCUJ,
      LCVP,
      LCW,
      LDW,
      LFS,
      LG,
      LHA,
      LHD,
      LKA,
      LL,
      LLB,
      LLP,
      LLT,
      LM,
      LPD,
      LPH,
      LPP,
      LS,
      LSD,
      LSL,
      LSM,
      LST,
      LSV,
      MC,
      MCCS,
      MCD,
      MCJ,
      MCMV,
      MCS,
      MCSL,
      MCT,
      MH,
      MHA,
      MHC,
      MHCD,
      MHI,
      MHO,
      MHS,
      MHSC,
      MHSD,
      MHSO,
      ML,
      MLA,
      MLC,
      MLI,
      MLO,
      MLR,
      MLS,
      MM,
      MS,
      MSA,
      MSB,
      MSC,
      MSCD,
      MSCJ,
      MSCK,
      MSCS,
      MSCT,
      MSD,
      MSF,
      MSFJ,
      MSFK,
      MSI,
      MSIJ,
      MSL,
      MSO,
      MSR,
      MSS,
      MYAC,
      NKN,
      NOS,
      PB,
      PBF,
      PBK,
      PBO,
      PBR,
      PC,
      PCE,
      PCF,
      PCFJ,
      PCFK,
      PCK,
      PCS,
      PCT,
      PG,
      PGB,
      PGF,
      PGG,
      PGGJ,
      PGGK,
      PGK,
      PGM,
      PGS,
      PHJ,
      PHJM,
      PHJS,
      PP,
      PSO,
      PT,
      PTG,
      PTGJ,
      PTGK,
      PTGT,
      PTJ,
      PTK,
      PTL,
      PTLK,
      PTT,
      QJ,
      QR,
      QS,
      RABOUT,
      RCRUSR,
      SCHOON,
      SLOOP,
      SPDBAT,
      SWCL,
      SWCM,
      TJ,
      TJC,
      TJF,
      TJGB,
      TJGS,
      TJL,
      TM,
      TMA,
      TMB,
      TMC,
      TMCS,
      TMD,
      TME,
      TMF,
      TMFR,
      TMGB,
      TMGS,
      TMH,
      TMI,
      TMK,
      TML,
      TMLS,
      TMM,
      TMO,
      TMOL,
      TMOR,
      TMOS,
      TMOT,
      TMP,
      TMR,
      TMS,
      TMT,
      TMTR,
      TMTS,
      TMWT,
      TMWW,
      TMX,
      TRIHUL,
      TU,
      TUB,
      TUC,
      TUF,
      TUI,
      TUR,
      TUS,
      TUT,
      TUW,
      VPB,
      VPC,
      VPG,
      VYDT,
      VYFL,
      WDD,
      WFF,
      WFFL,
      WQS,
      YAC,
      YAG,
      YAGE,
      YAGEN,
      YAGF,
      YAGK,
      YAGT,
      YAM,
      YAWL,
      YB,
      YC,
      YCK,
      YCV,
      YD,
      YDG,
      YDT,
      YE,
      YF,
      YFB,
      YFC,
      YFD,
      YFDB,
      YFDL,
      YFDM,
      YFL,
      YFLB,
      YFLK,
      YFLN,
      YFND,
      YFNX,
      YFP,
      YFR,
      YFRT,
      YFT,
      YFU,
      YGG,
      YGS,
      YGT,
      YGTN,
      YH,
      YHT,
      YL,
      YLC,
      YLG,
      YLWT,
      YM,
      YMN,
      YNC,
      YNG,
      YNT,
      YO,
      YOG,
      YOM,
      YOR,
      YOS,
      YOSR,
      YOSS,
      YP,
      YPB,
      YPD,
      YPK,
      YPT,
      YR,
      YRB,
      YRBM,
      YRC,
      YRCN,
      YRD,
      YRDB,
      YRDH,
      YRDL,
      YRDM,
      YRG,
      YRNS,
      YRR,
      YRRN,
      YRST,
      YS,
      YT,
      YTB,
      YTD,
      YTL,
      YTM,
      YTR,
      YTS,
      YTT,
      YV,
      YVS,
      YW,
      YXR,
      YXT,
      YY,
      ZPB,
      ZPC,
      ZPG,
      ZYFL,
      ZYTB,
      ZYTR
    };

    SurfaceVesselTypeCategoryCode (value v);

    SurfaceVesselTypeCategoryCode (const char* v);

    SurfaceVesselTypeCategoryCode (const ::std::string& v);

    SurfaceVesselTypeCategoryCode (const ::xml_schema::token& v);

    SurfaceVesselTypeCategoryCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    SurfaceVesselTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    SurfaceVesselTypeCategoryCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    SurfaceVesselTypeCategoryCode (const SurfaceVesselTypeCategoryCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual SurfaceVesselTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SurfaceVesselTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SurfaceVesselTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_SurfaceVesselTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_SurfaceVesselTypeCategoryCode_literals_[424];
    static const value _xsd_SurfaceVesselTypeCategoryCode_indexes_[424];
  };

  class SurveillanceCapabilityCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      COM,
      ELC,
      HUM,
      IMG,
      NKN,
      NOS,
      SIG
    };

    SurveillanceCapabilityCategoryCode (value v);

    SurveillanceCapabilityCategoryCode (const char* v);

    SurveillanceCapabilityCategoryCode (const ::std::string& v);

    SurveillanceCapabilityCategoryCode (const ::xml_schema::token& v);

    SurveillanceCapabilityCategoryCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    SurveillanceCapabilityCategoryCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    SurveillanceCapabilityCategoryCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    SurveillanceCapabilityCategoryCode (const SurveillanceCapabilityCategoryCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual SurveillanceCapabilityCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SurveillanceCapabilityCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SurveillanceCapabilityCategoryCode_convert ();
    }

    protected:
    value
    _xsd_SurveillanceCapabilityCategoryCode_convert () const;

    public:
    static const char* const _xsd_SurveillanceCapabilityCategoryCode_literals_[7];
    static const value _xsd_SurveillanceCapabilityCategoryCode_indexes_[7];
  };

  class SurveillanceCapabilityDescriptorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MRANGE,
      NRANGE
    };

    SurveillanceCapabilityDescriptorCode (value v);

    SurveillanceCapabilityDescriptorCode (const char* v);

    SurveillanceCapabilityDescriptorCode (const ::std::string& v);

    SurveillanceCapabilityDescriptorCode (const ::xml_schema::token& v);

    SurveillanceCapabilityDescriptorCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    SurveillanceCapabilityDescriptorCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    SurveillanceCapabilityDescriptorCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    SurveillanceCapabilityDescriptorCode (const SurveillanceCapabilityDescriptorCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual SurveillanceCapabilityDescriptorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SurveillanceCapabilityDescriptorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SurveillanceCapabilityDescriptorCode_convert ();
    }

    protected:
    value
    _xsd_SurveillanceCapabilityDescriptorCode_convert () const;

    public:
    static const char* const _xsd_SurveillanceCapabilityDescriptorCode_literals_[2];
    static const value _xsd_SurveillanceCapabilityDescriptorCode_indexes_[2];
  };

  class TargetEngagementAuthorityCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AVLB,
      EXCL,
      HPOTGT,
      NKN
    };

    TargetEngagementAuthorityCode (value v);

    TargetEngagementAuthorityCode (const char* v);

    TargetEngagementAuthorityCode (const ::std::string& v);

    TargetEngagementAuthorityCode (const ::xml_schema::token& v);

    TargetEngagementAuthorityCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    TargetEngagementAuthorityCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    TargetEngagementAuthorityCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    TargetEngagementAuthorityCode (const TargetEngagementAuthorityCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual TargetEngagementAuthorityCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TargetEngagementAuthorityCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_TargetEngagementAuthorityCode_convert ();
    }

    protected:
    value
    _xsd_TargetEngagementAuthorityCode_convert () const;

    public:
    static const char* const _xsd_TargetEngagementAuthorityCode_literals_[4];
    static const value _xsd_TargetEngagementAuthorityCode_indexes_[4];
  };

  class TargetPersonnelProtectionCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      COVER,
      DUGIN,
      PRAND,
      PRONE,
      PROVER,
      PRUG
    };

    TargetPersonnelProtectionCategoryCode (value v);

    TargetPersonnelProtectionCategoryCode (const char* v);

    TargetPersonnelProtectionCategoryCode (const ::std::string& v);

    TargetPersonnelProtectionCategoryCode (const ::xml_schema::token& v);

    TargetPersonnelProtectionCategoryCode (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    TargetPersonnelProtectionCategoryCode (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    TargetPersonnelProtectionCategoryCode (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    TargetPersonnelProtectionCategoryCode (const TargetPersonnelProtectionCategoryCode& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual TargetPersonnelProtectionCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TargetPersonnelProtectionCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_TargetPersonnelProtectionCategoryCode_convert ();
    }

    protected:
    value
    _xsd_TargetPersonnelProtectionCategoryCode_convert () const;

    public:
    static const char* const _xsd_TargetPersonnelProtectionCategoryCode_literals_[6];
    static const value _xsd_TargetPersonnelProtectionCategoryCode_indexes_[6];
  };

  class TaskFormationTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIRFMN,
      AIRTF,
      AMPHTF,
      CMBCTM,
      FLOTLA,
      GRNAVY,
      INTGTM,
      JNTTF,
      LANDTF,
      LNDFMN,
      MLCNVY,
      MRATCD,
      MRATCM,
      NAVFMN,
      NAVLTE,
      NAVLTF,
      NAVLTG,
      NAVLTU,
      NOS,
      PATROL,
      WRKPTY
    };

    TaskFormationTypeCategoryCode (value v);

    TaskFormationTypeCategoryCode (const char* v);

    TaskFormationTypeCategoryCode (const ::std::string& v);

    TaskFormationTypeCategoryCode (const ::xml_schema::token& v);

    TaskFormationTypeCategoryCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    TaskFormationTypeCategoryCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    TaskFormationTypeCategoryCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    TaskFormationTypeCategoryCode (const TaskFormationTypeCategoryCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual TaskFormationTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TaskFormationTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_TaskFormationTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_TaskFormationTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_TaskFormationTypeCategoryCode_literals_[21];
    static const value _xsd_TaskFormationTypeCategoryCode_indexes_[21];
  };

  class TransmissionCapabilityCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      RECEIV,
      TRNSMT,
      TRNSRC
    };

    TransmissionCapabilityCategoryCode (value v);

    TransmissionCapabilityCategoryCode (const char* v);

    TransmissionCapabilityCategoryCode (const ::std::string& v);

    TransmissionCapabilityCategoryCode (const ::xml_schema::token& v);

    TransmissionCapabilityCategoryCode (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    TransmissionCapabilityCategoryCode (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    TransmissionCapabilityCategoryCode (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    TransmissionCapabilityCategoryCode (const TransmissionCapabilityCategoryCode& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual TransmissionCapabilityCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TransmissionCapabilityCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_TransmissionCapabilityCategoryCode_convert ();
    }

    protected:
    value
    _xsd_TransmissionCapabilityCategoryCode_convert () const;

    public:
    static const char* const _xsd_TransmissionCapabilityCategoryCode_literals_[3];
    static const value _xsd_TransmissionCapabilityCategoryCode_indexes_[3];
  };

  class TransmissionCapabilityDescriptorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      MAXFRQ,
      MAXPRF,
      MNMFRQ,
      MNMPRF,
      POWER
    };

    TransmissionCapabilityDescriptorCode (value v);

    TransmissionCapabilityDescriptorCode (const char* v);

    TransmissionCapabilityDescriptorCode (const ::std::string& v);

    TransmissionCapabilityDescriptorCode (const ::xml_schema::token& v);

    TransmissionCapabilityDescriptorCode (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    TransmissionCapabilityDescriptorCode (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    TransmissionCapabilityDescriptorCode (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    TransmissionCapabilityDescriptorCode (const TransmissionCapabilityDescriptorCode& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual TransmissionCapabilityDescriptorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TransmissionCapabilityDescriptorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_TransmissionCapabilityDescriptorCode_convert ();
    }

    protected:
    value
    _xsd_TransmissionCapabilityDescriptorCode_convert () const;

    public:
    static const char* const _xsd_TransmissionCapabilityDescriptorCode_literals_[5];
    static const value _xsd_TransmissionCapabilityDescriptorCode_indexes_[5];
  };

  class UnitTypeArmCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AARMOR,
      ADMIN,
      AIRDEF,
      ARMANT,
      ARMOUR,
      ARTLRY,
      AV,
      AVACOM,
      AVAFW,
      AVARW,
      AVAVST,
      CBRN,
      ENG,
      EOD,
      FA,
      FIRSPT,
      HQSIGS,
      HQSTF,
      INF,
      INFWAR,
      ISFRCE,
      LAWENF,
      LNDSPT,
      LOG,
      MAINT,
      MANOV,
      MEDCL,
      MILINT,
      MSL,
      MSLSTA,
      NKN,
      NOS,
      RECCE,
      ROCKET,
      SIG,
      SUPPLY,
      TRNPTN,
      TRSSUP
    };

    UnitTypeArmCategoryCode (value v);

    UnitTypeArmCategoryCode (const char* v);

    UnitTypeArmCategoryCode (const ::std::string& v);

    UnitTypeArmCategoryCode (const ::xml_schema::token& v);

    UnitTypeArmCategoryCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    UnitTypeArmCategoryCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    UnitTypeArmCategoryCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    UnitTypeArmCategoryCode (const UnitTypeArmCategoryCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual UnitTypeArmCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UnitTypeArmCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_UnitTypeArmCategoryCode_convert ();
    }

    protected:
    value
    _xsd_UnitTypeArmCategoryCode_convert () const;

    public:
    static const char* const _xsd_UnitTypeArmCategoryCode_literals_[38];
    static const value _xsd_UnitTypeArmCategoryCode_indexes_[38];
  };

  class UnitTypeArmSpecialisationCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ADCOMP,
      ADGUN,
      ADMSL,
      AIREXP,
      ANTSUB,
      APOD,
      ARMREC,
      ARTSVY,
      ATTACK,
      AVASEC,
      BIOLOG,
      BIOREC,
      BRDGG,
      BRDRPT,
      C2AVA,
      CAVLRY,
      CBRNRC,
      CHMCAL,
      CHMREC,
      CHMSMD,
      CHMSMK,
      CIVAFR,
      CIVLWE,
      CNTINT,
      CNTRIN,
      CSAR,
      DECONT,
      DENTAL,
      DISSEC,
      ENCNST,
      ENGREC,
      ENGRRW,
      EW,
      EWDF,
      EWINTC,
      EWJAM,
      FAHOW,
      FAMLRS,
      FAMORT,
      FARCKL,
      FASLRS,
      FINANC,
      HNDLDG,
      INTERO,
      JNTINT,
      LABOUR,
      LEGAL,
      MCMAVA,
      MEDEVC,
      MEDTRS,
      MEDTRT,
      METEO,
      MILPOL,
      MIOPS,
      MNTELC,
      MNTELO,
      MNTHVY,
      MNTMSL,
      MNTORD,
      MRTGRR,
      MVTCNT,
      MWR,
      NUCRAD,
      PERSVC,
      PIPELN,
      POSTAL,
      PSYCH,
      PSYOP,
      PUBAF,
      PUBAFB,
      PUBAFJ,
      QM,
      RAILSE,
      RANGER,
      RECAVA,
      RECOVR,
      REFAVA,
      RELCHP,
      REPLHO,
      RIVSEC,
      SARAVA,
      SCOUT,
      SEAL,
      SECPOL,
      SGCMDO,
      SGELCR,
      SGNC,
      SGNLE,
      SGNSE,
      SGRAD,
      SGRDRL,
      SGSPT,
      SGTACS,
      SGTELC,
      SGTELS,
      SHRPAT,
      SIGINT,
      SPBOAT,
      SPCFOR,
      SPLC1,
      SPLC2,
      SPLC3,
      SPLC3A,
      SPLC4,
      SPLC5,
      SPLLDB,
      SPLWAT,
      SPOD,
      SPOPSP,
      SPSSNR,
      SRSNSC,
      SRV,
      SRVGSM,
      SRVGSR,
      SRVLR,
      SRVSEN,
      SURG,
      TACEXP,
      TGTACQ,
      TGTAOP,
      TGTARD,
      TGTASD,
      TGTNG,
      TOPO,
      TRNMSL,
      TRNRLY,
      UDT,
      UTLAVA,
      VET,
      WATER
    };

    UnitTypeArmSpecialisationCode (value v);

    UnitTypeArmSpecialisationCode (const char* v);

    UnitTypeArmSpecialisationCode (const ::std::string& v);

    UnitTypeArmSpecialisationCode (const ::xml_schema::token& v);

    UnitTypeArmSpecialisationCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    UnitTypeArmSpecialisationCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    UnitTypeArmSpecialisationCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    UnitTypeArmSpecialisationCode (const UnitTypeArmSpecialisationCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual UnitTypeArmSpecialisationCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UnitTypeArmSpecialisationCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_UnitTypeArmSpecialisationCode_convert ();
    }

    protected:
    value
    _xsd_UnitTypeArmSpecialisationCode_convert () const;

    public:
    static const char* const _xsd_UnitTypeArmSpecialisationCode_literals_[130];
    static const value _xsd_UnitTypeArmSpecialisationCode_indexes_[130];
  };

  class UnitTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      COMBAT,
      COMSER,
      COMSPT,
      NKN,
      SOF
    };

    UnitTypeCategoryCode (value v);

    UnitTypeCategoryCode (const char* v);

    UnitTypeCategoryCode (const ::std::string& v);

    UnitTypeCategoryCode (const ::xml_schema::token& v);

    UnitTypeCategoryCode (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    UnitTypeCategoryCode (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    UnitTypeCategoryCode (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    UnitTypeCategoryCode (const UnitTypeCategoryCode& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual UnitTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UnitTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_UnitTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_UnitTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_UnitTypeCategoryCode_literals_[5];
    static const value _xsd_UnitTypeCategoryCode_indexes_[5];
  };

  class UnitTypeGeneralMobilityCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIR,
      AIRCMP,
      AIRFW,
      AIRRW,
      AIRVST,
      AMPH,
      DSMNTD,
      HORSE,
      LAND,
      LNDRAI,
      LNDTRC,
      LNDTWD,
      LNDWHL
    };

    UnitTypeGeneralMobilityCode (value v);

    UnitTypeGeneralMobilityCode (const char* v);

    UnitTypeGeneralMobilityCode (const ::std::string& v);

    UnitTypeGeneralMobilityCode (const ::xml_schema::token& v);

    UnitTypeGeneralMobilityCode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    UnitTypeGeneralMobilityCode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    UnitTypeGeneralMobilityCode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    UnitTypeGeneralMobilityCode (const UnitTypeGeneralMobilityCode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual UnitTypeGeneralMobilityCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UnitTypeGeneralMobilityCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_UnitTypeGeneralMobilityCode_convert ();
    }

    protected:
    value
    _xsd_UnitTypeGeneralMobilityCode_convert () const;

    public:
    static const char* const _xsd_UnitTypeGeneralMobilityCode_literals_[13];
    static const value _xsd_UnitTypeGeneralMobilityCode_indexes_[13];
  };

  class UnitTypeQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CORPS,
      DIV,
      FORCE,
      HEAVY,
      HMAD,
      LIGHT,
      LR,
      MEDIUM,
      MR,
      SR,
      STRTGC,
      TACTCL,
      THTRE,
      TMD,
      VSR
    };

    UnitTypeQualifierCode (value v);

    UnitTypeQualifierCode (const char* v);

    UnitTypeQualifierCode (const ::std::string& v);

    UnitTypeQualifierCode (const ::xml_schema::token& v);

    UnitTypeQualifierCode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    UnitTypeQualifierCode (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    UnitTypeQualifierCode (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    UnitTypeQualifierCode (const UnitTypeQualifierCode& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual UnitTypeQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UnitTypeQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_UnitTypeQualifierCode_convert ();
    }

    protected:
    value
    _xsd_UnitTypeQualifierCode_convert () const;

    public:
    static const char* const _xsd_UnitTypeQualifierCode_literals_[15];
    static const value _xsd_UnitTypeQualifierCode_indexes_[15];
  };

  class UnitTypeSizeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AG,
      ARMY,
      BATGRP,
      BDE,
      BDEGRP,
      BN,
      BNG,
      CORPS,
      COY,
      COYG,
      DIV,
      FLEET,
      FLIGHT,
      NKN,
      NOS,
      NTF,
      NTG,
      NTU,
      PLT,
      REGION,
      RGT,
      SECT,
      SQDRNA,
      SQDRNM,
      SQUAD,
      TEAM,
      TSKELN,
      WING
    };

    UnitTypeSizeCode (value v);

    UnitTypeSizeCode (const char* v);

    UnitTypeSizeCode (const ::std::string& v);

    UnitTypeSizeCode (const ::xml_schema::token& v);

    UnitTypeSizeCode (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    UnitTypeSizeCode (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    UnitTypeSizeCode (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    UnitTypeSizeCode (const UnitTypeSizeCode& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual UnitTypeSizeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UnitTypeSizeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_UnitTypeSizeCode_convert ();
    }

    protected:
    value
    _xsd_UnitTypeSizeCode_convert () const;

    public:
    static const char* const _xsd_UnitTypeSizeCode_literals_[28];
    static const value _xsd_UnitTypeSizeCode_indexes_[28];
  };

  class UnitTypeSupplementarySpecialisationCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIR,
      AIRBRN,
      AMPH,
      ARASLT,
      ARCTIC,
      ARMORD,
      GROUND,
      LIGHT,
      MARINE,
      MECH,
      MOUNTN,
      MTRSD,
      NAVAL
    };

    UnitTypeSupplementarySpecialisationCode (value v);

    UnitTypeSupplementarySpecialisationCode (const char* v);

    UnitTypeSupplementarySpecialisationCode (const ::std::string& v);

    UnitTypeSupplementarySpecialisationCode (const ::xml_schema::token& v);

    UnitTypeSupplementarySpecialisationCode (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    UnitTypeSupplementarySpecialisationCode (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    UnitTypeSupplementarySpecialisationCode (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    UnitTypeSupplementarySpecialisationCode (const UnitTypeSupplementarySpecialisationCode& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual UnitTypeSupplementarySpecialisationCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UnitTypeSupplementarySpecialisationCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_UnitTypeSupplementarySpecialisationCode_convert ();
    }

    protected:
    value
    _xsd_UnitTypeSupplementarySpecialisationCode_convert () const;

    public:
    static const char* const _xsd_UnitTypeSupplementarySpecialisationCode_literals_[13];
    static const value _xsd_UnitTypeSupplementarySpecialisationCode_indexes_[13];
  };

  class UsageStatusCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ACTIVE,
      DEACTV,
      NKN
    };

    UsageStatusCode (value v);

    UsageStatusCode (const char* v);

    UsageStatusCode (const ::std::string& v);

    UsageStatusCode (const ::xml_schema::token& v);

    UsageStatusCode (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    UsageStatusCode (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    UsageStatusCode (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    UsageStatusCode (const UsageStatusCode& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual UsageStatusCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UsageStatusCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_UsageStatusCode_convert ();
    }

    protected:
    value
    _xsd_UsageStatusCode_convert () const;

    public:
    static const char* const _xsd_UsageStatusCode_literals_[3];
    static const value _xsd_UsageStatusCode_indexes_[3];
  };

  class UxoStatusExposureCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      FULEXP,
      NKN,
      NOS,
      PRTEX,
      PRTEXB,
      PRTEXN,
      PRTEXS,
      PRTEXT,
      UNEXPD
    };

    UxoStatusExposureCode (value v);

    UxoStatusExposureCode (const char* v);

    UxoStatusExposureCode (const ::std::string& v);

    UxoStatusExposureCode (const ::xml_schema::token& v);

    UxoStatusExposureCode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    UxoStatusExposureCode (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    UxoStatusExposureCode (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    UxoStatusExposureCode (const UxoStatusExposureCode& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual UxoStatusExposureCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UxoStatusExposureCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_UxoStatusExposureCode_convert ();
    }

    protected:
    value
    _xsd_UxoStatusExposureCode_convert () const;

    public:
    static const char* const _xsd_UxoStatusExposureCode_literals_[9];
    static const value _xsd_UxoStatusExposureCode_indexes_[9];
  };

  class UxoStatusQualifierCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BROKEN,
      INTACT,
      LEAKNG,
      NEW,
      NKN,
      NOS,
      OLD,
      RUSTED
    };

    UxoStatusQualifierCode (value v);

    UxoStatusQualifierCode (const char* v);

    UxoStatusQualifierCode (const ::std::string& v);

    UxoStatusQualifierCode (const ::xml_schema::token& v);

    UxoStatusQualifierCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    UxoStatusQualifierCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    UxoStatusQualifierCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    UxoStatusQualifierCode (const UxoStatusQualifierCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual UxoStatusQualifierCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UxoStatusQualifierCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_UxoStatusQualifierCode_convert ();
    }

    protected:
    value
    _xsd_UxoStatusQualifierCode_convert () const;

    public:
    static const char* const _xsd_UxoStatusQualifierCode_literals_[8];
    static const value _xsd_UxoStatusQualifierCode_indexes_[8];
  };

  class VegetationCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BARE,
      JUNGLE,
      NKN,
      NOS,
      PLANT,
      RNGLND,
      WETLND,
      WODLND
    };

    VegetationCategoryCode (value v);

    VegetationCategoryCode (const char* v);

    VegetationCategoryCode (const ::std::string& v);

    VegetationCategoryCode (const ::xml_schema::token& v);

    VegetationCategoryCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    VegetationCategoryCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    VegetationCategoryCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    VegetationCategoryCode (const VegetationCategoryCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual VegetationCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    VegetationCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_VegetationCategoryCode_convert ();
    }

    protected:
    value
    _xsd_VegetationCategoryCode_convert () const;

    public:
    static const char* const _xsd_VegetationCategoryCode_literals_[8];
    static const value _xsd_VegetationCategoryCode_indexes_[8];
  };

  class VegetationSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BAMBOO,
      BTNCLG,
      CRPLND,
      DESERT,
      FOREST,
      GRASS,
      GRSLND,
      HDGERW,
      HOPS,
      JUNGC,
      JUNGCE,
      JUNGP,
      JUNGS,
      MARSH,
      NURSRY,
      OASIS,
      ORCHRD,
      SAVNNH,
      SCRUB,
      SWAMP,
      TREES,
      TUNDRA,
      VNEYRD
    };

    VegetationSubcategoryCode (value v);

    VegetationSubcategoryCode (const char* v);

    VegetationSubcategoryCode (const ::std::string& v);

    VegetationSubcategoryCode (const ::xml_schema::token& v);

    VegetationSubcategoryCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    VegetationSubcategoryCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    VegetationSubcategoryCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    VegetationSubcategoryCode (const VegetationSubcategoryCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual VegetationSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    VegetationSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_VegetationSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_VegetationSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_VegetationSubcategoryCode_literals_[23];
    static const value _xsd_VegetationSubcategoryCode_indexes_[23];
  };

  class VehicleTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      ACVACV,
      AMBUL,
      AMPH,
      APC,
      APCREC,
      ARMORD,
      ARMRCC,
      ARVELT,
      ASSV,
      ASSVEH,
      AUTOMO,
      BICYCL,
      BTHVRE,
      BTLTRE,
      BTMDRE,
      BUS,
      CART,
      CCTRCK,
      CEVEH,
      CMDPST,
      CMDPTA,
      CMDPTW,
      CSVEH,
      ENGNOS,
      FORKLF,
      FRFGTN,
      GNLPRP,
      HALFTR,
      HETVEH,
      LNDVEH,
      MAINT,
      MHVEH,
      MILUV,
      MOTCYC,
      NKN,
      NOS,
      SEMI,
      SNOWPL,
      SPCPRP,
      TRACTR,
      TRAILR,
      TRANSG,
      TRANST,
      TRLBUS,
      TRUCK,
      TRUCKD,
      UTILTY,
      WRCKR
    };

    VehicleTypeCategoryCode (value v);

    VehicleTypeCategoryCode (const char* v);

    VehicleTypeCategoryCode (const ::std::string& v);

    VehicleTypeCategoryCode (const ::xml_schema::token& v);

    VehicleTypeCategoryCode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    VehicleTypeCategoryCode (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    VehicleTypeCategoryCode (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    VehicleTypeCategoryCode (const VehicleTypeCategoryCode& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual VehicleTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    VehicleTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_VehicleTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_VehicleTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_VehicleTypeCategoryCode_literals_[48];
    static const value _xsd_VehicleTypeCategoryCode_indexes_[48];
  };

  class VerticalDistanceReferenceCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CHADAT,
      LOCDAT,
      MNSLVL,
      PDQFE,
      PDQNH,
      PDSTDT,
      TOPOSR,
      WATBOT,
      WGS84G,
      WGS84R
    };

    VerticalDistanceReferenceCode (value v);

    VerticalDistanceReferenceCode (const char* v);

    VerticalDistanceReferenceCode (const ::std::string& v);

    VerticalDistanceReferenceCode (const ::xml_schema::token& v);

    VerticalDistanceReferenceCode (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    VerticalDistanceReferenceCode (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    VerticalDistanceReferenceCode (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    VerticalDistanceReferenceCode (const VerticalDistanceReferenceCode& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual VerticalDistanceReferenceCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    VerticalDistanceReferenceCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_VerticalDistanceReferenceCode_convert ();
    }

    protected:
    value
    _xsd_VerticalDistanceReferenceCode_convert () const;

    public:
    static const char* const _xsd_VerticalDistanceReferenceCode_literals_[10];
    static const value _xsd_VerticalDistanceReferenceCode_indexes_[10];
  };

  class VesselTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      IX,
      NKN,
      SUBSRF,
      SURFAC
    };

    VesselTypeCategoryCode (value v);

    VesselTypeCategoryCode (const char* v);

    VesselTypeCategoryCode (const ::std::string& v);

    VesselTypeCategoryCode (const ::xml_schema::token& v);

    VesselTypeCategoryCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    VesselTypeCategoryCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    VesselTypeCategoryCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    VesselTypeCategoryCode (const VesselTypeCategoryCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual VesselTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    VesselTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_VesselTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_VesselTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_VesselTypeCategoryCode_literals_[4];
    static const value _xsd_VesselTypeCategoryCode_indexes_[4];
  };

  class VesselTypePropulsionTypeCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AIP,
      CODAG,
      CODOG,
      COGOG,
      CONAS,
      COSAG,
      DE,
      DG,
      DM,
      DMWJ,
      EM,
      GTU,
      NUC,
      NUCE,
      OARS,
      PJ,
      PM,
      SAIL,
      TE,
      TU,
      WJ
    };

    VesselTypePropulsionTypeCode (value v);

    VesselTypePropulsionTypeCode (const char* v);

    VesselTypePropulsionTypeCode (const ::std::string& v);

    VesselTypePropulsionTypeCode (const ::xml_schema::token& v);

    VesselTypePropulsionTypeCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    VesselTypePropulsionTypeCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    VesselTypePropulsionTypeCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    VesselTypePropulsionTypeCode (const VesselTypePropulsionTypeCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual VesselTypePropulsionTypeCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    VesselTypePropulsionTypeCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_VesselTypePropulsionTypeCode_convert ();
    }

    protected:
    value
    _xsd_VesselTypePropulsionTypeCode_convert () const;

    public:
    static const char* const _xsd_VesselTypePropulsionTypeCode_literals_[21];
    static const value _xsd_VesselTypePropulsionTypeCode_indexes_[21];
  };

  class VisibilityCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      BLWSNW,
      DSTDVL,
      DSTSND,
      DSTSTR,
      FOG,
      FRZFOG,
      HAZE,
      NKN,
      NOS,
      SMOKE,
      SNDSTR
    };

    VisibilityCategoryCode (value v);

    VisibilityCategoryCode (const char* v);

    VisibilityCategoryCode (const ::std::string& v);

    VisibilityCategoryCode (const ::xml_schema::token& v);

    VisibilityCategoryCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    VisibilityCategoryCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    VisibilityCategoryCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    VisibilityCategoryCode (const VisibilityCategoryCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual VisibilityCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    VisibilityCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_VisibilityCategoryCode_convert ();
    }

    protected:
    value
    _xsd_VisibilityCategoryCode_convert () const;

    public:
    static const char* const _xsd_VisibilityCategoryCode_literals_[11];
    static const value _xsd_VisibilityCategoryCode_indexes_[11];
  };

  class WeaponTypeCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AD,
      ANTSUB,
      AT,
      CANNON,
      FA,
      MISSYS,
      MORTAR,
      NKN,
      NOS,
      RCKART,
      SMARMS,
      TANK
    };

    WeaponTypeCategoryCode (value v);

    WeaponTypeCategoryCode (const char* v);

    WeaponTypeCategoryCode (const ::std::string& v);

    WeaponTypeCategoryCode (const ::xml_schema::token& v);

    WeaponTypeCategoryCode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    WeaponTypeCategoryCode (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    WeaponTypeCategoryCode (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    WeaponTypeCategoryCode (const WeaponTypeCategoryCode& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual WeaponTypeCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    WeaponTypeCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_WeaponTypeCategoryCode_convert ();
    }

    protected:
    value
    _xsd_WeaponTypeCategoryCode_convert () const;

    public:
    static const char* const _xsd_WeaponTypeCategoryCode_literals_[12];
    static const value _xsd_WeaponTypeCategoryCode_indexes_[12];
  };

  class WeaponTypeFireGuidanceIndicatorCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      NO,
      YES
    };

    WeaponTypeFireGuidanceIndicatorCode (value v);

    WeaponTypeFireGuidanceIndicatorCode (const char* v);

    WeaponTypeFireGuidanceIndicatorCode (const ::std::string& v);

    WeaponTypeFireGuidanceIndicatorCode (const ::xml_schema::token& v);

    WeaponTypeFireGuidanceIndicatorCode (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    WeaponTypeFireGuidanceIndicatorCode (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    WeaponTypeFireGuidanceIndicatorCode (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    WeaponTypeFireGuidanceIndicatorCode (const WeaponTypeFireGuidanceIndicatorCode& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual WeaponTypeFireGuidanceIndicatorCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    WeaponTypeFireGuidanceIndicatorCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_WeaponTypeFireGuidanceIndicatorCode_convert ();
    }

    protected:
    value
    _xsd_WeaponTypeFireGuidanceIndicatorCode_convert () const;

    public:
    static const char* const _xsd_WeaponTypeFireGuidanceIndicatorCode_literals_[2];
    static const value _xsd_WeaponTypeFireGuidanceIndicatorCode_indexes_[2];
  };

  class WeaponTypeSubcategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      AAARTR,
      AAMGUN,
      ADCAN,
      ADGUN,
      ADHEV,
      ADLGT,
      ADMED,
      ADMIS,
      ADMLLR,
      ADMLMR,
      ADMLSR,
      ADMLT,
      AIFV,
      ARTHEV,
      ARTLGT,
      ARTMED,
      ARTVHV,
      ARV,
      ASSGUN,
      ASSML,
      ATGNHV,
      ATGNLT,
      ATGNMD,
      ATGRLC,
      ATGRLH,
      ATGRLL,
      ATGRLM,
      ATGUN,
      ATMIS,
      ATMLHV,
      ATMLLT,
      ATMLMD,
      ATRLHV,
      ATRLLT,
      ATRLMD,
      ATROC,
      BMLLR,
      BMLMR,
      BMLSR,
      BTNKHE,
      BTNKLI,
      BTNKME,
      CINWPS,
      CRWPUN,
      DFGN,
      DFGNHV,
      DFGNLT,
      DFGNMD,
      FFART,
      FLAMET,
      GCML,
      GRENLN,
      GRLNHV,
      GRLNLT,
      GRLNMD,
      GUN,
      GUNHOW,
      HOWIT,
      HOWTHV,
      HOWTLT,
      HOWTMD,
      MACGHV,
      MACGLT,
      MACGUN,
      MCHPTL,
      MLRS,
      MLRSHV,
      MLRSLT,
      MLRSMD,
      MRTHEV,
      MRTLGT,
      MRTMED,
      MRTVHV,
      NKN,
      NOS,
      PISTOL,
      RECGUN,
      RECTNK,
      RFLASS,
      RFLCRB,
      RIFLE,
      SAMISL,
      SHOTGU,
      SRCLAU,
      SRKLHV,
      SRKLLG,
      SRKLMD,
      SSMIS,
      SSMLLR,
      SSMLMR,
      SSMLSR,
      SUBMAC,
      TKDTRY,
      TKGUNH,
      TKGUNL,
      TKGUNM
    };

    WeaponTypeSubcategoryCode (value v);

    WeaponTypeSubcategoryCode (const char* v);

    WeaponTypeSubcategoryCode (const ::std::string& v);

    WeaponTypeSubcategoryCode (const ::xml_schema::token& v);

    WeaponTypeSubcategoryCode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    WeaponTypeSubcategoryCode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    WeaponTypeSubcategoryCode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    WeaponTypeSubcategoryCode (const WeaponTypeSubcategoryCode& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual WeaponTypeSubcategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    WeaponTypeSubcategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_WeaponTypeSubcategoryCode_convert ();
    }

    protected:
    value
    _xsd_WeaponTypeSubcategoryCode_convert () const;

    public:
    static const char* const _xsd_WeaponTypeSubcategoryCode_literals_[96];
    static const value _xsd_WeaponTypeSubcategoryCode_indexes_[96];
  };

  class WindAirStabilityCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_1,
      cxx_2,
      cxx_3,
      cxx_4,
      cxx_5,
      cxx_6,
      cxx_7,
      N,
      S,
      U
    };

    WindAirStabilityCategoryCode (value v);

    WindAirStabilityCategoryCode (const char* v);

    WindAirStabilityCategoryCode (const ::std::string& v);

    WindAirStabilityCategoryCode (const ::xml_schema::token& v);

    WindAirStabilityCategoryCode (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    WindAirStabilityCategoryCode (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    WindAirStabilityCategoryCode (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    WindAirStabilityCategoryCode (const WindAirStabilityCategoryCode& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual WindAirStabilityCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    WindAirStabilityCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_WindAirStabilityCategoryCode_convert ();
    }

    protected:
    value
    _xsd_WindAirStabilityCategoryCode_convert () const;

    public:
    static const char* const _xsd_WindAirStabilityCategoryCode_literals_[10];
    static const value _xsd_WindAirStabilityCategoryCode_indexes_[10];
  };

  class WindAltitudeLayerCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      cxx_10,
      cxx_12,
      cxx_14,
      cxx_16,
      cxx_18,
      cxx_2,
      cxx_20,
      cxx_22,
      cxx_24,
      cxx_26,
      cxx_28,
      cxx_30,
      cxx_4,
      cxx_6,
      cxx_8
    };

    WindAltitudeLayerCode (value v);

    WindAltitudeLayerCode (const char* v);

    WindAltitudeLayerCode (const ::std::string& v);

    WindAltitudeLayerCode (const ::xml_schema::token& v);

    WindAltitudeLayerCode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    WindAltitudeLayerCode (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    WindAltitudeLayerCode (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    WindAltitudeLayerCode (const WindAltitudeLayerCode& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual WindAltitudeLayerCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    WindAltitudeLayerCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_WindAltitudeLayerCode_convert ();
    }

    protected:
    value
    _xsd_WindAltitudeLayerCode_convert () const;

    public:
    static const char* const _xsd_WindAltitudeLayerCode_literals_[15];
    static const value _xsd_WindAltitudeLayerCode_indexes_[15];
  };

  class WindCategoryCode: public ::xml_schema::token
  {
    public:
    enum value
    {
      CONST,
      GUST,
      NKN,
      SQUAL,
      TRBLEX,
      TRBLLI,
      TRBLMO,
      TRBLSE,
      VRB,
      WSHEAR
    };

    WindCategoryCode (value v);

    WindCategoryCode (const char* v);

    WindCategoryCode (const ::std::string& v);

    WindCategoryCode (const ::xml_schema::token& v);

    WindCategoryCode (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    WindCategoryCode (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    WindCategoryCode (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    WindCategoryCode (const WindCategoryCode& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual WindCategoryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    WindCategoryCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_WindCategoryCode_convert ();
    }

    protected:
    value
    _xsd_WindCategoryCode_convert () const;

    public:
    static const char* const _xsd_WindCategoryCode_literals_[10];
    static const value _xsd_WindCategoryCode_indexes_[10];
  };
}

#include <iosfwd>

namespace oo_2_0
{
  ::std::ostream&
  operator<< (::std::ostream&, AbsolutePointCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AbsolutePointCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionAircraftEmploymentApproachOffsetCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionAircraftEmploymentApproachOffsetCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionAircraftEmploymentCrewCompositionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionAircraftEmploymentCrewCompositionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionAircraftEmploymentDeplanementMethodCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionAircraftEmploymentDeplanementMethodCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionAircraftEmploymentGeneralRoleCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionAircraftEmploymentGeneralRoleCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionAircraftEmploymentInflightReportRequirementIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionAircraftEmploymentInflightReportRequirementIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionContextCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionContextCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionEffectCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionEffectCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionEffectDescriptionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionEffectDescriptionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionEffectSeverityCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionEffectSeverityCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionElectronicWarfareEmploymentCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionElectronicWarfareEmploymentCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionEventCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionEventCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionEventDetailClassificationCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionEventDetailClassificationCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionEventDetailCrimeIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionEventDetailCrimeIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionFunctionalAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionFunctionalAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionMaritimeEmploymentVesselTransitInstructionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionMaritimeEmploymentVesselTransitInstructionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionObjectiveCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionObjectiveCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionObjectiveItemCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionObjectiveItemCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionObjectiveItemMarkingMethodCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionObjectiveItemMarkingMethodCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionObjectiveItemMarkingPanelShapeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionObjectiveItemMarkingPanelShapeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionObjectiveItemMarkingRecognitionSignalColourCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionObjectiveItemMarkingRecognitionSignalColourCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionObjectiveItemPrimacyCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionObjectiveItemPrimacyCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionObjectiveQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionObjectiveQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionObjectiveTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionObjectiveTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionObjectiveTypeImageryProductImageTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionObjectiveTypeImageryProductImageTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionReconnaissanceEmploymentImageCoverageModeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionReconnaissanceEmploymentImageCoverageModeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionReconnaissanceEmploymentImageViewQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionReconnaissanceEmploymentImageViewQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionReconnaissanceEmploymentTypeOfCoverageCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionReconnaissanceEmploymentTypeOfCoverageCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionReferenceAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionReferenceAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionResourceCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionResourceCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionResourceCriticalityIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionResourceCriticalityIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionResourceEmploymentCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionResourceEmploymentCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionResourceEmploymentMethodOfControlCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionResourceEmploymentMethodOfControlCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionResourceEmploymentTrajectoryFireCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionResourceEmploymentTrajectoryFireCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionResourceQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionResourceQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskActivityCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskActivityCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskEndQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskEndQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskEntailedSafetyDegreeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskEntailedSafetyDegreeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskMeteorologicalImpactCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskMeteorologicalImpactCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskOperationalLevelCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskOperationalLevelCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskOvertCovertCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskOvertCovertCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskPriorityCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskPriorityCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskStartQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskStartQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskStatusAmendTimingCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskStatusAmendTimingCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskStatusApprovalIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskStatusApprovalIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskStatusCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskStatusCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskStatusPlanningIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskStatusPlanningIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskStatusProgressCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskStatusProgressCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskTimingDayCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskTimingDayCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTaskTimingHourCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTaskTimingHourCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ActionTemporalAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ActionTemporalAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AddressCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AddressCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AffiliationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AffiliationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AffiliationEthnicGroupCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AffiliationEthnicGroupCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AffiliationFunctionalGroupCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AffiliationFunctionalGroupCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AffiliationGeopoliticalCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AffiliationGeopoliticalCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AffiliationReligionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AffiliationReligionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AirRouteSegmentCivilMilitaryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AirRouteSegmentCivilMilitaryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AirRouteSegmentInternationalRouteCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AirRouteSegmentInternationalRouteCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AirRouteSegmentRequiredNavigationPerformanceCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AirRouteSegmentRequiredNavigationPerformanceCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AircraftTypeAirframeDesignCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AircraftTypeAirframeDesignCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AircraftTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AircraftTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AircraftTypeDesignRangeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AircraftTypeDesignRangeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AircraftTypeDesignRoleCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AircraftTypeDesignRoleCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AircraftTypeLoadCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AircraftTypeLoadCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AircraftTypeMainPurposeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AircraftTypeMainPurposeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AircraftTypeManningCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AircraftTypeManningCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AircraftTypeMilitaryCivilianCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AircraftTypeMilitaryCivilianCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AircraftTypeModelCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AircraftTypeModelCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AircraftTypeTakeoffAndLandingCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AircraftTypeTakeoffAndLandingCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AircraftTypeTrainingCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AircraftTypeTrainingCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AircraftTypeWeatherQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AircraftTypeWeatherQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AirfieldAirTrafficControlPresenceIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AirfieldAirTrafficControlPresenceIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AirfieldInstrumentLandingSystemPresenceIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AirfieldInstrumentLandingSystemPresenceIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AirfieldStatusDayOperationsCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AirfieldStatusDayOperationsCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AirfieldStatusEvaluationIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AirfieldStatusEvaluationIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AirfieldStatusFlightSupportCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AirfieldStatusFlightSupportCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AirfieldTypeUseCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AirfieldTypeUseCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AirfieldVisualNavigationalAidIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AirfieldVisualNavigationalAidIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AmmunitionTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AmmunitionTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AmmunitionTypeExerciseMineFlareColourCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AmmunitionTypeExerciseMineFlareColourCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AmmunitionTypeMineMaritimeFiringCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AmmunitionTypeMineMaritimeFiringCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AnchorageBottomTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AnchorageBottomTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AnchorageMooringsTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AnchorageMooringsTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AnglePrecisionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AnglePrecisionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ApproachDirectionCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ApproachDirectionCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AssociationStatusCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AssociationStatusCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AtmosphereInversionLayerCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AtmosphereInversionLayerCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AtmospherePressureSystemCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AtmospherePressureSystemCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, AtmosphereTemperatureGradientCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const AtmosphereTemperatureGradientCode&);

  ::std::ostream&
  operator<< (::std::ostream&, BerthMajorVesselClassCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const BerthMajorVesselClassCode&);

  ::std::ostream&
  operator<< (::std::ostream&, BerthRailAvailabilityIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const BerthRailAvailabilityIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, BerthRollOnRollOffIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const BerthRollOnRollOffIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, BiologicalMaterielTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const BiologicalMaterielTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, BiologicalMaterielTypeSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const BiologicalMaterielTypeSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, BridgeTypeDesignTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const BridgeTypeDesignTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, BridgeUsageCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const BridgeUsageCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CandidateTargetDetailAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CandidateTargetDetailAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CandidateTargetDetailAuthorisationApprovalCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CandidateTargetDetailAuthorisationApprovalCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CandidateTargetDetailCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CandidateTargetDetailCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CandidateTargetDetailFocusTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CandidateTargetDetailFocusTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CandidateTargetDetailSchemeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CandidateTargetDetailSchemeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CandidateTargetListAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CandidateTargetListAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CandidateTargetListAuthorisationIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CandidateTargetListAuthorisationIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CapabilityCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CapabilityCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CapabilityDayNightCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CapabilityDayNightCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CapabilityReferenceAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CapabilityReferenceAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CapabilityUnitOfMeasureCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CapabilityUnitOfMeasureCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CargoCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CargoCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CasualtyGroupCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CasualtyGroupCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CbrnEquipmentTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CbrnEquipmentTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CbrnEventAlarmResultIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CbrnEventAlarmResultIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CbrnEventCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CbrnEventCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CbrnEventConfirmationTestIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CbrnEventConfirmationTestIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CbrnEventMaterielContainerTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CbrnEventMaterielContainerTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CbrnEventSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CbrnEventSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ChemicalBiologicalEventCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ChemicalBiologicalEventCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ChemicalBiologicalEventSpillSizeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ChemicalBiologicalEventSpillSizeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ChemicalMaterielTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ChemicalMaterielTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ChemicalMaterielTypeSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ChemicalMaterielTypeSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CivilianPostTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CivilianPostTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CloudCoverAverageCoverageCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CloudCoverAverageCoverageCode&);

  ::std::ostream&
  operator<< (::std::ostream&, CloudCoverCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const CloudCoverCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ConsumableMaterielTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ConsumableMaterielTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ConsumableMaterielTypeHazardCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ConsumableMaterielTypeHazardCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ConsumableMaterielTypeIssuingElementCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ConsumableMaterielTypeIssuingElementCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ConsumableMaterielTypeIssuingUnitOfMeasureCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ConsumableMaterielTypeIssuingUnitOfMeasureCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ConsumableMaterielTypePerishabilityIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ConsumableMaterielTypePerishabilityIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ConsumableMaterielTypeSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ConsumableMaterielTypeSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ConsumableMaterielTypeUnitedNationsNumberCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ConsumableMaterielTypeUnitedNationsNumberCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ContextAssessmentLimitingFactorsCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ContextAssessmentLimitingFactorsCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ContextAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ContextAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ContextCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ContextCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ContextElementStatusCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ContextElementStatusCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ContextObjectItemAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ContextObjectItemAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ContextReportingDataAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ContextReportingDataAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ControlFeatureCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ControlFeatureCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ControlFeatureStatusCbrnThreatLevelCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ControlFeatureStatusCbrnThreatLevelCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ControlFeatureStatusInvestigationStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ControlFeatureStatusInvestigationStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ControlFeatureStatusSecurityStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ControlFeatureStatusSecurityStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ControlFeatureTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ControlFeatureTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, DemolitionStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const DemolitionStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, DirectionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const DirectionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, DistancePrecisionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const DistancePrecisionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, DryDockMarineRailwaySizeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const DryDockMarineRailwaySizeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ElectronicEquipmentTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ElectronicEquipmentTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ElectronicEquipmentTypeSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ElectronicEquipmentTypeSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, EngineeringCapabilityCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const EngineeringCapabilityCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, EngineeringCapabilityDescriptorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const EngineeringCapabilityDescriptorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, EngineeringEquipmentTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const EngineeringEquipmentTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, EquipmentTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const EquipmentTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, EvacuationDestinationCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const EvacuationDestinationCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ExecutiveMilitaryOrganisationTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ExecutiveMilitaryOrganisationTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FacilityCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FacilityCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FacilityPrimaryConstructionMaterialCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FacilityPrimaryConstructionMaterialCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FacilityStatusCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FacilityStatusCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FacilityStatusEnemyActivityConditionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FacilityStatusEnemyActivityConditionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FacilityStatusOccupationProgramIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FacilityStatusOccupationProgramIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FacilityStatusOperationalStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FacilityStatusOperationalStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FacilityStatusOperationalStatusQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FacilityStatusOperationalStatusQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FacilityStatusReserveIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FacilityStatusReserveIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FacilityStatusSecurityStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FacilityStatusSecurityStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FacilityTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FacilityTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FeatureCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FeatureCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FeatureTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FeatureTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FeintIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FeintIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FireCapabilityCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FireCapabilityCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FireCapabilityDescriptorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FireCapabilityDescriptorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, FireCapabilityWeaponTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const FireCapabilityWeaponTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GenderCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GenderCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GeographicFeatureBottomHardnessCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GeographicFeatureBottomHardnessCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GeographicFeatureSolidSurfaceCompositionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GeographicFeatureSolidSurfaceCompositionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GeographicFeatureStatusCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GeographicFeatureStatusCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GeographicFeatureStatusSurfaceRecirculationIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GeographicFeatureStatusSurfaceRecirculationIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GeographicFeatureSurfaceCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GeographicFeatureSurfaceCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GeographicFeatureTerrainCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GeographicFeatureTerrainCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GeographicFeatureTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GeographicFeatureTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GeographicFeatureTypeSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GeographicFeatureTypeSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GeometricVolumeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GeometricVolumeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GovernmentOrganisationTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GovernmentOrganisationTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GroupCharacteristicAgeGroupCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GroupCharacteristicAgeGroupCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GroupCharacteristicMaladyCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GroupCharacteristicMaladyCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GroupCharacteristicMaladyTransmissibilityIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GroupCharacteristicMaladyTransmissibilityIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GroupCharacteristicTriageCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GroupCharacteristicTriageCode&);

  ::std::ostream&
  operator<< (::std::ostream&, GroupOrganisationTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const GroupOrganisationTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HandlingCapabilityActionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HandlingCapabilityActionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HandlingCapabilityDescriptorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HandlingCapabilityDescriptorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourAirportNearIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourAirportNearIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourBiologicallySecureAvailabilityIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourBiologicallySecureAvailabilityIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourConvoyMarshallingIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourConvoyMarshallingIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourDegaussingIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourDegaussingIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourDirtyBallastIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourDirtyBallastIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourEntranceRestrictionsIceIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourEntranceRestrictionsIceIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourEntranceRestrictionsSwellIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourEntranceRestrictionsSwellIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourEstimatedTimeOfArrivalIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourEstimatedTimeOfArrivalIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourFireFightingCapabilityCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourFireFightingCapabilityCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourFireFightingIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourFireFightingIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourFirstPortOfEntryIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourFirstPortOfEntryIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourFreshWaterAvailabilityIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourFreshWaterAvailabilityIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourLashIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourLashIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourLighterageAvailabilityIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourLighterageAvailabilityIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourOverheadLimitsIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourOverheadLimitsIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourPassengerHandlingIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourPassengerHandlingIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourPersistenceCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourPersistenceCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourPilotageAvailabilityIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourPilotageAvailabilityIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourPilotageRequirementIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourPilotageRequirementIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourRefuellingAvailabilityIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourRefuellingAvailabilityIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourRefuellingTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourRefuellingTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourShelterQualityCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourShelterQualityCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourTankerFacilitiesIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourTankerFacilitiesIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourTransitAccommodationIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourTransitAccommodationIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourTugAvailabilityIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourTugAvailabilityIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourTurningAreaIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourTurningAreaIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HarbourVehicleHandlingTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HarbourVehicleHandlingTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HoldingRequiredCalculationMethodCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HoldingRequiredCalculationMethodCode&);

  ::std::ostream&
  operator<< (::std::ostream&, HoldingTransferReasonCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const HoldingTransferReasonCode&);

  ::std::ostream&
  operator<< (::std::ostream&, IcingCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const IcingCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, IcingSeverityQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const IcingSeverityQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, JettyRailServedIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const JettyRailServedIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, LanguageCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const LanguageCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, LanguageSkillProficiencyCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const LanguageSkillProficiencyCode&);

  ::std::ostream&
  operator<< (::std::ostream&, LightCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const LightCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, LightMoonPhaseCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const LightMoonPhaseCode&);

  ::std::ostream&
  operator<< (::std::ostream&, LiquidSurfaceStatusSeaStateCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const LiquidSurfaceStatusSeaStateCode&);

  ::std::ostream&
  operator<< (::std::ostream&, LiquidSurfaceStatusSurfaceConditionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const LiquidSurfaceStatusSurfaceConditionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, LocationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const LocationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MainActivityCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MainActivityCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaintenanceCapabilityCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaintenanceCapabilityCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaintenanceCapabilityLevelCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaintenanceCapabilityLevelCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaritimeEquipmentTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaritimeEquipmentTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaritimeEquipmentTypeSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaritimeEquipmentTypeSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaterielCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaterielCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaterielStatusBodyColourCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaterielStatusBodyColourCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaterielStatusBuoyMalfunctionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaterielStatusBuoyMalfunctionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaterielStatusCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaterielStatusCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaterielStatusImoCompliantIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaterielStatusImoCompliantIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaterielStatusMarkingCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaterielStatusMarkingCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaterielStatusMarkingColourCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaterielStatusMarkingColourCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaterielStatusOperationalStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaterielStatusOperationalStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaterielStatusOperationalStatusModeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaterielStatusOperationalStatusModeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaterielStatusOperationalStatusQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaterielStatusOperationalStatusQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaterielStatusReserveIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaterielStatusReserveIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaterielStatusSafetyStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaterielStatusSafetyStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaterielTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaterielTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MaterielTypeSupplyClassCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MaterielTypeSupplyClassCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MedicalFacilityStatusIntervalCasualtyTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MedicalFacilityStatusIntervalCasualtyTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MedicalFacilityStatusPendingSurgeryTriageCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MedicalFacilityStatusPendingSurgeryTriageCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MeteorologicFeatureCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MeteorologicFeatureCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MeteorologicFeatureInterpretationCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MeteorologicFeatureInterpretationCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MeteorologicFeatureSourceCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MeteorologicFeatureSourceCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MilitaryObstacleCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MilitaryObstacleCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MilitaryObstacleTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MilitaryObstacleTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MilitaryObstacleTypeSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MilitaryObstacleTypeSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MilitaryOrganisationTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MilitaryOrganisationTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MilitaryOrganisationTypeServiceCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MilitaryOrganisationTypeServiceCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MilitaryPostTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MilitaryPostTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MilitaryPostTypeRankCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MilitaryPostTypeRankCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinePresenceCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinePresenceCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MineStatusAirDropEffectCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MineStatusAirDropEffectCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MineStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MineStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MineStatusMaritimeMineQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MineStatusMaritimeMineQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldLandDepthPlacementCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldLandDepthPlacementCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldLandFunctionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldLandFunctionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldLandPatternCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldLandPatternCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldLandPersistenceCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldLandPersistenceCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldLandStoppingPowerCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldLandStoppingPowerCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldMaritimeBottomNaturalCamouflageCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldMaritimeBottomNaturalCamouflageCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldMaritimeDepthPlacementCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldMaritimeDepthPlacementCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldMaritimeFunctionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldMaritimeFunctionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldMaritimeStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldMaritimeStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldMaritimeStatusColourCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldMaritimeStatusColourCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldMaritimeStatusExpectedLevelMcmCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldMaritimeStatusExpectedLevelMcmCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldMaritimeStatusMineDetectionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldMaritimeStatusMineDetectionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldMaritimeStatusMineZoneRiskCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldMaritimeStatusMineZoneRiskCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldMaritimeStatusSeedingCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldMaritimeStatusSeedingCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MinefieldMaritimeSubfunctionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MinefieldMaritimeSubfunctionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MiscellaneousEquipmentTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MiscellaneousEquipmentTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MiscellaneousEquipmentTypeSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MiscellaneousEquipmentTypeSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MissionPrimacyCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MissionPrimacyCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MobilityCapabilityCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MobilityCapabilityCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MobilityCapabilityDescriptorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MobilityCapabilityDescriptorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MobilityCapabilityTerrainTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MobilityCapabilityTerrainTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, MobilityCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const MobilityCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ModeOfTransportationCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ModeOfTransportationCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NetworkArchitectureCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NetworkArchitectureCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NetworkCapacityBandwidthCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NetworkCapacityBandwidthCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NetworkCapacityProtocolCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NetworkCapacityProtocolCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NetworkCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NetworkCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NetworkFrequencyBandCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NetworkFrequencyBandCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NetworkFrequencyModulationCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NetworkFrequencyModulationCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NetworkMeansCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NetworkMeansCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NetworkServiceCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NetworkServiceCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NetworkServiceCryptographicIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NetworkServiceCryptographicIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NetworkServiceStatusIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NetworkServiceStatusIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NetworkServiceSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NetworkServiceSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NetworkSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NetworkSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NuclearEventCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NuclearEventCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NuclearWeaponEventCraterPresenceCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NuclearWeaponEventCraterPresenceCode&);

  ::std::ostream&
  operator<< (::std::ostream&, NuclearYieldGroupCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const NuclearYieldGroupCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemAddressAuthorisationIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemAddressAuthorisationIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemAddressPrimacyCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemAddressPrimacyCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemAddressTransmitReceiveCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemAddressTransmitReceiveCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemAliasCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemAliasCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemAssociationSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemAssociationSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemGroupAccountDetailQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemGroupAccountDetailQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemHostilityStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemHostilityStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemLocationMeaningCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemLocationMeaningCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemLocationRelativeSpeedCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemLocationRelativeSpeedCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemReferenceAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemReferenceAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemStatusBoobyTrapPresenceCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemStatusBoobyTrapPresenceCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemStatusCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemStatusCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectItemStatusEmissionControlCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectItemStatusEmissionControlCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectTypeDecoyIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectTypeDecoyIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectTypeEstablishmentCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectTypeEstablishmentCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectTypeEstablishmentEnvironmentConditionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectTypeEstablishmentEnvironmentConditionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectTypeEstablishmentOperationalModeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectTypeEstablishmentOperationalModeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ObjectTypeReferenceAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectTypeReferenceAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OperationalCapabilityCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OperationalCapabilityCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OperationalCapabilityLevelCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OperationalCapabilityLevelCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OperationalCapabilityQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OperationalCapabilityQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OperationalInformationGroupCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OperationalInformationGroupCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OperationalInformationGroupOrganisationAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OperationalInformationGroupOrganisationAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrbitAreaAlignmentCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrbitAreaAlignmentCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrderCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrderCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrderStatusExecutionStateCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrderStatusExecutionStateCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationActionAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationActionAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationActionTaskRuleOfEngagementStatusCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationActionTaskRuleOfEngagementStatusCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationMaterielTypeAssociationReportableTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationMaterielTypeAssociationReportableTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationPlanOrderAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationPlanOrderAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationReferenceAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationReferenceAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationStatusAvailabilityCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationStatusAvailabilityCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationStatusCbrnDressStateCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationStatusCbrnDressStateCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationStatusCommandAndControlRoleCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationStatusCommandAndControlRoleCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationStatusCommitmentStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationStatusCommitmentStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationStatusFireModeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationStatusFireModeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationStatusOperationalStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationStatusOperationalStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationStatusOperationalStatusQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationStatusOperationalStatusQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationStatusReadinessCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationStatusReadinessCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationStatusReinforcementCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationStatusReinforcementCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationStatusReserveIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationStatusReserveIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationStatusTrainingCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationStatusTrainingCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationStatusUsageStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationStatusUsageStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationTypeCommandAndControlCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationTypeCommandAndControlCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, OrganisationTypeCommandFunctionIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const OrganisationTypeCommandFunctionIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PersistencyCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PersistencyCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PersonBloodTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PersonBloodTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PersonIdentificationDocumentCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PersonIdentificationDocumentCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PersonLanguageSkillGeneralProficiencyCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PersonLanguageSkillGeneralProficiencyCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PersonProfessingIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PersonProfessingIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PersonStatusDutyStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PersonStatusDutyStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PersonStatusPhysicalStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PersonStatusPhysicalStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PersonStatusPhysicalStatusQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PersonStatusPhysicalStatusQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PersonStatusReserveIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PersonStatusReserveIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PersonTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PersonTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PersonTypeRankCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PersonTypeRankCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PersonTypeSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PersonTypeSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PhysicalAddressCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PhysicalAddressCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PlanCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PlanCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PlanOrderAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PlanOrderAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PlanOrderCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PlanOrderCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PlanOrderComponentContentReferenceCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PlanOrderComponentContentReferenceCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PlanOrderComponentStructureCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PlanOrderComponentStructureCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PlanOrderDistributionAcknowledgementCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PlanOrderDistributionAcknowledgementCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PlanOrderDistributionCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PlanOrderDistributionCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PlanOrderHeaderContentTimeZoneCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PlanOrderHeaderContentTimeZoneCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PlanStatusDevelopmentStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PlanStatusDevelopmentStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PlanStatusStateCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PlanStatusStateCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PointCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PointCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PrecipitationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PrecipitationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, PrivateSectorOrganisationTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const PrivateSectorOrganisationTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, QuayContainerHandlingTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const QuayContainerHandlingTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, QuayCraneOffloadingTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const QuayCraneOffloadingTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, QuayRailServedIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const QuayRailServedIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, QuayStorageCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const QuayStorageCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RadioactiveEventCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RadioactiveEventCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RadioactiveEventDoseRateTrendCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RadioactiveEventDoseRateTrendCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RadioactiveEventRelativeDecayRateCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RadioactiveEventRelativeDecayRateCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RadioactiveMaterielTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RadioactiveMaterielTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RadioactiveMaterielTypePrimaryRadiationCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RadioactiveMaterielTypePrimaryRadiationCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RailcarTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RailcarTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RailcarTypeSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RailcarTypeSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RailwaySignalSystemCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RailwaySignalSystemCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RailwaySignalSystemEfficiencyCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RailwaySignalSystemEfficiencyCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RailwayTrackGaugeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RailwayTrackGaugeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RailwayTractionSystemCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RailwayTractionSystemCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReferenceAssociationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReferenceAssociationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReferenceContentCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReferenceContentCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReferenceLifecycleCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReferenceLifecycleCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReferenceMediumTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReferenceMediumTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReferenceTransmittalTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReferenceTransmittalTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReferenceVerificationCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReferenceVerificationCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RelativeCoordinateSystemReferenceCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RelativeCoordinateSystemReferenceCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReleaseCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReleaseCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReportingDataAccuracyCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReportingDataAccuracyCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReportingDataCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReportingDataCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReportingDataCountingIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReportingDataCountingIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReportingDataCredibilityCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReportingDataCredibilityCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReportingDataEntityCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReportingDataEntityCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReportingDataRealDataExerciseUseOnlyCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReportingDataRealDataExerciseUseOnlyCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReportingDataReliabilityCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReportingDataReliabilityCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReportingDataSourceTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReportingDataSourceTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, ReportingDataTimingCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const ReportingDataTimingCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RequestAnswerCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RequestAnswerCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RequestCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RequestCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RequestImmediateInterestIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RequestImmediateInterestIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RoadCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RoadCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RoadQualityCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RoadQualityCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RoadShoulderWidthCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RoadShoulderWidthCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RoadWeatherConditionCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RoadWeatherConditionCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RouteDirectionUsageCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RouteDirectionUsageCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RouteSegmentCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RouteSegmentCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RouteTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RouteTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RunwayLightingPresenceIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RunwayLightingPresenceIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RunwayPavementEvaluationMethodCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RunwayPavementEvaluationMethodCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RunwayPavementMaximumTyrePressureCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RunwayPavementMaximumTyrePressureCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RunwayPavementSubgradeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RunwayPavementSubgradeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, RunwayPavementTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const RunwayPavementTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, SecurityClassificationLevelCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const SecurityClassificationLevelCode&);

  ::std::ostream&
  operator<< (::std::ostream&, SolidSurfaceStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const SolidSurfaceStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, SolidSurfaceStatusSurfaceConditionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const SolidSurfaceStatusSurfaceConditionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, SolidSurfaceStatusSurfaceFirmnessCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const SolidSurfaceStatusSurfaceFirmnessCode&);

  ::std::ostream&
  operator<< (::std::ostream&, SpeedPrecisionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const SpeedPrecisionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, StorageCapabilityConditionCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const StorageCapabilityConditionCode&);

  ::std::ostream&
  operator<< (::std::ostream&, StorageCapabilityDescriptorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const StorageCapabilityDescriptorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, SubsurfaceVesselTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const SubsurfaceVesselTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, SupportCapabilityCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const SupportCapabilityCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, SupportCapabilityDescriptorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const SupportCapabilityDescriptorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, SurfaceCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const SurfaceCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, SurfaceVesselTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const SurfaceVesselTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, SurveillanceCapabilityCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const SurveillanceCapabilityCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, SurveillanceCapabilityDescriptorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const SurveillanceCapabilityDescriptorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, TargetEngagementAuthorityCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const TargetEngagementAuthorityCode&);

  ::std::ostream&
  operator<< (::std::ostream&, TargetPersonnelProtectionCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const TargetPersonnelProtectionCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, TaskFormationTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const TaskFormationTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, TransmissionCapabilityCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const TransmissionCapabilityCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, TransmissionCapabilityDescriptorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const TransmissionCapabilityDescriptorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, UnitTypeArmCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const UnitTypeArmCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, UnitTypeArmSpecialisationCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const UnitTypeArmSpecialisationCode&);

  ::std::ostream&
  operator<< (::std::ostream&, UnitTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const UnitTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, UnitTypeGeneralMobilityCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const UnitTypeGeneralMobilityCode&);

  ::std::ostream&
  operator<< (::std::ostream&, UnitTypeQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const UnitTypeQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, UnitTypeSizeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const UnitTypeSizeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, UnitTypeSupplementarySpecialisationCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const UnitTypeSupplementarySpecialisationCode&);

  ::std::ostream&
  operator<< (::std::ostream&, UsageStatusCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const UsageStatusCode&);

  ::std::ostream&
  operator<< (::std::ostream&, UxoStatusExposureCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const UxoStatusExposureCode&);

  ::std::ostream&
  operator<< (::std::ostream&, UxoStatusQualifierCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const UxoStatusQualifierCode&);

  ::std::ostream&
  operator<< (::std::ostream&, VegetationCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const VegetationCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, VegetationSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const VegetationSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, VehicleTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const VehicleTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, VerticalDistanceReferenceCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const VerticalDistanceReferenceCode&);

  ::std::ostream&
  operator<< (::std::ostream&, VesselTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const VesselTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, VesselTypePropulsionTypeCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const VesselTypePropulsionTypeCode&);

  ::std::ostream&
  operator<< (::std::ostream&, VisibilityCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const VisibilityCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, WeaponTypeCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const WeaponTypeCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, WeaponTypeFireGuidanceIndicatorCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const WeaponTypeFireGuidanceIndicatorCode&);

  ::std::ostream&
  operator<< (::std::ostream&, WeaponTypeSubcategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const WeaponTypeSubcategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, WindAirStabilityCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const WindAirStabilityCategoryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, WindAltitudeLayerCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const WindAltitudeLayerCode&);

  ::std::ostream&
  operator<< (::std::ostream&, WindCategoryCode::value);

  ::std::ostream&
  operator<< (::std::ostream&, const WindCategoryCode&);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace oo_2_0
{
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace oo_2_0
{
  void
  operator<< (::xercesc::DOMElement&, const AbsolutePointCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AbsolutePointCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AbsolutePointCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionAircraftEmploymentApproachOffsetCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionAircraftEmploymentApproachOffsetCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionAircraftEmploymentApproachOffsetCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionAircraftEmploymentCrewCompositionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionAircraftEmploymentCrewCompositionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionAircraftEmploymentCrewCompositionCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionAircraftEmploymentDeplanementMethodCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionAircraftEmploymentDeplanementMethodCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionAircraftEmploymentDeplanementMethodCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionAircraftEmploymentGeneralRoleCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionAircraftEmploymentGeneralRoleCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionAircraftEmploymentGeneralRoleCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionAircraftEmploymentInflightReportRequirementIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionAircraftEmploymentInflightReportRequirementIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionAircraftEmploymentInflightReportRequirementIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionContextCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionContextCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionContextCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionEffectCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionEffectCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionEffectCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionEffectDescriptionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionEffectDescriptionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionEffectDescriptionCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionEffectSeverityCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionEffectSeverityCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionEffectSeverityCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionElectronicWarfareEmploymentCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionElectronicWarfareEmploymentCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionElectronicWarfareEmploymentCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionEventCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionEventCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionEventCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionEventDetailClassificationCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionEventDetailClassificationCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionEventDetailClassificationCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionEventDetailCrimeIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionEventDetailCrimeIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionEventDetailCrimeIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionFunctionalAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionFunctionalAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionFunctionalAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionMaritimeEmploymentCoordinatedAirSeaProcedureCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionMaritimeEmploymentVesselTransitInstructionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionMaritimeEmploymentVesselTransitInstructionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionMaritimeEmploymentVesselTransitInstructionCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionObjectiveCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionObjectiveCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionObjectiveCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionObjectiveItemCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionObjectiveItemCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionObjectiveItemCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionObjectiveItemMarkingMethodCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionObjectiveItemMarkingMethodCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionObjectiveItemMarkingMethodCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionObjectiveItemMarkingPanelShapeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionObjectiveItemMarkingPanelShapeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionObjectiveItemMarkingPanelShapeCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionObjectiveItemMarkingRecognitionSignalColourCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionObjectiveItemMarkingRecognitionSignalColourCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionObjectiveItemMarkingRecognitionSignalColourCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionObjectiveItemPrimacyCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionObjectiveItemPrimacyCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionObjectiveItemPrimacyCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionObjectiveQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionObjectiveQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionObjectiveQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionObjectiveTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionObjectiveTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionObjectiveTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionObjectiveTypeImageryProductImageTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionObjectiveTypeImageryProductImageTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionObjectiveTypeImageryProductImageTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionReconnaissanceEmploymentImageCoverageModeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionReconnaissanceEmploymentImageCoverageModeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionReconnaissanceEmploymentImageCoverageModeCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionReconnaissanceEmploymentImageViewQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionReconnaissanceEmploymentImageViewQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionReconnaissanceEmploymentImageViewQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionReconnaissanceEmploymentTypeOfCoverageCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionReconnaissanceEmploymentTypeOfCoverageCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionReconnaissanceEmploymentTypeOfCoverageCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionReferenceAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionReferenceAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionReferenceAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionResourceCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionResourceCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionResourceCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionResourceCriticalityIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionResourceCriticalityIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionResourceCriticalityIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionResourceEmploymentCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionResourceEmploymentCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionResourceEmploymentCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionResourceEmploymentMethodOfControlCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionResourceEmploymentMethodOfControlCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionResourceEmploymentMethodOfControlCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionResourceEmploymentTrajectoryFireCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionResourceEmploymentTrajectoryFireCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionResourceEmploymentTrajectoryFireCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionResourceQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionResourceQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionResourceQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskActivityCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskActivityCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskActivityCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskEndQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskEndQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskEndQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskEntailedSafetyDegreeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskEntailedSafetyDegreeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskEntailedSafetyDegreeCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskMeteorologicalImpactCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskMeteorologicalImpactCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskMeteorologicalImpactCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskOperationalLevelCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskOperationalLevelCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskOperationalLevelCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskOvertCovertCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskOvertCovertCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskOvertCovertCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskPriorityCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskPriorityCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskPriorityCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskStartQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskStartQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskStartQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskStatusAmendTimingCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskStatusAmendTimingCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskStatusAmendTimingCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskStatusApprovalIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskStatusApprovalIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskStatusApprovalIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskStatusCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskStatusPlanningIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskStatusPlanningIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskStatusPlanningIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskStatusProgressCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskStatusProgressCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskStatusProgressCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskTimingDayCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskTimingDayCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskTimingDayCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTaskTimingHourCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTaskTimingHourCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTaskTimingHourCode&);

  void
  operator<< (::xercesc::DOMElement&, const ActionTemporalAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ActionTemporalAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ActionTemporalAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const AddressCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AddressCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AddressCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const AffiliationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AffiliationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AffiliationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const AffiliationEthnicGroupCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AffiliationEthnicGroupCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AffiliationEthnicGroupCode&);

  void
  operator<< (::xercesc::DOMElement&, const AffiliationFunctionalGroupCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AffiliationFunctionalGroupCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AffiliationFunctionalGroupCode&);

  void
  operator<< (::xercesc::DOMElement&, const AffiliationGeopoliticalCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AffiliationGeopoliticalCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AffiliationGeopoliticalCode&);

  void
  operator<< (::xercesc::DOMElement&, const AffiliationReligionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AffiliationReligionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AffiliationReligionCode&);

  void
  operator<< (::xercesc::DOMElement&, const AirRouteSegmentCivilMilitaryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AirRouteSegmentCivilMilitaryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AirRouteSegmentCivilMilitaryCode&);

  void
  operator<< (::xercesc::DOMElement&, const AirRouteSegmentInternationalRouteCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AirRouteSegmentInternationalRouteCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AirRouteSegmentInternationalRouteCode&);

  void
  operator<< (::xercesc::DOMElement&, const AirRouteSegmentRequiredNavigationPerformanceCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AirRouteSegmentRequiredNavigationPerformanceCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AirRouteSegmentRequiredNavigationPerformanceCode&);

  void
  operator<< (::xercesc::DOMElement&, const AircraftTypeAirframeDesignCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AircraftTypeAirframeDesignCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AircraftTypeAirframeDesignCode&);

  void
  operator<< (::xercesc::DOMElement&, const AircraftTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AircraftTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AircraftTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const AircraftTypeDesignRangeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AircraftTypeDesignRangeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AircraftTypeDesignRangeCode&);

  void
  operator<< (::xercesc::DOMElement&, const AircraftTypeDesignRoleCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AircraftTypeDesignRoleCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AircraftTypeDesignRoleCode&);

  void
  operator<< (::xercesc::DOMElement&, const AircraftTypeLoadCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AircraftTypeLoadCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AircraftTypeLoadCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const AircraftTypeMainPurposeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AircraftTypeMainPurposeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AircraftTypeMainPurposeCode&);

  void
  operator<< (::xercesc::DOMElement&, const AircraftTypeManningCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AircraftTypeManningCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AircraftTypeManningCode&);

  void
  operator<< (::xercesc::DOMElement&, const AircraftTypeMilitaryCivilianCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AircraftTypeMilitaryCivilianCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AircraftTypeMilitaryCivilianCode&);

  void
  operator<< (::xercesc::DOMElement&, const AircraftTypeModelCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AircraftTypeModelCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AircraftTypeModelCode&);

  void
  operator<< (::xercesc::DOMElement&, const AircraftTypeTakeoffAndLandingCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AircraftTypeTakeoffAndLandingCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AircraftTypeTakeoffAndLandingCode&);

  void
  operator<< (::xercesc::DOMElement&, const AircraftTypeTrainingCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AircraftTypeTrainingCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AircraftTypeTrainingCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const AircraftTypeWeatherQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AircraftTypeWeatherQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AircraftTypeWeatherQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const AirfieldAirTrafficControlPresenceIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AirfieldAirTrafficControlPresenceIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AirfieldAirTrafficControlPresenceIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const AirfieldInstrumentLandingSystemPresenceIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AirfieldInstrumentLandingSystemPresenceIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AirfieldInstrumentLandingSystemPresenceIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const AirfieldStatusDayOperationsCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AirfieldStatusDayOperationsCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AirfieldStatusDayOperationsCode&);

  void
  operator<< (::xercesc::DOMElement&, const AirfieldStatusEvaluationIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AirfieldStatusEvaluationIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AirfieldStatusEvaluationIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const AirfieldStatusFlightSupportCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AirfieldStatusFlightSupportCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AirfieldStatusFlightSupportCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const AirfieldTypeUseCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AirfieldTypeUseCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AirfieldTypeUseCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const AirfieldVisualNavigationalAidIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AirfieldVisualNavigationalAidIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AirfieldVisualNavigationalAidIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const AmmunitionTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AmmunitionTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AmmunitionTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const AmmunitionTypeExerciseMineFlareColourCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AmmunitionTypeExerciseMineFlareColourCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AmmunitionTypeExerciseMineFlareColourCode&);

  void
  operator<< (::xercesc::DOMElement&, const AmmunitionTypeMineMaritimeFiringCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AmmunitionTypeMineMaritimeFiringCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AmmunitionTypeMineMaritimeFiringCode&);

  void
  operator<< (::xercesc::DOMElement&, const AnchorageBottomTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AnchorageBottomTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AnchorageBottomTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const AnchorageMooringsTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AnchorageMooringsTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AnchorageMooringsTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const AnglePrecisionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AnglePrecisionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AnglePrecisionCode&);

  void
  operator<< (::xercesc::DOMElement&, const ApproachDirectionCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ApproachDirectionCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ApproachDirectionCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const AssociationStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AssociationStatusCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AssociationStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const AtmosphereInversionLayerCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AtmosphereInversionLayerCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AtmosphereInversionLayerCode&);

  void
  operator<< (::xercesc::DOMElement&, const AtmospherePressureSystemCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AtmospherePressureSystemCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AtmospherePressureSystemCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const AtmosphereTemperatureGradientCode&);

  void
  operator<< (::xercesc::DOMAttr&, const AtmosphereTemperatureGradientCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const AtmosphereTemperatureGradientCode&);

  void
  operator<< (::xercesc::DOMElement&, const BerthMajorVesselClassCode&);

  void
  operator<< (::xercesc::DOMAttr&, const BerthMajorVesselClassCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const BerthMajorVesselClassCode&);

  void
  operator<< (::xercesc::DOMElement&, const BerthRailAvailabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const BerthRailAvailabilityIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const BerthRailAvailabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const BerthRollOnRollOffIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const BerthRollOnRollOffIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const BerthRollOnRollOffIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const BiologicalMaterielTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const BiologicalMaterielTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const BiologicalMaterielTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const BiologicalMaterielTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const BiologicalMaterielTypeSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const BiologicalMaterielTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const BridgeTypeDesignTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const BridgeTypeDesignTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const BridgeTypeDesignTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const BridgeUsageCode&);

  void
  operator<< (::xercesc::DOMAttr&, const BridgeUsageCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const BridgeUsageCode&);

  void
  operator<< (::xercesc::DOMElement&, const CandidateTargetDetailAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CandidateTargetDetailAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CandidateTargetDetailAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const CandidateTargetDetailAuthorisationApprovalCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CandidateTargetDetailAuthorisationApprovalCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CandidateTargetDetailAuthorisationApprovalCode&);

  void
  operator<< (::xercesc::DOMElement&, const CandidateTargetDetailCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CandidateTargetDetailCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CandidateTargetDetailCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const CandidateTargetDetailFocusTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CandidateTargetDetailFocusTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CandidateTargetDetailFocusTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const CandidateTargetDetailSchemeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CandidateTargetDetailSchemeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CandidateTargetDetailSchemeCode&);

  void
  operator<< (::xercesc::DOMElement&, const CandidateTargetListAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CandidateTargetListAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CandidateTargetListAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const CandidateTargetListAuthorisationIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CandidateTargetListAuthorisationIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CandidateTargetListAuthorisationIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const CapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CapabilityCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const CapabilityDayNightCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CapabilityDayNightCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CapabilityDayNightCode&);

  void
  operator<< (::xercesc::DOMElement&, const CapabilityReferenceAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CapabilityReferenceAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CapabilityReferenceAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const CapabilityUnitOfMeasureCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CapabilityUnitOfMeasureCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CapabilityUnitOfMeasureCode&);

  void
  operator<< (::xercesc::DOMElement&, const CargoCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CargoCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CargoCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const CasualtyGroupCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CasualtyGroupCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CasualtyGroupCode&);

  void
  operator<< (::xercesc::DOMElement&, const CbrnEquipmentTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CbrnEquipmentTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CbrnEquipmentTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const CbrnEventAlarmResultIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CbrnEventAlarmResultIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CbrnEventAlarmResultIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const CbrnEventCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CbrnEventCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CbrnEventCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const CbrnEventConfirmationTestIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CbrnEventConfirmationTestIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CbrnEventConfirmationTestIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const CbrnEventMaterielContainerTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CbrnEventMaterielContainerTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CbrnEventMaterielContainerTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const CbrnEventSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CbrnEventSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CbrnEventSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ChemicalBiologicalEventCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ChemicalBiologicalEventCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ChemicalBiologicalEventCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ChemicalBiologicalEventSpillSizeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ChemicalBiologicalEventSpillSizeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ChemicalBiologicalEventSpillSizeCode&);

  void
  operator<< (::xercesc::DOMElement&, const ChemicalMaterielTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ChemicalMaterielTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ChemicalMaterielTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ChemicalMaterielTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ChemicalMaterielTypeSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ChemicalMaterielTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const CivilianPostTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CivilianPostTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CivilianPostTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const CloudCoverAverageCoverageCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CloudCoverAverageCoverageCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CloudCoverAverageCoverageCode&);

  void
  operator<< (::xercesc::DOMElement&, const CloudCoverCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const CloudCoverCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const CloudCoverCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ConsumableMaterielTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ConsumableMaterielTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ConsumableMaterielTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ConsumableMaterielTypeHazardCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ConsumableMaterielTypeHazardCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ConsumableMaterielTypeHazardCode&);

  void
  operator<< (::xercesc::DOMElement&, const ConsumableMaterielTypeIssuingElementCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ConsumableMaterielTypeIssuingElementCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ConsumableMaterielTypeIssuingElementCode&);

  void
  operator<< (::xercesc::DOMElement&, const ConsumableMaterielTypeIssuingUnitOfMeasureCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ConsumableMaterielTypeIssuingUnitOfMeasureCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ConsumableMaterielTypeIssuingUnitOfMeasureCode&);

  void
  operator<< (::xercesc::DOMElement&, const ConsumableMaterielTypePerishabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ConsumableMaterielTypePerishabilityIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ConsumableMaterielTypePerishabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const ConsumableMaterielTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ConsumableMaterielTypeSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ConsumableMaterielTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ConsumableMaterielTypeUnitedNationsNumberCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ConsumableMaterielTypeUnitedNationsNumberCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ConsumableMaterielTypeUnitedNationsNumberCode&);

  void
  operator<< (::xercesc::DOMElement&, const ContextAssessmentLimitingFactorsCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ContextAssessmentLimitingFactorsCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ContextAssessmentLimitingFactorsCode&);

  void
  operator<< (::xercesc::DOMElement&, const ContextAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ContextAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ContextAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ContextCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ContextCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ContextCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ContextElementStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ContextElementStatusCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ContextElementStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ContextObjectItemAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ContextObjectItemAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ContextObjectItemAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ContextReportingDataAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ContextReportingDataAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ContextReportingDataAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ControlFeatureCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ControlFeatureCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ControlFeatureCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ControlFeatureStatusCbrnThreatLevelCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ControlFeatureStatusCbrnThreatLevelCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ControlFeatureStatusCbrnThreatLevelCode&);

  void
  operator<< (::xercesc::DOMElement&, const ControlFeatureStatusInvestigationStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ControlFeatureStatusInvestigationStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ControlFeatureStatusInvestigationStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const ControlFeatureStatusSecurityStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ControlFeatureStatusSecurityStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ControlFeatureStatusSecurityStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const ControlFeatureTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ControlFeatureTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ControlFeatureTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const DemolitionStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const DemolitionStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const DemolitionStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const DirectionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const DirectionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const DirectionCode&);

  void
  operator<< (::xercesc::DOMElement&, const DistancePrecisionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const DistancePrecisionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const DistancePrecisionCode&);

  void
  operator<< (::xercesc::DOMElement&, const DryDockMarineRailwaySizeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const DryDockMarineRailwaySizeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const DryDockMarineRailwaySizeCode&);

  void
  operator<< (::xercesc::DOMElement&, const ElectronicEquipmentTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ElectronicEquipmentTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ElectronicEquipmentTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ElectronicEquipmentTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ElectronicEquipmentTypeSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ElectronicEquipmentTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const EngineeringCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const EngineeringCapabilityCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const EngineeringCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const EngineeringCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const EngineeringCapabilityDescriptorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const EngineeringCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMElement&, const EngineeringEquipmentTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const EngineeringEquipmentTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const EngineeringEquipmentTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const EquipmentTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const EquipmentTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const EquipmentTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const EvacuationDestinationCode&);

  void
  operator<< (::xercesc::DOMAttr&, const EvacuationDestinationCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const EvacuationDestinationCode&);

  void
  operator<< (::xercesc::DOMElement&, const ExecutiveMilitaryOrganisationTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ExecutiveMilitaryOrganisationTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ExecutiveMilitaryOrganisationTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const FacilityCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FacilityCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FacilityCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const FacilityPrimaryConstructionMaterialCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FacilityPrimaryConstructionMaterialCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FacilityPrimaryConstructionMaterialCode&);

  void
  operator<< (::xercesc::DOMElement&, const FacilityStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FacilityStatusCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FacilityStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const FacilityStatusEnemyActivityConditionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FacilityStatusEnemyActivityConditionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FacilityStatusEnemyActivityConditionCode&);

  void
  operator<< (::xercesc::DOMElement&, const FacilityStatusOccupationProgramIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FacilityStatusOccupationProgramIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FacilityStatusOccupationProgramIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const FacilityStatusOperationalStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FacilityStatusOperationalStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FacilityStatusOperationalStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const FacilityStatusOperationalStatusQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FacilityStatusOperationalStatusQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FacilityStatusOperationalStatusQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const FacilityStatusReserveIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FacilityStatusReserveIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FacilityStatusReserveIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const FacilityStatusSecurityStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FacilityStatusSecurityStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FacilityStatusSecurityStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const FacilityTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FacilityTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FacilityTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const FeatureCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FeatureCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FeatureCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const FeatureTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FeatureTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FeatureTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const FeintIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FeintIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FeintIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const FireCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FireCapabilityCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FireCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const FireCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FireCapabilityDescriptorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FireCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMElement&, const FireCapabilityWeaponTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const FireCapabilityWeaponTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const FireCapabilityWeaponTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const GenderCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GenderCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GenderCode&);

  void
  operator<< (::xercesc::DOMElement&, const GeographicFeatureBottomHardnessCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GeographicFeatureBottomHardnessCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GeographicFeatureBottomHardnessCode&);

  void
  operator<< (::xercesc::DOMElement&, const GeographicFeatureSolidSurfaceCompositionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GeographicFeatureSolidSurfaceCompositionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GeographicFeatureSolidSurfaceCompositionCode&);

  void
  operator<< (::xercesc::DOMElement&, const GeographicFeatureStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GeographicFeatureStatusCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GeographicFeatureStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const GeographicFeatureStatusSurfaceRecirculationIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GeographicFeatureStatusSurfaceRecirculationIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GeographicFeatureStatusSurfaceRecirculationIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const GeographicFeatureSurfaceCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GeographicFeatureSurfaceCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GeographicFeatureSurfaceCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const GeographicFeatureTerrainCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GeographicFeatureTerrainCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GeographicFeatureTerrainCode&);

  void
  operator<< (::xercesc::DOMElement&, const GeographicFeatureTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GeographicFeatureTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GeographicFeatureTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const GeographicFeatureTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GeographicFeatureTypeSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GeographicFeatureTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const GeometricVolumeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GeometricVolumeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GeometricVolumeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const GovernmentOrganisationTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GovernmentOrganisationTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GovernmentOrganisationTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const GroupCharacteristicAgeGroupCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GroupCharacteristicAgeGroupCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GroupCharacteristicAgeGroupCode&);

  void
  operator<< (::xercesc::DOMElement&, const GroupCharacteristicMaladyCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GroupCharacteristicMaladyCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GroupCharacteristicMaladyCode&);

  void
  operator<< (::xercesc::DOMElement&, const GroupCharacteristicMaladyTransmissibilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GroupCharacteristicMaladyTransmissibilityIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GroupCharacteristicMaladyTransmissibilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const GroupCharacteristicTriageCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GroupCharacteristicTriageCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GroupCharacteristicTriageCode&);

  void
  operator<< (::xercesc::DOMElement&, const GroupOrganisationTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const GroupOrganisationTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const GroupOrganisationTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const HandlingCapabilityActionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HandlingCapabilityActionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HandlingCapabilityActionCode&);

  void
  operator<< (::xercesc::DOMElement&, const HandlingCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HandlingCapabilityDescriptorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HandlingCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourAirportNearIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourAirportNearIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourAirportNearIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourBiologicallySecureAvailabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourBiologicallySecureAvailabilityIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourBiologicallySecureAvailabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourConvoyMarshallingIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourConvoyMarshallingIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourConvoyMarshallingIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourDegaussingIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourDegaussingIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourDegaussingIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourDirtyBallastIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourDirtyBallastIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourDirtyBallastIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourEntranceRestrictionsIceIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourEntranceRestrictionsIceIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourEntranceRestrictionsIceIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourEntranceRestrictionsSwellIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourEntranceRestrictionsSwellIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourEntranceRestrictionsSwellIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourEstimatedTimeOfArrivalIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourEstimatedTimeOfArrivalIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourEstimatedTimeOfArrivalIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourFireFightingCapabilityCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourFireFightingCapabilityCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourFireFightingCapabilityCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourFireFightingIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourFireFightingIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourFireFightingIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourFirstPortOfEntryIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourFirstPortOfEntryIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourFirstPortOfEntryIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourFreshWaterAvailabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourFreshWaterAvailabilityIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourFreshWaterAvailabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourLashIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourLashIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourLashIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourLighterageAvailabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourLighterageAvailabilityIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourLighterageAvailabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourOverheadLimitsIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourOverheadLimitsIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourOverheadLimitsIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourPassengerHandlingIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourPassengerHandlingIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourPassengerHandlingIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourPersistenceCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourPersistenceCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourPersistenceCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourPilotageAvailabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourPilotageAvailabilityIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourPilotageAvailabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourPilotageRequirementIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourPilotageRequirementIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourPilotageRequirementIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourRefuellingAvailabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourRefuellingAvailabilityIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourRefuellingAvailabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourRefuellingTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourRefuellingTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourRefuellingTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourShelterQualityCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourShelterQualityCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourShelterQualityCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourTankerFacilitiesIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourTankerFacilitiesIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourTankerFacilitiesIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourTransitAccommodationIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourTransitAccommodationIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourTransitAccommodationIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourTugAvailabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourTugAvailabilityIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourTugAvailabilityIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourTurningAreaIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourTurningAreaIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourTurningAreaIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const HarbourVehicleHandlingTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HarbourVehicleHandlingTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HarbourVehicleHandlingTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const HoldingRequiredCalculationMethodCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HoldingRequiredCalculationMethodCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HoldingRequiredCalculationMethodCode&);

  void
  operator<< (::xercesc::DOMElement&, const HoldingTransferReasonCode&);

  void
  operator<< (::xercesc::DOMAttr&, const HoldingTransferReasonCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const HoldingTransferReasonCode&);

  void
  operator<< (::xercesc::DOMElement&, const IcingCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const IcingCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const IcingCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const IcingSeverityQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const IcingSeverityQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const IcingSeverityQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const JettyRailServedIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const JettyRailServedIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const JettyRailServedIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const LanguageCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const LanguageCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const LanguageCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const LanguageSkillProficiencyCode&);

  void
  operator<< (::xercesc::DOMAttr&, const LanguageSkillProficiencyCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const LanguageSkillProficiencyCode&);

  void
  operator<< (::xercesc::DOMElement&, const LightCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const LightCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const LightCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const LightMoonPhaseCode&);

  void
  operator<< (::xercesc::DOMAttr&, const LightMoonPhaseCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const LightMoonPhaseCode&);

  void
  operator<< (::xercesc::DOMElement&, const LiquidSurfaceStatusSeaStateCode&);

  void
  operator<< (::xercesc::DOMAttr&, const LiquidSurfaceStatusSeaStateCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const LiquidSurfaceStatusSeaStateCode&);

  void
  operator<< (::xercesc::DOMElement&, const LiquidSurfaceStatusSurfaceConditionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const LiquidSurfaceStatusSurfaceConditionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const LiquidSurfaceStatusSurfaceConditionCode&);

  void
  operator<< (::xercesc::DOMElement&, const LocationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const LocationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const LocationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MainActivityCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MainActivityCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MainActivityCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaintenanceCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaintenanceCapabilityCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaintenanceCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaintenanceCapabilityLevelCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaintenanceCapabilityLevelCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaintenanceCapabilityLevelCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaritimeEquipmentTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaritimeEquipmentTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaritimeEquipmentTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaritimeEquipmentTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaritimeEquipmentTypeSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaritimeEquipmentTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaterielCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaterielCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaterielCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaterielStatusBodyColourCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaterielStatusBodyColourCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaterielStatusBodyColourCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaterielStatusBuoyMalfunctionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaterielStatusBuoyMalfunctionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaterielStatusBuoyMalfunctionCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaterielStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaterielStatusCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaterielStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaterielStatusImoCompliantIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaterielStatusImoCompliantIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaterielStatusImoCompliantIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaterielStatusMarkingCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaterielStatusMarkingCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaterielStatusMarkingCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaterielStatusMarkingColourCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaterielStatusMarkingColourCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaterielStatusMarkingColourCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaterielStatusOperationalStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaterielStatusOperationalStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaterielStatusOperationalStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaterielStatusOperationalStatusModeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaterielStatusOperationalStatusModeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaterielStatusOperationalStatusModeCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaterielStatusOperationalStatusQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaterielStatusOperationalStatusQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaterielStatusOperationalStatusQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaterielStatusReserveIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaterielStatusReserveIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaterielStatusReserveIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaterielStatusSafetyStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaterielStatusSafetyStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaterielStatusSafetyStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaterielTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaterielTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaterielTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MaterielTypeSupplyClassCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MaterielTypeSupplyClassCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MaterielTypeSupplyClassCode&);

  void
  operator<< (::xercesc::DOMElement&, const MedicalFacilityStatusIntervalCasualtyTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MedicalFacilityStatusIntervalCasualtyTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MedicalFacilityStatusIntervalCasualtyTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const MedicalFacilityStatusPendingSurgeryTriageCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MedicalFacilityStatusPendingSurgeryTriageCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MedicalFacilityStatusPendingSurgeryTriageCode&);

  void
  operator<< (::xercesc::DOMElement&, const MeteorologicFeatureCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MeteorologicFeatureCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MeteorologicFeatureCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MeteorologicFeatureInterpretationCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MeteorologicFeatureInterpretationCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MeteorologicFeatureInterpretationCode&);

  void
  operator<< (::xercesc::DOMElement&, const MeteorologicFeatureSourceCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MeteorologicFeatureSourceCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MeteorologicFeatureSourceCode&);

  void
  operator<< (::xercesc::DOMElement&, const MilitaryObstacleCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MilitaryObstacleCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MilitaryObstacleCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MilitaryObstacleTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MilitaryObstacleTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MilitaryObstacleTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MilitaryObstacleTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MilitaryObstacleTypeSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MilitaryObstacleTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MilitaryOrganisationTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MilitaryOrganisationTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MilitaryOrganisationTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MilitaryOrganisationTypeServiceCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MilitaryOrganisationTypeServiceCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MilitaryOrganisationTypeServiceCode&);

  void
  operator<< (::xercesc::DOMElement&, const MilitaryPostTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MilitaryPostTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MilitaryPostTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MilitaryPostTypeRankCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MilitaryPostTypeRankCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MilitaryPostTypeRankCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinePresenceCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinePresenceCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinePresenceCode&);

  void
  operator<< (::xercesc::DOMElement&, const MineStatusAirDropEffectCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MineStatusAirDropEffectCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MineStatusAirDropEffectCode&);

  void
  operator<< (::xercesc::DOMElement&, const MineStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MineStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MineStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const MineStatusMaritimeMineQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MineStatusMaritimeMineQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MineStatusMaritimeMineQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldLandDepthPlacementCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldLandDepthPlacementCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldLandDepthPlacementCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldLandFunctionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldLandFunctionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldLandFunctionCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldLandPatternCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldLandPatternCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldLandPatternCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldLandPersistenceCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldLandPersistenceCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldLandPersistenceCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldLandStoppingPowerCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldLandStoppingPowerCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldLandStoppingPowerCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldMaritimeBottomNaturalCamouflageCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldMaritimeBottomNaturalCamouflageCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldMaritimeBottomNaturalCamouflageCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldMaritimeDepthPlacementCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldMaritimeDepthPlacementCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldMaritimeDepthPlacementCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldMaritimeFunctionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldMaritimeFunctionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldMaritimeFunctionCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldMaritimeStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldMaritimeStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldMaritimeStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldMaritimeStatusColourCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldMaritimeStatusColourCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldMaritimeStatusColourCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldMaritimeStatusExpectedLevelMcmCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldMaritimeStatusExpectedLevelMcmCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldMaritimeStatusExpectedLevelMcmCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldMaritimeStatusMineDetectionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldMaritimeStatusMineDetectionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldMaritimeStatusMineDetectionCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldMaritimeStatusMineZoneRiskCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldMaritimeStatusMineZoneRiskCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldMaritimeStatusMineZoneRiskCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldMaritimeStatusSeedingCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldMaritimeStatusSeedingCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldMaritimeStatusSeedingCode&);

  void
  operator<< (::xercesc::DOMElement&, const MinefieldMaritimeSubfunctionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MinefieldMaritimeSubfunctionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MinefieldMaritimeSubfunctionCode&);

  void
  operator<< (::xercesc::DOMElement&, const MiscellaneousEquipmentTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MiscellaneousEquipmentTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MiscellaneousEquipmentTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MiscellaneousEquipmentTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MiscellaneousEquipmentTypeSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MiscellaneousEquipmentTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MissionPrimacyCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MissionPrimacyCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MissionPrimacyCode&);

  void
  operator<< (::xercesc::DOMElement&, const MobilityCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MobilityCapabilityCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MobilityCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const MobilityCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MobilityCapabilityDescriptorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MobilityCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMElement&, const MobilityCapabilityTerrainTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MobilityCapabilityTerrainTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MobilityCapabilityTerrainTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const MobilityCode&);

  void
  operator<< (::xercesc::DOMAttr&, const MobilityCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const MobilityCode&);

  void
  operator<< (::xercesc::DOMElement&, const ModeOfTransportationCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ModeOfTransportationCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ModeOfTransportationCode&);

  void
  operator<< (::xercesc::DOMElement&, const NetworkArchitectureCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NetworkArchitectureCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NetworkArchitectureCode&);

  void
  operator<< (::xercesc::DOMElement&, const NetworkCapacityBandwidthCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NetworkCapacityBandwidthCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NetworkCapacityBandwidthCode&);

  void
  operator<< (::xercesc::DOMElement&, const NetworkCapacityProtocolCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NetworkCapacityProtocolCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NetworkCapacityProtocolCode&);

  void
  operator<< (::xercesc::DOMElement&, const NetworkCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NetworkCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NetworkCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const NetworkFrequencyBandCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NetworkFrequencyBandCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NetworkFrequencyBandCode&);

  void
  operator<< (::xercesc::DOMElement&, const NetworkFrequencyModulationCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NetworkFrequencyModulationCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NetworkFrequencyModulationCode&);

  void
  operator<< (::xercesc::DOMElement&, const NetworkMeansCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NetworkMeansCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NetworkMeansCode&);

  void
  operator<< (::xercesc::DOMElement&, const NetworkServiceCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NetworkServiceCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NetworkServiceCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const NetworkServiceCryptographicIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NetworkServiceCryptographicIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NetworkServiceCryptographicIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const NetworkServiceStatusIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NetworkServiceStatusIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NetworkServiceStatusIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const NetworkServiceSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NetworkServiceSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NetworkServiceSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const NetworkSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NetworkSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NetworkSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const NuclearEventCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NuclearEventCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NuclearEventCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const NuclearWeaponEventCraterPresenceCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NuclearWeaponEventCraterPresenceCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NuclearWeaponEventCraterPresenceCode&);

  void
  operator<< (::xercesc::DOMElement&, const NuclearYieldGroupCode&);

  void
  operator<< (::xercesc::DOMAttr&, const NuclearYieldGroupCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const NuclearYieldGroupCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemAddressAuthorisationIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemAddressAuthorisationIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemAddressAuthorisationIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemAddressPrimacyCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemAddressPrimacyCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemAddressPrimacyCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemAddressTransmitReceiveCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemAddressTransmitReceiveCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemAddressTransmitReceiveCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemAliasCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemAliasCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemAliasCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemAssociationSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemAssociationSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemAssociationSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemGroupAccountDetailQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemGroupAccountDetailQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemGroupAccountDetailQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemHostilityStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemHostilityStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemHostilityStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemLocationMeaningCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemLocationMeaningCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemLocationMeaningCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemLocationRelativeSpeedCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemLocationRelativeSpeedCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemLocationRelativeSpeedCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemReferenceAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemReferenceAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemReferenceAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemStatusBoobyTrapPresenceCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemStatusBoobyTrapPresenceCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemStatusBoobyTrapPresenceCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemStatusCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectItemStatusEmissionControlCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectItemStatusEmissionControlCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectItemStatusEmissionControlCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectTypeDecoyIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectTypeDecoyIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectTypeDecoyIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectTypeEstablishmentCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectTypeEstablishmentCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectTypeEstablishmentCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectTypeEstablishmentEnvironmentConditionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectTypeEstablishmentEnvironmentConditionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectTypeEstablishmentEnvironmentConditionCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectTypeEstablishmentObjectTypeDetailMajorPartIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectTypeEstablishmentOperationalModeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectTypeEstablishmentOperationalModeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectTypeEstablishmentOperationalModeCode&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectTypeReferenceAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectTypeReferenceAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectTypeReferenceAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const OperationalCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OperationalCapabilityCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OperationalCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const OperationalCapabilityLevelCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OperationalCapabilityLevelCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OperationalCapabilityLevelCode&);

  void
  operator<< (::xercesc::DOMElement&, const OperationalCapabilityQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OperationalCapabilityQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OperationalCapabilityQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const OperationalInformationGroupCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OperationalInformationGroupCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OperationalInformationGroupCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const OperationalInformationGroupOrganisationAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OperationalInformationGroupOrganisationAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OperationalInformationGroupOrganisationAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrbitAreaAlignmentCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrbitAreaAlignmentCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrbitAreaAlignmentCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrderCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrderCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrderCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrderStatusExecutionStateCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrderStatusExecutionStateCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrderStatusExecutionStateCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationActionAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationActionAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationActionAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationActionTaskRuleOfEngagementStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationActionTaskRuleOfEngagementStatusCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationActionTaskRuleOfEngagementStatusCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationMaterielTypeAssociationReportableTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationMaterielTypeAssociationReportableTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationMaterielTypeAssociationReportableTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationPlanOrderAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationPlanOrderAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationPlanOrderAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationReferenceAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationReferenceAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationReferenceAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationStatusAvailabilityCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationStatusAvailabilityCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationStatusAvailabilityCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationStatusCbrnDressStateCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationStatusCbrnDressStateCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationStatusCbrnDressStateCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationStatusCommandAndControlRoleCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationStatusCommandAndControlRoleCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationStatusCommandAndControlRoleCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationStatusCommitmentStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationStatusCommitmentStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationStatusCommitmentStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationStatusFireModeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationStatusFireModeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationStatusFireModeCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationStatusOperationalStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationStatusOperationalStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationStatusOperationalStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationStatusOperationalStatusQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationStatusOperationalStatusQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationStatusOperationalStatusQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationStatusReadinessCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationStatusReadinessCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationStatusReadinessCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationStatusReinforcementCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationStatusReinforcementCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationStatusReinforcementCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationStatusReserveIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationStatusReserveIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationStatusReserveIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationStatusTrainingCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationStatusTrainingCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationStatusTrainingCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationStatusUsageStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationStatusUsageStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationStatusUsageStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationTypeCommandAndControlCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationTypeCommandAndControlCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationTypeCommandAndControlCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const OrganisationTypeCommandFunctionIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const OrganisationTypeCommandFunctionIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const OrganisationTypeCommandFunctionIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const PersistencyCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PersistencyCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PersistencyCode&);

  void
  operator<< (::xercesc::DOMElement&, const PersonBloodTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PersonBloodTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PersonBloodTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const PersonIdentificationDocumentCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PersonIdentificationDocumentCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PersonIdentificationDocumentCode&);

  void
  operator<< (::xercesc::DOMElement&, const PersonLanguageSkillGeneralProficiencyCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PersonLanguageSkillGeneralProficiencyCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PersonLanguageSkillGeneralProficiencyCode&);

  void
  operator<< (::xercesc::DOMElement&, const PersonProfessingIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PersonProfessingIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PersonProfessingIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const PersonStatusDutyStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PersonStatusDutyStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PersonStatusDutyStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const PersonStatusPhysicalStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PersonStatusPhysicalStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PersonStatusPhysicalStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const PersonStatusPhysicalStatusQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PersonStatusPhysicalStatusQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PersonStatusPhysicalStatusQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const PersonStatusReserveIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PersonStatusReserveIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PersonStatusReserveIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const PersonTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PersonTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PersonTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const PersonTypeRankCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PersonTypeRankCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PersonTypeRankCode&);

  void
  operator<< (::xercesc::DOMElement&, const PersonTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PersonTypeSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PersonTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const PhysicalAddressCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PhysicalAddressCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PhysicalAddressCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const PlanCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PlanCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PlanCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const PlanOrderAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PlanOrderAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PlanOrderAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const PlanOrderCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PlanOrderCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PlanOrderCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const PlanOrderComponentContentReferenceCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PlanOrderComponentContentReferenceCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PlanOrderComponentContentReferenceCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const PlanOrderComponentStructureCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PlanOrderComponentStructureCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PlanOrderComponentStructureCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const PlanOrderDistributionAcknowledgementCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PlanOrderDistributionAcknowledgementCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PlanOrderDistributionAcknowledgementCode&);

  void
  operator<< (::xercesc::DOMElement&, const PlanOrderDistributionCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PlanOrderDistributionCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PlanOrderDistributionCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const PlanOrderHeaderContentTimeZoneCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PlanOrderHeaderContentTimeZoneCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PlanOrderHeaderContentTimeZoneCode&);

  void
  operator<< (::xercesc::DOMElement&, const PlanStatusDevelopmentStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PlanStatusDevelopmentStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PlanStatusDevelopmentStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const PlanStatusStateCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PlanStatusStateCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PlanStatusStateCode&);

  void
  operator<< (::xercesc::DOMElement&, const PointCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PointCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PointCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const PrecipitationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PrecipitationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PrecipitationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const PrivateSectorOrganisationTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const PrivateSectorOrganisationTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const PrivateSectorOrganisationTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const QuayContainerHandlingTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const QuayContainerHandlingTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const QuayContainerHandlingTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const QuayCraneOffloadingTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const QuayCraneOffloadingTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const QuayCraneOffloadingTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const QuayRailServedIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const QuayRailServedIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const QuayRailServedIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const QuayStorageCode&);

  void
  operator<< (::xercesc::DOMAttr&, const QuayStorageCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const QuayStorageCode&);

  void
  operator<< (::xercesc::DOMElement&, const RadioactiveEventCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RadioactiveEventCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RadioactiveEventCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const RadioactiveEventDoseRateTrendCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RadioactiveEventDoseRateTrendCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RadioactiveEventDoseRateTrendCode&);

  void
  operator<< (::xercesc::DOMElement&, const RadioactiveEventRelativeDecayRateCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RadioactiveEventRelativeDecayRateCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RadioactiveEventRelativeDecayRateCode&);

  void
  operator<< (::xercesc::DOMElement&, const RadioactiveMaterielTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RadioactiveMaterielTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RadioactiveMaterielTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const RadioactiveMaterielTypePrimaryRadiationCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RadioactiveMaterielTypePrimaryRadiationCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RadioactiveMaterielTypePrimaryRadiationCode&);

  void
  operator<< (::xercesc::DOMElement&, const RailcarTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RailcarTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RailcarTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const RailcarTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RailcarTypeSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RailcarTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const RailwaySignalSystemCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RailwaySignalSystemCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RailwaySignalSystemCode&);

  void
  operator<< (::xercesc::DOMElement&, const RailwaySignalSystemEfficiencyCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RailwaySignalSystemEfficiencyCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RailwaySignalSystemEfficiencyCode&);

  void
  operator<< (::xercesc::DOMElement&, const RailwayTrackGaugeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RailwayTrackGaugeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RailwayTrackGaugeCode&);

  void
  operator<< (::xercesc::DOMElement&, const RailwayTractionSystemCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RailwayTractionSystemCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RailwayTractionSystemCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReferenceAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReferenceAssociationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReferenceAssociationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReferenceContentCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReferenceContentCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReferenceContentCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReferenceLifecycleCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReferenceLifecycleCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReferenceLifecycleCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReferenceMediumTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReferenceMediumTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReferenceMediumTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReferenceTransmittalTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReferenceTransmittalTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReferenceTransmittalTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReferenceVerificationCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReferenceVerificationCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReferenceVerificationCode&);

  void
  operator<< (::xercesc::DOMElement&, const RelativeCoordinateSystemReferenceCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RelativeCoordinateSystemReferenceCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RelativeCoordinateSystemReferenceCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReleaseCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReleaseCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReleaseCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReportingDataAccuracyCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReportingDataAccuracyCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReportingDataAccuracyCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReportingDataCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReportingDataCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReportingDataCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReportingDataCountingIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReportingDataCountingIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReportingDataCountingIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReportingDataCredibilityCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReportingDataCredibilityCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReportingDataCredibilityCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReportingDataEntityCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReportingDataEntityCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReportingDataEntityCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReportingDataRealDataExerciseUseOnlyCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReportingDataRealDataExerciseUseOnlyCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReportingDataRealDataExerciseUseOnlyCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReportingDataReliabilityCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReportingDataReliabilityCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReportingDataReliabilityCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReportingDataSourceTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReportingDataSourceTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReportingDataSourceTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const ReportingDataTimingCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const ReportingDataTimingCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const ReportingDataTimingCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const RequestAnswerCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RequestAnswerCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RequestAnswerCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const RequestCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RequestCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RequestCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const RequestImmediateInterestIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RequestImmediateInterestIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RequestImmediateInterestIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const RoadCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RoadCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RoadCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const RoadQualityCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RoadQualityCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RoadQualityCode&);

  void
  operator<< (::xercesc::DOMElement&, const RoadShoulderWidthCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RoadShoulderWidthCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RoadShoulderWidthCode&);

  void
  operator<< (::xercesc::DOMElement&, const RoadWeatherConditionCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RoadWeatherConditionCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RoadWeatherConditionCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const RouteDirectionUsageCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RouteDirectionUsageCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RouteDirectionUsageCode&);

  void
  operator<< (::xercesc::DOMElement&, const RouteSegmentCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RouteSegmentCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RouteSegmentCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const RouteTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RouteTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RouteTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const RunwayLightingPresenceIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RunwayLightingPresenceIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RunwayLightingPresenceIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const RunwayPavementEvaluationMethodCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RunwayPavementEvaluationMethodCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RunwayPavementEvaluationMethodCode&);

  void
  operator<< (::xercesc::DOMElement&, const RunwayPavementMaximumTyrePressureCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RunwayPavementMaximumTyrePressureCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RunwayPavementMaximumTyrePressureCode&);

  void
  operator<< (::xercesc::DOMElement&, const RunwayPavementSubgradeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RunwayPavementSubgradeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RunwayPavementSubgradeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const RunwayPavementTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const RunwayPavementTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const RunwayPavementTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const SecurityClassificationLevelCode&);

  void
  operator<< (::xercesc::DOMAttr&, const SecurityClassificationLevelCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const SecurityClassificationLevelCode&);

  void
  operator<< (::xercesc::DOMElement&, const SolidSurfaceStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const SolidSurfaceStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const SolidSurfaceStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const SolidSurfaceStatusSurfaceConditionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const SolidSurfaceStatusSurfaceConditionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const SolidSurfaceStatusSurfaceConditionCode&);

  void
  operator<< (::xercesc::DOMElement&, const SolidSurfaceStatusSurfaceFirmnessCode&);

  void
  operator<< (::xercesc::DOMAttr&, const SolidSurfaceStatusSurfaceFirmnessCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const SolidSurfaceStatusSurfaceFirmnessCode&);

  void
  operator<< (::xercesc::DOMElement&, const SpeedPrecisionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const SpeedPrecisionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const SpeedPrecisionCode&);

  void
  operator<< (::xercesc::DOMElement&, const StorageCapabilityConditionCode&);

  void
  operator<< (::xercesc::DOMAttr&, const StorageCapabilityConditionCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const StorageCapabilityConditionCode&);

  void
  operator<< (::xercesc::DOMElement&, const StorageCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const StorageCapabilityDescriptorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const StorageCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMElement&, const SubsurfaceVesselTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const SubsurfaceVesselTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const SubsurfaceVesselTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const SubsurfaceVesselTypeTorpedoLoadingGearIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const SupportCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const SupportCapabilityCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const SupportCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const SupportCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const SupportCapabilityDescriptorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const SupportCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMElement&, const SurfaceCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const SurfaceCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const SurfaceCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const SurfaceVesselTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const SurfaceVesselTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const SurfaceVesselTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const SurveillanceCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const SurveillanceCapabilityCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const SurveillanceCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const SurveillanceCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const SurveillanceCapabilityDescriptorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const SurveillanceCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMElement&, const TargetEngagementAuthorityCode&);

  void
  operator<< (::xercesc::DOMAttr&, const TargetEngagementAuthorityCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const TargetEngagementAuthorityCode&);

  void
  operator<< (::xercesc::DOMElement&, const TargetPersonnelProtectionCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const TargetPersonnelProtectionCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const TargetPersonnelProtectionCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const TaskFormationTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const TaskFormationTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const TaskFormationTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const TransmissionCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const TransmissionCapabilityCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const TransmissionCapabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const TransmissionCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const TransmissionCapabilityDescriptorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const TransmissionCapabilityDescriptorCode&);

  void
  operator<< (::xercesc::DOMElement&, const UnitTypeArmCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const UnitTypeArmCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const UnitTypeArmCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const UnitTypeArmSpecialisationCode&);

  void
  operator<< (::xercesc::DOMAttr&, const UnitTypeArmSpecialisationCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const UnitTypeArmSpecialisationCode&);

  void
  operator<< (::xercesc::DOMElement&, const UnitTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const UnitTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const UnitTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const UnitTypeGeneralMobilityCode&);

  void
  operator<< (::xercesc::DOMAttr&, const UnitTypeGeneralMobilityCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const UnitTypeGeneralMobilityCode&);

  void
  operator<< (::xercesc::DOMElement&, const UnitTypeQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const UnitTypeQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const UnitTypeQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const UnitTypeSizeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const UnitTypeSizeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const UnitTypeSizeCode&);

  void
  operator<< (::xercesc::DOMElement&, const UnitTypeSupplementarySpecialisationCode&);

  void
  operator<< (::xercesc::DOMAttr&, const UnitTypeSupplementarySpecialisationCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const UnitTypeSupplementarySpecialisationCode&);

  void
  operator<< (::xercesc::DOMElement&, const UsageStatusCode&);

  void
  operator<< (::xercesc::DOMAttr&, const UsageStatusCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const UsageStatusCode&);

  void
  operator<< (::xercesc::DOMElement&, const UxoStatusExposureCode&);

  void
  operator<< (::xercesc::DOMAttr&, const UxoStatusExposureCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const UxoStatusExposureCode&);

  void
  operator<< (::xercesc::DOMElement&, const UxoStatusQualifierCode&);

  void
  operator<< (::xercesc::DOMAttr&, const UxoStatusQualifierCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const UxoStatusQualifierCode&);

  void
  operator<< (::xercesc::DOMElement&, const VegetationCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const VegetationCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const VegetationCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const VegetationSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const VegetationSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const VegetationSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const VehicleTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const VehicleTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const VehicleTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const VerticalDistanceReferenceCode&);

  void
  operator<< (::xercesc::DOMAttr&, const VerticalDistanceReferenceCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const VerticalDistanceReferenceCode&);

  void
  operator<< (::xercesc::DOMElement&, const VesselTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const VesselTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const VesselTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const VesselTypePropulsionTypeCode&);

  void
  operator<< (::xercesc::DOMAttr&, const VesselTypePropulsionTypeCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const VesselTypePropulsionTypeCode&);

  void
  operator<< (::xercesc::DOMElement&, const VisibilityCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const VisibilityCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const VisibilityCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const WeaponTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const WeaponTypeCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const WeaponTypeCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const WeaponTypeFireGuidanceIndicatorCode&);

  void
  operator<< (::xercesc::DOMAttr&, const WeaponTypeFireGuidanceIndicatorCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const WeaponTypeFireGuidanceIndicatorCode&);

  void
  operator<< (::xercesc::DOMElement&, const WeaponTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const WeaponTypeSubcategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const WeaponTypeSubcategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const WindAirStabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const WindAirStabilityCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const WindAirStabilityCategoryCode&);

  void
  operator<< (::xercesc::DOMElement&, const WindAltitudeLayerCode&);

  void
  operator<< (::xercesc::DOMAttr&, const WindAltitudeLayerCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const WindAltitudeLayerCode&);

  void
  operator<< (::xercesc::DOMElement&, const WindCategoryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const WindCategoryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const WindCategoryCode&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // EXTERN_JC3IEDM_3_1_CODES_20061208_HXX
